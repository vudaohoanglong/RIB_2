/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./entries/dist.js":
/*!*************************!*\
  !*** ./entries/dist.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _styles_cp_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../styles/cp.css */ \"./styles/cp.css\");\n/* harmony import */ var _styles_go_to_slide_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/go-to-slide.scss */ \"./styles/go-to-slide.scss\");\n/* harmony import */ var _styles_keyword_menu_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/keyword-menu.css */ \"./styles/keyword-menu.css\");\n/* harmony import */ var _styles_summary_slide_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../styles/summary-slide.css */ \"./styles/summary-slide.css\");\n/* harmony import */ var _styles_navigation_line_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../styles/navigation-line.css */ \"./styles/navigation-line.css\");\n/* harmony import */ var _styles_slide_background_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/slide-background.css */ \"./styles/slide-background.css\");\n/* harmony import */ var _styles_print_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../styles/print.css */ \"./styles/print.css\");\n/* harmony import */ var _scripts_cp__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../scripts/cp */ \"./scripts/cp.js\");\n\n\n\n\n\n\n\n // Load library\n\nH5P = H5P || {};\n\nH5P.Tooltip = H5P.Tooltip || function () {};\n\nH5P.CoursePresentation = _scripts_cp__WEBPACK_IMPORTED_MODULE_7__[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9lbnRyaWVzL2Rpc3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Q0FHQTs7QUFDQUMsR0FBRyxHQUFHQSxHQUFHLElBQUksRUFBYjs7QUFDQUEsR0FBRyxDQUFDQyxPQUFKLEdBQWNELEdBQUcsQ0FBQ0MsT0FBSixJQUFlLFlBQVksQ0FBRSxDQUEzQzs7QUFDQUQsR0FBRyxDQUFDRCxrQkFBSixHQUF5QkEsbURBQXpCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vZW50cmllcy9kaXN0LmpzP2EyM2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFwiLi4vc3R5bGVzL2NwLmNzc1wiO1xyXG5pbXBvcnQgXCIuLi9zdHlsZXMvZ28tdG8tc2xpZGUuc2Nzc1wiO1xyXG5pbXBvcnQgXCIuLi9zdHlsZXMva2V5d29yZC1tZW51LmNzc1wiO1xyXG5pbXBvcnQgXCIuLi9zdHlsZXMvc3VtbWFyeS1zbGlkZS5jc3NcIjtcclxuaW1wb3J0IFwiLi4vc3R5bGVzL25hdmlnYXRpb24tbGluZS5jc3NcIjtcclxuaW1wb3J0IFwiLi4vc3R5bGVzL3NsaWRlLWJhY2tncm91bmQuY3NzXCI7XHJcbmltcG9ydCBcIi4uL3N0eWxlcy9wcmludC5jc3NcIjtcclxuaW1wb3J0IENvdXJzZVByZXNlbnRhdGlvbiBmcm9tIFwiLi4vc2NyaXB0cy9jcFwiO1xyXG5cclxuLy8gTG9hZCBsaWJyYXJ5XHJcbkg1UCA9IEg1UCB8fCB7fTtcclxuSDVQLlRvb2x0aXAgPSBINVAuVG9vbHRpcCB8fCBmdW5jdGlvbiAoKSB7fTtcclxuSDVQLkNvdXJzZVByZXNlbnRhdGlvbiA9IENvdXJzZVByZXNlbnRhdGlvbjtcclxuIl0sIm5hbWVzIjpbIkNvdXJzZVByZXNlbnRhdGlvbiIsIkg1UCIsIlRvb2x0aXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./entries/dist.js\n");

/***/ }),

/***/ "./scripts/confirmation-dialog.js":
/*!****************************************!*\
  !*** ./scripts/confirmation-dialog.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\r\n * Confirmation dialog\r\n * \r\n */\nvar ConfirmationDialog = function ConfirmationDialog(options, offset) {\n  var confirmationDialog = new H5P.ConfirmationDialog(options).appendTo(document.body);\n  var element = confirmationDialog.getElement();\n  element.classList.add('h5p-cp-confirmation-dialog');\n  confirmationDialog.show();\n  return confirmationDialog;\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ConfirmationDialog);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zY3JpcHRzL2NvbmZpcm1hdGlvbi1kaWFsb2cuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBTUEsa0JBQWtCLEdBQUcsU0FBckJBLGtCQUFxQixDQUFVQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtFQUNwRCxJQUFNQyxrQkFBa0IsR0FBRyxJQUFJQyxHQUFHLENBQUNKLGtCQUFSLENBQTJCQyxPQUEzQixFQUN4QkksUUFEd0IsQ0FDZkMsUUFBUSxDQUFDQyxJQURNLENBQTNCO0VBR0EsSUFBSUMsT0FBTyxHQUFHTCxrQkFBa0IsQ0FBQ00sVUFBbkIsRUFBZDtFQUNBRCxPQUFPLENBQUNFLFNBQVIsQ0FBa0JDLEdBQWxCLENBQXNCLDRCQUF0QjtFQUVBUixrQkFBa0IsQ0FBQ1MsSUFBbkI7RUFDQSxPQUFPVCxrQkFBUDtBQUNELENBVEQ7O0FBV0EsaUVBQWVILGtCQUFmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9jb25maXJtYXRpb24tZGlhbG9nLmpzP2U2ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8qKlxyXG4gKiBDb25maXJtYXRpb24gZGlhbG9nXHJcbiAqIFxyXG4gKi9cclxuY29uc3QgQ29uZmlybWF0aW9uRGlhbG9nID0gZnVuY3Rpb24gKG9wdGlvbnMsIG9mZnNldCkge1xyXG4gIGNvbnN0IGNvbmZpcm1hdGlvbkRpYWxvZyA9IG5ldyBINVAuQ29uZmlybWF0aW9uRGlhbG9nKG9wdGlvbnMpXHJcbiAgICAuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XHJcbiAgXHJcbiAgbGV0IGVsZW1lbnQgPSBjb25maXJtYXRpb25EaWFsb2cuZ2V0RWxlbWVudCgpO1xyXG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaDVwLWNwLWNvbmZpcm1hdGlvbi1kaWFsb2cnKTtcclxuICBcclxuICBjb25maXJtYXRpb25EaWFsb2cuc2hvdygpO1xyXG4gIHJldHVybiBjb25maXJtYXRpb25EaWFsb2c7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBDb25maXJtYXRpb25EaWFsb2c7Il0sIm5hbWVzIjpbIkNvbmZpcm1hdGlvbkRpYWxvZyIsIm9wdGlvbnMiLCJvZmZzZXQiLCJjb25maXJtYXRpb25EaWFsb2ciLCJINVAiLCJhcHBlbmRUbyIsImRvY3VtZW50IiwiYm9keSIsImVsZW1lbnQiLCJnZXRFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic2hvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./scripts/confirmation-dialog.js\n");

/***/ }),

/***/ "./scripts/cp.js":
/*!***********************!*\
  !*** ./scripts/cp.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var h5p_parent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! h5p-parent */ \"../node_modules/h5p-parent/src/parent.js\");\n/* harmony import */ var h5p_parent__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(h5p_parent__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! yjs */ \"../node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var y_socket_io__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-socket.io */ \"../node_modules/y-socket.io/dist/index.mjs\");\n/* harmony import */ var _summary_slide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./summary-slide */ \"./scripts/summary-slide.js\");\n/* harmony import */ var _navigation_line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./navigation-line */ \"./scripts/navigation-line.js\");\n/* harmony import */ var _slide_backgrounds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./slide-backgrounds */ \"./scripts/slide-backgrounds.js\");\n/* harmony import */ var _keyword_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./keyword-menu */ \"./scripts/keyword-menu.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\n/* harmony import */ var _slide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./slide.js */ \"./scripts/slide.js\");\n/* harmony import */ var _confirmation_dialog__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./confirmation-dialog */ \"./scripts/confirmation-dialog.js\");\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @const {string}\r\n */\n\nvar KEYWORD_TITLE_SKIP = null;\n/**\r\n * Constructor.\r\n *\r\n * @param {object} params Start paramteres.\r\n * @param {int} id Content identifier\r\n * @param {function} editor\r\n *  Set if an editor is initiating this library\r\n * @returns {undefined} Nothing.\r\n */\n\nvar CoursePresentation = function CoursePresentation(params, id, extras) {\n  var _this = this;\n\n  function between(min, max) {\n    return Math.floor(Math.random() * (max - min) + min);\n  }\n\n  var that = this;\n  this.data = [];\n  this.doc = new yjs__WEBPACK_IMPORTED_MODULE_10__.Doc();\n  this.presentation = params.presentation;\n  this.slides = this.presentation.slides;\n  this.contentId = id;\n  this.elementInstances = []; // elementInstances holds the instances for elements in an array.\n\n  this.elementsAttached = []; // Map to keep track of which slide has attached elements\n\n  this.slidesWithSolutions = [];\n  this.showCommentsAfterSolution = [];\n  this.hasAnswerElements = false;\n  this.ignoreResize = false;\n  this.isTask = false;\n  this.standalone = true;\n  this.isReportingEnabled = false;\n  this.popups = {};\n\n  if (extras.cpEditor) {\n    this.editor = extras.cpEditor;\n  }\n\n  if (this.editor) {\n    this.provider = new y_socket_io__WEBPACK_IMPORTED_MODULE_1__.SocketIOProvider('ws://192.168.1.3:1234', between(1, 10).toString(), this.doc, {\n      autoConnect: true // disableBc: true,\n      // auth: { token: 'valid-token' },\n\n    });\n  } else {\n    this.provider = new y_socket_io__WEBPACK_IMPORTED_MODULE_1__.SocketIOProvider('ws://192.168.1.3:1234', id, this.doc, {\n      autoConnect: true // disableBc: true,\n      // auth: { token: 'valid-token' },\n\n    });\n  }\n\n  var ymap = this.doc.getMap('pageState');\n  /*ymap.observe((e,t)=>{\r\n    console.log(e.changes.keys);\r\n    if (e.changes.keys.has('currentPage'))\r\n    {\r\n      console.log(ymap.get('currentPage'));\r\n      this.processJumpToSlide(ymap.get('currentPage'));\r\n    }\r\n    if (e.changes.keys.has('reset')){\r\n      this.IresetTask();\r\n    }\r\n  })*/\n\n  ymap.observe(function (ymapEvent) {\n    ymapEvent.target === ymap; // => true\n    // Find out what changed: \n    // Option 1: A set of keys that changed\n\n    ymapEvent.keysChanged; // => Set<strings>\n    // Option 2: Compute the differences\n\n    ymapEvent.changes.keys; // => Map<string, { action: 'add'|'update'|'delete', oldValue: any}>\n    // sample code.\n\n    ymapEvent.changes.keys.forEach(function (change, key) {\n      if (change.action === 'add') {\n        if (key === 'currentPage') {\n          //console.log(ymap.get('currentPage'));\n          _this.processJumpToSlide(ymap.get('currentPage'));\n        }\n      } else if (change.action === 'update') {\n        if (key === 'currentPage') {\n          //console.log(ymap.get('currentPage'));\n          _this.processJumpToSlide(ymap.get('currentPage'));\n        }\n\n        if (key === 'reset') {\n          //console.log('reseted');\n          _this.IresetTask();\n        }\n      } else if (change.action === 'delete') {//console.log(`Property \"${key}\" was deleted. New value: undefined. Previous value: \"${change.oldValue}\".`)\n      }\n    });\n  });\n\n  if (extras) {\n    this.previousState = extras.previousState;\n    this.standalone = extras.standalone;\n    this.isReportingEnabled = extras.isReportingEnabled || extras.isScoringEnabled;\n  }\n\n  this.currentSlideIndex = this.previousState && this.previousState.progress ? this.previousState.progress : 0;\n  this.presentation.keywordListEnabled = params.presentation.keywordListEnabled === undefined ? true : params.presentation.keywordListEnabled;\n  this.l10n = _globals__WEBPACK_IMPORTED_MODULE_6__.jQuery.extend({\n    slide: 'Slide',\n    score: 'Score',\n    yourScore: 'Your score',\n    maxScore: 'Max score',\n    total: 'Total',\n    totalScore: 'Total Score',\n    showSolutions: 'Show solutions',\n    summary: 'summary',\n    retry: 'Retry',\n    exportAnswers: 'Export text',\n    close: 'Close',\n    hideKeywords: 'Hide sidebar navigation menu',\n    showKeywords: 'Show sidebar navigation menu',\n    fullscreen: 'Fullscreen',\n    exitFullscreen: 'Exit fullscreen',\n    prevSlide: 'Previous slide',\n    nextSlide: 'Next slide',\n    currentSlide: 'Current slide',\n    lastSlide: 'Last slide',\n    solutionModeTitle: 'Exit solution mode',\n    solutionModeText: 'Solution Mode',\n    summaryMultipleTaskText: 'Multiple tasks',\n    scoreMessage: 'You achieved:',\n    shareFacebook: 'Share on Facebook',\n    shareTwitter: 'Share on Twitter',\n    shareGoogle: 'Share on Google+',\n    goToSlide: 'Go to slide :num',\n    solutionsButtonTitle: 'Show comments',\n    printTitle: 'Print',\n    printIngress: 'How would you like to print this presentation?',\n    printAllSlides: 'Print all slides',\n    printCurrentSlide: 'Print current slide',\n    noTitle: 'No title',\n    accessibilitySlideNavigationExplanation: 'Use left and right arrow to change slide in that direction whenever canvas is selected.',\n    accessibilityProgressBarLabel: 'Choose slide to display',\n    containsNotCompleted: '@slideName contains not completed interaction',\n    containsCompleted: '@slideName contains completed interaction',\n    slideCount: 'Slide @index of @total',\n    accessibilityCanvasLabel: 'Presentation canvas. Use left and right arrow to move between slides.',\n    containsOnlyCorrect: \"@slideName only has correct answers\",\n    containsIncorrectAnswers: '@slideName has incorrect answers',\n    shareResult: 'Share Result',\n    accessibilityTotalScore: 'You got @score of @maxScore points in total',\n    accessibilityEnteredFullscreen: 'Entered fullscreen',\n    accessibilityExitedFullscreen: 'Exited fullscreen',\n    confirmDialogHeader: 'Submit your answers',\n    confirmDialogText: 'This will submit your results, do you want to continue?',\n    confirmDialogConfirmText: 'Submit and see results',\n    slideshowNavigationLabel: 'Slideshow navigation'\n  }, params.l10n !== undefined ? params.l10n : {});\n\n  if (!!params.override) {\n    this.activeSurface = !!params.override.activeSurface;\n    this.hideSummarySlide = !!params.override.hideSummarySlide;\n    this.enablePrintButton = !!params.override.enablePrintButton;\n    this.showSummarySlideSolutionButton = params.override.summarySlideSolutionButton !== undefined ? params.override.summarySlideSolutionButton : true;\n    this.showSummarySlideRetryButton = params.override.summarySlideRetryButton !== undefined ? params.override.summarySlideRetryButton : true;\n\n    if (!!params.override.social) {\n      this.enableTwitterShare = !!params.override.social.showTwitterShare;\n      this.enableFacebookShare = !!params.override.social.showFacebookShare;\n      this.enableGoogleShare = !!params.override.social.showGoogleShare;\n      this.twitterShareStatement = params.override.social.twitterShare.statement;\n      this.twitterShareHashtags = params.override.social.twitterShare.hashtags;\n      this.twitterShareUrl = params.override.social.twitterShare.url;\n      this.facebookShareUrl = params.override.social.facebookShare.url;\n      this.facebookShareQuote = params.override.social.facebookShare.quote;\n      this.googleShareUrl = params.override.social.googleShareUrl;\n    }\n  }\n\n  this.keywordMenu = new _keyword_menu__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n    l10n: this.l10n,\n    currentIndex: this.previousState !== undefined ? this.previousState.progress : 0\n  }); // Set override for all actions\n\n  this.setElementsOverride(params.override); // Inheritance\n\n  h5p_parent__WEBPACK_IMPORTED_MODULE_0___default().call(this, _slide_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"], params.presentation.slides);\n  this.on('resize', this.resize, this);\n  this.on('printing', function (event) {\n    that.ignoreResize = !event.data.finished;\n\n    if (event.data.finished) {\n      that.resize();\n    } else if (event.data.allSlides) {\n      that.attachAllElements();\n    }\n  });\n};\n\nCoursePresentation.prototype = Object.create((h5p_parent__WEBPACK_IMPORTED_MODULE_0___default().prototype));\nCoursePresentation.prototype.constructor = CoursePresentation;\n/**\r\n * @public\r\n * @return {object}\r\n */\n\nCoursePresentation.prototype.getCurrentState = function () {\n  var _this2 = this;\n\n  var state = this.previousState ? this.previousState : {};\n  state.progress = this.getCurrentSlideIndex();\n\n  if (!state.answers) {\n    state.answers = [];\n  }\n\n  state.answered = this.elementInstances.map(function (interaction, index) {\n    return _this2.slideHasAnsweredTask(index);\n  }); // Get answers and answered\n\n  for (var slide = 0; slide < this.elementInstances.length; slide++) {\n    if (this.elementInstances[slide]) {\n      for (var element = 0; element < this.elementInstances[slide].length; element++) {\n        var instance = this.elementInstances[slide][element];\n\n        if (instance.getCurrentState instanceof Function || typeof instance.getCurrentState === 'function') {\n          if (!state.answers[slide]) {\n            state.answers[slide] = [];\n          }\n\n          state.answers[slide][element] = instance.getCurrentState();\n        }\n      }\n    }\n  }\n\n  return state;\n};\n/**\r\n * Returns true if a slide has answered interactions\r\n *\r\n * @param {number} index\r\n * @return {boolean}\r\n */\n\n\nCoursePresentation.prototype.slideHasAnsweredTask = function (index) {\n  var tasks = this.slidesWithSolutions[index] || [];\n  return tasks.filter(function (task) {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_7__.isFunction)(task.getAnswerGiven);\n  }).some(function (task) {\n    return task.getAnswerGiven();\n  });\n};\n/**\r\n * Render the presentation inside the given container.\r\n *\r\n * @param {H5P.jQuery} $container Container for this presentation.\r\n * @returns {undefined} Nothing.\r\n */\n\n\nCoursePresentation.prototype.attach = function ($container) {\n  var _this3 = this;\n\n  var that = this; // isRoot is undefined in the editor\n\n  if (this.isRoot !== undefined && this.isRoot()) {\n    this.setActivityStarted();\n  }\n\n  var html = '<div class=\"h5p-keymap-explanation hidden-but-read\">' + this.l10n.accessibilitySlideNavigationExplanation + '</div>' + '<div class=\"h5p-fullscreen-announcer hidden-but-read\" aria-live=\"polite\"></div>' + '<div class=\"h5p-wrapper\" tabindex=\"0\" role=\"region\" aria-roledescription=\"carousel\" aria-label=\"' + this.l10n.accessibilityCanvasLabel + '\">' + '  <div class=\"h5p-current-slide-announcer hidden-but-read\" aria-live=\"polite\"></div>' + '  <div tabindex=\"-1\"></div>' + '  <div class=\"h5p-box-and-nav-wrapper\">' + '    <nav class=\"h5p-cp-navigation\" aria-label=\"' + this.l10n.slideshowNavigationLabel + '\">' + '      <div class=\"h5p-progressbar\" role=\"tablist\" aria-label=\"' + this.l10n.accessibilityProgressBarLabel + '\"></div>' + '    </nav>' + '    <div class=\"h5p-box-wrapper\">' + '      <div class=\"h5p-presentation-wrapper\">' + '        <div class=\"h5p-keywords-wrapper\"></div>' + '        <div class=\"h5p-slides-wrapper\"></div>' + '      </div>' + '    </div>' + '  </div>' + '  <div class=\"h5p-footer\"></div>' + '</div>';\n  $container.attr('role', 'application').addClass('h5p-course-presentation').html(html);\n  this.$container = $container;\n  this.$slideAnnouncer = $container.find('.h5p-current-slide-announcer');\n  this.$fullscreenAnnouncer = $container.find('.h5p-fullscreen-announcer');\n  this.$slideTop = this.$slideAnnouncer.next();\n  this.$wrapper = $container.children('.h5p-wrapper');\n\n  if (this.activeSurface) {\n    this.$wrapper.addClass('h5p-course-presentation-active-surface');\n  }\n\n  this.$wrapper.focus(function () {\n    that.initKeyEvents();\n  }).blur(function () {\n    if (that.keydown !== undefined) {\n      H5P.jQuery('body').unbind('keydown', that.keydown);\n      delete that.keydown;\n    }\n  }).click(function (event) {\n    var $target = H5P.jQuery(event.target);\n    /*\r\n     * Add focus to the wrapper so that it may capture keyboard events unless\r\n     * the target or one of its parents should handle focus themselves.\r\n     */\n\n    var isFocusableElement = that.belongsToTagName(event.target, ['input', 'textarea', 'a', 'button'], event.currentTarget); // Does the target element have a tabIndex set?\n\n    var hasTabIndex = event.target.tabIndex !== -1; // The dialog container (if within a dialog)\n\n    var $dialogParent = $target.closest('.h5p-popup-container'); // Is target within a dialog\n\n    var isWithinDialog = $dialogParent.length !== 0;\n\n    if (!isFocusableElement && !hasTabIndex && !that.editor) {\n      if (!isWithinDialog) {\n        // We're not within a dialog, so we can seafely put focus on wrapper\n        that.$wrapper.focus();\n      } else {\n        // Find the closest tabbable parent element\n        var $tabbable = $target.closest('[tabindex]'); // Is the parent tabbable element inside the popup?\n\n        if ($tabbable.closest('.h5p-popup-container').length === 1) {\n          // We'll set focus here\n          $tabbable.focus();\n        } else {\n          // Fallback: set focus on close button\n          $dialogParent.find('.h5p-close-popup').focus();\n        }\n      }\n    }\n\n    if (that.presentation.keywordListEnabled && !that.presentation.keywordListAlwaysShow && that.presentation.keywordListAutoHide && !$target.is('textarea, .h5p-icon-pencil, span')) {\n      that.hideKeywords(); // Auto-hide keywords\n    }\n  });\n  this.on('exitFullScreen', function () {\n    _this3.$footer.removeClass('footer-full-screen');\n\n    _this3.$fullScreenButton.attr('aria-label', _this3.l10n.fullscreen);\n\n    _this3.$fullscreenAnnouncer.html(_this3.l10n.accessibilityExitedFullscreen);\n  });\n  this.on('enterFullScreen', function () {\n    _this3.$fullscreenAnnouncer.html(_this3.l10n.accessibilityEnteredFullscreen);\n  }); // Get intended base width from CSS.\n\n  var wrapperWidth = parseInt(this.$wrapper.css('width'));\n  this.width = wrapperWidth !== 0 ? wrapperWidth : 640;\n  var wrapperHeight = parseInt(this.$wrapper.css('height'));\n  this.height = wrapperHeight !== 0 ? wrapperHeight : 400;\n  this.ratio = 16 / 9; // Intended base font size cannot be read from CSS, as it might be modified\n  // by mobile browsers already. (The Android native browser does this.)\n\n  this.fontSize = 16;\n  this.$boxWrapper = this.$wrapper.find('.h5p-box-wrapper');\n  var $presentationWrapper = this.$boxWrapper.children('.h5p-presentation-wrapper');\n  this.$slidesWrapper = $presentationWrapper.children('.h5p-slides-wrapper');\n  this.$keywordsWrapper = $presentationWrapper.children('.h5p-keywords-wrapper');\n  this.$progressbar = this.$wrapper.find('.h5p-progressbar');\n  this.$footer = this.$wrapper.children('.h5p-footer'); // Determine if keywords pane should be initialized\n\n  this.initKeywords = this.presentation.keywordListEnabled === undefined || this.presentation.keywordListEnabled === true || this.editor !== undefined;\n\n  if (this.activeSurface && this.editor === undefined) {\n    this.initKeywords = false;\n    this.$boxWrapper.css('height', '100%');\n  }\n\n  this.isSolutionMode = false; // Create slides and retrieve keyword title details\n\n  this.createSlides(); // We have always attached all elements on current slide\n\n  this.elementsAttached[this.currentSlideIndex] = true; // Determine if summary slide should be added\n\n  var $summarySlide;\n  this.showSummarySlide = false;\n\n  if (this.hideSummarySlide) {\n    // Always hide\n    this.showSummarySlide = !this.hideSummarySlide;\n  } else {\n    // Determine by checking for slides with tasks\n    this.slidesWithSolutions.forEach(function (slide) {\n      that.showSummarySlide = slide.length;\n    });\n  }\n\n  if (this.editor === undefined && (this.showSummarySlide || this.hasAnswerElements)) {\n    // Create the summary slide\n    var summarySlideParams = {\n      elements: [],\n      keywords: []\n    };\n    this.slides.push(summarySlideParams);\n    $summarySlide = H5P.jQuery(_slide_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].createHTML(summarySlideParams)).appendTo(this.$slidesWrapper);\n    $summarySlide.addClass('h5p-summary-slide');\n\n    if (this.isCurrentSlide(this.slides.length - 1)) {\n      this.$current = $summarySlide;\n    }\n  }\n\n  var keywordMenuConfig = this.getKeywordMenuConfig(); // Do not show keywords pane if it's empty and there's no editor!\n\n  if (keywordMenuConfig.length > 0 || this.isEditor()) {\n    // Initialize keyword titles\n    this.keywordMenu.init(keywordMenuConfig);\n    this.keywordMenu.on('select', function (event) {\n      return _this3.keywordClick(event.data.index);\n    });\n    this.keywordMenu.on('close', function () {\n      return _this3.hideKeywords();\n    });\n    this.keywordMenu.on('select', function () {\n      _this3.$currentKeyword = _this3.$keywords.children('.h5p-current');\n    });\n    this.$keywords = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)(this.keywordMenu.getElement()).appendTo(this.$keywordsWrapper);\n    this.$currentKeyword = this.$keywords.children('.h5p-current');\n\n    if (this.presentation.keywordListOpacity !== undefined) {\n      this.setKeywordsOpacity(this.presentation.keywordListOpacity);\n    }\n\n    if (this.presentation.keywordListAlwaysShow) {\n      this.showKeywords();\n    }\n  } else {\n    // Remove keyword titles completely\n    this.$keywordsWrapper.remove(); // Do not show keywords pane if it's empty and there's no editor!\n\n    this.initKeywords = false;\n  }\n\n  if (this.editor !== undefined || !this.activeSurface) {\n    // Initialize touch events\n    this.initTouchEvents(); // init navigation line\n\n    this.navigationLine = new _navigation_line__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this); // Set slide title if initing on slide 0\n\n    if (!this.previousState || !this.previousState.progress) {\n      this.setSlideNumberAnnouncer(0, false);\n    }\n\n    this.summarySlideObject = new _summary_slide__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, $summarySlide);\n  } else {\n    this.$progressbar.add(this.$footer).remove();\n\n    if (H5P.fullscreenSupported) {\n      // Create full screen button\n      this.$fullScreenButton = H5P.jQuery('<div/>', {\n        'class': 'h5p-toggle-full-screen',\n        'aria-label': this.l10n.fullscreen,\n        role: 'button',\n        tabindex: 0,\n        appendTo: this.$wrapper\n      });\n      H5P.Tooltip(this.$fullScreenButton.get(0), {\n        position: 'left'\n      });\n      (0,_utils__WEBPACK_IMPORTED_MODULE_7__.addClickAndKeyboardListeners)(this.$fullScreenButton, function () {\n        return that.toggleFullScreen();\n      });\n    }\n  }\n\n  new _slide_backgrounds__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n  /*if (this.previousState && this.previousState.progress) {\r\n    this.jumpToSlide(this.previousState.progress,false, null, false, true);\r\n  }*/\n\n  var ymap = this.doc.getMap('pageState');\n  if (ymap.has('currentPage')) this.jumpToSlide(ymap.get('currentPage'));\n};\n/**\r\n * Check if a node or one of its parents has a particular tag name.\r\n *\r\n * @param {HTMLElement} node Node to check.\r\n * @param {string|string[]} tagNames Tag name(s).\r\n * @param {HTMLElement} [stop] Optional node to stop. Defaults to body node.\r\n * @return {boolean} True, if node belongs to a node with one of the tag names.\r\n */\n\n\nCoursePresentation.prototype.belongsToTagName = function (node, tagNames, stop) {\n  if (!node) {\n    return false;\n  } // Stop check at DOM tree root\n\n\n  stop = stop || document.body;\n\n  if (typeof tagNames === 'string') {\n    tagNames = [tagNames];\n  }\n\n  tagNames = tagNames.map(function (tagName) {\n    return tagName.toLowerCase();\n  });\n  var tagName = node.tagName.toLowerCase();\n\n  if (tagNames.indexOf(tagName) !== -1) {\n    return true;\n  } // Having stop can prevent always parsing DOM tree to root\n\n\n  if (stop === node) {\n    return false;\n  }\n\n  return this.belongsToTagName(node.parentNode, tagNames, stop);\n};\n/**\r\n * Removes old menu items, and create new ones from slides.\r\n * Returns menu items as jQuery\r\n *\r\n * @return {jQuery}\r\n */\n\n\nCoursePresentation.prototype.updateKeywordMenuFromSlides = function () {\n  this.keywordMenu.removeAllMenuItemElements();\n  var config = this.getKeywordMenuConfig();\n  return (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)(this.keywordMenu.init(config));\n};\n/**\r\n * Creates a keyword menu config based on the slides parameters\r\n *\r\n * @return {KeywordMenuItemConfig[]}\r\n */\n\n\nCoursePresentation.prototype.getKeywordMenuConfig = function () {\n  var _this4 = this;\n\n  return this.slides.map(function (slide, index) {\n    return {\n      title: _this4.createSlideTitle(slide),\n      subtitle: \"\".concat(_this4.l10n.slide, \" \").concat(index + 1),\n      index: index\n    };\n  }).filter(function (config) {\n    return config.title !== KEYWORD_TITLE_SKIP;\n  });\n};\n/**\r\n * Returns the slide title, or \"No title\" if inside editor without title\r\n *\r\n * @return {string|null}\r\n */\n\n\nCoursePresentation.prototype.createSlideTitle = function (slide) {\n  var fallbackTitleForEditor = this.isEditor() ? this.l10n.noTitle : KEYWORD_TITLE_SKIP;\n  return this.hasKeywords(slide) ? slide.keywords[0].main : fallbackTitleForEditor;\n};\n/**\r\n * Returns true if inside the editor\r\n *\r\n * @return {boolean}\r\n */\n\n\nCoursePresentation.prototype.isEditor = function () {\n  return this.editor !== undefined;\n};\n/**\r\n * Returns true if a slide has keywords\r\n *\r\n * @param {object} slide\r\n * @return {boolean}\r\n */\n\n\nCoursePresentation.prototype.hasKeywords = function (slide) {\n  return slide.keywords !== undefined && slide.keywords.length > 0;\n};\n/**\r\n * Create slides\r\n * Slides are directly attached to the slides wrapper.\r\n *\r\n * @param {Array} slidesParams\r\n */\n\n\nCoursePresentation.prototype.createSlides = function () {\n  var self = this;\n\n  for (var i = 0; i < self.children.length; i++) {\n    var isCurrentSlide = i === self.currentSlideIndex; // Create and append DOM Elements\n\n    self.children[i].getElement().appendTo(self.$slidesWrapper);\n\n    if (isCurrentSlide) {\n      self.children[i].setCurrent();\n    }\n\n    if (self.isEditor() || i === 0 || i === 1 || isCurrentSlide) {\n      self.children[i].appendElements();\n    }\n  }\n};\n/**\r\n * Does an object have functions to determine the score\r\n *\r\n * @public\r\n * @param obj The object to investigate\r\n * @returns {boolean}\r\n */\n\n\nCoursePresentation.prototype.hasScoreData = function (obj) {\n  return _typeof(obj) !== ( true ? \"undefined\" : 0) && typeof obj.getScore === 'function' && typeof obj.getMaxScore === 'function';\n};\n/**\r\n * Return the combined score of all children\r\n *\r\n * @public\r\n * @returns {Number}\r\n */\n\n\nCoursePresentation.prototype.getScore = function () {\n  var self = this;\n  return (0,_utils__WEBPACK_IMPORTED_MODULE_7__.flattenArray)(self.slidesWithSolutions).reduce(function (sum, slide) {\n    return sum + (self.hasScoreData(slide) ? slide.getScore() : 0);\n  }, 0);\n};\n/**\r\n * Return the combined maxScore of all children\r\n *\r\n * @public\r\n * @returns {Number}\r\n */\n\n\nCoursePresentation.prototype.getMaxScore = function () {\n  var self = this;\n  return (0,_utils__WEBPACK_IMPORTED_MODULE_7__.flattenArray)(self.slidesWithSolutions).reduce(function (sum, slide) {\n    return sum + (self.hasScoreData(slide) ? slide.getMaxScore() : 0);\n  }, 0);\n};\n/**\r\n * Updates the feedback icons for the progres bar.\r\n *\r\n * @param {array} [slideScores]\r\n */\n\n\nCoursePresentation.prototype.setProgressBarFeedback = function (slideScores) {\n  var _this5 = this;\n\n  if (slideScores !== undefined && slideScores) {\n    // Set feedback icons for progress bar.\n    slideScores.forEach(function (singleSlide) {\n      var $indicator = _this5.progressbarParts[singleSlide.slide - 1].find('.h5p-progressbar-part-has-task');\n\n      if ($indicator.hasClass('h5p-answered')) {\n        var isCorrect = singleSlide.score >= singleSlide.maxScore;\n        $indicator.addClass(isCorrect ? 'h5p-is-correct' : 'h5p-is-wrong');\n\n        _this5.navigationLine.updateSlideTitle(singleSlide.slide - 1);\n      }\n    });\n  } else {\n    // Remove all feedback icons.\n    this.progressbarParts.forEach(function (pbPart) {\n      pbPart.find('.h5p-progressbar-part-has-task').removeClass('h5p-is-correct').removeClass('h5p-is-wrong');\n    });\n  }\n};\n/**\r\n * Toggle keywords list on/off depending on current state\r\n */\n\n\nCoursePresentation.prototype.toggleKeywords = function () {\n  var keywordsAreShowing = this.$keywordsWrapper.hasClass('h5p-open');\n  this[keywordsAreShowing ? 'hideKeywords' : 'showKeywords']();\n};\n/**\r\n * Hide keywords\r\n */\n\n\nCoursePresentation.prototype.hideKeywords = function () {\n  if (this.$keywordsWrapper.hasClass('h5p-open')) {\n    if (this.$keywordsButton !== undefined) {\n      this.$keywordsButton.attr('aria-label', this.l10n.showKeywords);\n      this.$keywordsButton.attr('aria-expanded', 'false');\n      this.$keywordsButton.focus();\n    }\n\n    this.$keywordsWrapper.removeClass('h5p-open');\n  }\n};\n/**\r\n * Show keywords\r\n */\n\n\nCoursePresentation.prototype.showKeywords = function () {\n  if (this.$keywordsWrapper.hasClass('h5p-open')) {\n    // Already showing\n    return;\n  }\n\n  if (this.$keywordsButton !== undefined) {\n    this.$keywordsButton.attr('aria-label', this.l10n.hideKeywords);\n    this.$keywordsButton.attr('aria-expanded', 'true');\n  }\n\n  this.$keywordsWrapper.addClass('h5p-open'); // Do not focus if always showing\n\n  if (!this.presentation.keywordListAlwaysShow) {\n    this.$keywordsWrapper.find('li[tabindex=\"0\"]').focus();\n  }\n};\n/**\r\n * Change the background opacity of the keywords list.\r\n *\r\n * @param {number} value 0 - 100\r\n */\n\n\nCoursePresentation.prototype.setKeywordsOpacity = function (value) {\n  if (this.$keywordsWrapper.css('background-color') !== '') {\n    var _this$$keywordsWrappe = this.$keywordsWrapper.css('background-color').match(/\\d+/g),\n        _this$$keywordsWrappe2 = _slicedToArray(_this$$keywordsWrappe, 3),\n        red = _this$$keywordsWrappe2[0],\n        green = _this$$keywordsWrappe2[1],\n        blue = _this$$keywordsWrappe2[2];\n\n    this.$keywordsWrapper.css('background-color', \"rgba(\".concat(red, \", \").concat(green, \", \").concat(blue, \", \").concat(value / 100, \")\"));\n  }\n};\n/**\r\n * Makes continuous text smaller if it does not fit inside its container.\r\n * Only works in view mode.\r\n *\r\n * @returns {undefined}\r\n */\n\n\nCoursePresentation.prototype.fitCT = function () {\n  if (this.editor !== undefined) {\n    return;\n  }\n\n  this.$current.find('.h5p-ct').each(function () {\n    var percent = 100;\n    var $ct = H5P.jQuery(this);\n    var parentHeight = $ct.parent().height();\n\n    while ($ct.outerHeight() > parentHeight) {\n      percent--;\n      $ct.css({\n        fontSize: percent + '%',\n        lineHeight: percent + 65 + '%'\n      });\n\n      if (percent < 0) {\n        break; // Just in case.\n      }\n    }\n  });\n};\n/**\r\n * Resize handling.\r\n *\r\n * @param {Boolean} fullscreen\r\n * @returns {undefined}\r\n */\n\n\nCoursePresentation.prototype.resize = function () {\n  var fullscreenOn = this.$container.hasClass('h5p-fullscreen') || this.$container.hasClass('h5p-semi-fullscreen');\n\n  if (this.ignoreResize) {\n    return; // When printing.\n  } // Fill up all available width\n\n\n  this.$wrapper.css('width', 'auto');\n  var width = this.$container.width();\n  var style = {};\n\n  if (fullscreenOn) {\n    var maxHeight = this.$container.height();\n\n    if (width / maxHeight > this.ratio) {\n      // Top and bottom would be cut off so scale down.\n      width = maxHeight * this.ratio;\n      style.width = width + 'px';\n    }\n  } // TODO: Add support for -16 when content conversion script is created?\n\n\n  var widthRatio = width / this.width;\n  style.height = width / this.ratio + 'px';\n  style.fontSize = this.fontSize * widthRatio + 'px';\n\n  if (this.editor !== undefined) {\n    this.editor.setContainerEm(this.fontSize * widthRatio * 0.75);\n  }\n\n  this.$wrapper.css(style);\n  this.swipeThreshold = widthRatio * 100; // Default swipe threshold is 50px.\n  // Resize elements\n\n  var instances = this.elementInstances[this.$current.index()];\n\n  if (instances !== undefined) {\n    var slideElements = this.slides[this.$current.index()].elements;\n\n    for (var i = 0; i < instances.length; i++) {\n      var instance = instances[i];\n\n      if ((instance.preventResize === undefined || instance.preventResize === false) && instance.$ !== undefined && !slideElements[i].displayAsButton) {\n        H5P.trigger(instance, 'resize');\n      }\n    }\n  }\n\n  this.fitCT();\n};\n/**\r\n * Enter/exit full screen mode.\r\n */\n\n\nCoursePresentation.prototype.toggleFullScreen = function () {\n  if (H5P.isFullscreen || this.$container.hasClass('h5p-fullscreen') || this.$container.hasClass('h5p-semi-fullscreen')) {\n    // Cancel fullscreen\n    if (H5P.exitFullScreen !== undefined && H5P.fullScreenBrowserPrefix !== undefined) {\n      H5P.exitFullScreen();\n    } else {\n      // Use old system\n      if (H5P.fullScreenBrowserPrefix === undefined) {\n        // Click button to disable fullscreen\n        H5P.jQuery('.h5p-disable-fullscreen').click();\n      } else {\n        if (H5P.fullScreenBrowserPrefix === '') {\n          window.top.document.exitFullScreen();\n        } else if (H5P.fullScreenBrowserPrefix === 'ms') {\n          window.top.document.msExitFullscreen();\n        } else {\n          window.top.document[H5P.fullScreenBrowserPrefix + 'CancelFullScreen']();\n        }\n      }\n    }\n  } else {\n    // Rescale footer buttons\n    this.$footer.addClass('footer-full-screen');\n    this.$fullScreenButton.attr('aria-label', this.l10n.exitFullscreen);\n    H5P.fullScreen(this.$container, this);\n\n    if (H5P.fullScreenBrowserPrefix === undefined) {\n      // Hide disable full screen button. We have our own!\n      H5P.jQuery('.h5p-disable-fullscreen').hide();\n    }\n  }\n};\n/**\r\n * Set focus.\r\n */\n\n\nCoursePresentation.prototype.focus = function () {\n  this.$wrapper.focus();\n};\n/**\r\n * Handles click on keyword\r\n *\r\n * @param {number} index\r\n */\n\n\nCoursePresentation.prototype.keywordClick = function (index) {\n  if (this.shouldHideKeywordsAfterSelect()) {\n    // Auto-hide keywords list\n    this.hideKeywords();\n  }\n\n  this.jumpToSlide(index, true);\n};\n\nCoursePresentation.prototype.shouldHideKeywordsAfterSelect = function () {\n  return this.presentation.keywordListEnabled && !this.presentation.keywordListAlwaysShow && this.presentation.keywordListAutoHide && this.editor === undefined;\n};\n/**\r\n * Set the default behaviour override for all actions.\r\n *\r\n * @param {Object} override\r\n */\n\n\nCoursePresentation.prototype.setElementsOverride = function (override) {\n  // Create default object\n  this.elementsOverride = {\n    params: {}\n  };\n\n  if (override) {\n    // Create behaviour object for overriding\n    this.elementsOverride.params.behaviour = {};\n\n    if (override.showSolutionButton) {\n      // Override show solutions button\n      this.elementsOverride.params.behaviour.enableSolutionsButton = override.showSolutionButton === 'on' ? true : false;\n    }\n\n    if (override.retryButton) {\n      // Override retry button\n      this.elementsOverride.params.behaviour.enableRetry = override.retryButton === 'on' ? true : false;\n    }\n  }\n};\n/**\r\n * Attach all element instances to slide.\r\n *\r\n * @param {jQuery} $slide\r\n * @param {Number} index\r\n */\n\n\nCoursePresentation.prototype.attachElements = function ($slide, index) {\n  if (this.elementsAttached[index] !== undefined) {\n    return; // Already attached\n  }\n\n  var slide = this.slides[index];\n  var instances = this.elementInstances[index];\n\n  if (slide.elements !== undefined) {\n    for (var i = 0; i < slide.elements.length; i++) {\n      this.attachElement(slide.elements[i], instances[i], $slide, index);\n    }\n  }\n\n  this.trigger('domChanged', {\n    '$target': $slide,\n    'library': 'CoursePresentation',\n    'key': 'newSlide'\n  }, {\n    'bubbles': true,\n    'external': true\n  });\n  this.elementsAttached[index] = true;\n};\n/**\r\n * Attach element to slide container.\r\n *\r\n * @param {Object} element\r\n * @param {Object} instance\r\n * @param {jQuery} $slide\r\n * @param {Number} index\r\n * @returns {jQuery}\r\n */\n\n\nCoursePresentation.prototype.attachElement = function (element, instance, $slide, index) {\n  var displayAsButton = element.displayAsButton !== undefined && element.displayAsButton;\n  var buttonSizeClass = element.buttonSize !== undefined ? \"h5p-element-button-\" + element.buttonSize : \"\";\n  var classes = 'h5p-element' + (displayAsButton ? ' h5p-element-button-wrapper' : '') + (buttonSizeClass.length ? ' ' + buttonSizeClass : '');\n  var $elementContainer = H5P.jQuery('<div>', {\n    'class': classes\n  }).css({\n    left: element.x + '%',\n    top: element.y + '%',\n    width: element.width + '%',\n    height: element.height + '%'\n  }).appendTo($slide.children('[role=\"document\"]').first());\n  var isTransparent = element.backgroundOpacity === undefined || element.backgroundOpacity === 0;\n  $elementContainer.toggleClass('h5p-transparent', isTransparent);\n\n  if (displayAsButton) {\n    var $button = this.createInteractionButton(element, instance);\n    $button.appendTo($elementContainer);\n  } else {\n    var hasLibrary = element.action && element.action.library;\n    var libTypePmz = hasLibrary ? this.getLibraryTypePmz(element.action.library) : 'other';\n    var $outerElementContainer = H5P.jQuery('<div>', {\n      'class': \"h5p-element-outer \".concat(libTypePmz, \"-outer-element\")\n    }).css({\n      background: 'rgba(255,255,255,' + (element.backgroundOpacity === undefined ? 0 : element.backgroundOpacity / 100) + ')'\n    }).appendTo($elementContainer);\n    var $innerElementContainer = H5P.jQuery('<div>', {\n      'class': 'h5p-element-inner'\n    }).appendTo($outerElementContainer); // H5P.Shape sets it's own size when line in selected\n\n    instance.on('set-size', function (event) {\n      for (var property in event.data) {\n        $elementContainer.get(0).style[property] = event.data[property];\n      }\n    });\n    instance.attach($innerElementContainer);\n\n    if (element.action !== undefined && element.action.library.substr(0, 20) === 'H5P.InteractiveVideo') {\n      var handleIV = function handleIV() {\n        instance.$container.addClass('h5p-fullscreen');\n\n        if (instance.controls.$fullscreen) {\n          instance.controls.$fullscreen.remove();\n        }\n\n        instance.hasFullScreen = true;\n\n        if (instance.controls.$play.hasClass('h5p-pause')) {\n          instance.$controls.addClass('h5p-autohide');\n        } else {\n          instance.enableAutoHide();\n        }\n      };\n\n      if (instance.controls !== undefined) {\n        handleIV();\n      } else {\n        instance.on('controls', handleIV);\n      }\n    } // For first slide\n\n\n    this.setOverflowTabIndex();\n  }\n\n  if (this.editor !== undefined) {\n    // If we're in the H5P editor, allow it to manipulate the elementInstances\n    this.editor.processElement(element, $elementContainer, index, instance);\n  } else {\n    if (element.solution) {\n      this.addElementSolutionButton(element, instance, $elementContainer);\n    }\n    /* When in view mode, we need to know if there are any answer elements,\r\n     * so that we can display the export answers button on the last slide */\n\n\n    this.hasAnswerElements = this.hasAnswerElements || instance.exportAnswers !== undefined;\n  }\n\n  return $elementContainer;\n};\n/**\r\n * Disables tab indexes behind a popup container\r\n */\n\n\nCoursePresentation.prototype.disableTabIndexes = function () {\n  var $popupContainer = this.$container.find('.h5p-popup-container');\n  this.$tabbables = this.$container.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\n    var $tabbable = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)(this);\n    var insideContainer = _globals__WEBPACK_IMPORTED_MODULE_6__.jQuery.contains($popupContainer.get(0), $tabbable.get(0)); // tabIndex has already been modified, keep it in the set.\n\n    if ($tabbable.data('tabindex')) {\n      return true;\n    }\n\n    if (!insideContainer) {\n      // Store current tabindex, so we can set it back when dialog closes\n      var tabIndex = $tabbable.attr('tabindex');\n      $tabbable.data('tabindex', tabIndex); // Make it non tabbable\n\n      $tabbable.attr('tabindex', '-1');\n      return true;\n    } // If element is part of dialog wrapper, just ignore it\n\n\n    return false;\n  });\n};\n/**\r\n * Re-enables tab indexes after a popup container is closed\r\n */\n\n\nCoursePresentation.prototype.restoreTabIndexes = function () {\n  if (this.$tabbables) {\n    this.$tabbables.each(function () {\n      var $element = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)(this);\n      var tabindex = $element.data('tabindex'); // Specifically handle jquery ui slider, since it overwrites data in an inconsistent way\n\n      if ($element.hasClass('ui-slider-handle')) {\n        $element.attr('tabindex', 0);\n        $element.removeData('tabindex');\n      } else if (tabindex !== undefined) {\n        $element.attr('tabindex', tabindex);\n        $element.removeData('tabindex');\n      } else {\n        $element.removeAttr('tabindex');\n      }\n    });\n  }\n};\n/**\r\n * Creates the interaction button\r\n *\r\n * @param {Object} element\r\n * @param {Object} instance\r\n *\r\n * @return {jQuery}\r\n */\n\n\nCoursePresentation.prototype.createInteractionButton = function (element, instance) {\n  var _this6 = this;\n\n  var label = element.action.metadata ? element.action.metadata.title : '';\n\n  if (label === '') {\n    label = element.action.params && element.action.params.contentName || element.action.library.split(' ')[0].split('.')[1];\n  }\n\n  var libTypePmz = this.getLibraryTypePmz(element.action.library);\n  /**\r\n   * Returns a function that will set [aria-expanded=\"false\"] on the $btn element\r\n   *\r\n   * @param {jQuery} $btn\r\n   * @return {Function}\r\n   */\n\n  var setAriaExpandedFalse = function setAriaExpandedFalse($btn) {\n    return function () {\n      return $btn.attr('aria-expanded', 'false');\n    };\n  };\n\n  var $button = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)('<div>', {\n    role: 'button',\n    tabindex: 0,\n    'aria-label': label,\n    'aria-popup': true,\n    'aria-expanded': false,\n    'class': \"h5p-element-button h5p-element-button-\".concat(element.buttonSize, \" \").concat(libTypePmz, \"-button\")\n  });\n  var $buttonElement = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)('<div class=\"h5p-button-element\"></div>');\n  instance.attach($buttonElement);\n  var parentPosition = libTypePmz === 'h5p-advancedtext' ? {\n    x: element.x,\n    y: element.y\n  } : null;\n  (0,_utils__WEBPACK_IMPORTED_MODULE_7__.addClickAndKeyboardListeners)($button, function () {\n    $button.attr('aria-expanded', 'true');\n\n    _this6.showInteractionPopup(instance, $button, $buttonElement, libTypePmz, setAriaExpandedFalse($button), parentPosition);\n  });\n\n  if (element.action !== undefined && element.action.library.substr(0, 20) === 'H5P.InteractiveVideo') {\n    instance.on('controls', function () {\n      if (instance.controls.$fullscreen) {\n        instance.controls.$fullscreen.remove();\n      }\n    });\n  }\n\n  return $button;\n};\n/**\r\n * Shows the interaction popup on button press\r\n *\r\n * @param {object} instance\r\n * @param {string} libTypePmz\r\n * @param {function} closeCallback\r\n * @param {Object} [popupPosition] X and Y position of popup\r\n */\n\n\nCoursePresentation.prototype.showInteractionPopup = function (instance, $button, $buttonElement, libTypePmz, closeCallback) {\n  var _this7 = this;\n\n  var popupPosition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n  // Handle exit fullscreen\n  var exitFullScreen = function exitFullScreen() {\n    instance.trigger('resize');\n  };\n\n  if (!this.isEditor()) {\n    // Listen for exit fullscreens not triggered by button, for instance using 'esc'\n    this.on('exitFullScreen', exitFullScreen);\n    this.showPopup({\n      popupContent: $buttonElement,\n      $focusOnClose: $button,\n      parentPosition: popupPosition,\n      remove: function remove() {\n        var keepInDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (!keepInDOM) {\n          $buttonElement.detach();\n        } // Remove listener, we only need it for active popups\n\n\n        _this7.off('exitFullScreen', exitFullScreen);\n\n        closeCallback();\n      },\n      classes: libTypePmz,\n      instance: instance,\n      keepInDOM: libTypePmz === 'h5p-interactivevideo'\n    });\n    H5P.trigger(instance, 'resize'); // Resize images to fit popup dialog\n\n    if (libTypePmz === 'h5p-image') {\n      this.resizePopupImage($buttonElement);\n    } // Focus directly on content when popup is opened\n\n\n    setTimeout(function () {\n      var $tabbables = $buttonElement.find(':input').add($buttonElement.find('[tabindex]'));\n\n      if ($tabbables.length) {\n        $tabbables[0].focus();\n      } else {\n        $buttonElement.attr('tabindex', 0);\n        $buttonElement.focus();\n      }\n    }, 200); // start activity\n\n    if ((0,_utils__WEBPACK_IMPORTED_MODULE_7__.isFunction)(instance.setActivityStarted) && (0,_utils__WEBPACK_IMPORTED_MODULE_7__.isFunction)(instance.getScore)) {\n      instance.setActivityStarted();\n    }\n  }\n};\n/**\r\n * Returns the name part of a library string\r\n *\r\n * @param {string} library\r\n * @return {string}\r\n */\n\n\nCoursePresentation.prototype.getLibraryTypePmz = function (library) {\n  return (0,_utils__WEBPACK_IMPORTED_MODULE_7__.kebabCase)(library.split(' ')[0]).toLowerCase();\n};\n/**\r\n * Resize image inside popup dialog.\r\n *\r\n * @public\r\n * @param {H5P.jQuery} $wrapper\r\n */\n\n\nCoursePresentation.prototype.resizePopupImage = function ($wrapper) {\n  // Get fontsize, needed for scale\n  var fontSize = Number($wrapper.css('fontSize').replace('px', ''));\n  var $img = $wrapper.find('img');\n  /**\r\n   * Resize image to fit inside popup.\r\n   *\r\n   * @private\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\n\n  var resize = function resize(width, height) {\n    if (height / fontSize < 18.5) {\n      return;\n    }\n\n    var ratio = width / height;\n    height = 18.5 * fontSize;\n    $wrapper.css({\n      width: height * ratio,\n      height: height\n    });\n  };\n\n  if (!$img.height()) {\n    // Wait for image to load\n    $img.one('load', function () {\n      resize(this.width, this.height);\n    });\n  } else {\n    // Image already loaded, resize!\n    resize($img.width(), $img.height());\n  }\n};\n/**\r\n * Adds a info button\r\n *\r\n * @param {Object} element Properties from params.\r\n * @param {Object} elementInstance Instance of the element.\r\n * @param {jQuery} $elementContainer Wrapper for the element.\r\n */\n\n\nCoursePresentation.prototype.addElementSolutionButton = function (element, elementInstance, $elementContainer) {\n  var _this8 = this;\n\n  elementInstance.showCPComments = function () {\n    if ($elementContainer.children('.h5p-element-solution').length === 0 && (0,_utils__WEBPACK_IMPORTED_MODULE_7__.stripHTML)(element.solution).length > 0) {\n      var $commentButton = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)('<div/>', {\n        role: 'button',\n        tabindex: 0,\n        title: _this8.l10n.solutionsButtonTitle,\n        'aria-haspopup': 'dialog',\n        'aria-expanded': false,\n        'class': 'h5p-element-solution'\n      }).append('<span class=\"joubel-icon-comment-normal\"><span class=\"h5p-icon-shadow\"></span><span class=\"h5p-icon-speech-bubble\"></span><span class=\"h5p-icon-question\"></span></span>').appendTo($elementContainer);\n      var parentPosition = {\n        x: element.x,\n        y: element.y\n      };\n\n      if (!element.displayAsButton) {\n        parentPosition.x += element.width - 4;\n        parentPosition.y += element.height - 12;\n      }\n\n      (0,_utils__WEBPACK_IMPORTED_MODULE_7__.addClickAndKeyboardListeners)($commentButton, function (event) {\n        _this8.showPopup({\n          popupContent: element.solution,\n          $focusOnClose: $commentButton,\n          parentPosition: parentPosition,\n          updateAriaExpanded: true\n        });\n\n        $commentButton.attr('aria-expanded', true); // Prevents the wrapper from stealing the focus of screen readers\n\n        event.stopPropagation();\n      });\n    }\n  };\n\n  if (element.alwaysDisplayComments !== undefined && element.alwaysDisplayComments) {\n    elementInstance.showCPComments();\n  }\n};\n/**\r\n * Displays a popup.\r\n *\r\n * @param {string|jQuery} popupContent\r\n * @param {jQuery} $focusOnClose Prevents losing focus when dialog closes\r\n * @param {object} [parentPosition] x and y coordinates of parent\r\n * @param {Function} [remove] Gets called before the popup is removed.\r\n * @param {string} [classes]\r\n * @param {object} [instance] H5P library instance\r\n * @param {boolean} [keepInDOM] Hide the popup instead of removing it when it gets closed\r\n * @param {boolean} [updateAriaExpanded] Set aria-expanded=false on the $focusOnClose element when closing\r\n */\n\n\nCoursePresentation.prototype.showPopup = function (_ref) {\n  var _this9 = this;\n\n  var popupContent = _ref.popupContent,\n      $focusOnClose = _ref.$focusOnClose,\n      _ref$parentPosition = _ref.parentPosition,\n      parentPosition = _ref$parentPosition === void 0 ? null : _ref$parentPosition,\n      remove = _ref.remove,\n      _ref$classes = _ref.classes,\n      classes = _ref$classes === void 0 ? 'h5p-popup-comment-field' : _ref$classes,\n      instance = _ref.instance,\n      _ref$keepInDOM = _ref.keepInDOM,\n      keepInDOM = _ref$keepInDOM === void 0 ? false : _ref$keepInDOM,\n      updateAriaExpanded = _ref.updateAriaExpanded;\n  var self = this;\n  var doNotClose; // Give the popup elements unique ids\n\n  this.popupId = this.popupId === undefined ? 0 : this.popupId + 1;\n  /** @private */\n\n  var close = function close(event) {\n    if (doNotClose) {\n      // Prevent closing the popup\n      doNotClose = false;\n      return;\n    } // Enable focus to rest of page\n\n\n    self.restoreTabIndexes();\n    $focusOnClose.focus();\n\n    if (updateAriaExpanded) {\n      $focusOnClose.attr('aria-expanded', false);\n    } // Remove popup\n\n\n    if (remove !== undefined) {\n      setTimeout(function () {\n        remove(keepInDOM);\n      }, 100);\n    }\n\n    event.preventDefault();\n    $popup.addClass('h5p-animate');\n    $popup.find('.h5p-popup-container').addClass('h5p-animate');\n    setTimeout(function () {\n      if (keepInDOM) {\n        $popup.hide();\n      } else {\n        $popup.remove();\n      }\n    }, 100);\n  };\n\n  var $popup;\n\n  if (keepInDOM && instance && self.popups[instance.subContentId]) {\n    // The popup already exists in the DOM, but is hidden\n    $popup = self.popups[instance.subContentId];\n  }\n\n  if ($popup === undefined) {\n    // The popup must be created and added to the DOM\n    $popup = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)('<div class=\"h5p-popup-overlay ' + classes + '\">' + '<div ' + 'class=\"h5p-popup-container\" ' + 'role=\"dialog\"' + 'aria-modal=\"true\" ' + 'aria-live=\"true\" ' + 'aria-labelledby=\"popup-title-' + this.popupId + '\"> ' + '<div role=\"button\" tabindex=\"0\" class=\"h5p-close-popup\" title=\"' + this.l10n.close + '\"></div>' + '<div class=\"h5p-popup-wrapper\" role=\"document\"></div>' + '</div>' + '</div>');\n    var $popupWrapper = $popup.find('.h5p-popup-wrapper');\n\n    if (popupContent instanceof H5P.jQuery) {\n      $popupWrapper.append(popupContent);\n    } else {\n      $popupWrapper.html(popupContent);\n    } // Make sure the content is read by screen readers\n\n\n    var idList = '';\n    $popupWrapper.children().each(function (index, child) {\n      child.setAttribute('id', 'popup-content-' + _this9.popupId + '-' + index);\n      idList += 'popup-content-' + _this9.popupId + '-' + index + ' ';\n    });\n    $popup.find('.h5p-popup-container').attr('aria-describedby', idList);\n\n    if (instance && instance.subContentId) {\n      // Keep a reference to this popup\n      self.popups[instance.subContentId] = $popup;\n    }\n  }\n\n  var $popupContainer = $popup.find('.h5p-popup-container');\n\n  var resizePopup = function resizePopup($popup, $popupContainer, parentPosition) {\n    if (!parentPosition) {\n      return;\n    } // Do not show until we have finished calculating position\n\n\n    $popupContainer.css({\n      visibility: 'hidden'\n    });\n    $popup.prependTo(_this9.$wrapper);\n    var popupHeight = $popupContainer.height();\n    var popupWidth = $popupContainer.width();\n    var overlayHeight = $popup.height();\n    var overlayWidth = $popup.width();\n    var widthPercentage = popupWidth * (100 / overlayWidth);\n    var heightPercentage = popupHeight * (100 / overlayHeight); // Skip sufficiently big popups\n\n    var skipThreshold = 50;\n\n    if (widthPercentage > skipThreshold && heightPercentage > skipThreshold) {\n      $popup.detach();\n      return;\n    } // Only resize boxes that are disproportionally wide\n\n\n    var heightThreshold = 45;\n\n    if (widthPercentage > heightPercentage && heightPercentage < heightThreshold) {\n      // Make the popup quadratic\n      widthPercentage = Math.sqrt(widthPercentage * heightPercentage);\n      $popupContainer.css({\n        width: widthPercentage + '%'\n      });\n    } // Account for overflowing edges, use consistent percentage padding as css\n\n\n    var widthPaddingPercentage = 5; // Width percentage is capped at min 22 and max 90% in css\n\n    if (widthPercentage > 90) {\n      widthPercentage = 90;\n    } else if (widthPercentage < 22) {\n      widthPercentage = 22;\n    }\n\n    var overflowRightSideThreshold = 100 - widthPercentage - widthPaddingPercentage;\n    var leftPos = parentPosition.x;\n\n    if (parentPosition.x > overflowRightSideThreshold) {\n      leftPos = overflowRightSideThreshold;\n    } else if (parentPosition.x < widthPaddingPercentage) {\n      leftPos = widthPaddingPercentage;\n    }\n\n    heightPercentage = $popupContainer.height() * (100 / overlayHeight);\n    var heightPadding = 20 / 2;\n    var topPosThreshold = 100 - heightPercentage - heightPadding;\n    var topPos = parentPosition.y;\n\n    if (parentPosition.y > topPosThreshold) {\n      topPos = topPosThreshold;\n    } else if (parentPosition.y < heightPadding) {\n      topPos = heightPadding;\n    } // Reset and prepare to animate in\n\n\n    $popup.detach();\n    $popupContainer.css({\n      left: leftPos + '%',\n      top: topPos + '%'\n    });\n  };\n\n  resizePopup($popup, $popupContainer, parentPosition);\n  $popup.addClass('h5p-animate');\n  $popupContainer.css({\n    'visibility': ''\n  }).addClass('h5p-animate');\n\n  if ($popup.parent().length === 0) {\n    // Having no parent means the popup has not yet been added to the DOM\n    $popup.prependTo(this.$wrapper);\n  } else {\n    $popup.show();\n  } // Insert popup ready for use\n\n\n  $popup.removeClass('h5p-animate').click(close).find('.h5p-popup-container').removeClass('h5p-animate').click(function () {\n    doNotClose = true;\n  }).keydown(function (event) {\n    if (event.which === _utils__WEBPACK_IMPORTED_MODULE_7__.keyCode.ESC) {\n      close(event);\n    }\n  }).find('.h5p-close-popup').focus(); // Hide other elements from the tab order\n\n  this.disableTabIndexes();\n  (0,_utils__WEBPACK_IMPORTED_MODULE_7__.addClickAndKeyboardListeners)($popup.find('.h5p-close-popup'), function (event) {\n    return close(event);\n  });\n  return $popup;\n};\n/**\r\n * Checks if an element has a solution\r\n *\r\n * @param {H5P library instance} elementInstance\r\n * @returns {Boolean}\r\n *  true if the element has a solution\r\n *  false otherwise\r\n */\n\n\nCoursePresentation.prototype.checkForSolutions = function (elementInstance) {\n  return elementInstance.showSolutions !== undefined || elementInstance.showCPComments !== undefined;\n};\n/**\r\n * Initialize key press events.\r\n *\r\n * @returns {undefined} Nothing.\r\n */\n\n\nCoursePresentation.prototype.initKeyEvents = function () {\n  if (this.keydown !== undefined || this.activeSurface) {\n    return;\n  }\n\n  var that = this;\n  var wait = false;\n\n  this.keydown = function (event) {\n    if (wait) {\n      return;\n    } // Left\n\n\n    if ((event.keyCode === 37 || event.keyCode === 33) && that.previousSlide(undefined, false)) {\n      event.preventDefault();\n      wait = true;\n    } // Right\n    else if ((event.keyCode === 39 || event.keyCode === 34) && that.nextSlide(undefined, false)) {\n      event.preventDefault();\n      wait = true;\n    }\n\n    if (wait) {\n      // Make sure we only change slide every 300ms.\n      setTimeout(function () {\n        wait = false;\n      }, 300);\n    }\n  };\n\n  H5P.jQuery('body').keydown(this.keydown);\n};\n/**\r\n * Initialize touch events\r\n *\r\n * @returns {undefined} Nothing.\r\n */\n\n\nCoursePresentation.prototype.initTouchEvents = function () {\n  var that = this;\n  var startX, startY, lastX, prevX, nextX, scroll;\n  var touchStarted = false; // var containerWidth = this.$slidesWrapper.width();\n  // var containerPercentageForScrolling = 0.6; // 60% of container width used to reach endpoints with touch\n  // var slidesNumbers = this.slides.length;\n  // var pixelsPerSlide = (containerWidth * containerPercentageForScrolling) / slidesNumbers;\n  // var startTime;\n  // var currentTime;\n  // var navigateTimer = 500; // 500ms before navigation popup starts.\n\n  var isTouchJump = false; // var nextSlide;\n\n  var transform = function transform(value) {\n    return {\n      '-webkit-transform': value,\n      '-moz-transform': value,\n      '-ms-transform': value,\n      'transform': value\n    };\n  };\n\n  var reset = transform('');\n  this.$slidesWrapper.bind('touchstart', function (event) {\n    isTouchJump = false; // Set start positions\n\n    lastX = startX = event.originalEvent.touches[0].pageX;\n    startY = event.originalEvent.touches[0].pageY;\n    var slideWidth = that.$slidesWrapper.width(); // Set classes for slide movement and remember how much they move\n\n    prevX = that.currentSlideIndex === 0 ? 0 : -slideWidth;\n    nextX = that.currentSlideIndex + 1 >= that.slides.length ? 0 : slideWidth; // containerWidth = H5P.jQuery(this).width();\n    // startTime = new Date().getTime();\n\n    scroll = null;\n    touchStarted = true;\n  }).bind('touchmove', function (event) {\n    var touches = event.originalEvent.touches;\n\n    if (touchStarted) {\n      that.$current.prev().addClass('h5p-touch-move');\n      that.$current.next().addClass('h5p-touch-move');\n      touchStarted = false;\n    } // Determine horizontal movement\n\n\n    lastX = touches[0].pageX;\n    var movedX = startX - lastX;\n\n    if (scroll === null) {\n      // Detemine if we're scrolling horizontally or changing slide\n      scroll = Math.abs(startY - event.originalEvent.touches[0].pageY) > Math.abs(movedX);\n    }\n\n    if (touches.length !== 1 || scroll) {\n      // Do nothing if we're scrolling, zooming etc.\n      return;\n    } // Disable horizontal scrolling when changing slide\n\n\n    event.preventDefault(); // Create popup longer time than navigateTimer has passed\n\n    if (!isTouchJump) {\n      /*currentTime = new Date().getTime();\r\n      var timeLapsed = currentTime - startTime;\r\n      if (timeLapsed > navigateTimer) {\r\n        isTouchJump = true;\r\n      }*/\n      // Fast swipe to next slide\n      if (movedX < 0) {\n        // Move previous slide\n        that.$current.prev().css(transform('translateX(' + (prevX - movedX) + 'px'));\n      } else {\n        // Move next slide\n        that.$current.next().css(transform('translateX(' + (nextX - movedX) + 'px)'));\n      } // Move current slide\n\n\n      that.$current.css(transform('translateX(' + -movedX + 'px)'));\n    } // TODO: Jumping over multiple slides disabled until redesigned.\n\n    /* else {\r\n      that.$current.css(reset);\r\n      // Update slider popup.\r\n      nextSlide = parseInt(that.currentSlideIndex + (movedX / pixelsPerSlide), 10);\r\n      if (nextSlide >= that.slides.length -1) {\r\n        nextSlide = that.slides.length -1;\r\n      } else if (nextSlide < 0) {\r\n        nextSlide = 0;\r\n      }\r\n      // Create popup at initial touch point\r\n      that.updateTouchPopup(that.$slidesWrapper, nextSlide, startX, startY);\r\n    }*/\n\n  }).bind('touchend', function () {\n    if (!scroll) {\n      /*if (isTouchJump) {\r\n        that.jumpToSlide(nextSlide);\r\n        that.updateTouchPopup();\r\n        return;\r\n      }*/\n      // If we're not scrolling detemine if we're changing slide\n      var moved = startX - lastX;\n\n      if (moved > that.swipeThreshold && that.nextSlide(undefined, false) || moved < -that.swipeThreshold && that.previousSlide(undefined, false)) {\n        return;\n      }\n    } // Reset.\n\n\n    that.$slidesWrapper.children().css(reset).removeClass('h5p-touch-move');\n  });\n};\n/**\r\n *\r\n * @param $container\r\n * @param slideNumber\r\n * @param xPos\r\n * @param yPos\r\n */\n\n\nCoursePresentation.prototype.updateTouchPopup = function ($container, slideNumber, xPos, yPos) {\n  // Remove popup on no arguments\n  if (arguments.length <= 0) {\n    if (this.touchPopup !== undefined) {\n      this.touchPopup.remove();\n    }\n\n    return;\n  }\n\n  var keyword = '';\n  var yPosAdjustment = 0.15; // Adjust y-position 15% higher for visibility\n\n  if (this.$keywords !== undefined && this.$keywords.children(':eq(' + slideNumber + ')').find('span').html() !== undefined) {\n    keyword += this.$keywords.children(':eq(' + slideNumber + ')').find('span').html();\n  } else {\n    var slideIndexToNumber = slideNumber + 1;\n    keyword += this.l10n.slide + ' ' + slideIndexToNumber;\n  } // Summary slide keyword\n\n\n  if (this.editor === undefined) {\n    if (slideNumber >= this.slides.length - 1) {\n      keyword = this.l10n.showSolutions;\n    }\n  }\n\n  if (this.touchPopup === undefined) {\n    this.touchPopup = H5P.jQuery('<div/>', {\n      'class': 'h5p-touch-popup'\n    }).insertAfter($container);\n  } else {\n    this.touchPopup.insertAfter($container);\n  } // Adjust yPos above finger.\n\n\n  if (yPos - $container.parent().height() * yPosAdjustment < 0) {\n    yPos = 0;\n  } else {\n    yPos -= $container.parent().height() * yPosAdjustment;\n  }\n\n  this.touchPopup.css({\n    'max-width': $container.width() - xPos,\n    'left': xPos,\n    'top': yPos\n  });\n  this.touchPopup.html(keyword);\n};\n/**\r\n * Switch to previous slide\r\n *\r\n * @param {Boolean} [noScroll] Skip UI scrolling.\r\n * @returns {Boolean} Indicates if the move was made.\r\n */\n\n\nCoursePresentation.prototype.previousSlide = function (noScroll) {\n  var old = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var $prev = this.$current.prev();\n\n  if (!$prev.length) {\n    return false;\n  }\n\n  if (old) {\n    var ymap = this.doc.getMap('pageState');\n    ymap.set('currentPage', $prev.index());\n    return this.processJumpToSlide($prev.index(), noScroll, false);\n  } else {\n    return this.jumpToSlide($prev.index(), noScroll, null, false);\n  }\n};\n/**\r\n * Switch to next slide.\r\n *\r\n * @param {Boolean} noScroll Skip UI scrolling.\r\n * @returns {Boolean} Indicates if the move was made.\r\n */\n\n\nCoursePresentation.prototype.nextSlide = function (noScroll) {\n  var old = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var $next = this.$current.next();\n\n  if (!$next.length) {\n    return false;\n  }\n\n  if (old) {\n    var ymap = this.doc.getMap('pageState');\n    ymap.set('currentPage', $next.index());\n    return this.processJumpToSlide($next.index(), noScroll, false);\n  } else {\n    return this.jumpToSlide($next.index(), noScroll, null, false);\n  }\n};\n/**\r\n * Returns true when the element is the current slide\r\n *\r\n * @param {number} index\r\n * @return {boolean}\r\n */\n\n\nCoursePresentation.prototype.isCurrentSlide = function (index) {\n  return this.currentSlideIndex === index;\n};\n/**\r\n * Returns the current slide index\r\n *\r\n * @return {number}\r\n */\n\n\nCoursePresentation.prototype.getCurrentSlideIndex = function () {\n  return this.currentSlideIndex;\n};\n/**\r\n * Loads all slides (Needed by print)\r\n * @method attachAllElements\r\n */\n\n\nCoursePresentation.prototype.attachAllElements = function () {\n  var $slides = this.$slidesWrapper.children();\n\n  for (var i = 0; i < this.slides.length; i++) {\n    this.attachElements($slides.eq(i), i);\n  } // Need to force updating summary slide! This is normally done\n  // only when summary slide is about to be viewed\n\n\n  if (this.summarySlideObject !== undefined) {\n    this.summarySlideObject.updateSummarySlide(this.slides.length - 1, true);\n  }\n};\n/**\r\n * Process the jump to slide.\r\n *\r\n * @param {number} slideNumber The slide number to jump to.\r\n * @param {Boolean} [noScroll] Skip UI scrolling.\r\n * @returns {Boolean} Always true.\r\n */\n\n\nCoursePresentation.prototype.processJumpToSlide = function (slideNumber, noScroll, handleFocus) {\n  var that = this;\n\n  if (this.editor === undefined && this.contentId) {\n    // Content ID avoids crash when previewing in editor before saving\n    var progressedEvent = this.createXAPIEventTemplate('progressed');\n    progressedEvent.data.statement.object.definition.extensions['http://id.tincanapi.com/extension/ending-point'] = slideNumber + 1;\n    this.trigger(progressedEvent);\n  }\n\n  if (this.$current.hasClass('h5p-animate')) {\n    return;\n  } // Jump to given slide and enable animation.\n\n\n  var $old = this.$current.addClass('h5p-animate');\n  var $slides = that.$slidesWrapper.children();\n  var $prevs = $slides.filter(':lt(' + slideNumber + ')');\n  this.$current = $slides.eq(slideNumber).addClass('h5p-animate');\n  var previousSlideIndex = this.currentSlideIndex;\n  this.currentSlideIndex = slideNumber; // Attach elements for this slide\n\n  this.attachElements(this.$current, slideNumber); // Attach elements for next slide\n\n  var $nextSlide = this.$current.next();\n\n  if ($nextSlide.length) {\n    this.attachElements($nextSlide, slideNumber + 1);\n  } // For new slide\n\n\n  this.setOverflowTabIndex();\n  setTimeout(function () {\n    // Play animations\n    $old.removeClass('h5p-current');\n    $slides.css({\n      '-webkit-transform': '',\n      '-moz-transform': '',\n      '-ms-transform': '',\n      'transform': ''\n    }).removeClass('h5p-touch-move').removeClass('h5p-previous');\n    $prevs.addClass('h5p-previous');\n    that.$current.addClass('h5p-current');\n    that.trigger('changedSlide', that.$current.index());\n  }, 1);\n  setTimeout(function () {\n    // Done animating\n    that.$slidesWrapper.children().removeClass('h5p-animate');\n\n    if (that.editor !== undefined) {\n      return;\n    } // Set activity started\n\n\n    var instances = that.elementInstances[that.currentSlideIndex];\n    var instanceParams = that.slides[that.currentSlideIndex].elements;\n\n    if (instances !== undefined) {\n      for (var i = 0; i < instances.length; i++) {\n        if (!instanceParams[i].displayAsButton && typeof instances[i].setActivityStarted === 'function' && typeof instances[i].getScore === 'function') {\n          instances[i].setActivityStarted();\n        }\n      }\n    }\n  }, 250); // Jump keywords\n\n  if (this.$keywords !== undefined) {\n    this.keywordMenu.setCurrentSlideIndex(slideNumber);\n    this.$currentKeyword = this.$keywords.find('.h5p-current');\n\n    if (!noScroll) {\n      this.keywordMenu.scrollToKeywords(slideNumber);\n    }\n  } // Show keywords if they should always show\n\n\n  if (that.presentation.keywordListEnabled && that.presentation.keywordListAlwaysShow) {\n    that.showKeywords();\n  }\n\n  if (that.navigationLine) {\n    // Update progress bar\n    that.navigationLine.updateProgressBar(slideNumber, previousSlideIndex, this.isSolutionMode); // Update footer\n\n    that.navigationLine.updateFooter(slideNumber); // Announce slide change\n\n    this.setSlideNumberAnnouncer(slideNumber, handleFocus);\n  }\n\n  if (that.summarySlideObject) {\n    // Update summary slide if on last slide, do not jump\n    that.summarySlideObject.updateSummarySlide(slideNumber, true);\n  } // Editor specific settings\n\n\n  if (this.editor !== undefined && this.editor.dnb !== undefined) {\n    // Update drag and drop menu bar container\n    this.editor.dnb.setContainer(this.$current);\n    this.editor.dnb.blurAll();\n  }\n\n  this.trigger('resize'); // Triggered to resize elements.\n\n  this.fitCT();\n  return true;\n};\n/**\r\n * Jump to the given slide.\r\n *\r\n * @param {number} slideNumber The slide number to jump to.\r\n * @param {Boolean} [noScroll] Skip UI scrolling.\r\n * @param {Function|null} [callback] Callback to execute on successfull navigation\r\n * @param {Boolean} [ignoreConfirmationDialog] Will not show confirmation dialog for summary slide\r\n * @returns {Boolean}\r\n */\n\n\nCoursePresentation.prototype.jumpToSlide = function (slideNumber) {\n  var _this10 = this;\n\n  var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var handleFocus = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var ignoreConfirmationDialog = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  if (this.standalone && this.showSummarySlide && slideNumber === this.slides.length - 1 && !this.isSolutionMode && this.isReportingEnabled && !ignoreConfirmationDialog) {\n    // Currently in the summary slide\n    if (this.currentSlideIndex === this.slides.length - 1) {\n      return false;\n    }\n\n    var confirmationDialog = (0,_confirmation_dialog__WEBPACK_IMPORTED_MODULE_9__[\"default\"])({\n      headerText: this.l10n.confirmDialogHeader,\n      dialogText: this.l10n.confirmDialogText,\n      confirmText: this.l10n.confirmDialogConfirmationText\n    });\n    confirmationDialog.on('canceled', function () {\n      return false;\n    });\n    confirmationDialog.on('confirmed', function () {\n      var ymap = _this10.doc.getMap('pageState');\n\n      ymap.set('currentPage', slideNumber);\n\n      _this10.processJumpToSlide(slideNumber, noScroll, handleFocus);\n\n      if (callback) {\n        callback();\n      }\n    });\n  } else {\n    var ymap = this.doc.getMap('pageState');\n    ymap.set('currentPage', slideNumber);\n    this.processJumpToSlide(slideNumber, noScroll, handleFocus);\n\n    if (callback) {\n      callback();\n    }\n  }\n};\n/**\r\n * Set tab index for text containers that overflow with a scrollbar\r\n */\n\n\nCoursePresentation.prototype.setOverflowTabIndex = function () {\n  // On resume, this is not set yet, but it will be iovoked later\n  if (this.$current === undefined) {\n    return;\n  }\n\n  this.$current.find('.h5p-element-inner').each(function () {\n    var $inner = (0,_globals__WEBPACK_IMPORTED_MODULE_6__.jQuery)(this); // Currently, this rule is for tables only\n\n    var innerHeight;\n\n    if (this.classList.contains('h5p-table')) {\n      innerHeight = $inner.find('.h5p-table').outerHeight();\n    } // Add tabindex if there's an overflow (scrollbar depending on CSS)\n\n\n    var outerHeight = $inner.closest('.h5p-element-outer').innerHeight();\n\n    if (innerHeight !== undefined && outerHeight !== null && innerHeight > outerHeight) {\n      $inner.attr('tabindex', 0);\n    }\n  });\n};\n/**\r\n * Set slide number so it can be announced to assistive technologies\r\n * @param {number} slideNumber Index of slide that should have its' title announced\r\n * @param {boolean} [handleFocus=false] Moves focus to the top of the slide\r\n */\n\n\nCoursePresentation.prototype.setSlideNumberAnnouncer = function (slideNumber) {\n  var handleFocus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var slideTitle = '';\n\n  if (!this.navigationLine) {\n    return slideTitle;\n  } // Add slide number\n\n\n  var slide = this.slides[slideNumber];\n  var hasKeywords = slide.keywords && slide.keywords.length > 0;\n\n  if (hasKeywords && !this.navigationLine.isSummarySlide(slideNumber)) {\n    slideTitle += this.l10n.slide + ' ' + (slideNumber + 1) + ': ';\n  }\n\n  slideTitle += this.navigationLine.createSlideTitle(slideNumber);\n  this.$slideAnnouncer.html(slideTitle);\n\n  if (handleFocus) {\n    this.$slideTop.focus();\n  }\n};\n/**\r\n * Reset the content for all slides.\r\n * @public\r\n */\n\n\nCoursePresentation.prototype.IresetTask = function () {\n  this.summarySlideObject.toggleSolutionMode(false);\n\n  for (var i = 0; i < this.slidesWithSolutions.length; i++) {\n    if (this.slidesWithSolutions[i] !== undefined) {\n      for (var j = 0; j < this.slidesWithSolutions[i].length; j++) {\n        var elementInstance = this.slidesWithSolutions[i][j];\n\n        if (elementInstance.resetTask) {\n          elementInstance.resetTask();\n        }\n      }\n    }\n  }\n\n  this.navigationLine.updateProgressBar(0);\n  this.jumpToSlide(0);\n  this.$container.find('.h5p-popup-overlay').remove();\n};\n\nCoursePresentation.prototype.resetTask = function () {\n  var ymap = this.doc.getMap('pageState');\n  ymap.set('reset', \"yes\");\n  this.IresetTask();\n};\n/**\r\n * Show solutions for all slides that have solutions\r\n *\r\n * @returns {undefined}\r\n */\n\n\nCoursePresentation.prototype.showSolutions = function () {\n  var jumpedToFirst = false;\n  var slideScores = [];\n  var hasScores = false;\n\n  for (var i = 0; i < this.slidesWithSolutions.length; i++) {\n    if (this.slidesWithSolutions[i] !== undefined) {\n      if (!this.elementsAttached[i]) {\n        // Attach elements before showing solutions\n        this.attachElements(this.$slidesWrapper.children(':eq(' + i + ')'), i);\n      }\n\n      if (!jumpedToFirst) {\n        this.jumpToSlide(i, false);\n        jumpedToFirst = true; // TODO: Explain what this really does.\n      }\n\n      var slideScore = 0;\n      var slideMaxScore = 0;\n      var indexes = [];\n\n      for (var j = 0; j < this.slidesWithSolutions[i].length; j++) {\n        var elementInstance = this.slidesWithSolutions[i][j];\n\n        if (elementInstance.addSolutionButton !== undefined) {\n          elementInstance.addSolutionButton();\n        }\n\n        if (elementInstance.showSolutions) {\n          elementInstance.showSolutions();\n        }\n\n        if (elementInstance.showCPComments) {\n          elementInstance.showCPComments();\n        }\n\n        if (elementInstance.getMaxScore !== undefined) {\n          slideMaxScore += elementInstance.getMaxScore();\n          slideScore += elementInstance.getScore();\n          hasScores = true;\n          indexes.push(elementInstance.coursePresentationIndexOnSlide);\n        }\n      }\n\n      slideScores.push({\n        indexes: indexes,\n        slide: i + 1,\n        score: slideScore,\n        maxScore: slideMaxScore\n      });\n    } // Show comments of non graded contents\n\n\n    if (this.showCommentsAfterSolution[i]) {\n      for (var _j = 0; _j < this.showCommentsAfterSolution[i].length; _j++) {\n        if (typeof this.showCommentsAfterSolution[i][_j].showCPComments === 'function') {\n          this.showCommentsAfterSolution[i][_j].showCPComments();\n        }\n      }\n    }\n  }\n\n  if (hasScores) {\n    return slideScores;\n  }\n};\n/**\r\n * Gets slides scores for whole cp\r\n * @returns {Array} slideScores Array containing scores for all slides.\r\n */\n\n\nCoursePresentation.prototype.getSlideScores = function (noJump) {\n  var jumpedToFirst = noJump === true;\n  var slideScores = [];\n  var hasScores = false;\n\n  for (var i = 0; i < this.slidesWithSolutions.length; i++) {\n    if (this.slidesWithSolutions[i] !== undefined) {\n      if (!this.elementsAttached[i]) {\n        // Attach elements before showing solutions\n        this.attachElements(this.$slidesWrapper.children(':eq(' + i + ')'), i);\n      }\n\n      if (!jumpedToFirst) {\n        this.jumpToSlide(i, false);\n        jumpedToFirst = true; // TODO: Explain what this really does.\n      }\n\n      var slideScore = 0;\n      var slideMaxScore = 0;\n      var indexes = [];\n\n      for (var j = 0; j < this.slidesWithSolutions[i].length; j++) {\n        var elementInstance = this.slidesWithSolutions[i][j];\n\n        if (elementInstance.getMaxScore !== undefined) {\n          slideMaxScore += elementInstance.getMaxScore();\n          slideScore += elementInstance.getScore();\n          hasScores = true;\n          indexes.push(elementInstance.coursePresentationIndexOnSlide);\n        }\n      }\n\n      slideScores.push({\n        indexes: indexes,\n        slide: i + 1,\n        score: slideScore,\n        maxScore: slideMaxScore\n      });\n    }\n  }\n\n  if (hasScores) {\n    return slideScores;\n  }\n};\n/**\r\n * Gather copyright information for the current content.\r\n *\r\n * @returns {H5P.ContentCopyrights}\r\n */\n\n\nCoursePresentation.prototype.getCopyrights = function () {\n  var info = new H5P.ContentCopyrights();\n  var elementCopyrights; // Check for a common background image shared by all slides\n\n  if (this.presentation && this.presentation.globalBackgroundSelector && this.presentation.globalBackgroundSelector.imageGlobalBackground) {\n    // Add image copyrights to the presentation scope\n    var globalBackgroundImageParams = this.presentation.globalBackgroundSelector.imageGlobalBackground;\n    var globalBackgroundImageCopyright = new H5P.MediaCopyright(globalBackgroundImageParams.copyright);\n    globalBackgroundImageCopyright.setThumbnail(new H5P.Thumbnail(H5P.getPath(globalBackgroundImageParams.path, this.contentId), globalBackgroundImageParams.width, globalBackgroundImageParams.height));\n    info.addMedia(globalBackgroundImageCopyright);\n  }\n\n  for (var slide = 0; slide < this.slides.length; slide++) {\n    var slideInfo = new H5P.ContentCopyrights();\n    slideInfo.setLabel(this.l10n.slide + ' ' + (slide + 1)); // Check for a slide specific background image\n\n    if (this.slides[slide] && this.slides[slide].slideBackgroundSelector && this.slides[slide].slideBackgroundSelector.imageSlideBackground) {\n      // Add image copyrights to the slide scope\n      var slideBackgroundImageParams = this.slides[slide].slideBackgroundSelector.imageSlideBackground;\n      var slideBackgroundImageCopyright = new H5P.MediaCopyright(slideBackgroundImageParams.copyright);\n      slideBackgroundImageCopyright.setThumbnail(new H5P.Thumbnail(H5P.getPath(slideBackgroundImageParams.path, this.contentId), slideBackgroundImageParams.width, slideBackgroundImageParams.height));\n      slideInfo.addMedia(slideBackgroundImageCopyright);\n    } // If the slide has elements, add the ones with copyright info to this slides copyright\n\n\n    if (this.elementInstances[slide] !== undefined) {\n      for (var element = 0; element < this.elementInstances[slide].length; element++) {\n        var instance = this.elementInstances[slide][element];\n\n        if (!this.slides[slide].elements[element].action) {\n          continue;\n        }\n\n        var params = this.slides[slide].elements[element].action.params;\n        var metadata = this.slides[slide].elements[element].action.metadata;\n        elementCopyrights = undefined;\n\n        if (instance.getCopyrights !== undefined) {\n          // Use the instance's own copyright generator\n          elementCopyrights = instance.getCopyrights();\n        }\n\n        if (elementCopyrights === undefined) {\n          // Create a generic flat copyright list\n          elementCopyrights = new H5P.ContentCopyrights(); // In metadata alone there's no way of knowing what the machineName is.\n\n          H5P.findCopyrights(elementCopyrights, params, this.contentId, {\n            metadata: metadata,\n            machineName: instance.libraryInfo.machineName\n          });\n        }\n\n        var label = element + 1;\n\n        if (params.contentName !== undefined) {\n          label += ': ' + params.contentName;\n        } else if (instance.getTitle !== undefined) {\n          label += ': ' + instance.getTitle();\n        } else if (params.l10n && params.l10n.name) {\n          label += ': ' + params.l10n.name;\n        }\n\n        elementCopyrights.setLabel(label);\n        slideInfo.addContent(elementCopyrights);\n      }\n    }\n\n    info.addContent(slideInfo);\n  }\n\n  return info;\n};\n/**\r\n * Get xAPI data.\r\n * Contract used by report rendering engine.\r\n *\r\n * @see contract at {@link https://h5p.org/documentation/developers/contracts#guides-header-6}\r\n */\n\n\nCoursePresentation.prototype.getXAPIData = function () {\n  var xAPIEvent = this.createXAPIEventTemplate('answered'); // Extend definition\n\n  var definition = xAPIEvent.getVerifiedStatementValue(['object', 'definition']);\n  H5P.jQuery.extend(definition, {\n    interactionType: 'compound',\n    type: 'http://adlnet.gov/expapi/activities/cmi.interaction'\n  });\n  var score = this.getScore();\n  var maxScore = this.getMaxScore();\n  xAPIEvent.setScoredResult(score, maxScore, this, true, score === maxScore);\n  var childrenXAPIData = (0,_utils__WEBPACK_IMPORTED_MODULE_7__.flattenArray)(this.slidesWithSolutions).map(function (child) {\n    if (child && child.getXAPIData) {\n      return child.getXAPIData();\n    }\n  }).filter(function (data) {\n    return !!data;\n  });\n  return {\n    statement: xAPIEvent.data.statement,\n    children: childrenXAPIData\n  };\n};\n/**\r\n * Get context data.\r\n * Contract used for confusion report.\r\n */\n\n\nCoursePresentation.prototype.getContext = function () {\n  var self = this; // Get current slide number here it starts with zero\n\n  var slide = self.currentSlideIndex + 1;\n  return {\n    type: 'slide',\n    value: slide\n  };\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CoursePresentation);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEVBQXVERixLQUFLLEtBQUtFLFFBQWpFO0VBRUEsSUFBSTRlLGdCQUFnQixHQUFHL2lCLG9EQUFZLENBQUMsS0FBSzRCLG1CQUFOLENBQVosQ0FBdUNtSSxHQUF2QyxDQUEyQyxVQUFDcVEsS0FBRCxFQUFXO0lBQzNFLElBQUlBLEtBQUssSUFBSUEsS0FBSyxDQUFDcUksV0FBbkIsRUFBZ0M7TUFDOUIsT0FBT3JJLEtBQUssQ0FBQ3FJLFdBQU4sRUFBUDtJQUNEO0VBQ0YsQ0FKc0IsRUFJcEJqWSxNQUpvQixDQUliLFVBQUFwSixJQUFJO0lBQUEsT0FBSSxDQUFDLENBQUNBLElBQU47RUFBQSxDQUpTLENBQXZCO0VBTUEsT0FBTztJQUNMOEcsU0FBUyxFQUFFd2EsU0FBUyxDQUFDdGhCLElBQVYsQ0FBZThHLFNBRHJCO0lBRUx1RCxRQUFRLEVBQUVzWDtFQUZMLENBQVA7QUFJRCxDQXhCRDtBQTBCQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0F0aUIsa0JBQWtCLENBQUM2SSxTQUFuQixDQUE2QjBaLFVBQTdCLEdBQTBDLFlBQVk7RUFDcEQsSUFBSTNSLElBQUksR0FBRyxJQUFYLENBRG9ELENBR3BEOztFQUNBLElBQU1yTixLQUFLLEdBQUlxTixJQUFJLENBQUMzTixpQkFBTCxHQUF5QixDQUF4QztFQUNBLE9BQU87SUFDTG1mLElBQUksRUFBRSxPQUREO0lBRUxsUSxLQUFLLEVBQUUzTztFQUZGLENBQVA7QUFJRCxDQVREOztBQVdBLGlFQUFldkQsa0JBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2NwLmpzPzM0Y2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFBhcmVudCBmcm9tICdoNXAtcGFyZW50JztcclxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXHJcbmltcG9ydCB7IFNvY2tldElPUHJvdmlkZXIgfSBmcm9tICd5LXNvY2tldC5pbydcclxuaW1wb3J0IFN1bW1hcnlTbGlkZSBmcm9tICcuL3N1bW1hcnktc2xpZGUnO1xyXG5pbXBvcnQgTmF2aWdhdGlvbkxpbmUgZnJvbSAnLi9uYXZpZ2F0aW9uLWxpbmUnO1xyXG5pbXBvcnQgU2xpZGVCYWNrZ3JvdW5kIGZyb20gJy4vc2xpZGUtYmFja2dyb3VuZHMnO1xyXG5pbXBvcnQgS2V5d29yZHNNZW51IGZyb20gJy4va2V5d29yZC1tZW51JztcclxuaW1wb3J0IHsgalF1ZXJ5IGFzICQgfSBmcm9tICcuL2dsb2JhbHMnO1xyXG5pbXBvcnQgeyBmbGF0dGVuQXJyYXksIGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMsIGlzRnVuY3Rpb24sIGtlYmFiQ2FzZSwgc3RyaXBIVE1MLCBrZXlDb2RlIH0gZnJvbSAnLi91dGlscyc7XHJcbmltcG9ydCBTbGlkZSBmcm9tICcuL3NsaWRlLmpzJztcclxuaW1wb3J0IENvbmZpcm1hdGlvbkRpYWxvZyBmcm9tICcuL2NvbmZpcm1hdGlvbi1kaWFsb2cnO1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7c3RyaW5nfVxyXG4gKi9cclxuY29uc3QgS0VZV09SRF9USVRMRV9TS0lQID0gbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3Rvci5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBTdGFydCBwYXJhbXRlcmVzLlxyXG4gKiBAcGFyYW0ge2ludH0gaWQgQ29udGVudCBpZGVudGlmaWVyXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGVkaXRvclxyXG4gKiAgU2V0IGlmIGFuIGVkaXRvciBpcyBpbml0aWF0aW5nIHRoaXMgbGlicmFyeVxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBOb3RoaW5nLlxyXG4gKi9cclxubGV0IENvdXJzZVByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uIChwYXJhbXMsIGlkLCBleHRyYXMpIHtcclxuICBmdW5jdGlvbiBiZXR3ZWVuKG1pbiwgbWF4KSB7ICBcclxuICAgIHJldHVybiBNYXRoLmZsb29yKFxyXG4gICAgICBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW5cclxuICAgIClcclxuICB9XHJcbiAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gIHRoaXMuZGF0YSA9IFtdO1xyXG4gIHRoaXMuZG9jID0gbmV3IFkuRG9jKCk7XHJcbiAgdGhpcy5wcmVzZW50YXRpb24gPSBwYXJhbXMucHJlc2VudGF0aW9uO1xyXG4gIHRoaXMuc2xpZGVzID0gdGhpcy5wcmVzZW50YXRpb24uc2xpZGVzO1xyXG4gIHRoaXMuY29udGVudElkID0gaWQ7XHJcbiAgdGhpcy5lbGVtZW50SW5zdGFuY2VzID0gW107IC8vIGVsZW1lbnRJbnN0YW5jZXMgaG9sZHMgdGhlIGluc3RhbmNlcyBmb3IgZWxlbWVudHMgaW4gYW4gYXJyYXkuXHJcbiAgdGhpcy5lbGVtZW50c0F0dGFjaGVkID0gW107IC8vIE1hcCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIHNsaWRlIGhhcyBhdHRhY2hlZCBlbGVtZW50c1xyXG4gIHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9ucyA9IFtdO1xyXG4gIHRoaXMuc2hvd0NvbW1lbnRzQWZ0ZXJTb2x1dGlvbiA9IFtdO1xyXG4gIHRoaXMuaGFzQW5zd2VyRWxlbWVudHMgPSBmYWxzZTtcclxuICB0aGlzLmlnbm9yZVJlc2l6ZSA9IGZhbHNlO1xyXG4gIHRoaXMuaXNUYXNrID0gZmFsc2U7XHJcbiAgdGhpcy5zdGFuZGFsb25lID0gdHJ1ZTtcclxuICB0aGlzLmlzUmVwb3J0aW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gIHRoaXMucG9wdXBzID0ge307XHJcbiAgaWYgKGV4dHJhcy5jcEVkaXRvcikge1xyXG4gICAgdGhpcy5lZGl0b3IgPSBleHRyYXMuY3BFZGl0b3I7XHJcbiAgfVxyXG4gIGlmICh0aGlzLmVkaXRvcil7XHJcbiAgICB0aGlzLnByb3ZpZGVyICA9IG5ldyBTb2NrZXRJT1Byb3ZpZGVyKCd3czovLzE5Mi4xNjguMS4zOjEyMzQnLGJldHdlZW4oMSwxMCkudG9TdHJpbmcoKSx0aGlzLmRvYyx7XHJcbiAgICBhdXRvQ29ubmVjdDp0cnVlLFxyXG4gICAgLy8gZGlzYWJsZUJjOiB0cnVlLFxyXG4gICAgLy8gYXV0aDogeyB0b2tlbjogJ3ZhbGlkLXRva2VuJyB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgdGhpcy5wcm92aWRlciAgPSBuZXcgU29ja2V0SU9Qcm92aWRlcignd3M6Ly8xOTIuMTY4LjEuMzoxMjM0JyxpZCx0aGlzLmRvYyx7XHJcbiAgICBhdXRvQ29ubmVjdDp0cnVlLFxyXG4gICAgLy8gZGlzYWJsZUJjOiB0cnVlLFxyXG4gICAgLy8gYXV0aDogeyB0b2tlbjogJ3ZhbGlkLXRva2VuJyB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHZhciB5bWFwID0gdGhpcy5kb2MuZ2V0TWFwKCdwYWdlU3RhdGUnKTtcclxuICAvKnltYXAub2JzZXJ2ZSgoZSx0KT0+e1xyXG4gICAgY29uc29sZS5sb2coZS5jaGFuZ2VzLmtleXMpO1xyXG4gICAgaWYgKGUuY2hhbmdlcy5rZXlzLmhhcygnY3VycmVudFBhZ2UnKSlcclxuICAgIHtcclxuICAgICAgY29uc29sZS5sb2coeW1hcC5nZXQoJ2N1cnJlbnRQYWdlJykpO1xyXG4gICAgICB0aGlzLnByb2Nlc3NKdW1wVG9TbGlkZSh5bWFwLmdldCgnY3VycmVudFBhZ2UnKSk7XHJcbiAgICB9XHJcbiAgICBpZiAoZS5jaGFuZ2VzLmtleXMuaGFzKCdyZXNldCcpKXtcclxuICAgICAgdGhpcy5JcmVzZXRUYXNrKCk7XHJcbiAgICB9XHJcbiAgfSkqL1xyXG4gIHltYXAub2JzZXJ2ZSh5bWFwRXZlbnQgPT4ge1xyXG4gICAgeW1hcEV2ZW50LnRhcmdldCA9PT0geW1hcCAvLyA9PiB0cnVlXHJcbiAgXHJcbiAgICAvLyBGaW5kIG91dCB3aGF0IGNoYW5nZWQ6IFxyXG4gICAgLy8gT3B0aW9uIDE6IEEgc2V0IG9mIGtleXMgdGhhdCBjaGFuZ2VkXHJcbiAgICB5bWFwRXZlbnQua2V5c0NoYW5nZWQgLy8gPT4gU2V0PHN0cmluZ3M+XHJcbiAgICAvLyBPcHRpb24gMjogQ29tcHV0ZSB0aGUgZGlmZmVyZW5jZXNcclxuICAgIHltYXBFdmVudC5jaGFuZ2VzLmtleXMgLy8gPT4gTWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnfCd1cGRhdGUnfCdkZWxldGUnLCBvbGRWYWx1ZTogYW55fT5cclxuICBcclxuICAgIC8vIHNhbXBsZSBjb2RlLlxyXG4gICAgeW1hcEV2ZW50LmNoYW5nZXMua2V5cy5mb3JFYWNoKChjaGFuZ2UsIGtleSkgPT4ge1xyXG4gICAgICBpZiAoY2hhbmdlLmFjdGlvbiA9PT0gJ2FkZCcpIHtcclxuICAgICAgICBpZiAoa2V5PT09J2N1cnJlbnRQYWdlJyl7XHJcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHltYXAuZ2V0KCdjdXJyZW50UGFnZScpKTtcclxuICAgICAgICAgIHRoaXMucHJvY2Vzc0p1bXBUb1NsaWRlKHltYXAuZ2V0KCdjdXJyZW50UGFnZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLmFjdGlvbiA9PT0gJ3VwZGF0ZScpIHtcclxuICAgICAgICBpZiAoa2V5PT09J2N1cnJlbnRQYWdlJyl7XHJcbiAgICAgICAgICAvL2NvbnNvbGUubG9nKHltYXAuZ2V0KCdjdXJyZW50UGFnZScpKTtcclxuICAgICAgICAgIHRoaXMucHJvY2Vzc0p1bXBUb1NsaWRlKHltYXAuZ2V0KCdjdXJyZW50UGFnZScpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGtleT09PSdyZXNldCcpe1xyXG4gICAgICAgICAgLy9jb25zb2xlLmxvZygncmVzZXRlZCcpO1xyXG4gICAgICAgICAgdGhpcy5JcmVzZXRUYXNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2UgaWYgKGNoYW5nZS5hY3Rpb24gPT09ICdkZWxldGUnKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhgUHJvcGVydHkgXCIke2tleX1cIiB3YXMgZGVsZXRlZC4gTmV3IHZhbHVlOiB1bmRlZmluZWQuIFByZXZpb3VzIHZhbHVlOiBcIiR7Y2hhbmdlLm9sZFZhbHVlfVwiLmApXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfSlcclxuICBpZiAoZXh0cmFzKSB7XHJcbiAgICB0aGlzLnByZXZpb3VzU3RhdGUgPSBleHRyYXMucHJldmlvdXNTdGF0ZTtcclxuICAgIHRoaXMuc3RhbmRhbG9uZSA9IGV4dHJhcy5zdGFuZGFsb25lO1xyXG4gICAgdGhpcy5pc1JlcG9ydGluZ0VuYWJsZWQgPSBleHRyYXMuaXNSZXBvcnRpbmdFbmFibGVkIHx8IGV4dHJhcy5pc1Njb3JpbmdFbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgdGhpcy5jdXJyZW50U2xpZGVJbmRleCA9ICh0aGlzLnByZXZpb3VzU3RhdGUgJiYgdGhpcy5wcmV2aW91c1N0YXRlLnByb2dyZXNzKSA/IHRoaXMucHJldmlvdXNTdGF0ZS5wcm9ncmVzcyA6IDA7XHJcblxyXG4gIHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCA9IChwYXJhbXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IHBhcmFtcy5wcmVzZW50YXRpb24ua2V5d29yZExpc3RFbmFibGVkKTtcclxuXHJcbiAgdGhpcy5sMTBuID0gJC5leHRlbmQoe1xyXG4gICAgc2xpZGU6ICdTbGlkZScsXHJcbiAgICBzY29yZTogJ1Njb3JlJyxcclxuICAgIHlvdXJTY29yZTogJ1lvdXIgc2NvcmUnLFxyXG4gICAgbWF4U2NvcmU6ICdNYXggc2NvcmUnLFxyXG4gICAgdG90YWw6ICdUb3RhbCcsXHJcbiAgICB0b3RhbFNjb3JlOiAnVG90YWwgU2NvcmUnLFxyXG4gICAgc2hvd1NvbHV0aW9uczogJ1Nob3cgc29sdXRpb25zJyxcclxuICAgIHN1bW1hcnk6ICdzdW1tYXJ5JyxcclxuICAgIHJldHJ5OiAnUmV0cnknLFxyXG4gICAgZXhwb3J0QW5zd2VyczogJ0V4cG9ydCB0ZXh0JyxcclxuICAgIGNsb3NlOiAnQ2xvc2UnLFxyXG4gICAgaGlkZUtleXdvcmRzOiAnSGlkZSBzaWRlYmFyIG5hdmlnYXRpb24gbWVudScsXHJcbiAgICBzaG93S2V5d29yZHM6ICdTaG93IHNpZGViYXIgbmF2aWdhdGlvbiBtZW51JyxcclxuICAgIGZ1bGxzY3JlZW46ICdGdWxsc2NyZWVuJyxcclxuICAgIGV4aXRGdWxsc2NyZWVuOiAnRXhpdCBmdWxsc2NyZWVuJyxcclxuICAgIHByZXZTbGlkZTogJ1ByZXZpb3VzIHNsaWRlJyxcclxuICAgIG5leHRTbGlkZTogJ05leHQgc2xpZGUnLFxyXG4gICAgY3VycmVudFNsaWRlOiAnQ3VycmVudCBzbGlkZScsXHJcbiAgICBsYXN0U2xpZGU6ICdMYXN0IHNsaWRlJyxcclxuICAgIHNvbHV0aW9uTW9kZVRpdGxlOiAnRXhpdCBzb2x1dGlvbiBtb2RlJyxcclxuICAgIHNvbHV0aW9uTW9kZVRleHQ6ICdTb2x1dGlvbiBNb2RlJyxcclxuICAgIHN1bW1hcnlNdWx0aXBsZVRhc2tUZXh0OiAnTXVsdGlwbGUgdGFza3MnLFxyXG4gICAgc2NvcmVNZXNzYWdlOiAnWW91IGFjaGlldmVkOicsXHJcbiAgICBzaGFyZUZhY2Vib29rOiAnU2hhcmUgb24gRmFjZWJvb2snLFxyXG4gICAgc2hhcmVUd2l0dGVyOiAnU2hhcmUgb24gVHdpdHRlcicsXHJcbiAgICBzaGFyZUdvb2dsZTogJ1NoYXJlIG9uIEdvb2dsZSsnLFxyXG4gICAgZ29Ub1NsaWRlOiAnR28gdG8gc2xpZGUgOm51bScsXHJcbiAgICBzb2x1dGlvbnNCdXR0b25UaXRsZTogJ1Nob3cgY29tbWVudHMnLFxyXG4gICAgcHJpbnRUaXRsZTogJ1ByaW50JyxcclxuICAgIHByaW50SW5ncmVzczogJ0hvdyB3b3VsZCB5b3UgbGlrZSB0byBwcmludCB0aGlzIHByZXNlbnRhdGlvbj8nLFxyXG4gICAgcHJpbnRBbGxTbGlkZXM6ICdQcmludCBhbGwgc2xpZGVzJyxcclxuICAgIHByaW50Q3VycmVudFNsaWRlOiAnUHJpbnQgY3VycmVudCBzbGlkZScsXHJcbiAgICBub1RpdGxlOiAnTm8gdGl0bGUnLFxyXG4gICAgYWNjZXNzaWJpbGl0eVNsaWRlTmF2aWdhdGlvbkV4cGxhbmF0aW9uOiAnVXNlIGxlZnQgYW5kIHJpZ2h0IGFycm93IHRvIGNoYW5nZSBzbGlkZSBpbiB0aGF0IGRpcmVjdGlvbiB3aGVuZXZlciBjYW52YXMgaXMgc2VsZWN0ZWQuJyxcclxuICAgIGFjY2Vzc2liaWxpdHlQcm9ncmVzc0JhckxhYmVsOiAnQ2hvb3NlIHNsaWRlIHRvIGRpc3BsYXknLFxyXG4gICAgY29udGFpbnNOb3RDb21wbGV0ZWQ6ICdAc2xpZGVOYW1lIGNvbnRhaW5zIG5vdCBjb21wbGV0ZWQgaW50ZXJhY3Rpb24nLFxyXG4gICAgY29udGFpbnNDb21wbGV0ZWQ6ICdAc2xpZGVOYW1lIGNvbnRhaW5zIGNvbXBsZXRlZCBpbnRlcmFjdGlvbicsXHJcbiAgICBzbGlkZUNvdW50OiAnU2xpZGUgQGluZGV4IG9mIEB0b3RhbCcsXHJcbiAgICBhY2Nlc3NpYmlsaXR5Q2FudmFzTGFiZWw6ICdQcmVzZW50YXRpb24gY2FudmFzLiBVc2UgbGVmdCBhbmQgcmlnaHQgYXJyb3cgdG8gbW92ZSBiZXR3ZWVuIHNsaWRlcy4nLFxyXG4gICAgY29udGFpbnNPbmx5Q29ycmVjdDogXCJAc2xpZGVOYW1lIG9ubHkgaGFzIGNvcnJlY3QgYW5zd2Vyc1wiLFxyXG4gICAgY29udGFpbnNJbmNvcnJlY3RBbnN3ZXJzOiAnQHNsaWRlTmFtZSBoYXMgaW5jb3JyZWN0IGFuc3dlcnMnLFxyXG4gICAgc2hhcmVSZXN1bHQ6ICdTaGFyZSBSZXN1bHQnLFxyXG4gICAgYWNjZXNzaWJpbGl0eVRvdGFsU2NvcmU6ICdZb3UgZ290IEBzY29yZSBvZiBAbWF4U2NvcmUgcG9pbnRzIGluIHRvdGFsJyxcclxuICAgIGFjY2Vzc2liaWxpdHlFbnRlcmVkRnVsbHNjcmVlbjogJ0VudGVyZWQgZnVsbHNjcmVlbicsXHJcbiAgICBhY2Nlc3NpYmlsaXR5RXhpdGVkRnVsbHNjcmVlbjogJ0V4aXRlZCBmdWxsc2NyZWVuJyxcclxuICAgIGNvbmZpcm1EaWFsb2dIZWFkZXI6ICdTdWJtaXQgeW91ciBhbnN3ZXJzJyxcclxuICAgIGNvbmZpcm1EaWFsb2dUZXh0OiAnVGhpcyB3aWxsIHN1Ym1pdCB5b3VyIHJlc3VsdHMsIGRvIHlvdSB3YW50IHRvIGNvbnRpbnVlPycsXHJcbiAgICBjb25maXJtRGlhbG9nQ29uZmlybVRleHQ6ICdTdWJtaXQgYW5kIHNlZSByZXN1bHRzJyxcclxuICAgIHNsaWRlc2hvd05hdmlnYXRpb25MYWJlbDogJ1NsaWRlc2hvdyBuYXZpZ2F0aW9uJyxcclxuICB9LCBwYXJhbXMubDEwbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1zLmwxMG4gOiB7fSk7XHJcblxyXG4gIGlmICghIXBhcmFtcy5vdmVycmlkZSkge1xyXG4gICAgdGhpcy5hY3RpdmVTdXJmYWNlID0gISFwYXJhbXMub3ZlcnJpZGUuYWN0aXZlU3VyZmFjZTtcclxuICAgIHRoaXMuaGlkZVN1bW1hcnlTbGlkZSA9ICEhcGFyYW1zLm92ZXJyaWRlLmhpZGVTdW1tYXJ5U2xpZGU7XHJcbiAgICB0aGlzLmVuYWJsZVByaW50QnV0dG9uID0gISFwYXJhbXMub3ZlcnJpZGUuZW5hYmxlUHJpbnRCdXR0b247XHJcbiAgICB0aGlzLnNob3dTdW1tYXJ5U2xpZGVTb2x1dGlvbkJ1dHRvbiA9IHBhcmFtcy5vdmVycmlkZS5zdW1tYXJ5U2xpZGVTb2x1dGlvbkJ1dHRvbiAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gcGFyYW1zLm92ZXJyaWRlLnN1bW1hcnlTbGlkZVNvbHV0aW9uQnV0dG9uIDogdHJ1ZTtcclxuICAgIHRoaXMuc2hvd1N1bW1hcnlTbGlkZVJldHJ5QnV0dG9uID0gcGFyYW1zLm92ZXJyaWRlLnN1bW1hcnlTbGlkZVJldHJ5QnV0dG9uICE9PSB1bmRlZmluZWRcclxuICAgICAgPyBwYXJhbXMub3ZlcnJpZGUuc3VtbWFyeVNsaWRlUmV0cnlCdXR0b24gOiB0cnVlO1xyXG5cclxuICAgIGlmICghIXBhcmFtcy5vdmVycmlkZS5zb2NpYWwpIHtcclxuICAgICAgdGhpcy5lbmFibGVUd2l0dGVyU2hhcmUgPSAhIXBhcmFtcy5vdmVycmlkZS5zb2NpYWwuc2hvd1R3aXR0ZXJTaGFyZTtcclxuICAgICAgdGhpcy5lbmFibGVGYWNlYm9va1NoYXJlID0gISFwYXJhbXMub3ZlcnJpZGUuc29jaWFsLnNob3dGYWNlYm9va1NoYXJlO1xyXG4gICAgICB0aGlzLmVuYWJsZUdvb2dsZVNoYXJlID0gISFwYXJhbXMub3ZlcnJpZGUuc29jaWFsLnNob3dHb29nbGVTaGFyZTtcclxuXHJcbiAgICAgIHRoaXMudHdpdHRlclNoYXJlU3RhdGVtZW50ID0gcGFyYW1zLm92ZXJyaWRlLnNvY2lhbC50d2l0dGVyU2hhcmUuc3RhdGVtZW50O1xyXG4gICAgICB0aGlzLnR3aXR0ZXJTaGFyZUhhc2h0YWdzID0gcGFyYW1zLm92ZXJyaWRlLnNvY2lhbC50d2l0dGVyU2hhcmUuaGFzaHRhZ3M7XHJcbiAgICAgIHRoaXMudHdpdHRlclNoYXJlVXJsID0gcGFyYW1zLm92ZXJyaWRlLnNvY2lhbC50d2l0dGVyU2hhcmUudXJsO1xyXG5cclxuICAgICAgdGhpcy5mYWNlYm9va1NoYXJlVXJsID0gcGFyYW1zLm92ZXJyaWRlLnNvY2lhbC5mYWNlYm9va1NoYXJlLnVybDtcclxuICAgICAgdGhpcy5mYWNlYm9va1NoYXJlUXVvdGUgPSBwYXJhbXMub3ZlcnJpZGUuc29jaWFsLmZhY2Vib29rU2hhcmUucXVvdGU7XHJcblxyXG4gICAgICB0aGlzLmdvb2dsZVNoYXJlVXJsID0gcGFyYW1zLm92ZXJyaWRlLnNvY2lhbC5nb29nbGVTaGFyZVVybDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHRoaXMua2V5d29yZE1lbnUgPSBuZXcgS2V5d29yZHNNZW51KHtcclxuICAgIGwxMG4gOiB0aGlzLmwxMG4sXHJcbiAgICBjdXJyZW50SW5kZXg6IHRoaXMucHJldmlvdXNTdGF0ZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5wcmV2aW91c1N0YXRlLnByb2dyZXNzIDogMFxyXG4gIH0pO1xyXG5cclxuICAvLyBTZXQgb3ZlcnJpZGUgZm9yIGFsbCBhY3Rpb25zXHJcbiAgdGhpcy5zZXRFbGVtZW50c092ZXJyaWRlKHBhcmFtcy5vdmVycmlkZSk7XHJcblxyXG4gIC8vIEluaGVyaXRhbmNlXHJcbiAgUGFyZW50LmNhbGwodGhpcywgU2xpZGUsIHBhcmFtcy5wcmVzZW50YXRpb24uc2xpZGVzKTtcclxuXHJcbiAgdGhpcy5vbigncmVzaXplJywgdGhpcy5yZXNpemUsIHRoaXMpO1xyXG5cclxuICB0aGlzLm9uKCdwcmludGluZycsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdGhhdC5pZ25vcmVSZXNpemUgPSAhZXZlbnQuZGF0YS5maW5pc2hlZDtcclxuXHJcbiAgICBpZiAoZXZlbnQuZGF0YS5maW5pc2hlZCkge1xyXG4gICAgICB0aGF0LnJlc2l6ZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXZlbnQuZGF0YS5hbGxTbGlkZXMpIHtcclxuICAgICAgdGhhdC5hdHRhY2hBbGxFbGVtZW50cygpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGFyZW50LnByb3RvdHlwZSk7XHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb3Vyc2VQcmVzZW50YXRpb247XHJcblxyXG4vKipcclxuICogQHB1YmxpY1xyXG4gKiBAcmV0dXJuIHtvYmplY3R9XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmdldEN1cnJlbnRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc3RhdGUgPSB0aGlzLnByZXZpb3VzU3RhdGUgPyB0aGlzLnByZXZpb3VzU3RhdGUgOiB7fTtcclxuICBzdGF0ZS5wcm9ncmVzcyA9IHRoaXMuZ2V0Q3VycmVudFNsaWRlSW5kZXgoKTtcclxuICBpZiAoIXN0YXRlLmFuc3dlcnMpIHtcclxuICAgIHN0YXRlLmFuc3dlcnMgPSBbXTtcclxuICB9XHJcblxyXG4gIHN0YXRlLmFuc3dlcmVkID0gdGhpcy5lbGVtZW50SW5zdGFuY2VzXHJcbiAgICAubWFwKChpbnRlcmFjdGlvbiwgaW5kZXgpID0+IHRoaXMuc2xpZGVIYXNBbnN3ZXJlZFRhc2soaW5kZXgpKTtcclxuXHJcbiAgLy8gR2V0IGFuc3dlcnMgYW5kIGFuc3dlcmVkXHJcbiAgZm9yICh2YXIgc2xpZGUgPSAwOyBzbGlkZSA8IHRoaXMuZWxlbWVudEluc3RhbmNlcy5sZW5ndGg7IHNsaWRlKyspIHtcclxuICAgIGlmICh0aGlzLmVsZW1lbnRJbnN0YW5jZXNbc2xpZGVdKSB7XHJcbiAgICAgIGZvciAodmFyIGVsZW1lbnQgPSAwOyBlbGVtZW50IDwgdGhpcy5lbGVtZW50SW5zdGFuY2VzW3NsaWRlXS5sZW5ndGg7IGVsZW1lbnQrKykge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZWxlbWVudEluc3RhbmNlc1tzbGlkZV1bZWxlbWVudF07XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmdldEN1cnJlbnRTdGF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uIHx8XHJcbiAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRDdXJyZW50U3RhdGUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGlmICghc3RhdGUuYW5zd2Vyc1tzbGlkZV0pIHtcclxuICAgICAgICAgICAgc3RhdGUuYW5zd2Vyc1tzbGlkZV0gPSBbXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHN0YXRlLmFuc3dlcnNbc2xpZGVdW2VsZW1lbnRdID0gaW5zdGFuY2UuZ2V0Q3VycmVudFN0YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGEgc2xpZGUgaGFzIGFuc3dlcmVkIGludGVyYWN0aW9uc1xyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2xpZGVIYXNBbnN3ZXJlZFRhc2sgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICBjb25zdCB0YXNrcyA9IHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9uc1tpbmRleF0gfHwgW107XHJcblxyXG4gIHJldHVybiB0YXNrc1xyXG4gICAgLmZpbHRlcih0YXNrID0+IGlzRnVuY3Rpb24odGFzay5nZXRBbnN3ZXJHaXZlbikpXHJcbiAgICAuc29tZSh0YXNrID0+IHRhc2suZ2V0QW5zd2VyR2l2ZW4oKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVuZGVyIHRoZSBwcmVzZW50YXRpb24gaW5zaWRlIHRoZSBnaXZlbiBjb250YWluZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SDVQLmpRdWVyeX0gJGNvbnRhaW5lciBDb250YWluZXIgZm9yIHRoaXMgcHJlc2VudGF0aW9uLlxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBOb3RoaW5nLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoJGNvbnRhaW5lcikge1xyXG4gIHZhciB0aGF0ID0gdGhpcztcclxuXHJcbiAgLy8gaXNSb290IGlzIHVuZGVmaW5lZCBpbiB0aGUgZWRpdG9yXHJcbiAgaWYgKHRoaXMuaXNSb290ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pc1Jvb3QoKSkge1xyXG4gICAgdGhpcy5zZXRBY3Rpdml0eVN0YXJ0ZWQoKTtcclxuICB9XHJcblxyXG4gIHZhciBodG1sID1cclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLWtleW1hcC1leHBsYW5hdGlvbiBoaWRkZW4tYnV0LXJlYWRcIj4nICsgdGhpcy5sMTBuLmFjY2Vzc2liaWxpdHlTbGlkZU5hdmlnYXRpb25FeHBsYW5hdGlvbiArICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLWZ1bGxzY3JlZW4tYW5ub3VuY2VyIGhpZGRlbi1idXQtcmVhZFwiIGFyaWEtbGl2ZT1cInBvbGl0ZVwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XCJoNXAtd3JhcHBlclwiIHRhYmluZGV4PVwiMFwiIHJvbGU9XCJyZWdpb25cIiBhcmlhLXJvbGVkZXNjcmlwdGlvbj1cImNhcm91c2VsXCIgYXJpYS1sYWJlbD1cIicgKyB0aGlzLmwxMG4uYWNjZXNzaWJpbGl0eUNhbnZhc0xhYmVsICsgJ1wiPicgK1xyXG4gICAgICAgICAgJyAgPGRpdiBjbGFzcz1cImg1cC1jdXJyZW50LXNsaWRlLWFubm91bmNlciBoaWRkZW4tYnV0LXJlYWRcIiBhcmlhLWxpdmU9XCJwb2xpdGVcIj48L2Rpdj4nICtcclxuICAgICAgICAgICcgIDxkaXYgdGFiaW5kZXg9XCItMVwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgJyAgPGRpdiBjbGFzcz1cImg1cC1ib3gtYW5kLW5hdi13cmFwcGVyXCI+JyArXHJcbiAgICAgICAgICAnICAgIDxuYXYgY2xhc3M9XCJoNXAtY3AtbmF2aWdhdGlvblwiIGFyaWEtbGFiZWw9XCInICsgdGhpcy5sMTBuLnNsaWRlc2hvd05hdmlnYXRpb25MYWJlbCArICdcIj4nICtcclxuICAgICAgICAgICcgICAgICA8ZGl2IGNsYXNzPVwiaDVwLXByb2dyZXNzYmFyXCIgcm9sZT1cInRhYmxpc3RcIiBhcmlhLWxhYmVsPVwiJyArIHRoaXMubDEwbi5hY2Nlc3NpYmlsaXR5UHJvZ3Jlc3NCYXJMYWJlbCArICdcIj48L2Rpdj4nICtcclxuICAgICAgICAgICcgICAgPC9uYXY+JyArXHJcbiAgICAgICAgICAnICAgIDxkaXYgY2xhc3M9XCJoNXAtYm94LXdyYXBwZXJcIj4nICtcclxuICAgICAgICAgICcgICAgICA8ZGl2IGNsYXNzPVwiaDVwLXByZXNlbnRhdGlvbi13cmFwcGVyXCI+JyArXHJcbiAgICAgICAgICAnICAgICAgICA8ZGl2IGNsYXNzPVwiaDVwLWtleXdvcmRzLXdyYXBwZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICcgICAgICAgIDxkaXYgY2xhc3M9XCJoNXAtc2xpZGVzLXdyYXBwZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICcgICAgICA8L2Rpdj4nICtcclxuICAgICAgICAgICcgICAgPC9kaXY+JyArXHJcbiAgICAgICAgICAnICA8L2Rpdj4nICtcclxuICAgICAgICAgICcgIDxkaXYgY2xhc3M9XCJoNXAtZm9vdGVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JztcclxuXHJcbiAgJGNvbnRhaW5lclxyXG4gICAgLmF0dHIoJ3JvbGUnLCAnYXBwbGljYXRpb24nKVxyXG4gICAgLmFkZENsYXNzKCdoNXAtY291cnNlLXByZXNlbnRhdGlvbicpXHJcbiAgICAuaHRtbChodG1sKTtcclxuXHJcbiAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcclxuICB0aGlzLiRzbGlkZUFubm91bmNlciA9ICRjb250YWluZXIuZmluZCgnLmg1cC1jdXJyZW50LXNsaWRlLWFubm91bmNlcicpO1xyXG4gIHRoaXMuJGZ1bGxzY3JlZW5Bbm5vdW5jZXIgPSAkY29udGFpbmVyLmZpbmQoJy5oNXAtZnVsbHNjcmVlbi1hbm5vdW5jZXInKTtcclxuICB0aGlzLiRzbGlkZVRvcCA9IHRoaXMuJHNsaWRlQW5ub3VuY2VyLm5leHQoKTtcclxuICB0aGlzLiR3cmFwcGVyID0gJGNvbnRhaW5lci5jaGlsZHJlbignLmg1cC13cmFwcGVyJyk7XHJcblxyXG4gIGlmICh0aGlzLmFjdGl2ZVN1cmZhY2UpIHtcclxuICAgIHRoaXMuJHdyYXBwZXIuYWRkQ2xhc3MoJ2g1cC1jb3Vyc2UtcHJlc2VudGF0aW9uLWFjdGl2ZS1zdXJmYWNlJyk7XHJcbiAgfVxyXG5cclxuICB0aGlzLiR3cmFwcGVyLmZvY3VzKGZ1bmN0aW9uICgpIHtcclxuICAgIHRoYXQuaW5pdEtleUV2ZW50cygpO1xyXG4gIH0pLmJsdXIoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoYXQua2V5ZG93biAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIEg1UC5qUXVlcnkoJ2JvZHknKS51bmJpbmQoJ2tleWRvd24nLCB0aGF0LmtleWRvd24pO1xyXG4gICAgICBkZWxldGUgdGhhdC5rZXlkb3duO1xyXG4gICAgfVxyXG4gIH0pLmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdmFyICR0YXJnZXQgPSBINVAualF1ZXJ5KGV2ZW50LnRhcmdldCk7XHJcblxyXG4gICAgLypcclxuICAgICAqIEFkZCBmb2N1cyB0byB0aGUgd3JhcHBlciBzbyB0aGF0IGl0IG1heSBjYXB0dXJlIGtleWJvYXJkIGV2ZW50cyB1bmxlc3NcclxuICAgICAqIHRoZSB0YXJnZXQgb3Igb25lIG9mIGl0cyBwYXJlbnRzIHNob3VsZCBoYW5kbGUgZm9jdXMgdGhlbXNlbHZlcy5cclxuICAgICAqL1xyXG4gICAgY29uc3QgaXNGb2N1c2FibGVFbGVtZW50ID0gdGhhdC5iZWxvbmdzVG9UYWdOYW1lKFxyXG4gICAgICBldmVudC50YXJnZXQsIFsnaW5wdXQnLCAndGV4dGFyZWEnLCAnYScsICdidXR0b24nXSwgZXZlbnQuY3VycmVudFRhcmdldCk7XHJcbiAgICAvLyBEb2VzIHRoZSB0YXJnZXQgZWxlbWVudCBoYXZlIGEgdGFiSW5kZXggc2V0P1xyXG4gICAgY29uc3QgaGFzVGFiSW5kZXggPSAoZXZlbnQudGFyZ2V0LnRhYkluZGV4ICE9PSAtMSk7XHJcbiAgICAvLyBUaGUgZGlhbG9nIGNvbnRhaW5lciAoaWYgd2l0aGluIGEgZGlhbG9nKVxyXG4gICAgY29uc3QgJGRpYWxvZ1BhcmVudCA9ICR0YXJnZXQuY2xvc2VzdCgnLmg1cC1wb3B1cC1jb250YWluZXInKTtcclxuICAgIC8vIElzIHRhcmdldCB3aXRoaW4gYSBkaWFsb2dcclxuICAgIGNvbnN0IGlzV2l0aGluRGlhbG9nID0gJGRpYWxvZ1BhcmVudC5sZW5ndGggIT09IDA7XHJcblxyXG4gICAgaWYgKCFpc0ZvY3VzYWJsZUVsZW1lbnQgJiYgIWhhc1RhYkluZGV4ICYmICF0aGF0LmVkaXRvcikge1xyXG4gICAgICBpZiAoIWlzV2l0aGluRGlhbG9nKSB7XHJcbiAgICAgICAgLy8gV2UncmUgbm90IHdpdGhpbiBhIGRpYWxvZywgc28gd2UgY2FuIHNlYWZlbHkgcHV0IGZvY3VzIG9uIHdyYXBwZXJcclxuICAgICAgICB0aGF0LiR3cmFwcGVyLmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgY2xvc2VzdCB0YWJiYWJsZSBwYXJlbnQgZWxlbWVudFxyXG4gICAgICAgIGNvbnN0ICR0YWJiYWJsZSA9ICR0YXJnZXQuY2xvc2VzdCgnW3RhYmluZGV4XScpO1xyXG4gICAgICAgIC8vIElzIHRoZSBwYXJlbnQgdGFiYmFibGUgZWxlbWVudCBpbnNpZGUgdGhlIHBvcHVwP1xyXG4gICAgICAgIGlmICgkdGFiYmFibGUuY2xvc2VzdCgnLmg1cC1wb3B1cC1jb250YWluZXInKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgIC8vIFdlJ2xsIHNldCBmb2N1cyBoZXJlXHJcbiAgICAgICAgICAkdGFiYmFibGUuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAvLyBGYWxsYmFjazogc2V0IGZvY3VzIG9uIGNsb3NlIGJ1dHRvblxyXG4gICAgICAgICAgJGRpYWxvZ1BhcmVudC5maW5kKCcuaDVwLWNsb3NlLXBvcHVwJykuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhhdC5wcmVzZW50YXRpb24ua2V5d29yZExpc3RFbmFibGVkICYmXHJcbiAgICAgICAgIXRoYXQucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0QWx3YXlzU2hvdyAmJlxyXG4gICAgICAgIHRoYXQucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0QXV0b0hpZGUgJiZcclxuICAgICAgICAhJHRhcmdldC5pcygndGV4dGFyZWEsIC5oNXAtaWNvbi1wZW5jaWwsIHNwYW4nKSkge1xyXG4gICAgICB0aGF0LmhpZGVLZXl3b3JkcygpOyAvLyBBdXRvLWhpZGUga2V5d29yZHNcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgdGhpcy5vbignZXhpdEZ1bGxTY3JlZW4nLCAoKSA9PiB7XHJcbiAgICB0aGlzLiRmb290ZXIucmVtb3ZlQ2xhc3MoJ2Zvb3Rlci1mdWxsLXNjcmVlbicpO1xyXG4gICAgdGhpcy4kZnVsbFNjcmVlbkJ1dHRvbi5hdHRyKCdhcmlhLWxhYmVsJywgdGhpcy5sMTBuLmZ1bGxzY3JlZW4pO1xyXG4gICAgdGhpcy4kZnVsbHNjcmVlbkFubm91bmNlci5odG1sKHRoaXMubDEwbi5hY2Nlc3NpYmlsaXR5RXhpdGVkRnVsbHNjcmVlbik7XHJcbiAgfSk7XHJcblxyXG4gIHRoaXMub24oJ2VudGVyRnVsbFNjcmVlbicsICgpID0+IHtcclxuICAgIHRoaXMuJGZ1bGxzY3JlZW5Bbm5vdW5jZXIuaHRtbCh0aGlzLmwxMG4uYWNjZXNzaWJpbGl0eUVudGVyZWRGdWxsc2NyZWVuKTtcclxuICB9KTtcclxuXHJcbiAgLy8gR2V0IGludGVuZGVkIGJhc2Ugd2lkdGggZnJvbSBDU1MuXHJcbiAgdmFyIHdyYXBwZXJXaWR0aCA9IHBhcnNlSW50KHRoaXMuJHdyYXBwZXIuY3NzKCd3aWR0aCcpKTtcclxuICB0aGlzLndpZHRoID0gd3JhcHBlcldpZHRoICE9PSAwID8gd3JhcHBlcldpZHRoIDogNjQwO1xyXG5cclxuICB2YXIgd3JhcHBlckhlaWdodCA9IHBhcnNlSW50KHRoaXMuJHdyYXBwZXIuY3NzKCdoZWlnaHQnKSk7XHJcbiAgdGhpcy5oZWlnaHQgPSB3cmFwcGVySGVpZ2h0ICE9PSAwID8gd3JhcHBlckhlaWdodCA6IDQwMDtcclxuXHJcbiAgdGhpcy5yYXRpbyA9IDE2IC8gOTtcclxuICAvLyBJbnRlbmRlZCBiYXNlIGZvbnQgc2l6ZSBjYW5ub3QgYmUgcmVhZCBmcm9tIENTUywgYXMgaXQgbWlnaHQgYmUgbW9kaWZpZWRcclxuICAvLyBieSBtb2JpbGUgYnJvd3NlcnMgYWxyZWFkeS4gKFRoZSBBbmRyb2lkIG5hdGl2ZSBicm93c2VyIGRvZXMgdGhpcy4pXHJcbiAgdGhpcy5mb250U2l6ZSA9IDE2O1xyXG5cclxuICB0aGlzLiRib3hXcmFwcGVyID0gdGhpcy4kd3JhcHBlci5maW5kKCcuaDVwLWJveC13cmFwcGVyJyk7XHJcbiAgdmFyICRwcmVzZW50YXRpb25XcmFwcGVyID0gdGhpcy4kYm94V3JhcHBlci5jaGlsZHJlbignLmg1cC1wcmVzZW50YXRpb24td3JhcHBlcicpO1xyXG4gIHRoaXMuJHNsaWRlc1dyYXBwZXIgPSAkcHJlc2VudGF0aW9uV3JhcHBlci5jaGlsZHJlbignLmg1cC1zbGlkZXMtd3JhcHBlcicpO1xyXG4gIHRoaXMuJGtleXdvcmRzV3JhcHBlciA9ICRwcmVzZW50YXRpb25XcmFwcGVyLmNoaWxkcmVuKCcuaDVwLWtleXdvcmRzLXdyYXBwZXInKTtcclxuICB0aGlzLiRwcm9ncmVzc2JhciA9IHRoaXMuJHdyYXBwZXIuZmluZCgnLmg1cC1wcm9ncmVzc2JhcicpO1xyXG4gIHRoaXMuJGZvb3RlciA9IHRoaXMuJHdyYXBwZXIuY2hpbGRyZW4oJy5oNXAtZm9vdGVyJyk7XHJcblxyXG4gIC8vIERldGVybWluZSBpZiBrZXl3b3JkcyBwYW5lIHNob3VsZCBiZSBpbml0aWFsaXplZFxyXG4gIHRoaXMuaW5pdEtleXdvcmRzID0gKHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCA9PT0gdW5kZWZpbmVkIHx8IHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCA9PT0gdHJ1ZSB8fCB0aGlzLmVkaXRvciAhPT0gdW5kZWZpbmVkKTtcclxuICBpZiAodGhpcy5hY3RpdmVTdXJmYWNlICYmIHRoaXMuZWRpdG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMuaW5pdEtleXdvcmRzID0gZmFsc2U7XHJcbiAgICB0aGlzLiRib3hXcmFwcGVyLmNzcygnaGVpZ2h0JywgJzEwMCUnKTtcclxuICB9XHJcbiAgdGhpcy5pc1NvbHV0aW9uTW9kZSA9IGZhbHNlO1xyXG5cclxuICAvLyBDcmVhdGUgc2xpZGVzIGFuZCByZXRyaWV2ZSBrZXl3b3JkIHRpdGxlIGRldGFpbHNcclxuICB0aGlzLmNyZWF0ZVNsaWRlcygpO1xyXG5cclxuICAvLyBXZSBoYXZlIGFsd2F5cyBhdHRhY2hlZCBhbGwgZWxlbWVudHMgb24gY3VycmVudCBzbGlkZVxyXG4gIHRoaXMuZWxlbWVudHNBdHRhY2hlZFt0aGlzLmN1cnJlbnRTbGlkZUluZGV4XSA9IHRydWU7XHJcblxyXG4gIC8vIERldGVybWluZSBpZiBzdW1tYXJ5IHNsaWRlIHNob3VsZCBiZSBhZGRlZFxyXG4gIHZhciAkc3VtbWFyeVNsaWRlO1xyXG4gIHRoaXMuc2hvd1N1bW1hcnlTbGlkZSA9IGZhbHNlO1xyXG4gIGlmICh0aGlzLmhpZGVTdW1tYXJ5U2xpZGUpIHtcclxuICAgIC8vIEFsd2F5cyBoaWRlXHJcbiAgICB0aGlzLnNob3dTdW1tYXJ5U2xpZGUgPSAhdGhpcy5oaWRlU3VtbWFyeVNsaWRlO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIERldGVybWluZSBieSBjaGVja2luZyBmb3Igc2xpZGVzIHdpdGggdGFza3NcclxuICAgIHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChzbGlkZSkge1xyXG4gICAgICB0aGF0LnNob3dTdW1tYXJ5U2xpZGUgPSBzbGlkZS5sZW5ndGg7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGlmICgodGhpcy5lZGl0b3IgPT09IHVuZGVmaW5lZCkgJiYgKHRoaXMuc2hvd1N1bW1hcnlTbGlkZSB8fCB0aGlzLmhhc0Fuc3dlckVsZW1lbnRzKSkge1xyXG4gICAgLy8gQ3JlYXRlIHRoZSBzdW1tYXJ5IHNsaWRlXHJcbiAgICB2YXIgc3VtbWFyeVNsaWRlUGFyYW1zID0ge1xyXG4gICAgICBlbGVtZW50czogW10sXHJcbiAgICAgIGtleXdvcmRzOiBbXVxyXG4gICAgfTtcclxuICAgIHRoaXMuc2xpZGVzLnB1c2goc3VtbWFyeVNsaWRlUGFyYW1zKTtcclxuXHJcbiAgICAkc3VtbWFyeVNsaWRlID0gSDVQLmpRdWVyeShTbGlkZS5jcmVhdGVIVE1MKHN1bW1hcnlTbGlkZVBhcmFtcykpLmFwcGVuZFRvKHRoaXMuJHNsaWRlc1dyYXBwZXIpO1xyXG4gICAgJHN1bW1hcnlTbGlkZS5hZGRDbGFzcygnaDVwLXN1bW1hcnktc2xpZGUnKTtcclxuXHJcbiAgICBpZiAodGhpcy5pc0N1cnJlbnRTbGlkZSh0aGlzLnNsaWRlcy5sZW5ndGggLSAxKSkge1xyXG4gICAgICB0aGlzLiRjdXJyZW50ID0gJHN1bW1hcnlTbGlkZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGNvbnN0IGtleXdvcmRNZW51Q29uZmlnID0gdGhpcy5nZXRLZXl3b3JkTWVudUNvbmZpZygpO1xyXG5cclxuICAvLyBEbyBub3Qgc2hvdyBrZXl3b3JkcyBwYW5lIGlmIGl0J3MgZW1wdHkgYW5kIHRoZXJlJ3Mgbm8gZWRpdG9yIVxyXG4gIGlmIChrZXl3b3JkTWVudUNvbmZpZy5sZW5ndGggPiAwIHx8IHRoaXMuaXNFZGl0b3IoKSkge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSBrZXl3b3JkIHRpdGxlc1xyXG4gICAgdGhpcy5rZXl3b3JkTWVudS5pbml0KGtleXdvcmRNZW51Q29uZmlnKTtcclxuICAgIHRoaXMua2V5d29yZE1lbnUub24oJ3NlbGVjdCcsIGV2ZW50ID0+IHRoaXMua2V5d29yZENsaWNrKGV2ZW50LmRhdGEuaW5kZXgpKTtcclxuICAgIHRoaXMua2V5d29yZE1lbnUub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5oaWRlS2V5d29yZHMoKSk7XHJcbiAgICB0aGlzLmtleXdvcmRNZW51Lm9uKCdzZWxlY3QnLCAoKSA9PiB7XHJcbiAgICAgIHRoaXMuJGN1cnJlbnRLZXl3b3JkID0gdGhpcy4ka2V5d29yZHMuY2hpbGRyZW4oJy5oNXAtY3VycmVudCcpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy4ka2V5d29yZHMgPSAkKHRoaXMua2V5d29yZE1lbnUuZ2V0RWxlbWVudCgpKS5hcHBlbmRUbyh0aGlzLiRrZXl3b3Jkc1dyYXBwZXIpO1xyXG4gICAgdGhpcy4kY3VycmVudEtleXdvcmQgPSB0aGlzLiRrZXl3b3Jkcy5jaGlsZHJlbignLmg1cC1jdXJyZW50Jyk7XHJcblxyXG4gICAgaWYgKHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0T3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRoaXMuc2V0S2V5d29yZHNPcGFjaXR5KHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0T3BhY2l0eSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0QWx3YXlzU2hvdykge1xyXG4gICAgICB0aGlzLnNob3dLZXl3b3JkcygpO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIFJlbW92ZSBrZXl3b3JkIHRpdGxlcyBjb21wbGV0ZWx5XHJcbiAgICB0aGlzLiRrZXl3b3Jkc1dyYXBwZXIucmVtb3ZlKCk7XHJcblxyXG4gICAgLy8gRG8gbm90IHNob3cga2V5d29yZHMgcGFuZSBpZiBpdCdzIGVtcHR5IGFuZCB0aGVyZSdzIG5vIGVkaXRvciFcclxuICAgIHRoaXMuaW5pdEtleXdvcmRzID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy5lZGl0b3IgIT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hY3RpdmVTdXJmYWNlKSB7XHJcbiAgICAvLyBJbml0aWFsaXplIHRvdWNoIGV2ZW50c1xyXG4gICAgdGhpcy5pbml0VG91Y2hFdmVudHMoKTtcclxuXHJcbiAgICAvLyBpbml0IG5hdmlnYXRpb24gbGluZVxyXG4gICAgdGhpcy5uYXZpZ2F0aW9uTGluZSA9IG5ldyBOYXZpZ2F0aW9uTGluZSh0aGlzKTtcclxuXHJcbiAgICAvLyBTZXQgc2xpZGUgdGl0bGUgaWYgaW5pdGluZyBvbiBzbGlkZSAwXHJcbiAgICBpZiAoIXRoaXMucHJldmlvdXNTdGF0ZSB8fCAhdGhpcy5wcmV2aW91c1N0YXRlLnByb2dyZXNzKSB7XHJcbiAgICAgIHRoaXMuc2V0U2xpZGVOdW1iZXJBbm5vdW5jZXIoMCwgZmFsc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuc3VtbWFyeVNsaWRlT2JqZWN0ID0gbmV3IFN1bW1hcnlTbGlkZSh0aGlzLCAkc3VtbWFyeVNsaWRlKTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICB0aGlzLiRwcm9ncmVzc2Jhci5hZGQodGhpcy4kZm9vdGVyKS5yZW1vdmUoKTtcclxuXHJcbiAgICBpZiAoSDVQLmZ1bGxzY3JlZW5TdXBwb3J0ZWQpIHtcclxuICAgICAgLy8gQ3JlYXRlIGZ1bGwgc2NyZWVuIGJ1dHRvblxyXG4gICAgICB0aGlzLiRmdWxsU2NyZWVuQnV0dG9uID0gSDVQLmpRdWVyeSgnPGRpdi8+Jywge1xyXG4gICAgICAgICdjbGFzcyc6ICdoNXAtdG9nZ2xlLWZ1bGwtc2NyZWVuJyxcclxuICAgICAgICAnYXJpYS1sYWJlbCc6IHRoaXMubDEwbi5mdWxsc2NyZWVuLFxyXG4gICAgICAgIHJvbGU6ICdidXR0b24nLFxyXG4gICAgICAgIHRhYmluZGV4OiAwLFxyXG4gICAgICAgIGFwcGVuZFRvOiB0aGlzLiR3cmFwcGVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgSDVQLlRvb2x0aXAodGhpcy4kZnVsbFNjcmVlbkJ1dHRvbi5nZXQoMCksIHtwb3NpdGlvbjogJ2xlZnQnfSk7XHJcblxyXG4gICAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKHRoaXMuJGZ1bGxTY3JlZW5CdXR0b24sICgpID0+IHRoYXQudG9nZ2xlRnVsbFNjcmVlbigpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5ldyBTbGlkZUJhY2tncm91bmQodGhpcyk7XHJcbiAgLyppZiAodGhpcy5wcmV2aW91c1N0YXRlICYmIHRoaXMucHJldmlvdXNTdGF0ZS5wcm9ncmVzcykge1xyXG4gICAgdGhpcy5qdW1wVG9TbGlkZSh0aGlzLnByZXZpb3VzU3RhdGUucHJvZ3Jlc3MsZmFsc2UsIG51bGwsIGZhbHNlLCB0cnVlKTtcclxuICB9Ki9cclxuICB2YXIgeW1hcCA9IHRoaXMuZG9jLmdldE1hcCgncGFnZVN0YXRlJyk7XHJcbiAgaWYgKHltYXAuaGFzKCdjdXJyZW50UGFnZScpKSB0aGlzLmp1bXBUb1NsaWRlKHltYXAuZ2V0KCdjdXJyZW50UGFnZScpKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBhIG5vZGUgb3Igb25lIG9mIGl0cyBwYXJlbnRzIGhhcyBhIHBhcnRpY3VsYXIgdGFnIG5hbWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjay5cclxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRhZ05hbWVzIFRhZyBuYW1lKHMpLlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbc3RvcF0gT3B0aW9uYWwgbm9kZSB0byBzdG9wLiBEZWZhdWx0cyB0byBib2R5IG5vZGUuXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUsIGlmIG5vZGUgYmVsb25ncyB0byBhIG5vZGUgd2l0aCBvbmUgb2YgdGhlIHRhZyBuYW1lcy5cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuYmVsb25nc1RvVGFnTmFtZSA9IGZ1bmN0aW9uIChub2RlLCB0YWdOYW1lcywgc3RvcCkge1xyXG4gIGlmICghbm9kZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RvcCBjaGVjayBhdCBET00gdHJlZSByb290XHJcbiAgc3RvcCA9IHN0b3AgfHwgZG9jdW1lbnQuYm9keTtcclxuXHJcbiAgaWYgKHR5cGVvZiB0YWdOYW1lcyA9PT0gJ3N0cmluZycpIHtcclxuICAgIHRhZ05hbWVzID0gW3RhZ05hbWVzXTtcclxuICB9XHJcbiAgdGFnTmFtZXMgPSB0YWdOYW1lcy5tYXAodGFnTmFtZSA9PiB0YWdOYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuICBjb25zdCB0YWdOYW1lID0gbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgaWYgKHRhZ05hbWVzLmluZGV4T2YodGFnTmFtZSkgIT09IC0xKSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIEhhdmluZyBzdG9wIGNhbiBwcmV2ZW50IGFsd2F5cyBwYXJzaW5nIERPTSB0cmVlIHRvIHJvb3RcclxuICBpZiAoc3RvcCA9PT0gbm9kZSkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXMuYmVsb25nc1RvVGFnTmFtZShub2RlLnBhcmVudE5vZGUsIHRhZ05hbWVzLCBzdG9wKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIG9sZCBtZW51IGl0ZW1zLCBhbmQgY3JlYXRlIG5ldyBvbmVzIGZyb20gc2xpZGVzLlxyXG4gKiBSZXR1cm5zIG1lbnUgaXRlbXMgYXMgalF1ZXJ5XHJcbiAqXHJcbiAqIEByZXR1cm4ge2pRdWVyeX1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUudXBkYXRlS2V5d29yZE1lbnVGcm9tU2xpZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMua2V5d29yZE1lbnUucmVtb3ZlQWxsTWVudUl0ZW1FbGVtZW50cygpO1xyXG4gIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0S2V5d29yZE1lbnVDb25maWcoKTtcclxuICByZXR1cm4gJCh0aGlzLmtleXdvcmRNZW51LmluaXQoY29uZmlnKSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBrZXl3b3JkIG1lbnUgY29uZmlnIGJhc2VkIG9uIHRoZSBzbGlkZXMgcGFyYW1ldGVyc1xyXG4gKlxyXG4gKiBAcmV0dXJuIHtLZXl3b3JkTWVudUl0ZW1Db25maWdbXX1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuZ2V0S2V5d29yZE1lbnVDb25maWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuc2xpZGVzXHJcbiAgICAubWFwKChzbGlkZSwgaW5kZXgpID0+ICh7XHJcbiAgICAgIHRpdGxlOiB0aGlzLmNyZWF0ZVNsaWRlVGl0bGUoc2xpZGUpLFxyXG4gICAgICBzdWJ0aXRsZTogYCR7dGhpcy5sMTBuLnNsaWRlfSAke2luZGV4ICsgMX1gLFxyXG4gICAgICBpbmRleFxyXG4gICAgfSkpXHJcbiAgICAuZmlsdGVyKGNvbmZpZyA9PiBjb25maWcudGl0bGUgIT09IEtFWVdPUkRfVElUTEVfU0tJUCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc2xpZGUgdGl0bGUsIG9yIFwiTm8gdGl0bGVcIiBpZiBpbnNpZGUgZWRpdG9yIHdpdGhvdXQgdGl0bGVcclxuICpcclxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmNyZWF0ZVNsaWRlVGl0bGUgPSBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICBjb25zdCBmYWxsYmFja1RpdGxlRm9yRWRpdG9yID0gdGhpcy5pc0VkaXRvcigpID8gdGhpcy5sMTBuLm5vVGl0bGUgOiBLRVlXT1JEX1RJVExFX1NLSVA7XHJcbiAgcmV0dXJuIHRoaXMuaGFzS2V5d29yZHMoc2xpZGUpID8gc2xpZGUua2V5d29yZHNbMF0ubWFpbiA6IGZhbGxiYWNrVGl0bGVGb3JFZGl0b3I7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGluc2lkZSB0aGUgZWRpdG9yXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmlzRWRpdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLmVkaXRvciAhPT0gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHNsaWRlIGhhcyBrZXl3b3Jkc1xyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gc2xpZGVcclxuICogQHJldHVybiB7Ym9vbGVhbn1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuaGFzS2V5d29yZHMgPSBmdW5jdGlvbiAoc2xpZGUpIHtcclxuICByZXR1cm4gc2xpZGUua2V5d29yZHMgIT09IHVuZGVmaW5lZCAmJiBzbGlkZS5rZXl3b3Jkcy5sZW5ndGggPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGUgc2xpZGVzXHJcbiAqIFNsaWRlcyBhcmUgZGlyZWN0bHkgYXR0YWNoZWQgdG8gdGhlIHNsaWRlcyB3cmFwcGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBzbGlkZXNQYXJhbXNcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuY3JlYXRlU2xpZGVzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGYuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGlzQ3VycmVudFNsaWRlID0gKGkgPT09IHNlbGYuY3VycmVudFNsaWRlSW5kZXgpO1xyXG5cclxuICAgIC8vIENyZWF0ZSBhbmQgYXBwZW5kIERPTSBFbGVtZW50c1xyXG4gICAgc2VsZi5jaGlsZHJlbltpXS5nZXRFbGVtZW50KCkuYXBwZW5kVG8oc2VsZi4kc2xpZGVzV3JhcHBlcik7XHJcblxyXG4gICAgaWYgKGlzQ3VycmVudFNsaWRlKSB7XHJcbiAgICAgIHNlbGYuY2hpbGRyZW5baV0uc2V0Q3VycmVudCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZWxmLmlzRWRpdG9yKCkgfHwgaSA9PT0gMCB8fCBpID09PSAxIHx8IGlzQ3VycmVudFNsaWRlKSB7XHJcbiAgICAgIHNlbGYuY2hpbGRyZW5baV0uYXBwZW5kRWxlbWVudHMoKTtcclxuICAgIH1cclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogRG9lcyBhbiBvYmplY3QgaGF2ZSBmdW5jdGlvbnMgdG8gZGV0ZXJtaW5lIHRoZSBzY29yZVxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBpbnZlc3RpZ2F0ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuaGFzU2NvcmVEYXRhID0gZnVuY3Rpb24gKG9iaikge1xyXG4gIHJldHVybiAoXHJcbiAgICAodHlwZW9mIG9iaiAhPT0gdHlwZW9mIHVuZGVmaW5lZCkgJiZcclxuICAgICh0eXBlb2Ygb2JqLmdldFNjb3JlID09PSAnZnVuY3Rpb24nKSAmJlxyXG4gICAgKHR5cGVvZiBvYmouZ2V0TWF4U2NvcmUgPT09ICdmdW5jdGlvbicpXHJcbiAgKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGNvbWJpbmVkIHNjb3JlIG9mIGFsbCBjaGlsZHJlblxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmdldFNjb3JlID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgcmV0dXJuIGZsYXR0ZW5BcnJheShzZWxmLnNsaWRlc1dpdGhTb2x1dGlvbnMpLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBzbGlkZSkge1xyXG4gICAgcmV0dXJuIHN1bSArIChzZWxmLmhhc1Njb3JlRGF0YShzbGlkZSkgPyBzbGlkZS5nZXRTY29yZSgpIDogMCk7XHJcbiAgfSwgMCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIHRoZSBjb21iaW5lZCBtYXhTY29yZSBvZiBhbGwgY2hpbGRyZW5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5nZXRNYXhTY29yZSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIHJldHVybiBmbGF0dGVuQXJyYXkoc2VsZi5zbGlkZXNXaXRoU29sdXRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKHN1bSwgc2xpZGUpIHtcclxuICAgIHJldHVybiBzdW0gKyAoc2VsZi5oYXNTY29yZURhdGEoc2xpZGUpID8gc2xpZGUuZ2V0TWF4U2NvcmUoKSA6IDApO1xyXG4gIH0sIDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIGZlZWRiYWNrIGljb25zIGZvciB0aGUgcHJvZ3JlcyBiYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YXJyYXl9IFtzbGlkZVNjb3Jlc11cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2V0UHJvZ3Jlc3NCYXJGZWVkYmFjayA9IGZ1bmN0aW9uIChzbGlkZVNjb3Jlcykge1xyXG4gIGlmIChzbGlkZVNjb3JlcyAhPT0gdW5kZWZpbmVkICYmIHNsaWRlU2NvcmVzKSB7XHJcbiAgICAvLyBTZXQgZmVlZGJhY2sgaWNvbnMgZm9yIHByb2dyZXNzIGJhci5cclxuICAgIHNsaWRlU2NvcmVzLmZvckVhY2goc2luZ2xlU2xpZGUgPT4ge1xyXG4gICAgICBjb25zdCAkaW5kaWNhdG9yID0gdGhpcy5wcm9ncmVzc2JhclBhcnRzW3NpbmdsZVNsaWRlLnNsaWRlIC0gMV1cclxuICAgICAgICAuZmluZCgnLmg1cC1wcm9ncmVzc2Jhci1wYXJ0LWhhcy10YXNrJyk7XHJcblxyXG4gICAgICBpZiAoJGluZGljYXRvci5oYXNDbGFzcygnaDVwLWFuc3dlcmVkJykpIHtcclxuICAgICAgICBjb25zdCBpc0NvcnJlY3QgPSBzaW5nbGVTbGlkZS5zY29yZSA+PSBzaW5nbGVTbGlkZS5tYXhTY29yZTtcclxuICAgICAgICAkaW5kaWNhdG9yLmFkZENsYXNzKGlzQ29ycmVjdCA/ICdoNXAtaXMtY29ycmVjdCcgOiAnaDVwLWlzLXdyb25nJyk7XHJcblxyXG4gICAgICAgIHRoaXMubmF2aWdhdGlvbkxpbmUudXBkYXRlU2xpZGVUaXRsZShzaW5nbGVTbGlkZS5zbGlkZSAtIDEpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBSZW1vdmUgYWxsIGZlZWRiYWNrIGljb25zLlxyXG4gICAgdGhpcy5wcm9ncmVzc2JhclBhcnRzLmZvckVhY2gocGJQYXJ0ID0+IHtcclxuICAgICAgcGJQYXJ0LmZpbmQoJy5oNXAtcHJvZ3Jlc3NiYXItcGFydC1oYXMtdGFzaycpXHJcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdoNXAtaXMtY29ycmVjdCcpXHJcbiAgICAgICAgLnJlbW92ZUNsYXNzKCdoNXAtaXMtd3JvbmcnKTtcclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBUb2dnbGUga2V5d29yZHMgbGlzdCBvbi9vZmYgZGVwZW5kaW5nIG9uIGN1cnJlbnQgc3RhdGVcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUudG9nZ2xlS2V5d29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgY29uc3Qga2V5d29yZHNBcmVTaG93aW5nID0gdGhpcy4ka2V5d29yZHNXcmFwcGVyLmhhc0NsYXNzKCdoNXAtb3BlbicpO1xyXG4gIHRoaXNba2V5d29yZHNBcmVTaG93aW5nID8gJ2hpZGVLZXl3b3JkcycgOiAnc2hvd0tleXdvcmRzJ10oKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIaWRlIGtleXdvcmRzXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmhpZGVLZXl3b3JkcyA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy4ka2V5d29yZHNXcmFwcGVyLmhhc0NsYXNzKCdoNXAtb3BlbicpKSB7XHJcbiAgICBpZiAodGhpcy4ka2V5d29yZHNCdXR0b24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLiRrZXl3b3Jkc0J1dHRvbi5hdHRyKCdhcmlhLWxhYmVsJywgdGhpcy5sMTBuLnNob3dLZXl3b3Jkcyk7XHJcbiAgICAgIHRoaXMuJGtleXdvcmRzQnV0dG9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcclxuICAgICAgdGhpcy4ka2V5d29yZHNCdXR0b24uZm9jdXMoKTtcclxuICAgIH1cclxuICAgIHRoaXMuJGtleXdvcmRzV3JhcHBlci5yZW1vdmVDbGFzcygnaDVwLW9wZW4nKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogU2hvdyBrZXl3b3Jkc1xyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5zaG93S2V5d29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuJGtleXdvcmRzV3JhcHBlci5oYXNDbGFzcygnaDVwLW9wZW4nKSkge1xyXG4gICAgLy8gQWxyZWFkeSBzaG93aW5nXHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy4ka2V5d29yZHNCdXR0b24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhpcy4ka2V5d29yZHNCdXR0b24uYXR0cignYXJpYS1sYWJlbCcsIHRoaXMubDEwbi5oaWRlS2V5d29yZHMpO1xyXG4gICAgdGhpcy4ka2V5d29yZHNCdXR0b24uYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XHJcbiAgfVxyXG4gIHRoaXMuJGtleXdvcmRzV3JhcHBlci5hZGRDbGFzcygnaDVwLW9wZW4nKTtcclxuXHJcbiAgLy8gRG8gbm90IGZvY3VzIGlmIGFsd2F5cyBzaG93aW5nXHJcbiAgaWYgKCF0aGlzLnByZXNlbnRhdGlvbi5rZXl3b3JkTGlzdEFsd2F5c1Nob3cpIHtcclxuICAgIHRoaXMuJGtleXdvcmRzV3JhcHBlci5maW5kKCdsaVt0YWJpbmRleD1cIjBcIl0nKS5mb2N1cygpO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2UgdGhlIGJhY2tncm91bmQgb3BhY2l0eSBvZiB0aGUga2V5d29yZHMgbGlzdC5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIDAgLSAxMDBcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2V0S2V5d29yZHNPcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgaWYgKHRoaXMuJGtleXdvcmRzV3JhcHBlci5jc3MoJ2JhY2tncm91bmQtY29sb3InKSAhPT0gJycpIHtcclxuICAgIGNvbnN0IFtyZWQsIGdyZWVuLCBibHVlXSA9IHRoaXMuJGtleXdvcmRzV3JhcHBlci5jc3MoJ2JhY2tncm91bmQtY29sb3InKS5tYXRjaCgvXFxkKy9nKTtcclxuICAgIHRoaXMuJGtleXdvcmRzV3JhcHBlci5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBgcmdiYSgke3JlZH0sICR7Z3JlZW59LCAke2JsdWV9LCAke3ZhbHVlIC8gMTAwfSlgKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogTWFrZXMgY29udGludW91cyB0ZXh0IHNtYWxsZXIgaWYgaXQgZG9lcyBub3QgZml0IGluc2lkZSBpdHMgY29udGFpbmVyLlxyXG4gKiBPbmx5IHdvcmtzIGluIHZpZXcgbW9kZS5cclxuICpcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuZml0Q1QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMuZWRpdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHRoaXMuJGN1cnJlbnQuZmluZCgnLmg1cC1jdCcpLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHBlcmNlbnQgPSAxMDA7XHJcbiAgICB2YXIgJGN0ID0gSDVQLmpRdWVyeSh0aGlzKTtcclxuICAgIHZhciBwYXJlbnRIZWlnaHQgPSAkY3QucGFyZW50KCkuaGVpZ2h0KCk7XHJcbiAgICB3aGlsZSAoJGN0Lm91dGVySGVpZ2h0KCkgPiBwYXJlbnRIZWlnaHQpIHtcclxuICAgICAgcGVyY2VudC0tO1xyXG4gICAgICAkY3QuY3NzKHtcclxuICAgICAgICBmb250U2l6ZTogcGVyY2VudCArICclJyxcclxuICAgICAgICBsaW5lSGVpZ2h0OiAocGVyY2VudCArIDY1KSArICclJ1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGlmIChwZXJjZW50IDwgMCkge1xyXG4gICAgICAgIGJyZWFrOyAvLyBKdXN0IGluIGNhc2UuXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXNpemUgaGFuZGxpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZnVsbHNjcmVlblxyXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGZ1bGxzY3JlZW5PbiA9IHRoaXMuJGNvbnRhaW5lci5oYXNDbGFzcygnaDVwLWZ1bGxzY3JlZW4nKSB8fCB0aGlzLiRjb250YWluZXIuaGFzQ2xhc3MoJ2g1cC1zZW1pLWZ1bGxzY3JlZW4nKTtcclxuXHJcbiAgaWYgKHRoaXMuaWdub3JlUmVzaXplKSB7XHJcbiAgICByZXR1cm47IC8vIFdoZW4gcHJpbnRpbmcuXHJcbiAgfVxyXG5cclxuICAvLyBGaWxsIHVwIGFsbCBhdmFpbGFibGUgd2lkdGhcclxuICB0aGlzLiR3cmFwcGVyLmNzcygnd2lkdGgnLCAnYXV0bycpO1xyXG4gIHZhciB3aWR0aCA9IHRoaXMuJGNvbnRhaW5lci53aWR0aCgpO1xyXG4gIHZhciBzdHlsZSA9IHt9O1xyXG5cclxuICBpZiAoZnVsbHNjcmVlbk9uKSB7XHJcbiAgICB2YXIgbWF4SGVpZ2h0ID0gdGhpcy4kY29udGFpbmVyLmhlaWdodCgpO1xyXG4gICAgaWYgKHdpZHRoIC8gbWF4SGVpZ2h0ID4gdGhpcy5yYXRpbykge1xyXG4gICAgICAvLyBUb3AgYW5kIGJvdHRvbSB3b3VsZCBiZSBjdXQgb2ZmIHNvIHNjYWxlIGRvd24uXHJcbiAgICAgIHdpZHRoID0gbWF4SGVpZ2h0ICogdGhpcy5yYXRpbztcclxuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgLTE2IHdoZW4gY29udGVudCBjb252ZXJzaW9uIHNjcmlwdCBpcyBjcmVhdGVkP1xyXG4gIHZhciB3aWR0aFJhdGlvID0gd2lkdGggLyB0aGlzLndpZHRoO1xyXG4gIHN0eWxlLmhlaWdodCA9ICh3aWR0aCAvIHRoaXMucmF0aW8pICsgJ3B4JztcclxuICBzdHlsZS5mb250U2l6ZSA9ICh0aGlzLmZvbnRTaXplICogd2lkdGhSYXRpbykgKyAncHgnO1xyXG5cclxuICBpZiAodGhpcy5lZGl0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhpcy5lZGl0b3Iuc2V0Q29udGFpbmVyRW0odGhpcy5mb250U2l6ZSAqIHdpZHRoUmF0aW8gKiAwLjc1KTtcclxuICB9XHJcblxyXG4gIHRoaXMuJHdyYXBwZXIuY3NzKHN0eWxlKTtcclxuXHJcbiAgdGhpcy5zd2lwZVRocmVzaG9sZCA9IHdpZHRoUmF0aW8gKiAxMDA7IC8vIERlZmF1bHQgc3dpcGUgdGhyZXNob2xkIGlzIDUwcHguXHJcblxyXG4gIC8vIFJlc2l6ZSBlbGVtZW50c1xyXG4gIHZhciBpbnN0YW5jZXMgPSB0aGlzLmVsZW1lbnRJbnN0YW5jZXNbdGhpcy4kY3VycmVudC5pbmRleCgpXTtcclxuICBpZiAoaW5zdGFuY2VzICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHZhciBzbGlkZUVsZW1lbnRzID0gdGhpcy5zbGlkZXNbdGhpcy4kY3VycmVudC5pbmRleCgpXS5lbGVtZW50cztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcclxuICAgICAgaWYgKChpbnN0YW5jZS5wcmV2ZW50UmVzaXplID09PSB1bmRlZmluZWQgfHwgaW5zdGFuY2UucHJldmVudFJlc2l6ZSA9PT0gZmFsc2UpICYmIGluc3RhbmNlLiQgIT09IHVuZGVmaW5lZCAmJiAhc2xpZGVFbGVtZW50c1tpXS5kaXNwbGF5QXNCdXR0b24pIHtcclxuICAgICAgICBINVAudHJpZ2dlcihpbnN0YW5jZSwgJ3Jlc2l6ZScpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB0aGlzLmZpdENUKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogRW50ZXIvZXhpdCBmdWxsIHNjcmVlbiBtb2RlLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS50b2dnbGVGdWxsU2NyZWVuID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmIChINVAuaXNGdWxsc2NyZWVuIHx8IHRoaXMuJGNvbnRhaW5lci5oYXNDbGFzcygnaDVwLWZ1bGxzY3JlZW4nKSB8fCB0aGlzLiRjb250YWluZXIuaGFzQ2xhc3MoJ2g1cC1zZW1pLWZ1bGxzY3JlZW4nKSkge1xyXG4gICAgLy8gQ2FuY2VsIGZ1bGxzY3JlZW5cclxuICAgIGlmIChINVAuZXhpdEZ1bGxTY3JlZW4gIT09IHVuZGVmaW5lZCAmJiBINVAuZnVsbFNjcmVlbkJyb3dzZXJQcmVmaXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBINVAuZXhpdEZ1bGxTY3JlZW4oKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBVc2Ugb2xkIHN5c3RlbVxyXG4gICAgICBpZiAoSDVQLmZ1bGxTY3JlZW5Ccm93c2VyUHJlZml4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBDbGljayBidXR0b24gdG8gZGlzYWJsZSBmdWxsc2NyZWVuXHJcbiAgICAgICAgSDVQLmpRdWVyeSgnLmg1cC1kaXNhYmxlLWZ1bGxzY3JlZW4nKS5jbGljaygpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChINVAuZnVsbFNjcmVlbkJyb3dzZXJQcmVmaXggPT09ICcnKSB7XHJcbiAgICAgICAgICB3aW5kb3cudG9wLmRvY3VtZW50LmV4aXRGdWxsU2NyZWVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEg1UC5mdWxsU2NyZWVuQnJvd3NlclByZWZpeCA9PT0gJ21zJykge1xyXG4gICAgICAgICAgd2luZG93LnRvcC5kb2N1bWVudC5tc0V4aXRGdWxsc2NyZWVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgd2luZG93LnRvcC5kb2N1bWVudFtINVAuZnVsbFNjcmVlbkJyb3dzZXJQcmVmaXggKyAnQ2FuY2VsRnVsbFNjcmVlbiddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgLy8gUmVzY2FsZSBmb290ZXIgYnV0dG9uc1xyXG4gICAgdGhpcy4kZm9vdGVyLmFkZENsYXNzKCdmb290ZXItZnVsbC1zY3JlZW4nKTtcclxuXHJcbiAgICB0aGlzLiRmdWxsU2NyZWVuQnV0dG9uLmF0dHIoJ2FyaWEtbGFiZWwnLCB0aGlzLmwxMG4uZXhpdEZ1bGxzY3JlZW4pO1xyXG4gICAgSDVQLmZ1bGxTY3JlZW4odGhpcy4kY29udGFpbmVyLCB0aGlzKTtcclxuICAgIGlmIChINVAuZnVsbFNjcmVlbkJyb3dzZXJQcmVmaXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAvLyBIaWRlIGRpc2FibGUgZnVsbCBzY3JlZW4gYnV0dG9uLiBXZSBoYXZlIG91ciBvd24hXHJcbiAgICAgIEg1UC5qUXVlcnkoJy5oNXAtZGlzYWJsZS1mdWxsc2NyZWVuJykuaGlkZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgZm9jdXMuXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuJHdyYXBwZXIuZm9jdXMoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIYW5kbGVzIGNsaWNrIG9uIGtleXdvcmRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmtleXdvcmRDbGljayA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gIGlmICh0aGlzLnNob3VsZEhpZGVLZXl3b3Jkc0FmdGVyU2VsZWN0KCkpIHtcclxuICAgIC8vIEF1dG8taGlkZSBrZXl3b3JkcyBsaXN0XHJcbiAgICB0aGlzLmhpZGVLZXl3b3JkcygpO1xyXG4gIH1cclxuICB0aGlzLmp1bXBUb1NsaWRlKGluZGV4LCB0cnVlKTtcclxufTtcclxuXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2hvdWxkSGlkZUtleXdvcmRzQWZ0ZXJTZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCAmJlxyXG4gICAgIXRoaXMucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0QWx3YXlzU2hvdyAmJlxyXG4gICAgdGhpcy5wcmVzZW50YXRpb24ua2V5d29yZExpc3RBdXRvSGlkZSAmJlxyXG4gICAgdGhpcy5lZGl0b3IgPT09IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG92ZXJyaWRlIGZvciBhbGwgYWN0aW9ucy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLnNldEVsZW1lbnRzT3ZlcnJpZGUgPSBmdW5jdGlvbiAob3ZlcnJpZGUpIHtcclxuICAvLyBDcmVhdGUgZGVmYXVsdCBvYmplY3RcclxuICB0aGlzLmVsZW1lbnRzT3ZlcnJpZGUgPSB7XHJcbiAgICBwYXJhbXM6IHt9XHJcbiAgfTtcclxuXHJcbiAgaWYgKG92ZXJyaWRlKSB7XHJcbiAgICAvLyBDcmVhdGUgYmVoYXZpb3VyIG9iamVjdCBmb3Igb3ZlcnJpZGluZ1xyXG4gICAgdGhpcy5lbGVtZW50c092ZXJyaWRlLnBhcmFtcy5iZWhhdmlvdXIgPSB7fTtcclxuXHJcbiAgICBpZiAob3ZlcnJpZGUuc2hvd1NvbHV0aW9uQnV0dG9uKSB7XHJcbiAgICAgIC8vIE92ZXJyaWRlIHNob3cgc29sdXRpb25zIGJ1dHRvblxyXG4gICAgICB0aGlzLmVsZW1lbnRzT3ZlcnJpZGUucGFyYW1zLmJlaGF2aW91ci5lbmFibGVTb2x1dGlvbnNCdXR0b24gPVxyXG4gICAgICAgICAgKG92ZXJyaWRlLnNob3dTb2x1dGlvbkJ1dHRvbiA9PT0gJ29uJyA/IHRydWUgOiBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG92ZXJyaWRlLnJldHJ5QnV0dG9uKSB7XHJcbiAgICAgIC8vIE92ZXJyaWRlIHJldHJ5IGJ1dHRvblxyXG4gICAgICB0aGlzLmVsZW1lbnRzT3ZlcnJpZGUucGFyYW1zLmJlaGF2aW91ci5lbmFibGVSZXRyeSA9XHJcbiAgICAgICAgICAob3ZlcnJpZGUucmV0cnlCdXR0b24gPT09ICdvbicgPyB0cnVlIDogZmFsc2UpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBBdHRhY2ggYWxsIGVsZW1lbnQgaW5zdGFuY2VzIHRvIHNsaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2pRdWVyeX0gJHNsaWRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5hdHRhY2hFbGVtZW50cyA9IGZ1bmN0aW9uICgkc2xpZGUsIGluZGV4KSB7XHJcbiAgaWYgKHRoaXMuZWxlbWVudHNBdHRhY2hlZFtpbmRleF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuOyAvLyBBbHJlYWR5IGF0dGFjaGVkXHJcbiAgfVxyXG5cclxuICB2YXIgc2xpZGUgPSB0aGlzLnNsaWRlc1tpbmRleF07XHJcbiAgdmFyIGluc3RhbmNlcyA9IHRoaXMuZWxlbWVudEluc3RhbmNlc1tpbmRleF07XHJcbiAgaWYgKHNsaWRlLmVsZW1lbnRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGUuZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdGhpcy5hdHRhY2hFbGVtZW50KHNsaWRlLmVsZW1lbnRzW2ldLCBpbnN0YW5jZXNbaV0sICRzbGlkZSwgaW5kZXgpO1xyXG4gICAgfVxyXG4gIH1cclxuICB0aGlzLnRyaWdnZXIoJ2RvbUNoYW5nZWQnLCB7XHJcbiAgICAnJHRhcmdldCc6ICRzbGlkZSxcclxuICAgICdsaWJyYXJ5JzogJ0NvdXJzZVByZXNlbnRhdGlvbicsXHJcbiAgICAna2V5JzogJ25ld1NsaWRlJ1xyXG4gIH0sIHsnYnViYmxlcyc6IHRydWUsICdleHRlcm5hbCc6IHRydWV9KTtcclxuXHJcbiAgdGhpcy5lbGVtZW50c0F0dGFjaGVkW2luZGV4XSA9IHRydWU7XHJcbn07XHJcblxyXG4vKipcclxuICogQXR0YWNoIGVsZW1lbnQgdG8gc2xpZGUgY29udGFpbmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudFxyXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VcclxuICogQHBhcmFtIHtqUXVlcnl9ICRzbGlkZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuICogQHJldHVybnMge2pRdWVyeX1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuYXR0YWNoRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBpbnN0YW5jZSwgJHNsaWRlLCBpbmRleCkge1xyXG4gIGNvbnN0IGRpc3BsYXlBc0J1dHRvbiA9IChlbGVtZW50LmRpc3BsYXlBc0J1dHRvbiAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQuZGlzcGxheUFzQnV0dG9uKTtcclxuICB2YXIgYnV0dG9uU2l6ZUNsYXNzID0gKGVsZW1lbnQuYnV0dG9uU2l6ZSAhPT0gdW5kZWZpbmVkID8gXCJoNXAtZWxlbWVudC1idXR0b24tXCIgKyBlbGVtZW50LmJ1dHRvblNpemUgOiBcIlwiKTtcclxuICB2YXIgY2xhc3NlcyA9ICdoNXAtZWxlbWVudCcgK1xyXG4gICAgKGRpc3BsYXlBc0J1dHRvbiA/ICcgaDVwLWVsZW1lbnQtYnV0dG9uLXdyYXBwZXInIDogJycpICtcclxuICAgIChidXR0b25TaXplQ2xhc3MubGVuZ3RoID8gJyAnICsgYnV0dG9uU2l6ZUNsYXNzIDogJycpO1xyXG4gIHZhciAkZWxlbWVudENvbnRhaW5lciA9IEg1UC5qUXVlcnkoJzxkaXY+Jywge1xyXG4gICAgJ2NsYXNzJzogY2xhc3NlcyxcclxuICB9KS5jc3Moe1xyXG4gICAgbGVmdDogZWxlbWVudC54ICsgJyUnLFxyXG4gICAgdG9wOiBlbGVtZW50LnkgKyAnJScsXHJcbiAgICB3aWR0aDogZWxlbWVudC53aWR0aCArICclJyxcclxuICAgIGhlaWdodDogZWxlbWVudC5oZWlnaHQgKyAnJSdcclxuICB9KS5hcHBlbmRUbygkc2xpZGUuY2hpbGRyZW4oJ1tyb2xlPVwiZG9jdW1lbnRcIl0nKS5maXJzdCgpKTtcclxuXHJcbiAgY29uc3QgaXNUcmFuc3BhcmVudCA9IGVsZW1lbnQuYmFja2dyb3VuZE9wYWNpdHkgPT09IHVuZGVmaW5lZCB8fCBlbGVtZW50LmJhY2tncm91bmRPcGFjaXR5ID09PSAwO1xyXG4gICRlbGVtZW50Q29udGFpbmVyLnRvZ2dsZUNsYXNzKCdoNXAtdHJhbnNwYXJlbnQnLCBpc1RyYW5zcGFyZW50KTtcclxuXHJcbiAgaWYgKGRpc3BsYXlBc0J1dHRvbikge1xyXG4gICAgY29uc3QgJGJ1dHRvbiA9IHRoaXMuY3JlYXRlSW50ZXJhY3Rpb25CdXR0b24oZWxlbWVudCwgaW5zdGFuY2UpO1xyXG4gICAgJGJ1dHRvbi5hcHBlbmRUbygkZWxlbWVudENvbnRhaW5lcik7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgY29uc3QgaGFzTGlicmFyeSA9IGVsZW1lbnQuYWN0aW9uICYmIGVsZW1lbnQuYWN0aW9uLmxpYnJhcnk7XHJcbiAgICBjb25zdCBsaWJUeXBlUG16ID0gaGFzTGlicmFyeSA/IHRoaXMuZ2V0TGlicmFyeVR5cGVQbXooZWxlbWVudC5hY3Rpb24ubGlicmFyeSkgOiAnb3RoZXInO1xyXG5cclxuICAgIHZhciAkb3V0ZXJFbGVtZW50Q29udGFpbmVyID0gSDVQLmpRdWVyeSgnPGRpdj4nLCB7XHJcbiAgICAgICdjbGFzcyc6IGBoNXAtZWxlbWVudC1vdXRlciAke2xpYlR5cGVQbXp9LW91dGVyLWVsZW1lbnRgXHJcbiAgICB9KS5jc3Moe1xyXG4gICAgICBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsMjU1LDI1NSwnICsgKGVsZW1lbnQuYmFja2dyb3VuZE9wYWNpdHkgPT09IHVuZGVmaW5lZCA/IDAgOiBlbGVtZW50LmJhY2tncm91bmRPcGFjaXR5IC8gMTAwKSArICcpJ1xyXG4gICAgfSkuYXBwZW5kVG8oJGVsZW1lbnRDb250YWluZXIpO1xyXG5cclxuICAgIHZhciAkaW5uZXJFbGVtZW50Q29udGFpbmVyID0gSDVQLmpRdWVyeSgnPGRpdj4nLCB7XHJcbiAgICAgICdjbGFzcyc6ICdoNXAtZWxlbWVudC1pbm5lcidcclxuICAgIH0pLmFwcGVuZFRvKCRvdXRlckVsZW1lbnRDb250YWluZXIpO1xyXG5cclxuICAgIC8vIEg1UC5TaGFwZSBzZXRzIGl0J3Mgb3duIHNpemUgd2hlbiBsaW5lIGluIHNlbGVjdGVkXHJcbiAgICBpbnN0YW5jZS5vbignc2V0LXNpemUnLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgZm9yIChsZXQgcHJvcGVydHkgaW4gZXZlbnQuZGF0YSkge1xyXG4gICAgICAgICRlbGVtZW50Q29udGFpbmVyLmdldCgwKS5zdHlsZVtwcm9wZXJ0eV0gPSBldmVudC5kYXRhW3Byb3BlcnR5XTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaW5zdGFuY2UuYXR0YWNoKCRpbm5lckVsZW1lbnRDb250YWluZXIpO1xyXG4gICAgaWYgKGVsZW1lbnQuYWN0aW9uICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudC5hY3Rpb24ubGlicmFyeS5zdWJzdHIoMCwgMjApID09PSAnSDVQLkludGVyYWN0aXZlVmlkZW8nKSB7XHJcbiAgICAgIHZhciBoYW5kbGVJViA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpbnN0YW5jZS4kY29udGFpbmVyLmFkZENsYXNzKCdoNXAtZnVsbHNjcmVlbicpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jb250cm9scy4kZnVsbHNjcmVlbikge1xyXG4gICAgICAgICAgaW5zdGFuY2UuY29udHJvbHMuJGZ1bGxzY3JlZW4ucmVtb3ZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGluc3RhbmNlLmhhc0Z1bGxTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZS5jb250cm9scy4kcGxheS5oYXNDbGFzcygnaDVwLXBhdXNlJykpIHtcclxuICAgICAgICAgIGluc3RhbmNlLiRjb250cm9scy5hZGRDbGFzcygnaDVwLWF1dG9oaWRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgaW5zdGFuY2UuZW5hYmxlQXV0b0hpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChpbnN0YW5jZS5jb250cm9scyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaGFuZGxlSVYoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpbnN0YW5jZS5vbignY29udHJvbHMnLCBoYW5kbGVJVik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3IgZmlyc3Qgc2xpZGVcclxuICAgIHRoaXMuc2V0T3ZlcmZsb3dUYWJJbmRleCgpO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRoaXMuZWRpdG9yICE9PSB1bmRlZmluZWQpIHtcclxuICAgIC8vIElmIHdlJ3JlIGluIHRoZSBINVAgZWRpdG9yLCBhbGxvdyBpdCB0byBtYW5pcHVsYXRlIHRoZSBlbGVtZW50SW5zdGFuY2VzXHJcbiAgICB0aGlzLmVkaXRvci5wcm9jZXNzRWxlbWVudChlbGVtZW50LCAkZWxlbWVudENvbnRhaW5lciwgaW5kZXgsIGluc3RhbmNlKTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBpZiAoZWxlbWVudC5zb2x1dGlvbikge1xyXG4gICAgICB0aGlzLmFkZEVsZW1lbnRTb2x1dGlvbkJ1dHRvbihlbGVtZW50LCBpbnN0YW5jZSwgJGVsZW1lbnRDb250YWluZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qIFdoZW4gaW4gdmlldyBtb2RlLCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhlcmUgYXJlIGFueSBhbnN3ZXIgZWxlbWVudHMsXHJcbiAgICAgKiBzbyB0aGF0IHdlIGNhbiBkaXNwbGF5IHRoZSBleHBvcnQgYW5zd2VycyBidXR0b24gb24gdGhlIGxhc3Qgc2xpZGUgKi9cclxuICAgIHRoaXMuaGFzQW5zd2VyRWxlbWVudHMgPSB0aGlzLmhhc0Fuc3dlckVsZW1lbnRzIHx8IGluc3RhbmNlLmV4cG9ydEFuc3dlcnMgIT09IHVuZGVmaW5lZDtcclxuICB9XHJcblxyXG4gIHJldHVybiAkZWxlbWVudENvbnRhaW5lcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEaXNhYmxlcyB0YWIgaW5kZXhlcyBiZWhpbmQgYSBwb3B1cCBjb250YWluZXJcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuZGlzYWJsZVRhYkluZGV4ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyICRwb3B1cENvbnRhaW5lciA9IHRoaXMuJGNvbnRhaW5lci5maW5kKCcuaDVwLXBvcHVwLWNvbnRhaW5lcicpO1xyXG5cclxuICB0aGlzLiR0YWJiYWJsZXMgPSB0aGlzLiRjb250YWluZXIuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgJHRhYmJhYmxlID0gJCh0aGlzKTtcclxuICAgIHZhciBpbnNpZGVDb250YWluZXIgPSAkLmNvbnRhaW5zKCRwb3B1cENvbnRhaW5lci5nZXQoMCksICR0YWJiYWJsZS5nZXQoMCkpO1xyXG5cclxuICAgIC8vIHRhYkluZGV4IGhhcyBhbHJlYWR5IGJlZW4gbW9kaWZpZWQsIGtlZXAgaXQgaW4gdGhlIHNldC5cclxuICAgIGlmICgkdGFiYmFibGUuZGF0YSgndGFiaW5kZXgnKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWluc2lkZUNvbnRhaW5lcikge1xyXG4gICAgICAvLyBTdG9yZSBjdXJyZW50IHRhYmluZGV4LCBzbyB3ZSBjYW4gc2V0IGl0IGJhY2sgd2hlbiBkaWFsb2cgY2xvc2VzXHJcbiAgICAgIHZhciB0YWJJbmRleCA9ICR0YWJiYWJsZS5hdHRyKCd0YWJpbmRleCcpO1xyXG4gICAgICAkdGFiYmFibGUuZGF0YSgndGFiaW5kZXgnLCB0YWJJbmRleCk7XHJcblxyXG4gICAgICAvLyBNYWtlIGl0IG5vbiB0YWJiYWJsZVxyXG4gICAgICAkdGFiYmFibGUuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgZWxlbWVudCBpcyBwYXJ0IG9mIGRpYWxvZyB3cmFwcGVyLCBqdXN0IGlnbm9yZSBpdFxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZS1lbmFibGVzIHRhYiBpbmRleGVzIGFmdGVyIGEgcG9wdXAgY29udGFpbmVyIGlzIGNsb3NlZFxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5yZXN0b3JlVGFiSW5kZXhlcyA9IGZ1bmN0aW9uICgpIHtcclxuICBpZiAodGhpcy4kdGFiYmFibGVzKSB7XHJcbiAgICB0aGlzLiR0YWJiYWJsZXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciAkZWxlbWVudCA9ICQodGhpcyk7XHJcbiAgICAgIHZhciB0YWJpbmRleCA9ICRlbGVtZW50LmRhdGEoJ3RhYmluZGV4Jyk7XHJcblxyXG4gICAgICAvLyBTcGVjaWZpY2FsbHkgaGFuZGxlIGpxdWVyeSB1aSBzbGlkZXIsIHNpbmNlIGl0IG92ZXJ3cml0ZXMgZGF0YSBpbiBhbiBpbmNvbnNpc3RlbnQgd2F5XHJcbiAgICAgIGlmICgkZWxlbWVudC5oYXNDbGFzcygndWktc2xpZGVyLWhhbmRsZScpKSB7XHJcbiAgICAgICAgJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAwKTtcclxuICAgICAgICAkZWxlbWVudC5yZW1vdmVEYXRhKCd0YWJpbmRleCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHRhYmluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAkZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcclxuICAgICAgICAkZWxlbWVudC5yZW1vdmVEYXRhKCd0YWJpbmRleCcpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICRlbGVtZW50LnJlbW92ZUF0dHIoJ3RhYmluZGV4Jyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIHRoZSBpbnRlcmFjdGlvbiBidXR0b25cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnRcclxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlXHJcbiAqXHJcbiAqIEByZXR1cm4ge2pRdWVyeX1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuY3JlYXRlSW50ZXJhY3Rpb25CdXR0b24gPSBmdW5jdGlvbiAoZWxlbWVudCwgaW5zdGFuY2UpIHtcclxuICBsZXQgbGFiZWwgPSBlbGVtZW50LmFjdGlvbi5tZXRhZGF0YSA/IGVsZW1lbnQuYWN0aW9uLm1ldGFkYXRhLnRpdGxlIDogJyc7XHJcbiAgaWYgKGxhYmVsID09PSAnJykge1xyXG4gICAgbGFiZWwgPSAoZWxlbWVudC5hY3Rpb24ucGFyYW1zICYmIGVsZW1lbnQuYWN0aW9uLnBhcmFtcy5jb250ZW50TmFtZSkgfHwgZWxlbWVudC5hY3Rpb24ubGlicmFyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylbMV07XHJcbiAgfVxyXG4gIGNvbnN0IGxpYlR5cGVQbXogPSB0aGlzLmdldExpYnJhcnlUeXBlUG16KGVsZW1lbnQuYWN0aW9uLmxpYnJhcnkpO1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHNldCBbYXJpYS1leHBhbmRlZD1cImZhbHNlXCJdIG9uIHRoZSAkYnRuIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkYnRuXHJcbiAgICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgY29uc3Qgc2V0QXJpYUV4cGFuZGVkRmFsc2UgPSAkYnRuID0+ICgpID0+ICRidG4uYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xyXG5cclxuICBjb25zdCAkYnV0dG9uID0gJCgnPGRpdj4nLCB7XHJcbiAgICByb2xlOiAnYnV0dG9uJyxcclxuICAgIHRhYmluZGV4OiAwLFxyXG4gICAgJ2FyaWEtbGFiZWwnOiBsYWJlbCxcclxuICAgICdhcmlhLXBvcHVwJzogdHJ1ZSxcclxuICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXHJcbiAgICAnY2xhc3MnOiBgaDVwLWVsZW1lbnQtYnV0dG9uIGg1cC1lbGVtZW50LWJ1dHRvbi0ke2VsZW1lbnQuYnV0dG9uU2l6ZX0gJHtsaWJUeXBlUG16fS1idXR0b25gXHJcbiAgfSk7XHJcblxyXG4gIGNvbnN0ICRidXR0b25FbGVtZW50ID0gJCgnPGRpdiBjbGFzcz1cImg1cC1idXR0b24tZWxlbWVudFwiPjwvZGl2PicpO1xyXG4gIGluc3RhbmNlLmF0dGFjaCgkYnV0dG9uRWxlbWVudCk7XHJcblxyXG4gIGNvbnN0IHBhcmVudFBvc2l0aW9uID0gbGliVHlwZVBteiA9PT0gJ2g1cC1hZHZhbmNlZHRleHQnID8ge1xyXG4gICAgeDogZWxlbWVudC54LFxyXG4gICAgeTogZWxlbWVudC55XHJcbiAgfSA6IG51bGw7XHJcbiAgYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycygkYnV0dG9uLCAoKSA9PiB7XHJcbiAgICAkYnV0dG9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xyXG4gICAgdGhpcy5zaG93SW50ZXJhY3Rpb25Qb3B1cChpbnN0YW5jZSwgJGJ1dHRvbiwgJGJ1dHRvbkVsZW1lbnQsIGxpYlR5cGVQbXosIHNldEFyaWFFeHBhbmRlZEZhbHNlKCRidXR0b24pLCBwYXJlbnRQb3NpdGlvbik7XHJcbiAgfSk7XHJcblxyXG4gIGlmIChlbGVtZW50LmFjdGlvbiAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQuYWN0aW9uLmxpYnJhcnkuc3Vic3RyKDAsIDIwKSA9PT0gJ0g1UC5JbnRlcmFjdGl2ZVZpZGVvJykge1xyXG4gICAgaW5zdGFuY2Uub24oJ2NvbnRyb2xzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAoaW5zdGFuY2UuY29udHJvbHMuJGZ1bGxzY3JlZW4pIHtcclxuICAgICAgICBpbnN0YW5jZS5jb250cm9scy4kZnVsbHNjcmVlbi5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gJGJ1dHRvbjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaG93cyB0aGUgaW50ZXJhY3Rpb24gcG9wdXAgb24gYnV0dG9uIHByZXNzXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbGliVHlwZVBtelxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjbG9zZUNhbGxiYWNrXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcG9wdXBQb3NpdGlvbl0gWCBhbmQgWSBwb3NpdGlvbiBvZiBwb3B1cFxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5zaG93SW50ZXJhY3Rpb25Qb3B1cCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgJGJ1dHRvbiwgJGJ1dHRvbkVsZW1lbnQsIGxpYlR5cGVQbXosIGNsb3NlQ2FsbGJhY2ssIHBvcHVwUG9zaXRpb24gPSBudWxsKSB7XHJcblxyXG4gIC8vIEhhbmRsZSBleGl0IGZ1bGxzY3JlZW5cclxuICBjb25zdCBleGl0RnVsbFNjcmVlbiA9ICgpID0+IHtcclxuICAgIGluc3RhbmNlLnRyaWdnZXIoJ3Jlc2l6ZScpO1xyXG4gIH07XHJcblxyXG4gIGlmICghdGhpcy5pc0VkaXRvcigpKSB7XHJcbiAgICAvLyBMaXN0ZW4gZm9yIGV4aXQgZnVsbHNjcmVlbnMgbm90IHRyaWdnZXJlZCBieSBidXR0b24sIGZvciBpbnN0YW5jZSB1c2luZyAnZXNjJ1xyXG4gICAgdGhpcy5vbignZXhpdEZ1bGxTY3JlZW4nLCBleGl0RnVsbFNjcmVlbik7XHJcblxyXG4gICAgdGhpcy5zaG93UG9wdXAoe1xyXG4gICAgICBwb3B1cENvbnRlbnQ6ICRidXR0b25FbGVtZW50LCBcclxuICAgICAgJGZvY3VzT25DbG9zZTogJGJ1dHRvbiwgXHJcbiAgICAgIHBhcmVudFBvc2l0aW9uOiBwb3B1cFBvc2l0aW9uLCBcclxuICAgICAgcmVtb3ZlOiAoa2VlcEluRE9NID0gZmFsc2UpID0+IHtcclxuICAgICAgICBpZiAoIWtlZXBJbkRPTSkge1xyXG4gICAgICAgICAgJGJ1dHRvbkVsZW1lbnQuZGV0YWNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgbGlzdGVuZXIsIHdlIG9ubHkgbmVlZCBpdCBmb3IgYWN0aXZlIHBvcHVwc1xyXG4gICAgICAgIHRoaXMub2ZmKCdleGl0RnVsbFNjcmVlbicsIGV4aXRGdWxsU2NyZWVuKTtcclxuICAgICAgICBjbG9zZUNhbGxiYWNrKCk7XHJcbiAgICAgIH0sIFxyXG4gICAgICBjbGFzc2VzOiBsaWJUeXBlUG16LCBcclxuICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLCBcclxuICAgICAga2VlcEluRE9NOiBsaWJUeXBlUG16ID09PSAnaDVwLWludGVyYWN0aXZldmlkZW8nXHJcbiAgICB9KTtcclxuXHJcbiAgICBINVAudHJpZ2dlcihpbnN0YW5jZSwgJ3Jlc2l6ZScpO1xyXG5cclxuICAgIC8vIFJlc2l6ZSBpbWFnZXMgdG8gZml0IHBvcHVwIGRpYWxvZ1xyXG4gICAgaWYgKGxpYlR5cGVQbXogPT09ICdoNXAtaW1hZ2UnKSB7XHJcbiAgICAgIHRoaXMucmVzaXplUG9wdXBJbWFnZSgkYnV0dG9uRWxlbWVudCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9jdXMgZGlyZWN0bHkgb24gY29udGVudCB3aGVuIHBvcHVwIGlzIG9wZW5lZFxyXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgIHZhciAkdGFiYmFibGVzID0gJGJ1dHRvbkVsZW1lbnQuZmluZCgnOmlucHV0JykuYWRkKCRidXR0b25FbGVtZW50LmZpbmQoJ1t0YWJpbmRleF0nKSk7XHJcbiAgICAgIGlmICgkdGFiYmFibGVzLmxlbmd0aCkge1xyXG4gICAgICAgICR0YWJiYWJsZXNbMF0uZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAkYnV0dG9uRWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIDApO1xyXG4gICAgICAgICRidXR0b25FbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH0sIDIwMCk7XHJcblxyXG4gICAgLy8gc3RhcnQgYWN0aXZpdHlcclxuICAgIGlmIChpc0Z1bmN0aW9uKGluc3RhbmNlLnNldEFjdGl2aXR5U3RhcnRlZCkgJiYgaXNGdW5jdGlvbihpbnN0YW5jZS5nZXRTY29yZSkpIHtcclxuICAgICAgaW5zdGFuY2Uuc2V0QWN0aXZpdHlTdGFydGVkKCk7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5hbWUgcGFydCBvZiBhIGxpYnJhcnkgc3RyaW5nXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBsaWJyYXJ5XHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuZ2V0TGlicmFyeVR5cGVQbXogPSBsaWJyYXJ5ID0+IGtlYmFiQ2FzZShsaWJyYXJ5LnNwbGl0KCcgJylbMF0pLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4vKipcclxuICogUmVzaXplIGltYWdlIGluc2lkZSBwb3B1cCBkaWFsb2cuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHtINVAualF1ZXJ5fSAkd3JhcHBlclxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5yZXNpemVQb3B1cEltYWdlID0gZnVuY3Rpb24gKCR3cmFwcGVyKSB7XHJcbiAgLy8gR2V0IGZvbnRzaXplLCBuZWVkZWQgZm9yIHNjYWxlXHJcbiAgdmFyIGZvbnRTaXplID0gTnVtYmVyKCR3cmFwcGVyLmNzcygnZm9udFNpemUnKS5yZXBsYWNlKCdweCcsICcnKSk7XHJcbiAgdmFyICRpbWcgPSAkd3JhcHBlci5maW5kKCdpbWcnKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmVzaXplIGltYWdlIHRvIGZpdCBpbnNpZGUgcG9wdXAuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcclxuICAgKi9cclxuICB2YXIgcmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgIGlmICgoaGVpZ2h0IC8gZm9udFNpemUpIDwgMTguNSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJhdGlvID0gKHdpZHRoIC8gaGVpZ2h0KTtcclxuICAgIGhlaWdodCA9IDE4LjUgKiBmb250U2l6ZTtcclxuICAgICR3cmFwcGVyLmNzcyh7XHJcbiAgICAgIHdpZHRoOiBoZWlnaHQgKiByYXRpbyxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHRcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGlmICghJGltZy5oZWlnaHQoKSkge1xyXG4gICAgLy8gV2FpdCBmb3IgaW1hZ2UgdG8gbG9hZFxyXG4gICAgJGltZy5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJlc2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICAvLyBJbWFnZSBhbHJlYWR5IGxvYWRlZCwgcmVzaXplIVxyXG4gICAgcmVzaXplKCRpbWcud2lkdGgoKSwgJGltZy5oZWlnaHQoKSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBpbmZvIGJ1dHRvblxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCBQcm9wZXJ0aWVzIGZyb20gcGFyYW1zLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudEluc3RhbmNlIEluc3RhbmNlIG9mIHRoZSBlbGVtZW50LlxyXG4gKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW1lbnRDb250YWluZXIgV3JhcHBlciBmb3IgdGhlIGVsZW1lbnQuXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmFkZEVsZW1lbnRTb2x1dGlvbkJ1dHRvbiA9IGZ1bmN0aW9uIChlbGVtZW50LCBlbGVtZW50SW5zdGFuY2UsICRlbGVtZW50Q29udGFpbmVyKSB7XHJcbiAgZWxlbWVudEluc3RhbmNlLnNob3dDUENvbW1lbnRzID0gKCkgPT4ge1xyXG4gICAgaWYgKCRlbGVtZW50Q29udGFpbmVyLmNoaWxkcmVuKCcuaDVwLWVsZW1lbnQtc29sdXRpb24nKS5sZW5ndGggPT09IDAgJiYgc3RyaXBIVE1MKGVsZW1lbnQuc29sdXRpb24pLmxlbmd0aCA+IDApIHtcclxuICAgICAgY29uc3QgJGNvbW1lbnRCdXR0b24gPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICAgcm9sZTogJ2J1dHRvbicsXHJcbiAgICAgICAgdGFiaW5kZXg6IDAsXHJcbiAgICAgICAgdGl0bGU6IHRoaXMubDEwbi5zb2x1dGlvbnNCdXR0b25UaXRsZSxcclxuICAgICAgICAnYXJpYS1oYXNwb3B1cCc6ICdkaWFsb2cnLFxyXG4gICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXHJcbiAgICAgICAgJ2NsYXNzJzogJ2g1cC1lbGVtZW50LXNvbHV0aW9uJ1xyXG4gICAgICB9KS5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiam91YmVsLWljb24tY29tbWVudC1ub3JtYWxcIj48c3BhbiBjbGFzcz1cImg1cC1pY29uLXNoYWRvd1wiPjwvc3Bhbj48c3BhbiBjbGFzcz1cImg1cC1pY29uLXNwZWVjaC1idWJibGVcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJoNXAtaWNvbi1xdWVzdGlvblwiPjwvc3Bhbj48L3NwYW4+JylcclxuICAgICAgICAuYXBwZW5kVG8oJGVsZW1lbnRDb250YWluZXIpO1xyXG5cclxuICAgICAgY29uc3QgcGFyZW50UG9zaXRpb24gPSB7XHJcbiAgICAgICAgeDogZWxlbWVudC54LFxyXG4gICAgICAgIHk6IGVsZW1lbnQueVxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoIWVsZW1lbnQuZGlzcGxheUFzQnV0dG9uKSB7XHJcbiAgICAgICAgcGFyZW50UG9zaXRpb24ueCArPSBlbGVtZW50LndpZHRoIC0gNDtcclxuICAgICAgICBwYXJlbnRQb3NpdGlvbi55ICs9IGVsZW1lbnQuaGVpZ2h0IC0gMTI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMoJGNvbW1lbnRCdXR0b24sIChldmVudCkgPT4ge1xyXG4gICAgICAgIHRoaXMuc2hvd1BvcHVwKHsgXHJcbiAgICAgICAgICBwb3B1cENvbnRlbnQ6IGVsZW1lbnQuc29sdXRpb24sIFxyXG4gICAgICAgICAgJGZvY3VzT25DbG9zZTogJGNvbW1lbnRCdXR0b24sIFxyXG4gICAgICAgICAgcGFyZW50UG9zaXRpb246IHBhcmVudFBvc2l0aW9uLFxyXG4gICAgICAgICAgdXBkYXRlQXJpYUV4cGFuZGVkOiB0cnVlLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICRjb21tZW50QnV0dG9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBQcmV2ZW50cyB0aGUgd3JhcHBlciBmcm9tIHN0ZWFsaW5nIHRoZSBmb2N1cyBvZiBzY3JlZW4gcmVhZGVyc1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBpZiAoZWxlbWVudC5hbHdheXNEaXNwbGF5Q29tbWVudHMgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50LmFsd2F5c0Rpc3BsYXlDb21tZW50cykge1xyXG4gICAgZWxlbWVudEluc3RhbmNlLnNob3dDUENvbW1lbnRzKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIERpc3BsYXlzIGEgcG9wdXAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfGpRdWVyeX0gcG9wdXBDb250ZW50XHJcbiAqIEBwYXJhbSB7alF1ZXJ5fSAkZm9jdXNPbkNsb3NlIFByZXZlbnRzIGxvc2luZyBmb2N1cyB3aGVuIGRpYWxvZyBjbG9zZXNcclxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJlbnRQb3NpdGlvbl0geCBhbmQgeSBjb29yZGluYXRlcyBvZiBwYXJlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlbW92ZV0gR2V0cyBjYWxsZWQgYmVmb3JlIHRoZSBwb3B1cCBpcyByZW1vdmVkLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NsYXNzZXNdXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbaW5zdGFuY2VdIEg1UCBsaWJyYXJ5IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2tlZXBJbkRPTV0gSGlkZSB0aGUgcG9wdXAgaW5zdGVhZCBvZiByZW1vdmluZyBpdCB3aGVuIGl0IGdldHMgY2xvc2VkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VwZGF0ZUFyaWFFeHBhbmRlZF0gU2V0IGFyaWEtZXhwYW5kZWQ9ZmFsc2Ugb24gdGhlICRmb2N1c09uQ2xvc2UgZWxlbWVudCB3aGVuIGNsb3NpbmdcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2hvd1BvcHVwID0gZnVuY3Rpb24gKHtcclxuICBwb3B1cENvbnRlbnQsIFxyXG4gICRmb2N1c09uQ2xvc2UsIFxyXG4gIHBhcmVudFBvc2l0aW9uID0gbnVsbCwgXHJcbiAgcmVtb3ZlLCBcclxuICBjbGFzc2VzID0gJ2g1cC1wb3B1cC1jb21tZW50LWZpZWxkJywgXHJcbiAgaW5zdGFuY2UsIFxyXG4gIGtlZXBJbkRPTSA9IGZhbHNlLFxyXG4gIHVwZGF0ZUFyaWFFeHBhbmRlZCxcclxufSkge1xyXG5cclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgdmFyIGRvTm90Q2xvc2U7XHJcbiAgLy8gR2l2ZSB0aGUgcG9wdXAgZWxlbWVudHMgdW5pcXVlIGlkc1xyXG4gIHRoaXMucG9wdXBJZCA9IHRoaXMucG9wdXBJZCA9PT0gdW5kZWZpbmVkID8gMCA6IHRoaXMucG9wdXBJZCArIDE7XHJcblxyXG4gIC8qKiBAcHJpdmF0ZSAqL1xyXG4gIHZhciBjbG9zZSA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgaWYgKGRvTm90Q2xvc2UpIHtcclxuICAgICAgLy8gUHJldmVudCBjbG9zaW5nIHRoZSBwb3B1cFxyXG4gICAgICBkb05vdENsb3NlID0gZmFsc2U7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbmFibGUgZm9jdXMgdG8gcmVzdCBvZiBwYWdlXHJcbiAgICBzZWxmLnJlc3RvcmVUYWJJbmRleGVzKCk7XHJcblxyXG4gICAgJGZvY3VzT25DbG9zZS5mb2N1cygpO1xyXG4gICAgaWYgKHVwZGF0ZUFyaWFFeHBhbmRlZCkge1xyXG4gICAgICAkZm9jdXNPbkNsb3NlLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHBvcHVwXHJcbiAgICBpZiAocmVtb3ZlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmVtb3ZlKGtlZXBJbkRPTSk7XHJcbiAgICAgIH0sIDEwMCk7XHJcbiAgICB9XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgJHBvcHVwLmFkZENsYXNzKCdoNXAtYW5pbWF0ZScpO1xyXG4gICAgJHBvcHVwLmZpbmQoJy5oNXAtcG9wdXAtY29udGFpbmVyJykuYWRkQ2xhc3MoJ2g1cC1hbmltYXRlJyk7XHJcblxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIGlmIChrZWVwSW5ET00pIHtcclxuICAgICAgICAkcG9wdXAuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICRwb3B1cC5yZW1vdmUoKTtcclxuICAgICAgfVxyXG4gICAgfSwgMTAwKTtcclxuICB9O1xyXG5cclxuICBsZXQgJHBvcHVwO1xyXG5cclxuICBpZiAoa2VlcEluRE9NICYmIGluc3RhbmNlICYmIHNlbGYucG9wdXBzW2luc3RhbmNlLnN1YkNvbnRlbnRJZF0pIHtcclxuICAgIC8vIFRoZSBwb3B1cCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgRE9NLCBidXQgaXMgaGlkZGVuXHJcbiAgICAkcG9wdXAgPSBzZWxmLnBvcHVwc1tpbnN0YW5jZS5zdWJDb250ZW50SWRdO1xyXG4gIH1cclxuXHJcbiAgaWYgKCRwb3B1cCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyBUaGUgcG9wdXAgbXVzdCBiZSBjcmVhdGVkIGFuZCBhZGRlZCB0byB0aGUgRE9NXHJcbiAgICAkcG9wdXAgPSAkKFxyXG4gICAgICAnPGRpdiBjbGFzcz1cImg1cC1wb3B1cC1vdmVybGF5ICcgKyBjbGFzc2VzICsgJ1wiPicgK1xyXG4gICAgICAgICc8ZGl2ICcgKyBcclxuICAgICAgICAgICdjbGFzcz1cImg1cC1wb3B1cC1jb250YWluZXJcIiAnICsgXHJcbiAgICAgICAgICAncm9sZT1cImRpYWxvZ1wiJyArIFxyXG4gICAgICAgICAgJ2FyaWEtbW9kYWw9XCJ0cnVlXCIgJyArIFxyXG4gICAgICAgICAgJ2FyaWEtbGl2ZT1cInRydWVcIiAnICsgXHJcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5PVwicG9wdXAtdGl0bGUtJyArIHRoaXMucG9wdXBJZCArICdcIj4gJyArICAgXHJcbiAgICAgICAgICAnPGRpdiByb2xlPVwiYnV0dG9uXCIgdGFiaW5kZXg9XCIwXCIgY2xhc3M9XCJoNXAtY2xvc2UtcG9wdXBcIiB0aXRsZT1cIicgKyB0aGlzLmwxMG4uY2xvc2UgKyAnXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cImg1cC1wb3B1cC13cmFwcGVyXCIgcm9sZT1cImRvY3VtZW50XCI+PC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPC9kaXY+J1xyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCAkcG9wdXBXcmFwcGVyID0gJHBvcHVwLmZpbmQoJy5oNXAtcG9wdXAtd3JhcHBlcicpO1xyXG4gICAgaWYgKHBvcHVwQ29udGVudCBpbnN0YW5jZW9mIEg1UC5qUXVlcnkpIHtcclxuICAgICAgJHBvcHVwV3JhcHBlci5hcHBlbmQocG9wdXBDb250ZW50KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAkcG9wdXBXcmFwcGVyLmh0bWwocG9wdXBDb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNvbnRlbnQgaXMgcmVhZCBieSBzY3JlZW4gcmVhZGVyc1xyXG4gICAgbGV0IGlkTGlzdCA9ICcnO1xyXG4gICAgJHBvcHVwV3JhcHBlclxyXG4gICAgICAuY2hpbGRyZW4oKVxyXG4gICAgICAuZWFjaCgoaW5kZXgsIGNoaWxkKSA9PiB7XHJcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdpZCcsICdwb3B1cC1jb250ZW50LScgKyB0aGlzLnBvcHVwSWQgKyAnLScgKyBpbmRleCk7XHJcbiAgICAgICAgaWRMaXN0ICs9ICdwb3B1cC1jb250ZW50LScgKyB0aGlzLnBvcHVwSWQgKyAnLScgKyBpbmRleCArICcgJztcclxuICAgICAgfSk7XHJcbiAgICAkcG9wdXBcclxuICAgICAgLmZpbmQoJy5oNXAtcG9wdXAtY29udGFpbmVyJylcclxuICAgICAgLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCBpZExpc3QpO1xyXG5cclxuICAgIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5zdWJDb250ZW50SWQpIHtcclxuICAgICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGlzIHBvcHVwXHJcbiAgICAgIHNlbGYucG9wdXBzW2luc3RhbmNlLnN1YkNvbnRlbnRJZF0gPSAkcG9wdXA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCAkcG9wdXBDb250YWluZXIgPSAkcG9wdXAuZmluZCgnLmg1cC1wb3B1cC1jb250YWluZXInKTtcclxuXHJcbiAgY29uc3QgcmVzaXplUG9wdXAgPSAoJHBvcHVwLCAkcG9wdXBDb250YWluZXIsIHBhcmVudFBvc2l0aW9uKSA9PiB7XHJcbiAgICBpZiAoIXBhcmVudFBvc2l0aW9uKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBub3Qgc2hvdyB1bnRpbCB3ZSBoYXZlIGZpbmlzaGVkIGNhbGN1bGF0aW5nIHBvc2l0aW9uXHJcbiAgICAkcG9wdXBDb250YWluZXIuY3NzKHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSk7XHJcbiAgICAkcG9wdXAucHJlcGVuZFRvKHRoaXMuJHdyYXBwZXIpO1xyXG5cclxuICAgIGxldCBwb3B1cEhlaWdodCA9ICRwb3B1cENvbnRhaW5lci5oZWlnaHQoKTtcclxuICAgIGxldCBwb3B1cFdpZHRoID0gJHBvcHVwQ29udGFpbmVyLndpZHRoKCk7XHJcbiAgICBjb25zdCBvdmVybGF5SGVpZ2h0ID0gJHBvcHVwLmhlaWdodCgpO1xyXG4gICAgY29uc3Qgb3ZlcmxheVdpZHRoID0gJHBvcHVwLndpZHRoKCk7XHJcbiAgICBsZXQgd2lkdGhQZXJjZW50YWdlID0gcG9wdXBXaWR0aCAqICgxMDAgLyBvdmVybGF5V2lkdGgpO1xyXG4gICAgbGV0IGhlaWdodFBlcmNlbnRhZ2UgPSBwb3B1cEhlaWdodCAqICgxMDAgLyBvdmVybGF5SGVpZ2h0KTtcclxuXHJcbiAgICAvLyBTa2lwIHN1ZmZpY2llbnRseSBiaWcgcG9wdXBzXHJcbiAgICBjb25zdCBza2lwVGhyZXNob2xkID0gNTA7XHJcbiAgICBpZiAod2lkdGhQZXJjZW50YWdlID4gc2tpcFRocmVzaG9sZCAmJiBoZWlnaHRQZXJjZW50YWdlID4gc2tpcFRocmVzaG9sZCkge1xyXG4gICAgICAkcG9wdXAuZGV0YWNoKCk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBPbmx5IHJlc2l6ZSBib3hlcyB0aGF0IGFyZSBkaXNwcm9wb3J0aW9uYWxseSB3aWRlXHJcbiAgICBjb25zdCBoZWlnaHRUaHJlc2hvbGQgPSA0NTtcclxuICAgIGlmICh3aWR0aFBlcmNlbnRhZ2UgPiBoZWlnaHRQZXJjZW50YWdlICYmIGhlaWdodFBlcmNlbnRhZ2UgPCBoZWlnaHRUaHJlc2hvbGQpIHtcclxuICAgICAgLy8gTWFrZSB0aGUgcG9wdXAgcXVhZHJhdGljXHJcbiAgICAgIHdpZHRoUGVyY2VudGFnZSA9IE1hdGguc3FydCh3aWR0aFBlcmNlbnRhZ2UgKiBoZWlnaHRQZXJjZW50YWdlKTtcclxuICAgICAgJHBvcHVwQ29udGFpbmVyLmNzcyh7XHJcbiAgICAgICAgd2lkdGg6IHdpZHRoUGVyY2VudGFnZSArICclJyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWNjb3VudCBmb3Igb3ZlcmZsb3dpbmcgZWRnZXMsIHVzZSBjb25zaXN0ZW50IHBlcmNlbnRhZ2UgcGFkZGluZyBhcyBjc3NcclxuICAgIGNvbnN0IHdpZHRoUGFkZGluZ1BlcmNlbnRhZ2UgPSA1O1xyXG5cclxuICAgIC8vIFdpZHRoIHBlcmNlbnRhZ2UgaXMgY2FwcGVkIGF0IG1pbiAyMiBhbmQgbWF4IDkwJSBpbiBjc3NcclxuICAgIGlmICh3aWR0aFBlcmNlbnRhZ2UgPiA5MCkge1xyXG4gICAgICB3aWR0aFBlcmNlbnRhZ2UgPSA5MDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHdpZHRoUGVyY2VudGFnZSA8IDIyKSB7XHJcbiAgICAgIHdpZHRoUGVyY2VudGFnZSA9IDIyO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG92ZXJmbG93UmlnaHRTaWRlVGhyZXNob2xkID0gMTAwIC0gd2lkdGhQZXJjZW50YWdlIC0gd2lkdGhQYWRkaW5nUGVyY2VudGFnZTtcclxuICAgIGxldCBsZWZ0UG9zID0gcGFyZW50UG9zaXRpb24ueDtcclxuICAgIGlmIChwYXJlbnRQb3NpdGlvbi54ID4gb3ZlcmZsb3dSaWdodFNpZGVUaHJlc2hvbGQpIHtcclxuICAgICAgbGVmdFBvcyA9IG92ZXJmbG93UmlnaHRTaWRlVGhyZXNob2xkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyZW50UG9zaXRpb24ueCA8IHdpZHRoUGFkZGluZ1BlcmNlbnRhZ2UpIHtcclxuICAgICAgbGVmdFBvcyA9IHdpZHRoUGFkZGluZ1BlcmNlbnRhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgaGVpZ2h0UGVyY2VudGFnZSA9ICRwb3B1cENvbnRhaW5lci5oZWlnaHQoKSAqICgxMDAgLyBvdmVybGF5SGVpZ2h0KTtcclxuICAgIGNvbnN0IGhlaWdodFBhZGRpbmcgPSAyMCAvIDI7XHJcbiAgICBjb25zdCB0b3BQb3NUaHJlc2hvbGQgPSAxMDAgLSBoZWlnaHRQZXJjZW50YWdlIC0gaGVpZ2h0UGFkZGluZztcclxuICAgIGxldCB0b3BQb3MgPSBwYXJlbnRQb3NpdGlvbi55O1xyXG4gICAgaWYgKHBhcmVudFBvc2l0aW9uLnkgPiB0b3BQb3NUaHJlc2hvbGQpIHtcclxuICAgICAgdG9wUG9zID0gdG9wUG9zVGhyZXNob2xkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocGFyZW50UG9zaXRpb24ueSA8IGhlaWdodFBhZGRpbmcpIHtcclxuICAgICAgdG9wUG9zID0gaGVpZ2h0UGFkZGluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNldCBhbmQgcHJlcGFyZSB0byBhbmltYXRlIGluXHJcbiAgICAkcG9wdXAuZGV0YWNoKCk7XHJcbiAgICAkcG9wdXBDb250YWluZXIuY3NzKHtcclxuICAgICAgbGVmdDogbGVmdFBvcyArICclJyxcclxuICAgICAgdG9wOiB0b3BQb3MgKyAnJScsXHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICByZXNpemVQb3B1cCgkcG9wdXAsICRwb3B1cENvbnRhaW5lciwgcGFyZW50UG9zaXRpb24pO1xyXG4gICRwb3B1cC5hZGRDbGFzcygnaDVwLWFuaW1hdGUnKTtcclxuICAkcG9wdXBDb250YWluZXIuY3NzKHtcclxuICAgICd2aXNpYmlsaXR5JzogJycsXHJcbiAgfSkuYWRkQ2xhc3MoJ2g1cC1hbmltYXRlJyk7XHJcblxyXG4gIGlmICgkcG9wdXAucGFyZW50KCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAvLyBIYXZpbmcgbm8gcGFyZW50IG1lYW5zIHRoZSBwb3B1cCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIHRoZSBET01cclxuICAgICRwb3B1cC5wcmVwZW5kVG8odGhpcy4kd3JhcHBlcik7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgJHBvcHVwLnNob3coKTtcclxuICB9XHJcblxyXG4gIC8vIEluc2VydCBwb3B1cCByZWFkeSBmb3IgdXNlXHJcbiAgJHBvcHVwXHJcbiAgICAucmVtb3ZlQ2xhc3MoJ2g1cC1hbmltYXRlJylcclxuICAgIC5jbGljayhjbG9zZSlcclxuICAgIC5maW5kKCcuaDVwLXBvcHVwLWNvbnRhaW5lcicpXHJcbiAgICAgIC5yZW1vdmVDbGFzcygnaDVwLWFuaW1hdGUnKVxyXG4gICAgICAuY2xpY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRvTm90Q2xvc2UgPSB0cnVlO1xyXG4gICAgICB9KVxyXG4gICAgICAua2V5ZG93bihmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQud2hpY2ggPT09IGtleUNvZGUuRVNDKSB7XHJcbiAgICAgICAgICBjbG9zZShldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KVxyXG4gICAgICAuZmluZCgnLmg1cC1jbG9zZS1wb3B1cCcpXHJcbiAgICAgICAgLmZvY3VzKCk7XHJcblxyXG4gIC8vIEhpZGUgb3RoZXIgZWxlbWVudHMgZnJvbSB0aGUgdGFiIG9yZGVyXHJcbiAgdGhpcy5kaXNhYmxlVGFiSW5kZXhlcygpO1xyXG5cclxuICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKCRwb3B1cC5maW5kKCcuaDVwLWNsb3NlLXBvcHVwJyksIGV2ZW50ID0+IGNsb3NlKGV2ZW50KSk7XHJcblxyXG4gIHJldHVybiAkcG9wdXA7XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaGFzIGEgc29sdXRpb25cclxuICpcclxuICogQHBhcmFtIHtINVAgbGlicmFyeSBpbnN0YW5jZX0gZWxlbWVudEluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiAgdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgYSBzb2x1dGlvblxyXG4gKiAgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmNoZWNrRm9yU29sdXRpb25zID0gZnVuY3Rpb24gKGVsZW1lbnRJbnN0YW5jZSkge1xyXG4gIHJldHVybiAoZWxlbWVudEluc3RhbmNlLnNob3dTb2x1dGlvbnMgIT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAgICAgZWxlbWVudEluc3RhbmNlLnNob3dDUENvbW1lbnRzICE9PSB1bmRlZmluZWQpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGtleSBwcmVzcyBldmVudHMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IE5vdGhpbmcuXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmluaXRLZXlFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgaWYgKHRoaXMua2V5ZG93biAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuYWN0aXZlU3VyZmFjZSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gIHZhciB3YWl0ID0gZmFsc2U7XHJcblxyXG4gIHRoaXMua2V5ZG93biA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgaWYgKHdhaXQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIExlZnRcclxuICAgIGlmICgoZXZlbnQua2V5Q29kZSA9PT0gMzcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzMpICYmIHRoYXQucHJldmlvdXNTbGlkZSh1bmRlZmluZWQsIGZhbHNlKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB3YWl0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSaWdodFxyXG4gICAgZWxzZSBpZiAoKGV2ZW50LmtleUNvZGUgPT09IDM5IHx8IGV2ZW50LmtleUNvZGUgPT09IDM0KSAmJiB0aGF0Lm5leHRTbGlkZSh1bmRlZmluZWQsIGZhbHNlKSkge1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB3YWl0ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAod2FpdCkge1xyXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugb25seSBjaGFuZ2Ugc2xpZGUgZXZlcnkgMzAwbXMuXHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdhaXQgPSBmYWxzZTtcclxuICAgICAgfSwgMzAwKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICBINVAualF1ZXJ5KCdib2R5Jykua2V5ZG93bih0aGlzLmtleWRvd24pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgdG91Y2ggZXZlbnRzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9IE5vdGhpbmcuXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmluaXRUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgdmFyIHN0YXJ0WCwgc3RhcnRZLCBsYXN0WCwgcHJldlgsIG5leHRYLCBzY3JvbGw7XHJcbiAgdmFyIHRvdWNoU3RhcnRlZCA9IGZhbHNlO1xyXG4gIC8vIHZhciBjb250YWluZXJXaWR0aCA9IHRoaXMuJHNsaWRlc1dyYXBwZXIud2lkdGgoKTtcclxuICAvLyB2YXIgY29udGFpbmVyUGVyY2VudGFnZUZvclNjcm9sbGluZyA9IDAuNjsgLy8gNjAlIG9mIGNvbnRhaW5lciB3aWR0aCB1c2VkIHRvIHJlYWNoIGVuZHBvaW50cyB3aXRoIHRvdWNoXHJcbiAgLy8gdmFyIHNsaWRlc051bWJlcnMgPSB0aGlzLnNsaWRlcy5sZW5ndGg7XHJcbiAgLy8gdmFyIHBpeGVsc1BlclNsaWRlID0gKGNvbnRhaW5lcldpZHRoICogY29udGFpbmVyUGVyY2VudGFnZUZvclNjcm9sbGluZykgLyBzbGlkZXNOdW1iZXJzO1xyXG4gIC8vIHZhciBzdGFydFRpbWU7XHJcbiAgLy8gdmFyIGN1cnJlbnRUaW1lO1xyXG4gIC8vIHZhciBuYXZpZ2F0ZVRpbWVyID0gNTAwOyAvLyA1MDBtcyBiZWZvcmUgbmF2aWdhdGlvbiBwb3B1cCBzdGFydHMuXHJcbiAgdmFyIGlzVG91Y2hKdW1wID0gZmFsc2U7XHJcbiAgLy8gdmFyIG5leHRTbGlkZTtcclxuICB2YXIgdHJhbnNmb3JtID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAnLXdlYmtpdC10cmFuc2Zvcm0nOiB2YWx1ZSxcclxuICAgICAgJy1tb3otdHJhbnNmb3JtJzogdmFsdWUsXHJcbiAgICAgICctbXMtdHJhbnNmb3JtJzogdmFsdWUsXHJcbiAgICAgICd0cmFuc2Zvcm0nOiB2YWx1ZVxyXG4gICAgfTtcclxuICB9O1xyXG4gIHZhciByZXNldCA9IHRyYW5zZm9ybSgnJyk7XHJcblxyXG4gIHRoaXMuJHNsaWRlc1dyYXBwZXIuYmluZCgndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgaXNUb3VjaEp1bXAgPSBmYWxzZTtcclxuICAgIC8vIFNldCBzdGFydCBwb3NpdGlvbnNcclxuICAgIGxhc3RYID0gc3RhcnRYID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLnBhZ2VYO1xyXG4gICAgc3RhcnRZID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgY29uc3Qgc2xpZGVXaWR0aCA9IHRoYXQuJHNsaWRlc1dyYXBwZXIud2lkdGgoKTtcclxuXHJcbiAgICAvLyBTZXQgY2xhc3NlcyBmb3Igc2xpZGUgbW92ZW1lbnQgYW5kIHJlbWVtYmVyIGhvdyBtdWNoIHRoZXkgbW92ZVxyXG4gICAgcHJldlggPSAodGhhdC5jdXJyZW50U2xpZGVJbmRleCA9PT0gMCA/IDAgOiAtIHNsaWRlV2lkdGgpO1xyXG4gICAgbmV4dFggPSAodGhhdC5jdXJyZW50U2xpZGVJbmRleCArIDEgPj0gdGhhdC5zbGlkZXMubGVuZ3RoID8gMCA6IHNsaWRlV2lkdGgpO1xyXG5cclxuICAgIC8vIGNvbnRhaW5lcldpZHRoID0gSDVQLmpRdWVyeSh0aGlzKS53aWR0aCgpO1xyXG4gICAgLy8gc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblxyXG4gICAgc2Nyb2xsID0gbnVsbDtcclxuICAgIHRvdWNoU3RhcnRlZCA9IHRydWU7XHJcblxyXG4gIH0pLmJpbmQoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcblxyXG4gICAgaWYgKHRvdWNoU3RhcnRlZCkge1xyXG4gICAgICB0aGF0LiRjdXJyZW50LnByZXYoKS5hZGRDbGFzcygnaDVwLXRvdWNoLW1vdmUnKTtcclxuICAgICAgdGhhdC4kY3VycmVudC5uZXh0KCkuYWRkQ2xhc3MoJ2g1cC10b3VjaC1tb3ZlJyk7XHJcbiAgICAgIHRvdWNoU3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERldGVybWluZSBob3Jpem9udGFsIG1vdmVtZW50XHJcbiAgICBsYXN0WCA9IHRvdWNoZXNbMF0ucGFnZVg7XHJcbiAgICB2YXIgbW92ZWRYID0gc3RhcnRYIC0gbGFzdFg7XHJcblxyXG4gICAgaWYgKHNjcm9sbCA9PT0gbnVsbCkge1xyXG4gICAgICAvLyBEZXRlbWluZSBpZiB3ZSdyZSBzY3JvbGxpbmcgaG9yaXpvbnRhbGx5IG9yIGNoYW5naW5nIHNsaWRlXHJcbiAgICAgIHNjcm9sbCA9IE1hdGguYWJzKHN0YXJ0WSAtIGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1swXS5wYWdlWSkgPiBNYXRoLmFicyhtb3ZlZFgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRvdWNoZXMubGVuZ3RoICE9PSAxIHx8IHNjcm9sbCkge1xyXG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHdlJ3JlIHNjcm9sbGluZywgem9vbWluZyBldGMuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEaXNhYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nIHdoZW4gY2hhbmdpbmcgc2xpZGVcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgLy8gQ3JlYXRlIHBvcHVwIGxvbmdlciB0aW1lIHRoYW4gbmF2aWdhdGVUaW1lciBoYXMgcGFzc2VkXHJcbiAgICBpZiAoIWlzVG91Y2hKdW1wKSB7XHJcbiAgICAgIC8qY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgdmFyIHRpbWVMYXBzZWQgPSBjdXJyZW50VGltZSAtIHN0YXJ0VGltZTtcclxuICAgICAgaWYgKHRpbWVMYXBzZWQgPiBuYXZpZ2F0ZVRpbWVyKSB7XHJcbiAgICAgICAgaXNUb3VjaEp1bXAgPSB0cnVlO1xyXG4gICAgICB9Ki9cclxuXHJcbiAgICAgIC8vIEZhc3Qgc3dpcGUgdG8gbmV4dCBzbGlkZVxyXG4gICAgICBpZiAobW92ZWRYIDwgMCkge1xyXG4gICAgICAgIC8vIE1vdmUgcHJldmlvdXMgc2xpZGVcclxuICAgICAgICB0aGF0LiRjdXJyZW50LnByZXYoKS5jc3ModHJhbnNmb3JtKCd0cmFuc2xhdGVYKCcgKyAocHJldlggLSBtb3ZlZFgpICsgJ3B4JykpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIE1vdmUgbmV4dCBzbGlkZVxyXG4gICAgICAgIHRoYXQuJGN1cnJlbnQubmV4dCgpLmNzcyh0cmFuc2Zvcm0oJ3RyYW5zbGF0ZVgoJyArIChuZXh0WCAtIG1vdmVkWCkgKyAncHgpJykpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBNb3ZlIGN1cnJlbnQgc2xpZGVcclxuICAgICAgdGhhdC4kY3VycmVudC5jc3ModHJhbnNmb3JtKCd0cmFuc2xhdGVYKCcgKyAoLW1vdmVkWCkgKyAncHgpJykpO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogSnVtcGluZyBvdmVyIG11bHRpcGxlIHNsaWRlcyBkaXNhYmxlZCB1bnRpbCByZWRlc2lnbmVkLlxyXG5cclxuICAgIC8qIGVsc2Uge1xyXG4gICAgICB0aGF0LiRjdXJyZW50LmNzcyhyZXNldCk7XHJcbiAgICAgIC8vIFVwZGF0ZSBzbGlkZXIgcG9wdXAuXHJcbiAgICAgIG5leHRTbGlkZSA9IHBhcnNlSW50KHRoYXQuY3VycmVudFNsaWRlSW5kZXggKyAobW92ZWRYIC8gcGl4ZWxzUGVyU2xpZGUpLCAxMCk7XHJcbiAgICAgIGlmIChuZXh0U2xpZGUgPj0gdGhhdC5zbGlkZXMubGVuZ3RoIC0xKSB7XHJcbiAgICAgICAgbmV4dFNsaWRlID0gdGhhdC5zbGlkZXMubGVuZ3RoIC0xO1xyXG4gICAgICB9IGVsc2UgaWYgKG5leHRTbGlkZSA8IDApIHtcclxuICAgICAgICBuZXh0U2xpZGUgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENyZWF0ZSBwb3B1cCBhdCBpbml0aWFsIHRvdWNoIHBvaW50XHJcbiAgICAgIHRoYXQudXBkYXRlVG91Y2hQb3B1cCh0aGF0LiRzbGlkZXNXcmFwcGVyLCBuZXh0U2xpZGUsIHN0YXJ0WCwgc3RhcnRZKTtcclxuICAgIH0qL1xyXG5cclxuICB9KS5iaW5kKCd0b3VjaGVuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghc2Nyb2xsKSB7XHJcbiAgICAgIC8qaWYgKGlzVG91Y2hKdW1wKSB7XHJcbiAgICAgICAgdGhhdC5qdW1wVG9TbGlkZShuZXh0U2xpZGUpO1xyXG4gICAgICAgIHRoYXQudXBkYXRlVG91Y2hQb3B1cCgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSovXHJcblxyXG4gICAgICAvLyBJZiB3ZSdyZSBub3Qgc2Nyb2xsaW5nIGRldGVtaW5lIGlmIHdlJ3JlIGNoYW5naW5nIHNsaWRlXHJcbiAgICAgIHZhciBtb3ZlZCA9IHN0YXJ0WCAtIGxhc3RYO1xyXG4gICAgICBpZiAobW92ZWQgPiB0aGF0LnN3aXBlVGhyZXNob2xkICYmIHRoYXQubmV4dFNsaWRlKHVuZGVmaW5lZCwgZmFsc2UpIHx8IG1vdmVkIDwgLXRoYXQuc3dpcGVUaHJlc2hvbGQgJiYgdGhhdC5wcmV2aW91c1NsaWRlKHVuZGVmaW5lZCwgZmFsc2UpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZXNldC5cclxuICAgIHRoYXQuJHNsaWRlc1dyYXBwZXIuY2hpbGRyZW4oKS5jc3MocmVzZXQpLnJlbW92ZUNsYXNzKCdoNXAtdG91Y2gtbW92ZScpO1xyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSAkY29udGFpbmVyXHJcbiAqIEBwYXJhbSBzbGlkZU51bWJlclxyXG4gKiBAcGFyYW0geFBvc1xyXG4gKiBAcGFyYW0geVBvc1xyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS51cGRhdGVUb3VjaFBvcHVwID0gZnVuY3Rpb24gKCRjb250YWluZXIsIHNsaWRlTnVtYmVyLCB4UG9zLCB5UG9zKSB7XHJcbiAgLy8gUmVtb3ZlIHBvcHVwIG9uIG5vIGFyZ3VtZW50c1xyXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcclxuICAgIGlmICh0aGlzLnRvdWNoUG9wdXAgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnRvdWNoUG9wdXAucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm47XHJcbiAgfVxyXG5cclxuICB2YXIga2V5d29yZCA9ICcnO1xyXG4gIHZhciB5UG9zQWRqdXN0bWVudCA9IDAuMTU7IC8vIEFkanVzdCB5LXBvc2l0aW9uIDE1JSBoaWdoZXIgZm9yIHZpc2liaWxpdHlcclxuXHJcbiAgaWYgKCh0aGlzLiRrZXl3b3JkcyAhPT0gdW5kZWZpbmVkKSAmJiAodGhpcy4ka2V5d29yZHMuY2hpbGRyZW4oJzplcSgnICsgc2xpZGVOdW1iZXIgKyAnKScpLmZpbmQoJ3NwYW4nKS5odG1sKCkgIT09IHVuZGVmaW5lZCkpIHtcclxuICAgIGtleXdvcmQgKz0gdGhpcy4ka2V5d29yZHMuY2hpbGRyZW4oJzplcSgnICsgc2xpZGVOdW1iZXIgKyAnKScpLmZpbmQoJ3NwYW4nKS5odG1sKCk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgdmFyIHNsaWRlSW5kZXhUb051bWJlciA9IHNsaWRlTnVtYmVyICsgMTtcclxuICAgIGtleXdvcmQgKz0gdGhpcy5sMTBuLnNsaWRlICsgJyAnICsgc2xpZGVJbmRleFRvTnVtYmVyO1xyXG4gIH1cclxuXHJcbiAgLy8gU3VtbWFyeSBzbGlkZSBrZXl3b3JkXHJcbiAgaWYgKHRoaXMuZWRpdG9yID09PSB1bmRlZmluZWQpIHtcclxuICAgIGlmIChzbGlkZU51bWJlciA+PSB0aGlzLnNsaWRlcy5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGtleXdvcmQgPSB0aGlzLmwxMG4uc2hvd1NvbHV0aW9ucztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmICh0aGlzLnRvdWNoUG9wdXAgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgdGhpcy50b3VjaFBvcHVwID0gSDVQLmpRdWVyeSgnPGRpdi8+Jywge1xyXG4gICAgICAnY2xhc3MnOiAnaDVwLXRvdWNoLXBvcHVwJ1xyXG4gICAgfSkuaW5zZXJ0QWZ0ZXIoJGNvbnRhaW5lcik7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgdGhpcy50b3VjaFBvcHVwLmluc2VydEFmdGVyKCRjb250YWluZXIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRqdXN0IHlQb3MgYWJvdmUgZmluZ2VyLlxyXG4gIGlmICgoeVBvcyAtICgkY29udGFpbmVyLnBhcmVudCgpLmhlaWdodCgpICogeVBvc0FkanVzdG1lbnQpKSA8IDApIHtcclxuICAgIHlQb3MgPSAwO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHlQb3MgLT0gKCRjb250YWluZXIucGFyZW50KCkuaGVpZ2h0KCkgKiB5UG9zQWRqdXN0bWVudCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnRvdWNoUG9wdXAuY3NzKHtcclxuICAgICdtYXgtd2lkdGgnOiAkY29udGFpbmVyLndpZHRoKCkgLSB4UG9zLFxyXG4gICAgJ2xlZnQnOiB4UG9zLFxyXG4gICAgJ3RvcCc6IHlQb3NcclxuICB9KTtcclxuICB0aGlzLnRvdWNoUG9wdXAuaHRtbChrZXl3b3JkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTd2l0Y2ggdG8gcHJldmlvdXMgc2xpZGVcclxuICpcclxuICogQHBhcmFtIHtCb29sZWFufSBbbm9TY3JvbGxdIFNraXAgVUkgc2Nyb2xsaW5nLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBtb3ZlIHdhcyBtYWRlLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5wcmV2aW91c1NsaWRlID0gZnVuY3Rpb24gKG5vU2Nyb2xsLCBvbGQgPSB0cnVlKSB7XHJcbiAgdmFyICRwcmV2ID0gdGhpcy4kY3VycmVudC5wcmV2KCk7XHJcbiAgaWYgKCEkcHJldi5sZW5ndGgpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgaWYgKG9sZCkge1xyXG4gICAgdmFyIHltYXAgPSB0aGlzLmRvYy5nZXRNYXAoJ3BhZ2VTdGF0ZScpO1xyXG4gICAgeW1hcC5zZXQoJ2N1cnJlbnRQYWdlJywkcHJldi5pbmRleCgpKTtcclxuICAgIHJldHVybiB0aGlzLnByb2Nlc3NKdW1wVG9TbGlkZSgkcHJldi5pbmRleCgpLCBub1Njcm9sbCwgZmFsc2UpO1xyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIHJldHVybiB0aGlzLmp1bXBUb1NsaWRlKCRwcmV2LmluZGV4KCksIG5vU2Nyb2xsLCBudWxsLCBmYWxzZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFN3aXRjaCB0byBuZXh0IHNsaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5vU2Nyb2xsIFNraXAgVUkgc2Nyb2xsaW5nLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSW5kaWNhdGVzIGlmIHRoZSBtb3ZlIHdhcyBtYWRlLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5uZXh0U2xpZGUgPSBmdW5jdGlvbiAobm9TY3JvbGwsIG9sZCA9IHRydWUpIHtcclxuICB2YXIgJG5leHQgPSB0aGlzLiRjdXJyZW50Lm5leHQoKTtcclxuICBpZiAoISRuZXh0Lmxlbmd0aCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICBpZiAob2xkKSB7XHJcbiAgICB2YXIgeW1hcCA9IHRoaXMuZG9jLmdldE1hcCgncGFnZVN0YXRlJyk7XHJcbiAgICB5bWFwLnNldCgnY3VycmVudFBhZ2UnLCRuZXh0LmluZGV4KCkpO1xyXG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc0p1bXBUb1NsaWRlKCRuZXh0LmluZGV4KCksIG5vU2Nyb2xsLCBmYWxzZSk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgcmV0dXJuIHRoaXMuanVtcFRvU2xpZGUoJG5leHQuaW5kZXgoKSwgbm9TY3JvbGwsIG51bGwsIGZhbHNlKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVsZW1lbnQgaXMgdGhlIGN1cnJlbnQgc2xpZGVcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmlzQ3VycmVudFNsaWRlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgcmV0dXJuIHRoaXMuY3VycmVudFNsaWRlSW5kZXggPT09IGluZGV4O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2xpZGUgaW5kZXhcclxuICpcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5nZXRDdXJyZW50U2xpZGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5jdXJyZW50U2xpZGVJbmRleDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhbGwgc2xpZGVzIChOZWVkZWQgYnkgcHJpbnQpXHJcbiAqIEBtZXRob2QgYXR0YWNoQWxsRWxlbWVudHNcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuYXR0YWNoQWxsRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyICRzbGlkZXMgPSB0aGlzLiRzbGlkZXNXcmFwcGVyLmNoaWxkcmVuKCk7XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIHRoaXMuYXR0YWNoRWxlbWVudHMoJHNsaWRlcy5lcShpKSwgaSk7XHJcbiAgfVxyXG5cclxuICAvLyBOZWVkIHRvIGZvcmNlIHVwZGF0aW5nIHN1bW1hcnkgc2xpZGUhIFRoaXMgaXMgbm9ybWFsbHkgZG9uZVxyXG4gIC8vIG9ubHkgd2hlbiBzdW1tYXJ5IHNsaWRlIGlzIGFib3V0IHRvIGJlIHZpZXdlZFxyXG4gIGlmICh0aGlzLnN1bW1hcnlTbGlkZU9iamVjdCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzLnN1bW1hcnlTbGlkZU9iamVjdC51cGRhdGVTdW1tYXJ5U2xpZGUodGhpcy5zbGlkZXMubGVuZ3RoIC0gMSwgdHJ1ZSk7XHJcbiAgfVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgdGhlIGp1bXAgdG8gc2xpZGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbGlkZU51bWJlciBUaGUgc2xpZGUgbnVtYmVyIHRvIGp1bXAgdG8uXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU2Nyb2xsXSBTa2lwIFVJIHNjcm9sbGluZy5cclxuICogQHJldHVybnMge0Jvb2xlYW59IEFsd2F5cyB0cnVlLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5wcm9jZXNzSnVtcFRvU2xpZGUgPSBmdW5jdGlvbiAoc2xpZGVOdW1iZXIsIG5vU2Nyb2xsLCBoYW5kbGVGb2N1cykge1xyXG4gIHZhciB0aGF0ID0gdGhpcztcclxuICBpZiAodGhpcy5lZGl0b3IgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmNvbnRlbnRJZCkgeyAvLyBDb250ZW50IElEIGF2b2lkcyBjcmFzaCB3aGVuIHByZXZpZXdpbmcgaW4gZWRpdG9yIGJlZm9yZSBzYXZpbmdcclxuICAgIHZhciBwcm9ncmVzc2VkRXZlbnQgPSB0aGlzLmNyZWF0ZVhBUElFdmVudFRlbXBsYXRlKCdwcm9ncmVzc2VkJyk7XHJcbiAgICBwcm9ncmVzc2VkRXZlbnQuZGF0YS5zdGF0ZW1lbnQub2JqZWN0LmRlZmluaXRpb24uZXh0ZW5zaW9uc1snaHR0cDovL2lkLnRpbmNhbmFwaS5jb20vZXh0ZW5zaW9uL2VuZGluZy1wb2ludCddID0gc2xpZGVOdW1iZXIgKyAxO1xyXG4gICAgdGhpcy50cmlnZ2VyKHByb2dyZXNzZWRFdmVudCk7XHJcbiAgfVxyXG5cclxuICBpZiAodGhpcy4kY3VycmVudC5oYXNDbGFzcygnaDVwLWFuaW1hdGUnKSkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgLy8gSnVtcCB0byBnaXZlbiBzbGlkZSBhbmQgZW5hYmxlIGFuaW1hdGlvbi5cclxuICB2YXIgJG9sZCA9IHRoaXMuJGN1cnJlbnQuYWRkQ2xhc3MoJ2g1cC1hbmltYXRlJyk7XHJcbiAgdmFyICRzbGlkZXMgPSB0aGF0LiRzbGlkZXNXcmFwcGVyLmNoaWxkcmVuKCk7XHJcbiAgdmFyICRwcmV2cyA9ICRzbGlkZXMuZmlsdGVyKCc6bHQoJyArIHNsaWRlTnVtYmVyICsgJyknKTtcclxuICB0aGlzLiRjdXJyZW50ID0gJHNsaWRlcy5lcShzbGlkZU51bWJlcikuYWRkQ2xhc3MoJ2g1cC1hbmltYXRlJyk7XHJcbiAgdmFyIHByZXZpb3VzU2xpZGVJbmRleCA9IHRoaXMuY3VycmVudFNsaWRlSW5kZXg7XHJcbiAgdGhpcy5jdXJyZW50U2xpZGVJbmRleCA9IHNsaWRlTnVtYmVyO1xyXG5cclxuICAvLyBBdHRhY2ggZWxlbWVudHMgZm9yIHRoaXMgc2xpZGVcclxuICB0aGlzLmF0dGFjaEVsZW1lbnRzKHRoaXMuJGN1cnJlbnQsIHNsaWRlTnVtYmVyKTtcclxuXHJcbiAgLy8gQXR0YWNoIGVsZW1lbnRzIGZvciBuZXh0IHNsaWRlXHJcbiAgdmFyICRuZXh0U2xpZGUgPSB0aGlzLiRjdXJyZW50Lm5leHQoKTtcclxuICBpZiAoJG5leHRTbGlkZS5sZW5ndGgpIHtcclxuICAgIHRoaXMuYXR0YWNoRWxlbWVudHMoJG5leHRTbGlkZSwgc2xpZGVOdW1iZXIgKyAxKTtcclxuICB9XHJcblxyXG4gIC8vIEZvciBuZXcgc2xpZGVcclxuICB0aGlzLnNldE92ZXJmbG93VGFiSW5kZXgoKTtcclxuXHJcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBQbGF5IGFuaW1hdGlvbnNcclxuICAgICRvbGQucmVtb3ZlQ2xhc3MoJ2g1cC1jdXJyZW50Jyk7XHJcbiAgICAkc2xpZGVzLmNzcyh7XHJcbiAgICAgICctd2Via2l0LXRyYW5zZm9ybSc6ICcnLFxyXG4gICAgICAnLW1vei10cmFuc2Zvcm0nOiAnJyxcclxuICAgICAgJy1tcy10cmFuc2Zvcm0nOiAnJyxcclxuICAgICAgJ3RyYW5zZm9ybSc6ICcnXHJcbiAgICB9KS5yZW1vdmVDbGFzcygnaDVwLXRvdWNoLW1vdmUnKS5yZW1vdmVDbGFzcygnaDVwLXByZXZpb3VzJyk7XHJcbiAgICAkcHJldnMuYWRkQ2xhc3MoJ2g1cC1wcmV2aW91cycpO1xyXG4gICAgdGhhdC4kY3VycmVudC5hZGRDbGFzcygnaDVwLWN1cnJlbnQnKTtcclxuXHJcbiAgICB0aGF0LnRyaWdnZXIoJ2NoYW5nZWRTbGlkZScsIHRoYXQuJGN1cnJlbnQuaW5kZXgoKSk7XHJcbiAgfSwgMSk7XHJcblxyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gRG9uZSBhbmltYXRpbmdcclxuICAgIHRoYXQuJHNsaWRlc1dyYXBwZXIuY2hpbGRyZW4oKS5yZW1vdmVDbGFzcygnaDVwLWFuaW1hdGUnKTtcclxuXHJcbiAgICBpZiAodGhhdC5lZGl0b3IgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGFjdGl2aXR5IHN0YXJ0ZWRcclxuICAgIHZhciBpbnN0YW5jZXMgPSB0aGF0LmVsZW1lbnRJbnN0YW5jZXNbdGhhdC5jdXJyZW50U2xpZGVJbmRleF07XHJcbiAgICB2YXIgaW5zdGFuY2VQYXJhbXMgPSB0aGF0LnNsaWRlc1t0aGF0LmN1cnJlbnRTbGlkZUluZGV4XS5lbGVtZW50cztcclxuICAgIGlmIChpbnN0YW5jZXMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghaW5zdGFuY2VQYXJhbXNbaV0uZGlzcGxheUFzQnV0dG9uICYmIHR5cGVvZiBpbnN0YW5jZXNbaV0uc2V0QWN0aXZpdHlTdGFydGVkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZXNbaV0uZ2V0U2NvcmUgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIGluc3RhbmNlc1tpXS5zZXRBY3Rpdml0eVN0YXJ0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCAyNTApO1xyXG5cclxuICAvLyBKdW1wIGtleXdvcmRzXHJcbiAgaWYgKHRoaXMuJGtleXdvcmRzICE9PSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXMua2V5d29yZE1lbnUuc2V0Q3VycmVudFNsaWRlSW5kZXgoc2xpZGVOdW1iZXIpO1xyXG4gICAgdGhpcy4kY3VycmVudEtleXdvcmQgPSB0aGlzLiRrZXl3b3Jkcy5maW5kKCcuaDVwLWN1cnJlbnQnKTtcclxuXHJcbiAgICBpZiAoIW5vU2Nyb2xsKSB7XHJcbiAgICAgIHRoaXMua2V5d29yZE1lbnUuc2Nyb2xsVG9LZXl3b3JkcyhzbGlkZU51bWJlcik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBTaG93IGtleXdvcmRzIGlmIHRoZXkgc2hvdWxkIGFsd2F5cyBzaG93XHJcbiAgaWYgKHRoYXQucHJlc2VudGF0aW9uLmtleXdvcmRMaXN0RW5hYmxlZCAmJiB0aGF0LnByZXNlbnRhdGlvbi5rZXl3b3JkTGlzdEFsd2F5c1Nob3cpIHtcclxuICAgIHRoYXQuc2hvd0tleXdvcmRzKCk7XHJcbiAgfVxyXG5cclxuICBpZiAodGhhdC5uYXZpZ2F0aW9uTGluZSkge1xyXG4gICAgLy8gVXBkYXRlIHByb2dyZXNzIGJhclxyXG4gICAgdGhhdC5uYXZpZ2F0aW9uTGluZS51cGRhdGVQcm9ncmVzc0JhcihzbGlkZU51bWJlciwgcHJldmlvdXNTbGlkZUluZGV4LCB0aGlzLmlzU29sdXRpb25Nb2RlKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgZm9vdGVyXHJcbiAgICB0aGF0Lm5hdmlnYXRpb25MaW5lLnVwZGF0ZUZvb3RlcihzbGlkZU51bWJlcik7XHJcblxyXG4gICAgLy8gQW5ub3VuY2Ugc2xpZGUgY2hhbmdlXHJcbiAgICB0aGlzLnNldFNsaWRlTnVtYmVyQW5ub3VuY2VyKHNsaWRlTnVtYmVyLCBoYW5kbGVGb2N1cyk7XHJcbiAgfVxyXG5cclxuICBpZiAodGhhdC5zdW1tYXJ5U2xpZGVPYmplY3QpIHtcclxuICAgIC8vIFVwZGF0ZSBzdW1tYXJ5IHNsaWRlIGlmIG9uIGxhc3Qgc2xpZGUsIGRvIG5vdCBqdW1wXHJcbiAgICB0aGF0LnN1bW1hcnlTbGlkZU9iamVjdC51cGRhdGVTdW1tYXJ5U2xpZGUoc2xpZGVOdW1iZXIsIHRydWUpO1xyXG4gIH1cclxuXHJcbiAgLy8gRWRpdG9yIHNwZWNpZmljIHNldHRpbmdzXHJcbiAgaWYgKHRoaXMuZWRpdG9yICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lZGl0b3IuZG5iICE9PSB1bmRlZmluZWQpIHtcclxuICAgIC8vIFVwZGF0ZSBkcmFnIGFuZCBkcm9wIG1lbnUgYmFyIGNvbnRhaW5lclxyXG4gICAgdGhpcy5lZGl0b3IuZG5iLnNldENvbnRhaW5lcih0aGlzLiRjdXJyZW50KTtcclxuICAgIHRoaXMuZWRpdG9yLmRuYi5ibHVyQWxsKCk7XHJcbiAgfVxyXG5cclxuICB0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpOyAvLyBUcmlnZ2VyZWQgdG8gcmVzaXplIGVsZW1lbnRzLlxyXG4gIHRoaXMuZml0Q1QoKTtcclxuICByZXR1cm4gdHJ1ZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBKdW1wIHRvIHRoZSBnaXZlbiBzbGlkZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHNsaWRlTnVtYmVyIFRoZSBzbGlkZSBudW1iZXIgdG8ganVtcCB0by5cclxuICogQHBhcmFtIHtCb29sZWFufSBbbm9TY3JvbGxdIFNraXAgVUkgc2Nyb2xsaW5nLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufG51bGx9IFtjYWxsYmFja10gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBvbiBzdWNjZXNzZnVsbCBuYXZpZ2F0aW9uXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lnbm9yZUNvbmZpcm1hdGlvbkRpYWxvZ10gV2lsbCBub3Qgc2hvdyBjb25maXJtYXRpb24gZGlhbG9nIGZvciBzdW1tYXJ5IHNsaWRlXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5qdW1wVG9TbGlkZSA9IGZ1bmN0aW9uIChzbGlkZU51bWJlciwgbm9TY3JvbGwgPSBmYWxzZSwgY2FsbGJhY2sgPSBudWxsLCBoYW5kbGVGb2N1cyA9IGZhbHNlLCBpZ25vcmVDb25maXJtYXRpb25EaWFsb2cgPSBmYWxzZSkge1xyXG4gIGlmICh0aGlzLnN0YW5kYWxvbmVcclxuICAgICYmIHRoaXMuc2hvd1N1bW1hcnlTbGlkZVxyXG4gICAgJiYgc2xpZGVOdW1iZXIgPT09IHRoaXMuc2xpZGVzLmxlbmd0aCAtIDFcclxuICAgICYmICF0aGlzLmlzU29sdXRpb25Nb2RlXHJcbiAgICAmJiB0aGlzLmlzUmVwb3J0aW5nRW5hYmxlZFxyXG4gICAgJiYgIWlnbm9yZUNvbmZpcm1hdGlvbkRpYWxvZ1xyXG4gICkge1xyXG5cclxuICAgIC8vIEN1cnJlbnRseSBpbiB0aGUgc3VtbWFyeSBzbGlkZVxyXG4gICAgaWYgKHRoaXMuY3VycmVudFNsaWRlSW5kZXggPT09IHRoaXMuc2xpZGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNvbmZpcm1hdGlvbkRpYWxvZyA9IENvbmZpcm1hdGlvbkRpYWxvZyh7XHJcbiAgICAgIGhlYWRlclRleHQ6IHRoaXMubDEwbi5jb25maXJtRGlhbG9nSGVhZGVyLFxyXG4gICAgICBkaWFsb2dUZXh0OiB0aGlzLmwxMG4uY29uZmlybURpYWxvZ1RleHQsXHJcbiAgICAgIGNvbmZpcm1UZXh0OiB0aGlzLmwxMG4uY29uZmlybURpYWxvZ0NvbmZpcm1hdGlvblRleHQsXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25maXJtYXRpb25EaWFsb2cub24oJ2NhbmNlbGVkJywgKCkgPT4ge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuICAgIGNvbmZpcm1hdGlvbkRpYWxvZy5vbignY29uZmlybWVkJywgKCkgPT4ge1xyXG4gICAgICB2YXIgeW1hcCA9IHRoaXMuZG9jLmdldE1hcCgncGFnZVN0YXRlJyk7XHJcbiAgICAgIHltYXAuc2V0KCdjdXJyZW50UGFnZScsc2xpZGVOdW1iZXIpO1xyXG4gICAgICB0aGlzLnByb2Nlc3NKdW1wVG9TbGlkZShzbGlkZU51bWJlciwgbm9TY3JvbGwsIGhhbmRsZUZvY3VzKTtcclxuICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIGVsc2Uge1xyXG4gICAgdmFyIHltYXAgPSB0aGlzLmRvYy5nZXRNYXAoJ3BhZ2VTdGF0ZScpO1xyXG4gICAgeW1hcC5zZXQoJ2N1cnJlbnRQYWdlJyxzbGlkZU51bWJlcik7XHJcbiAgICB0aGlzLnByb2Nlc3NKdW1wVG9TbGlkZShzbGlkZU51bWJlciwgbm9TY3JvbGwsIGhhbmRsZUZvY3VzKTtcclxuICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICBjYWxsYmFjaygpO1xyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGFiIGluZGV4IGZvciB0ZXh0IGNvbnRhaW5lcnMgdGhhdCBvdmVyZmxvdyB3aXRoIGEgc2Nyb2xsYmFyXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLnNldE92ZXJmbG93VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgLy8gT24gcmVzdW1lLCB0aGlzIGlzIG5vdCBzZXQgeWV0LCBidXQgaXQgd2lsbCBiZSBpb3Zva2VkIGxhdGVyXHJcbiAgaWYgKHRoaXMuJGN1cnJlbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgdGhpcy4kY3VycmVudC5maW5kKCcuaDVwLWVsZW1lbnQtaW5uZXInKS5lYWNoKCBmdW5jdGlvbiAoKSB7XHJcbiAgICBjb25zdCAkaW5uZXIgPSAkKHRoaXMpO1xyXG5cclxuICAgIC8vIEN1cnJlbnRseSwgdGhpcyBydWxlIGlzIGZvciB0YWJsZXMgb25seVxyXG4gICAgbGV0IGlubmVySGVpZ2h0O1xyXG4gICAgaWYgKHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdoNXAtdGFibGUnKSkge1xyXG4gICAgICBpbm5lckhlaWdodCA9ICRpbm5lci5maW5kKCcuaDVwLXRhYmxlJykub3V0ZXJIZWlnaHQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGFiaW5kZXggaWYgdGhlcmUncyBhbiBvdmVyZmxvdyAoc2Nyb2xsYmFyIGRlcGVuZGluZyBvbiBDU1MpXHJcbiAgICBjb25zdCBvdXRlckhlaWdodCA9ICRpbm5lci5jbG9zZXN0KCcuaDVwLWVsZW1lbnQtb3V0ZXInKS5pbm5lckhlaWdodCgpO1xyXG4gICAgaWYgKGlubmVySGVpZ2h0ICE9PSB1bmRlZmluZWQgJiYgb3V0ZXJIZWlnaHQgIT09IG51bGwgJiYgaW5uZXJIZWlnaHQgPiBvdXRlckhlaWdodCkge1xyXG4gICAgICAkaW5uZXIuYXR0cigndGFiaW5kZXgnLCAwKTtcclxuICAgIH1cclxuICB9KTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgc2xpZGUgbnVtYmVyIHNvIGl0IGNhbiBiZSBhbm5vdW5jZWQgdG8gYXNzaXN0aXZlIHRlY2hub2xvZ2llc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gc2xpZGVOdW1iZXIgSW5kZXggb2Ygc2xpZGUgdGhhdCBzaG91bGQgaGF2ZSBpdHMnIHRpdGxlIGFubm91bmNlZFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoYW5kbGVGb2N1cz1mYWxzZV0gTW92ZXMgZm9jdXMgdG8gdGhlIHRvcCBvZiB0aGUgc2xpZGVcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2V0U2xpZGVOdW1iZXJBbm5vdW5jZXIgPSBmdW5jdGlvbiAoc2xpZGVOdW1iZXIsIGhhbmRsZUZvY3VzID0gZmFsc2UpIHtcclxuICBsZXQgc2xpZGVUaXRsZSA9ICcnO1xyXG5cclxuICBpZiAoIXRoaXMubmF2aWdhdGlvbkxpbmUpIHtcclxuICAgIHJldHVybiBzbGlkZVRpdGxlO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHNsaWRlIG51bWJlclxyXG4gIGNvbnN0IHNsaWRlID0gdGhpcy5zbGlkZXNbc2xpZGVOdW1iZXJdO1xyXG4gIGNvbnN0IGhhc0tleXdvcmRzID0gc2xpZGUua2V5d29yZHMgJiYgc2xpZGUua2V5d29yZHMubGVuZ3RoID4gMDtcclxuICBpZiAoaGFzS2V5d29yZHMgJiYgIXRoaXMubmF2aWdhdGlvbkxpbmUuaXNTdW1tYXJ5U2xpZGUoc2xpZGVOdW1iZXIpKSB7XHJcbiAgICBzbGlkZVRpdGxlICs9IHRoaXMubDEwbi5zbGlkZSArICcgJyArIChzbGlkZU51bWJlciArIDEpICsgJzogJztcclxuICB9XHJcblxyXG4gIHNsaWRlVGl0bGUgKz0gdGhpcy5uYXZpZ2F0aW9uTGluZS5jcmVhdGVTbGlkZVRpdGxlKHNsaWRlTnVtYmVyKTtcclxuICB0aGlzLiRzbGlkZUFubm91bmNlci5odG1sKHNsaWRlVGl0bGUpO1xyXG4gIGlmIChoYW5kbGVGb2N1cykge1xyXG4gICAgdGhpcy4kc2xpZGVUb3AuZm9jdXMoKTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmVzZXQgdGhlIGNvbnRlbnQgZm9yIGFsbCBzbGlkZXMuXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuSXJlc2V0VGFzayA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnN1bW1hcnlTbGlkZU9iamVjdC50b2dnbGVTb2x1dGlvbk1vZGUoZmFsc2UpO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zbGlkZXNXaXRoU29sdXRpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAodGhpcy5zbGlkZXNXaXRoU29sdXRpb25zW2ldICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNsaWRlc1dpdGhTb2x1dGlvbnNbaV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICB2YXIgZWxlbWVudEluc3RhbmNlID0gdGhpcy5zbGlkZXNXaXRoU29sdXRpb25zW2ldW2pdO1xyXG4gICAgICAgIGlmIChlbGVtZW50SW5zdGFuY2UucmVzZXRUYXNrKSB7XHJcbiAgICAgICAgICBlbGVtZW50SW5zdGFuY2UucmVzZXRUYXNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHRoaXMubmF2aWdhdGlvbkxpbmUudXBkYXRlUHJvZ3Jlc3NCYXIoMCk7XHJcbiAgdGhpcy5qdW1wVG9TbGlkZSgwKTtcclxuICB0aGlzLiRjb250YWluZXIuZmluZCgnLmg1cC1wb3B1cC1vdmVybGF5JykucmVtb3ZlKCk7XHJcbn07XHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUucmVzZXRUYXNrID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB5bWFwID0gdGhpcy5kb2MuZ2V0TWFwKCdwYWdlU3RhdGUnKTtcclxuICB5bWFwLnNldCgncmVzZXQnLFwieWVzXCIpO1xyXG4gIHRoaXMuSXJlc2V0VGFzaygpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNob3cgc29sdXRpb25zIGZvciBhbGwgc2xpZGVzIHRoYXQgaGF2ZSBzb2x1dGlvbnNcclxuICpcclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuc2hvd1NvbHV0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIganVtcGVkVG9GaXJzdCA9IGZhbHNlO1xyXG4gIHZhciBzbGlkZVNjb3JlcyA9IFtdO1xyXG4gIHZhciBoYXNTY29yZXMgPSBmYWxzZTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9uc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c0F0dGFjaGVkW2ldKSB7XHJcbiAgICAgICAgLy8gQXR0YWNoIGVsZW1lbnRzIGJlZm9yZSBzaG93aW5nIHNvbHV0aW9uc1xyXG4gICAgICAgIHRoaXMuYXR0YWNoRWxlbWVudHModGhpcy4kc2xpZGVzV3JhcHBlci5jaGlsZHJlbignOmVxKCcgKyBpICsgJyknKSwgaSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFqdW1wZWRUb0ZpcnN0KSB7XHJcbiAgICAgICAgdGhpcy5qdW1wVG9TbGlkZShpLCBmYWxzZSk7XHJcbiAgICAgICAganVtcGVkVG9GaXJzdCA9IHRydWU7IC8vIFRPRE86IEV4cGxhaW4gd2hhdCB0aGlzIHJlYWxseSBkb2VzLlxyXG4gICAgICB9XHJcbiAgICAgIHZhciBzbGlkZVNjb3JlID0gMDtcclxuICAgICAgdmFyIHNsaWRlTWF4U2NvcmUgPSAwO1xyXG4gICAgICB2YXIgaW5kZXhlcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9uc1tpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5zdGFuY2UgPSB0aGlzLnNsaWRlc1dpdGhTb2x1dGlvbnNbaV1bal07XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0YW5jZS5hZGRTb2x1dGlvbkJ1dHRvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBlbGVtZW50SW5zdGFuY2UuYWRkU29sdXRpb25CdXR0b24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0YW5jZS5zaG93U29sdXRpb25zKSB7XHJcbiAgICAgICAgICBlbGVtZW50SW5zdGFuY2Uuc2hvd1NvbHV0aW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZWxlbWVudEluc3RhbmNlLnNob3dDUENvbW1lbnRzKSB7XHJcbiAgICAgICAgICBlbGVtZW50SW5zdGFuY2Uuc2hvd0NQQ29tbWVudHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0YW5jZS5nZXRNYXhTY29yZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBzbGlkZU1heFNjb3JlICs9IGVsZW1lbnRJbnN0YW5jZS5nZXRNYXhTY29yZSgpO1xyXG4gICAgICAgICAgc2xpZGVTY29yZSArPSBlbGVtZW50SW5zdGFuY2UuZ2V0U2NvcmUoKTtcclxuICAgICAgICAgIGhhc1Njb3JlcyA9IHRydWU7XHJcbiAgICAgICAgICBpbmRleGVzLnB1c2goZWxlbWVudEluc3RhbmNlLmNvdXJzZVByZXNlbnRhdGlvbkluZGV4T25TbGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNsaWRlU2NvcmVzLnB1c2goe1xyXG4gICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXHJcbiAgICAgICAgc2xpZGU6IChpICsgMSksXHJcbiAgICAgICAgc2NvcmU6IHNsaWRlU2NvcmUsXHJcbiAgICAgICAgbWF4U2NvcmU6IHNsaWRlTWF4U2NvcmVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBTaG93IGNvbW1lbnRzIG9mIG5vbiBncmFkZWQgY29udGVudHNcclxuICAgIGlmICh0aGlzLnNob3dDb21tZW50c0FmdGVyU29sdXRpb25baV0pIHtcclxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLnNob3dDb21tZW50c0FmdGVyU29sdXRpb25baV0ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuc2hvd0NvbW1lbnRzQWZ0ZXJTb2x1dGlvbltpXVtqXS5zaG93Q1BDb21tZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgdGhpcy5zaG93Q29tbWVudHNBZnRlclNvbHV0aW9uW2ldW2pdLnNob3dDUENvbW1lbnRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNTY29yZXMpIHtcclxuICAgIHJldHVybiBzbGlkZVNjb3JlcztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyBzbGlkZXMgc2NvcmVzIGZvciB3aG9sZSBjcFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IHNsaWRlU2NvcmVzIEFycmF5IGNvbnRhaW5pbmcgc2NvcmVzIGZvciBhbGwgc2xpZGVzLlxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5nZXRTbGlkZVNjb3JlcyA9IGZ1bmN0aW9uIChub0p1bXApIHtcclxuICB2YXIganVtcGVkVG9GaXJzdCA9IChub0p1bXAgPT09IHRydWUpO1xyXG4gIHZhciBzbGlkZVNjb3JlcyA9IFtdO1xyXG4gIHZhciBoYXNTY29yZXMgPSBmYWxzZTtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9uc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGlmICghdGhpcy5lbGVtZW50c0F0dGFjaGVkW2ldKSB7XHJcbiAgICAgICAgLy8gQXR0YWNoIGVsZW1lbnRzIGJlZm9yZSBzaG93aW5nIHNvbHV0aW9uc1xyXG4gICAgICAgIHRoaXMuYXR0YWNoRWxlbWVudHModGhpcy4kc2xpZGVzV3JhcHBlci5jaGlsZHJlbignOmVxKCcgKyBpICsgJyknKSwgaSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFqdW1wZWRUb0ZpcnN0KSB7XHJcbiAgICAgICAgdGhpcy5qdW1wVG9TbGlkZShpLCBmYWxzZSk7XHJcbiAgICAgICAganVtcGVkVG9GaXJzdCA9IHRydWU7IC8vIFRPRE86IEV4cGxhaW4gd2hhdCB0aGlzIHJlYWxseSBkb2VzLlxyXG4gICAgICB9XHJcbiAgICAgIHZhciBzbGlkZVNjb3JlID0gMDtcclxuICAgICAgdmFyIHNsaWRlTWF4U2NvcmUgPSAwO1xyXG4gICAgICB2YXIgaW5kZXhlcyA9IFtdO1xyXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuc2xpZGVzV2l0aFNvbHV0aW9uc1tpXS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIHZhciBlbGVtZW50SW5zdGFuY2UgPSB0aGlzLnNsaWRlc1dpdGhTb2x1dGlvbnNbaV1bal07XHJcbiAgICAgICAgaWYgKGVsZW1lbnRJbnN0YW5jZS5nZXRNYXhTY29yZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBzbGlkZU1heFNjb3JlICs9IGVsZW1lbnRJbnN0YW5jZS5nZXRNYXhTY29yZSgpO1xyXG4gICAgICAgICAgc2xpZGVTY29yZSArPSBlbGVtZW50SW5zdGFuY2UuZ2V0U2NvcmUoKTtcclxuICAgICAgICAgIGhhc1Njb3JlcyA9IHRydWU7XHJcbiAgICAgICAgICBpbmRleGVzLnB1c2goZWxlbWVudEluc3RhbmNlLmNvdXJzZVByZXNlbnRhdGlvbkluZGV4T25TbGlkZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHNsaWRlU2NvcmVzLnB1c2goe1xyXG4gICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXHJcbiAgICAgICAgc2xpZGU6IChpICsgMSksXHJcbiAgICAgICAgc2NvcmU6IHNsaWRlU2NvcmUsXHJcbiAgICAgICAgbWF4U2NvcmU6IHNsaWRlTWF4U2NvcmVcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChoYXNTY29yZXMpIHtcclxuICAgIHJldHVybiBzbGlkZVNjb3JlcztcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2F0aGVyIGNvcHlyaWdodCBpbmZvcm1hdGlvbiBmb3IgdGhlIGN1cnJlbnQgY29udGVudC5cclxuICpcclxuICogQHJldHVybnMge0g1UC5Db250ZW50Q29weXJpZ2h0c31cclxuICovXHJcbkNvdXJzZVByZXNlbnRhdGlvbi5wcm90b3R5cGUuZ2V0Q29weXJpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaW5mbyA9IG5ldyBINVAuQ29udGVudENvcHlyaWdodHMoKTtcclxuICB2YXIgZWxlbWVudENvcHlyaWdodHM7XHJcblxyXG4gIC8vIENoZWNrIGZvciBhIGNvbW1vbiBiYWNrZ3JvdW5kIGltYWdlIHNoYXJlZCBieSBhbGwgc2xpZGVzXHJcbiAgaWYgKHRoaXMucHJlc2VudGF0aW9uICYmIHRoaXMucHJlc2VudGF0aW9uLmdsb2JhbEJhY2tncm91bmRTZWxlY3RvciAmJlxyXG4gICAgICB0aGlzLnByZXNlbnRhdGlvbi5nbG9iYWxCYWNrZ3JvdW5kU2VsZWN0b3IuaW1hZ2VHbG9iYWxCYWNrZ3JvdW5kKSB7XHJcblxyXG4gICAgLy8gQWRkIGltYWdlIGNvcHlyaWdodHMgdG8gdGhlIHByZXNlbnRhdGlvbiBzY29wZVxyXG4gICAgdmFyIGdsb2JhbEJhY2tncm91bmRJbWFnZVBhcmFtcyA9IHRoaXMucHJlc2VudGF0aW9uLmdsb2JhbEJhY2tncm91bmRTZWxlY3Rvci5pbWFnZUdsb2JhbEJhY2tncm91bmQ7XHJcbiAgICB2YXIgZ2xvYmFsQmFja2dyb3VuZEltYWdlQ29weXJpZ2h0ID0gbmV3IEg1UC5NZWRpYUNvcHlyaWdodChnbG9iYWxCYWNrZ3JvdW5kSW1hZ2VQYXJhbXMuY29weXJpZ2h0KTtcclxuICAgIGdsb2JhbEJhY2tncm91bmRJbWFnZUNvcHlyaWdodC5zZXRUaHVtYm5haWwobmV3IEg1UC5UaHVtYm5haWwoSDVQLmdldFBhdGgoZ2xvYmFsQmFja2dyb3VuZEltYWdlUGFyYW1zLnBhdGgsIHRoaXMuY29udGVudElkKSwgZ2xvYmFsQmFja2dyb3VuZEltYWdlUGFyYW1zLndpZHRoLCBnbG9iYWxCYWNrZ3JvdW5kSW1hZ2VQYXJhbXMuaGVpZ2h0KSk7XHJcbiAgICBpbmZvLmFkZE1lZGlhKGdsb2JhbEJhY2tncm91bmRJbWFnZUNvcHlyaWdodCk7XHJcbiAgfVxyXG5cclxuICBmb3IgKHZhciBzbGlkZSA9IDA7IHNsaWRlIDwgdGhpcy5zbGlkZXMubGVuZ3RoOyBzbGlkZSsrKSB7XHJcbiAgICB2YXIgc2xpZGVJbmZvID0gbmV3IEg1UC5Db250ZW50Q29weXJpZ2h0cygpO1xyXG4gICAgc2xpZGVJbmZvLnNldExhYmVsKHRoaXMubDEwbi5zbGlkZSArICcgJyArIChzbGlkZSArIDEpKTtcclxuXHJcbiAgICAvLyBDaGVjayBmb3IgYSBzbGlkZSBzcGVjaWZpYyBiYWNrZ3JvdW5kIGltYWdlXHJcbiAgICBpZiAodGhpcy5zbGlkZXNbc2xpZGVdICYmIHRoaXMuc2xpZGVzW3NsaWRlXS5zbGlkZUJhY2tncm91bmRTZWxlY3RvciAmJlxyXG4gICAgICAgIHRoaXMuc2xpZGVzW3NsaWRlXS5zbGlkZUJhY2tncm91bmRTZWxlY3Rvci5pbWFnZVNsaWRlQmFja2dyb3VuZCkge1xyXG5cclxuICAgICAgLy8gQWRkIGltYWdlIGNvcHlyaWdodHMgdG8gdGhlIHNsaWRlIHNjb3BlXHJcbiAgICAgIHZhciBzbGlkZUJhY2tncm91bmRJbWFnZVBhcmFtcyA9IHRoaXMuc2xpZGVzW3NsaWRlXS5zbGlkZUJhY2tncm91bmRTZWxlY3Rvci5pbWFnZVNsaWRlQmFja2dyb3VuZDtcclxuICAgICAgdmFyIHNsaWRlQmFja2dyb3VuZEltYWdlQ29weXJpZ2h0ID0gbmV3IEg1UC5NZWRpYUNvcHlyaWdodChzbGlkZUJhY2tncm91bmRJbWFnZVBhcmFtcy5jb3B5cmlnaHQpO1xyXG4gICAgICBzbGlkZUJhY2tncm91bmRJbWFnZUNvcHlyaWdodC5zZXRUaHVtYm5haWwobmV3IEg1UC5UaHVtYm5haWwoSDVQLmdldFBhdGgoc2xpZGVCYWNrZ3JvdW5kSW1hZ2VQYXJhbXMucGF0aCwgdGhpcy5jb250ZW50SWQpLCBzbGlkZUJhY2tncm91bmRJbWFnZVBhcmFtcy53aWR0aCwgc2xpZGVCYWNrZ3JvdW5kSW1hZ2VQYXJhbXMuaGVpZ2h0KSk7XHJcbiAgICAgIHNsaWRlSW5mby5hZGRNZWRpYShzbGlkZUJhY2tncm91bmRJbWFnZUNvcHlyaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgdGhlIHNsaWRlIGhhcyBlbGVtZW50cywgYWRkIHRoZSBvbmVzIHdpdGggY29weXJpZ2h0IGluZm8gdG8gdGhpcyBzbGlkZXMgY29weXJpZ2h0XHJcbiAgICBpZiAodGhpcy5lbGVtZW50SW5zdGFuY2VzW3NsaWRlXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGZvciAodmFyIGVsZW1lbnQgPSAwOyBlbGVtZW50IDwgdGhpcy5lbGVtZW50SW5zdGFuY2VzW3NsaWRlXS5sZW5ndGg7IGVsZW1lbnQrKykge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZWxlbWVudEluc3RhbmNlc1tzbGlkZV1bZWxlbWVudF07XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5zbGlkZXNbc2xpZGVdLmVsZW1lbnRzW2VsZW1lbnRdLmFjdGlvbikge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5zbGlkZXNbc2xpZGVdLmVsZW1lbnRzW2VsZW1lbnRdLmFjdGlvbi5wYXJhbXM7XHJcbiAgICAgICAgdmFyIG1ldGFkYXRhID0gdGhpcy5zbGlkZXNbc2xpZGVdLmVsZW1lbnRzW2VsZW1lbnRdLmFjdGlvbi5tZXRhZGF0YTtcclxuXHJcbiAgICAgICAgZWxlbWVudENvcHlyaWdodHMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlLmdldENvcHlyaWdodHMgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgLy8gVXNlIHRoZSBpbnN0YW5jZSdzIG93biBjb3B5cmlnaHQgZ2VuZXJhdG9yXHJcbiAgICAgICAgICBlbGVtZW50Q29weXJpZ2h0cyA9IGluc3RhbmNlLmdldENvcHlyaWdodHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnRDb3B5cmlnaHRzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIC8vIENyZWF0ZSBhIGdlbmVyaWMgZmxhdCBjb3B5cmlnaHQgbGlzdFxyXG4gICAgICAgICAgZWxlbWVudENvcHlyaWdodHMgPSBuZXcgSDVQLkNvbnRlbnRDb3B5cmlnaHRzKCk7XHJcbiAgICAgICAgICAvLyBJbiBtZXRhZGF0YSBhbG9uZSB0aGVyZSdzIG5vIHdheSBvZiBrbm93aW5nIHdoYXQgdGhlIG1hY2hpbmVOYW1lIGlzLlxyXG4gICAgICAgICAgSDVQLmZpbmRDb3B5cmlnaHRzKGVsZW1lbnRDb3B5cmlnaHRzLCBwYXJhbXMsIHRoaXMuY29udGVudElkLCB7bWV0YWRhdGE6IG1ldGFkYXRhLCBtYWNoaW5lTmFtZTogaW5zdGFuY2UubGlicmFyeUluZm8ubWFjaGluZU5hbWV9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxhYmVsID0gKGVsZW1lbnQgKyAxKTtcclxuICAgICAgICBpZiAocGFyYW1zLmNvbnRlbnROYW1lICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGxhYmVsICs9ICc6ICcgKyBwYXJhbXMuY29udGVudE5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGluc3RhbmNlLmdldFRpdGxlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGxhYmVsICs9ICc6ICcgKyBpbnN0YW5jZS5nZXRUaXRsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXJhbXMubDEwbiAmJiBwYXJhbXMubDEwbi5uYW1lKSB7XHJcbiAgICAgICAgICBsYWJlbCArPSAnOiAnICsgcGFyYW1zLmwxMG4ubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudENvcHlyaWdodHMuc2V0TGFiZWwobGFiZWwpO1xyXG5cclxuICAgICAgICBzbGlkZUluZm8uYWRkQ29udGVudChlbGVtZW50Q29weXJpZ2h0cyk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGluZm8uYWRkQ29udGVudChzbGlkZUluZm8pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGluZm87XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHhBUEkgZGF0YS5cclxuICogQ29udHJhY3QgdXNlZCBieSByZXBvcnQgcmVuZGVyaW5nIGVuZ2luZS5cclxuICpcclxuICogQHNlZSBjb250cmFjdCBhdCB7QGxpbmsgaHR0cHM6Ly9oNXAub3JnL2RvY3VtZW50YXRpb24vZGV2ZWxvcGVycy9jb250cmFjdHMjZ3VpZGVzLWhlYWRlci02fVxyXG4gKi9cclxuQ291cnNlUHJlc2VudGF0aW9uLnByb3RvdHlwZS5nZXRYQVBJRGF0YSA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeEFQSUV2ZW50ID0gdGhpcy5jcmVhdGVYQVBJRXZlbnRUZW1wbGF0ZSgnYW5zd2VyZWQnKTtcclxuXHJcbiAgLy8gRXh0ZW5kIGRlZmluaXRpb25cclxuICB2YXIgZGVmaW5pdGlvbiA9IHhBUElFdmVudC5nZXRWZXJpZmllZFN0YXRlbWVudFZhbHVlKFsnb2JqZWN0JywgJ2RlZmluaXRpb24nXSk7XHJcbiAgSDVQLmpRdWVyeS5leHRlbmQoZGVmaW5pdGlvbiwge1xyXG4gICAgaW50ZXJhY3Rpb25UeXBlOiAnY29tcG91bmQnLFxyXG4gICAgdHlwZTogJ2h0dHA6Ly9hZGxuZXQuZ292L2V4cGFwaS9hY3Rpdml0aWVzL2NtaS5pbnRlcmFjdGlvbidcclxuICB9KTtcclxuXHJcbiAgdmFyIHNjb3JlID0gdGhpcy5nZXRTY29yZSgpO1xyXG4gIHZhciBtYXhTY29yZSA9IHRoaXMuZ2V0TWF4U2NvcmUoKTtcclxuICB4QVBJRXZlbnQuc2V0U2NvcmVkUmVzdWx0KHNjb3JlLCBtYXhTY29yZSwgdGhpcywgdHJ1ZSwgc2NvcmUgPT09IG1heFNjb3JlKTtcclxuXHJcbiAgdmFyIGNoaWxkcmVuWEFQSURhdGEgPSBmbGF0dGVuQXJyYXkodGhpcy5zbGlkZXNXaXRoU29sdXRpb25zKS5tYXAoKGNoaWxkKSA9PiB7XHJcbiAgICBpZiAoY2hpbGQgJiYgY2hpbGQuZ2V0WEFQSURhdGEpIHtcclxuICAgICAgcmV0dXJuIGNoaWxkLmdldFhBUElEYXRhKCk7XHJcbiAgICB9XHJcbiAgfSkuZmlsdGVyKGRhdGEgPT4gISFkYXRhKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRlbWVudDogeEFQSUV2ZW50LmRhdGEuc3RhdGVtZW50LFxyXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuWEFQSURhdGFcclxuICB9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBjb250ZXh0IGRhdGEuXHJcbiAqIENvbnRyYWN0IHVzZWQgZm9yIGNvbmZ1c2lvbiByZXBvcnQuXHJcbiAqL1xyXG5Db3Vyc2VQcmVzZW50YXRpb24ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAvLyBHZXQgY3VycmVudCBzbGlkZSBudW1iZXIgaGVyZSBpdCBzdGFydHMgd2l0aCB6ZXJvXHJcbiAgY29uc3Qgc2xpZGUgPSAoc2VsZi5jdXJyZW50U2xpZGVJbmRleCArIDEpO1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnc2xpZGUnLFxyXG4gICAgdmFsdWU6IHNsaWRlXHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENvdXJzZVByZXNlbnRhdGlvbjtcclxuIl0sIm5hbWVzIjpbIlBhcmVudCIsIlkiLCJTb2NrZXRJT1Byb3ZpZGVyIiwiU3VtbWFyeVNsaWRlIiwiTmF2aWdhdGlvbkxpbmUiLCJTbGlkZUJhY2tncm91bmQiLCJLZXl3b3Jkc01lbnUiLCJqUXVlcnkiLCIkIiwiZmxhdHRlbkFycmF5IiwiYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyIsImlzRnVuY3Rpb24iLCJrZWJhYkNhc2UiLCJzdHJpcEhUTUwiLCJrZXlDb2RlIiwiU2xpZGUiLCJDb25maXJtYXRpb25EaWFsb2ciLCJLRVlXT1JEX1RJVExFX1NLSVAiLCJDb3Vyc2VQcmVzZW50YXRpb24iLCJwYXJhbXMiLCJpZCIsImV4dHJhcyIsImJldHdlZW4iLCJtaW4iLCJtYXgiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0aGF0IiwiZGF0YSIsImRvYyIsIkRvYyIsInByZXNlbnRhdGlvbiIsInNsaWRlcyIsImNvbnRlbnRJZCIsImVsZW1lbnRJbnN0YW5jZXMiLCJlbGVtZW50c0F0dGFjaGVkIiwic2xpZGVzV2l0aFNvbHV0aW9ucyIsInNob3dDb21tZW50c0FmdGVyU29sdXRpb24iLCJoYXNBbnN3ZXJFbGVtZW50cyIsImlnbm9yZVJlc2l6ZSIsImlzVGFzayIsInN0YW5kYWxvbmUiLCJpc1JlcG9ydGluZ0VuYWJsZWQiLCJwb3B1cHMiLCJjcEVkaXRvciIsImVkaXRvciIsInByb3ZpZGVyIiwidG9TdHJpbmciLCJhdXRvQ29ubmVjdCIsInltYXAiLCJnZXRNYXAiLCJvYnNlcnZlIiwieW1hcEV2ZW50IiwidGFyZ2V0Iiwia2V5c0NoYW5nZWQiLCJjaGFuZ2VzIiwia2V5cyIsImZvckVhY2giLCJjaGFuZ2UiLCJrZXkiLCJhY3Rpb24iLCJwcm9jZXNzSnVtcFRvU2xpZGUiLCJnZXQiLCJJcmVzZXRUYXNrIiwicHJldmlvdXNTdGF0ZSIsImlzU2NvcmluZ0VuYWJsZWQiLCJjdXJyZW50U2xpZGVJbmRleCIsInByb2dyZXNzIiwia2V5d29yZExpc3RFbmFibGVkIiwidW5kZWZpbmVkIiwibDEwbiIsImV4dGVuZCIsInNsaWRlIiwic2NvcmUiLCJ5b3VyU2NvcmUiLCJtYXhTY29yZSIsInRvdGFsIiwidG90YWxTY29yZSIsInNob3dTb2x1dGlvbnMiLCJzdW1tYXJ5IiwicmV0cnkiLCJleHBvcnRBbnN3ZXJzIiwiY2xvc2UiLCJoaWRlS2V5d29yZHMiLCJzaG93S2V5d29yZHMiLCJmdWxsc2NyZWVuIiwiZXhpdEZ1bGxzY3JlZW4iLCJwcmV2U2xpZGUiLCJuZXh0U2xpZGUiLCJjdXJyZW50U2xpZGUiLCJsYXN0U2xpZGUiLCJzb2x1dGlvbk1vZGVUaXRsZSIsInNvbHV0aW9uTW9kZVRleHQiLCJzdW1tYXJ5TXVsdGlwbGVUYXNrVGV4dCIsInNjb3JlTWVzc2FnZSIsInNoYXJlRmFjZWJvb2siLCJzaGFyZVR3aXR0ZXIiLCJzaGFyZUdvb2dsZSIsImdvVG9TbGlkZSIsInNvbHV0aW9uc0J1dHRvblRpdGxlIiwicHJpbnRUaXRsZSIsInByaW50SW5ncmVzcyIsInByaW50QWxsU2xpZGVzIiwicHJpbnRDdXJyZW50U2xpZGUiLCJub1RpdGxlIiwiYWNjZXNzaWJpbGl0eVNsaWRlTmF2aWdhdGlvbkV4cGxhbmF0aW9uIiwiYWNjZXNzaWJpbGl0eVByb2dyZXNzQmFyTGFiZWwiLCJjb250YWluc05vdENvbXBsZXRlZCIsImNvbnRhaW5zQ29tcGxldGVkIiwic2xpZGVDb3VudCIsImFjY2Vzc2liaWxpdHlDYW52YXNMYWJlbCIsImNvbnRhaW5zT25seUNvcnJlY3QiLCJjb250YWluc0luY29ycmVjdEFuc3dlcnMiLCJzaGFyZVJlc3VsdCIsImFjY2Vzc2liaWxpdHlUb3RhbFNjb3JlIiwiYWNjZXNzaWJpbGl0eUVudGVyZWRGdWxsc2NyZWVuIiwiYWNjZXNzaWJpbGl0eUV4aXRlZEZ1bGxzY3JlZW4iLCJjb25maXJtRGlhbG9nSGVhZGVyIiwiY29uZmlybURpYWxvZ1RleHQiLCJjb25maXJtRGlhbG9nQ29uZmlybVRleHQiLCJzbGlkZXNob3dOYXZpZ2F0aW9uTGFiZWwiLCJvdmVycmlkZSIsImFjdGl2ZVN1cmZhY2UiLCJoaWRlU3VtbWFyeVNsaWRlIiwiZW5hYmxlUHJpbnRCdXR0b24iLCJzaG93U3VtbWFyeVNsaWRlU29sdXRpb25CdXR0b24iLCJzdW1tYXJ5U2xpZGVTb2x1dGlvbkJ1dHRvbiIsInNob3dTdW1tYXJ5U2xpZGVSZXRyeUJ1dHRvbiIsInN1bW1hcnlTbGlkZVJldHJ5QnV0dG9uIiwic29jaWFsIiwiZW5hYmxlVHdpdHRlclNoYXJlIiwic2hvd1R3aXR0ZXJTaGFyZSIsImVuYWJsZUZhY2Vib29rU2hhcmUiLCJzaG93RmFjZWJvb2tTaGFyZSIsImVuYWJsZUdvb2dsZVNoYXJlIiwic2hvd0dvb2dsZVNoYXJlIiwidHdpdHRlclNoYXJlU3RhdGVtZW50IiwidHdpdHRlclNoYXJlIiwic3RhdGVtZW50IiwidHdpdHRlclNoYXJlSGFzaHRhZ3MiLCJoYXNodGFncyIsInR3aXR0ZXJTaGFyZVVybCIsInVybCIsImZhY2Vib29rU2hhcmVVcmwiLCJmYWNlYm9va1NoYXJlIiwiZmFjZWJvb2tTaGFyZVF1b3RlIiwicXVvdGUiLCJnb29nbGVTaGFyZVVybCIsImtleXdvcmRNZW51IiwiY3VycmVudEluZGV4Iiwic2V0RWxlbWVudHNPdmVycmlkZSIsImNhbGwiLCJvbiIsInJlc2l6ZSIsImV2ZW50IiwiZmluaXNoZWQiLCJhbGxTbGlkZXMiLCJhdHRhY2hBbGxFbGVtZW50cyIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiZ2V0Q3VycmVudFN0YXRlIiwic3RhdGUiLCJnZXRDdXJyZW50U2xpZGVJbmRleCIsImFuc3dlcnMiLCJhbnN3ZXJlZCIsIm1hcCIsImludGVyYWN0aW9uIiwiaW5kZXgiLCJzbGlkZUhhc0Fuc3dlcmVkVGFzayIsImxlbmd0aCIsImVsZW1lbnQiLCJpbnN0YW5jZSIsIkZ1bmN0aW9uIiwidGFza3MiLCJmaWx0ZXIiLCJ0YXNrIiwiZ2V0QW5zd2VyR2l2ZW4iLCJzb21lIiwiYXR0YWNoIiwiJGNvbnRhaW5lciIsImlzUm9vdCIsInNldEFjdGl2aXR5U3RhcnRlZCIsImh0bWwiLCJhdHRyIiwiYWRkQ2xhc3MiLCIkc2xpZGVBbm5vdW5jZXIiLCJmaW5kIiwiJGZ1bGxzY3JlZW5Bbm5vdW5jZXIiLCIkc2xpZGVUb3AiLCJuZXh0IiwiJHdyYXBwZXIiLCJjaGlsZHJlbiIsImZvY3VzIiwiaW5pdEtleUV2ZW50cyIsImJsdXIiLCJrZXlkb3duIiwiSDVQIiwidW5iaW5kIiwiY2xpY2siLCIkdGFyZ2V0IiwiaXNGb2N1c2FibGVFbGVtZW50IiwiYmVsb25nc1RvVGFnTmFtZSIsImN1cnJlbnRUYXJnZXQiLCJoYXNUYWJJbmRleCIsInRhYkluZGV4IiwiJGRpYWxvZ1BhcmVudCIsImNsb3Nlc3QiLCJpc1dpdGhpbkRpYWxvZyIsIiR0YWJiYWJsZSIsImtleXdvcmRMaXN0QWx3YXlzU2hvdyIsImtleXdvcmRMaXN0QXV0b0hpZGUiLCJpcyIsIiRmb290ZXIiLCJyZW1vdmVDbGFzcyIsIiRmdWxsU2NyZWVuQnV0dG9uIiwid3JhcHBlcldpZHRoIiwicGFyc2VJbnQiLCJjc3MiLCJ3aWR0aCIsIndyYXBwZXJIZWlnaHQiLCJoZWlnaHQiLCJyYXRpbyIsImZvbnRTaXplIiwiJGJveFdyYXBwZXIiLCIkcHJlc2VudGF0aW9uV3JhcHBlciIsIiRzbGlkZXNXcmFwcGVyIiwiJGtleXdvcmRzV3JhcHBlciIsIiRwcm9ncmVzc2JhciIsImluaXRLZXl3b3JkcyIsImlzU29sdXRpb25Nb2RlIiwiY3JlYXRlU2xpZGVzIiwiJHN1bW1hcnlTbGlkZSIsInNob3dTdW1tYXJ5U2xpZGUiLCJzdW1tYXJ5U2xpZGVQYXJhbXMiLCJlbGVtZW50cyIsImtleXdvcmRzIiwicHVzaCIsImNyZWF0ZUhUTUwiLCJhcHBlbmRUbyIsImlzQ3VycmVudFNsaWRlIiwiJGN1cnJlbnQiLCJrZXl3b3JkTWVudUNvbmZpZyIsImdldEtleXdvcmRNZW51Q29uZmlnIiwiaXNFZGl0b3IiLCJpbml0Iiwia2V5d29yZENsaWNrIiwiJGN1cnJlbnRLZXl3b3JkIiwiJGtleXdvcmRzIiwiZ2V0RWxlbWVudCIsImtleXdvcmRMaXN0T3BhY2l0eSIsInNldEtleXdvcmRzT3BhY2l0eSIsInJlbW92ZSIsImluaXRUb3VjaEV2ZW50cyIsIm5hdmlnYXRpb25MaW5lIiwic2V0U2xpZGVOdW1iZXJBbm5vdW5jZXIiLCJzdW1tYXJ5U2xpZGVPYmplY3QiLCJhZGQiLCJmdWxsc2NyZWVuU3VwcG9ydGVkIiwicm9sZSIsInRhYmluZGV4IiwiVG9vbHRpcCIsInBvc2l0aW9uIiwidG9nZ2xlRnVsbFNjcmVlbiIsImhhcyIsImp1bXBUb1NsaWRlIiwibm9kZSIsInRhZ05hbWVzIiwic3RvcCIsImRvY3VtZW50IiwiYm9keSIsInRhZ05hbWUiLCJ0b0xvd2VyQ2FzZSIsImluZGV4T2YiLCJwYXJlbnROb2RlIiwidXBkYXRlS2V5d29yZE1lbnVGcm9tU2xpZGVzIiwicmVtb3ZlQWxsTWVudUl0ZW1FbGVtZW50cyIsImNvbmZpZyIsInRpdGxlIiwiY3JlYXRlU2xpZGVUaXRsZSIsInN1YnRpdGxlIiwiZmFsbGJhY2tUaXRsZUZvckVkaXRvciIsImhhc0tleXdvcmRzIiwibWFpbiIsInNlbGYiLCJpIiwic2V0Q3VycmVudCIsImFwcGVuZEVsZW1lbnRzIiwiaGFzU2NvcmVEYXRhIiwib2JqIiwiZ2V0U2NvcmUiLCJnZXRNYXhTY29yZSIsInJlZHVjZSIsInN1bSIsInNldFByb2dyZXNzQmFyRmVlZGJhY2siLCJzbGlkZVNjb3JlcyIsInNpbmdsZVNsaWRlIiwiJGluZGljYXRvciIsInByb2dyZXNzYmFyUGFydHMiLCJoYXNDbGFzcyIsImlzQ29ycmVjdCIsInVwZGF0ZVNsaWRlVGl0bGUiLCJwYlBhcnQiLCJ0b2dnbGVLZXl3b3JkcyIsImtleXdvcmRzQXJlU2hvd2luZyIsIiRrZXl3b3Jkc0J1dHRvbiIsInZhbHVlIiwibWF0Y2giLCJyZWQiLCJncmVlbiIsImJsdWUiLCJmaXRDVCIsImVhY2giLCJwZXJjZW50IiwiJGN0IiwicGFyZW50SGVpZ2h0IiwicGFyZW50Iiwib3V0ZXJIZWlnaHQiLCJsaW5lSGVpZ2h0IiwiZnVsbHNjcmVlbk9uIiwic3R5bGUiLCJtYXhIZWlnaHQiLCJ3aWR0aFJhdGlvIiwic2V0Q29udGFpbmVyRW0iLCJzd2lwZVRocmVzaG9sZCIsImluc3RhbmNlcyIsInNsaWRlRWxlbWVudHMiLCJwcmV2ZW50UmVzaXplIiwiZGlzcGxheUFzQnV0dG9uIiwidHJpZ2dlciIsImlzRnVsbHNjcmVlbiIsImV4aXRGdWxsU2NyZWVuIiwiZnVsbFNjcmVlbkJyb3dzZXJQcmVmaXgiLCJ3aW5kb3ciLCJ0b3AiLCJtc0V4aXRGdWxsc2NyZWVuIiwiZnVsbFNjcmVlbiIsImhpZGUiLCJzaG91bGRIaWRlS2V5d29yZHNBZnRlclNlbGVjdCIsImVsZW1lbnRzT3ZlcnJpZGUiLCJiZWhhdmlvdXIiLCJzaG93U29sdXRpb25CdXR0b24iLCJlbmFibGVTb2x1dGlvbnNCdXR0b24iLCJyZXRyeUJ1dHRvbiIsImVuYWJsZVJldHJ5IiwiYXR0YWNoRWxlbWVudHMiLCIkc2xpZGUiLCJhdHRhY2hFbGVtZW50IiwiYnV0dG9uU2l6ZUNsYXNzIiwiYnV0dG9uU2l6ZSIsImNsYXNzZXMiLCIkZWxlbWVudENvbnRhaW5lciIsImxlZnQiLCJ4IiwieSIsImZpcnN0IiwiaXNUcmFuc3BhcmVudCIsImJhY2tncm91bmRPcGFjaXR5IiwidG9nZ2xlQ2xhc3MiLCIkYnV0dG9uIiwiY3JlYXRlSW50ZXJhY3Rpb25CdXR0b24iLCJoYXNMaWJyYXJ5IiwibGlicmFyeSIsImxpYlR5cGVQbXoiLCJnZXRMaWJyYXJ5VHlwZVBteiIsIiRvdXRlckVsZW1lbnRDb250YWluZXIiLCJiYWNrZ3JvdW5kIiwiJGlubmVyRWxlbWVudENvbnRhaW5lciIsInByb3BlcnR5Iiwic3Vic3RyIiwiaGFuZGxlSVYiLCJjb250cm9scyIsIiRmdWxsc2NyZWVuIiwiaGFzRnVsbFNjcmVlbiIsIiRwbGF5IiwiJGNvbnRyb2xzIiwiZW5hYmxlQXV0b0hpZGUiLCJzZXRPdmVyZmxvd1RhYkluZGV4IiwicHJvY2Vzc0VsZW1lbnQiLCJzb2x1dGlvbiIsImFkZEVsZW1lbnRTb2x1dGlvbkJ1dHRvbiIsImRpc2FibGVUYWJJbmRleGVzIiwiJHBvcHVwQ29udGFpbmVyIiwiJHRhYmJhYmxlcyIsImluc2lkZUNvbnRhaW5lciIsImNvbnRhaW5zIiwicmVzdG9yZVRhYkluZGV4ZXMiLCIkZWxlbWVudCIsInJlbW92ZURhdGEiLCJyZW1vdmVBdHRyIiwibGFiZWwiLCJtZXRhZGF0YSIsImNvbnRlbnROYW1lIiwic3BsaXQiLCJzZXRBcmlhRXhwYW5kZWRGYWxzZSIsIiRidG4iLCIkYnV0dG9uRWxlbWVudCIsInBhcmVudFBvc2l0aW9uIiwic2hvd0ludGVyYWN0aW9uUG9wdXAiLCJjbG9zZUNhbGxiYWNrIiwicG9wdXBQb3NpdGlvbiIsInNob3dQb3B1cCIsInBvcHVwQ29udGVudCIsIiRmb2N1c09uQ2xvc2UiLCJrZWVwSW5ET00iLCJkZXRhY2giLCJvZmYiLCJyZXNpemVQb3B1cEltYWdlIiwic2V0VGltZW91dCIsIk51bWJlciIsInJlcGxhY2UiLCIkaW1nIiwib25lIiwiZWxlbWVudEluc3RhbmNlIiwic2hvd0NQQ29tbWVudHMiLCIkY29tbWVudEJ1dHRvbiIsImFwcGVuZCIsInVwZGF0ZUFyaWFFeHBhbmRlZCIsInN0b3BQcm9wYWdhdGlvbiIsImFsd2F5c0Rpc3BsYXlDb21tZW50cyIsImRvTm90Q2xvc2UiLCJwb3B1cElkIiwicHJldmVudERlZmF1bHQiLCIkcG9wdXAiLCJzdWJDb250ZW50SWQiLCIkcG9wdXBXcmFwcGVyIiwiaWRMaXN0IiwiY2hpbGQiLCJzZXRBdHRyaWJ1dGUiLCJyZXNpemVQb3B1cCIsInZpc2liaWxpdHkiLCJwcmVwZW5kVG8iLCJwb3B1cEhlaWdodCIsInBvcHVwV2lkdGgiLCJvdmVybGF5SGVpZ2h0Iiwib3ZlcmxheVdpZHRoIiwid2lkdGhQZXJjZW50YWdlIiwiaGVpZ2h0UGVyY2VudGFnZSIsInNraXBUaHJlc2hvbGQiLCJoZWlnaHRUaHJlc2hvbGQiLCJzcXJ0Iiwid2lkdGhQYWRkaW5nUGVyY2VudGFnZSIsIm92ZXJmbG93UmlnaHRTaWRlVGhyZXNob2xkIiwibGVmdFBvcyIsImhlaWdodFBhZGRpbmciLCJ0b3BQb3NUaHJlc2hvbGQiLCJ0b3BQb3MiLCJzaG93Iiwid2hpY2giLCJFU0MiLCJjaGVja0ZvclNvbHV0aW9ucyIsIndhaXQiLCJwcmV2aW91c1NsaWRlIiwic3RhcnRYIiwic3RhcnRZIiwibGFzdFgiLCJwcmV2WCIsIm5leHRYIiwic2Nyb2xsIiwidG91Y2hTdGFydGVkIiwiaXNUb3VjaEp1bXAiLCJ0cmFuc2Zvcm0iLCJyZXNldCIsImJpbmQiLCJvcmlnaW5hbEV2ZW50IiwidG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJzbGlkZVdpZHRoIiwicHJldiIsIm1vdmVkWCIsImFicyIsIm1vdmVkIiwidXBkYXRlVG91Y2hQb3B1cCIsInNsaWRlTnVtYmVyIiwieFBvcyIsInlQb3MiLCJhcmd1bWVudHMiLCJ0b3VjaFBvcHVwIiwia2V5d29yZCIsInlQb3NBZGp1c3RtZW50Iiwic2xpZGVJbmRleFRvTnVtYmVyIiwiaW5zZXJ0QWZ0ZXIiLCJub1Njcm9sbCIsIm9sZCIsIiRwcmV2Iiwic2V0IiwiJG5leHQiLCIkc2xpZGVzIiwiZXEiLCJ1cGRhdGVTdW1tYXJ5U2xpZGUiLCJoYW5kbGVGb2N1cyIsInByb2dyZXNzZWRFdmVudCIsImNyZWF0ZVhBUElFdmVudFRlbXBsYXRlIiwib2JqZWN0IiwiZGVmaW5pdGlvbiIsImV4dGVuc2lvbnMiLCIkb2xkIiwiJHByZXZzIiwicHJldmlvdXNTbGlkZUluZGV4IiwiJG5leHRTbGlkZSIsImluc3RhbmNlUGFyYW1zIiwic2V0Q3VycmVudFNsaWRlSW5kZXgiLCJzY3JvbGxUb0tleXdvcmRzIiwidXBkYXRlUHJvZ3Jlc3NCYXIiLCJ1cGRhdGVGb290ZXIiLCJkbmIiLCJzZXRDb250YWluZXIiLCJibHVyQWxsIiwiY2FsbGJhY2siLCJpZ25vcmVDb25maXJtYXRpb25EaWFsb2ciLCJjb25maXJtYXRpb25EaWFsb2ciLCJoZWFkZXJUZXh0IiwiZGlhbG9nVGV4dCIsImNvbmZpcm1UZXh0IiwiY29uZmlybURpYWxvZ0NvbmZpcm1hdGlvblRleHQiLCIkaW5uZXIiLCJpbm5lckhlaWdodCIsImNsYXNzTGlzdCIsInNsaWRlVGl0bGUiLCJpc1N1bW1hcnlTbGlkZSIsInRvZ2dsZVNvbHV0aW9uTW9kZSIsImoiLCJyZXNldFRhc2siLCJqdW1wZWRUb0ZpcnN0IiwiaGFzU2NvcmVzIiwic2xpZGVTY29yZSIsInNsaWRlTWF4U2NvcmUiLCJpbmRleGVzIiwiYWRkU29sdXRpb25CdXR0b24iLCJjb3Vyc2VQcmVzZW50YXRpb25JbmRleE9uU2xpZGUiLCJnZXRTbGlkZVNjb3JlcyIsIm5vSnVtcCIsImdldENvcHlyaWdodHMiLCJpbmZvIiwiQ29udGVudENvcHlyaWdodHMiLCJlbGVtZW50Q29weXJpZ2h0cyIsImdsb2JhbEJhY2tncm91bmRTZWxlY3RvciIsImltYWdlR2xvYmFsQmFja2dyb3VuZCIsImdsb2JhbEJhY2tncm91bmRJbWFnZVBhcmFtcyIsImdsb2JhbEJhY2tncm91bmRJbWFnZUNvcHlyaWdodCIsIk1lZGlhQ29weXJpZ2h0IiwiY29weXJpZ2h0Iiwic2V0VGh1bWJuYWlsIiwiVGh1bWJuYWlsIiwiZ2V0UGF0aCIsInBhdGgiLCJhZGRNZWRpYSIsInNsaWRlSW5mbyIsInNldExhYmVsIiwic2xpZGVCYWNrZ3JvdW5kU2VsZWN0b3IiLCJpbWFnZVNsaWRlQmFja2dyb3VuZCIsInNsaWRlQmFja2dyb3VuZEltYWdlUGFyYW1zIiwic2xpZGVCYWNrZ3JvdW5kSW1hZ2VDb3B5cmlnaHQiLCJmaW5kQ29weXJpZ2h0cyIsIm1hY2hpbmVOYW1lIiwibGlicmFyeUluZm8iLCJnZXRUaXRsZSIsIm5hbWUiLCJhZGRDb250ZW50IiwiZ2V0WEFQSURhdGEiLCJ4QVBJRXZlbnQiLCJnZXRWZXJpZmllZFN0YXRlbWVudFZhbHVlIiwiaW50ZXJhY3Rpb25UeXBlIiwidHlwZSIsInNldFNjb3JlZFJlc3VsdCIsImNoaWxkcmVuWEFQSURhdGEiLCJnZXRDb250ZXh0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./scripts/cp.js\n");

/***/ }),

/***/ "./scripts/element.js":
/*!****************************!*\
  !*** ./scripts/element.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _go_to_slide__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./go-to-slide */ \"./scripts/go-to-slide.js\");\n\n/**\r\n * @class\r\n */\n\nfunction Element(parameters) {\n  var self = this;\n\n  if (parameters.action === undefined) {\n    // goToSlide, internal element\n    self.instance = new _go_to_slide__WEBPACK_IMPORTED_MODULE_0__[\"default\"](parameters, {\n      l10n: self.parent.parent.l10n,\n      currentIndex: self.parent.index\n    });\n\n    if (!self.parent.parent.isEditor()) {\n      self.instance.on('navigate', function (event) {\n        var index = event.data;\n        self.parent.parent.jumpToSlide(index);\n      });\n    }\n  } else {\n    // H5P library\n    var library;\n\n    if (self.parent.parent.isEditor()) {\n      // Clone the whole tree to avoid libraries accidentally changing params while running.\n      library = H5P.jQuery.extend(true, {}, parameters.action, self.parent.parent.elementsOverride);\n    } else {\n      // Add defaults\n      library = H5P.jQuery.extend(true, parameters.action, self.parent.parent.elementsOverride);\n    }\n\n    var internalSlideId = self.parent.parent.elementInstances[self.parent.index] ? self.parent.parent.elementInstances[self.parent.index].length : 0;\n\n    if (self.parent.parent.previousState && self.parent.parent.previousState.answers && self.parent.parent.previousState.answers[self.parent.index] && self.parent.parent.previousState.answers[self.parent.index][internalSlideId]) {\n      // Restore previous state\n      library.userDatas = {\n        state: self.parent.parent.previousState.answers[self.parent.index][internalSlideId]\n      };\n    } // Override child settings\n\n\n    library.params = library.params || {};\n    self.instance = H5P.newRunnable(library, self.parent.parent.contentId, undefined, true, {\n      parent: self.parent.parent\n    });\n\n    if (self.instance.preventResize !== undefined) {\n      self.instance.preventResize = true;\n    }\n  }\n\n  if (self.parent.parent.elementInstances[self.parent.index] === undefined) {\n    self.parent.parent.elementInstances[self.parent.index] = [self.instance];\n  } else {\n    self.parent.parent.elementInstances[self.parent.index].push(self.instance);\n  }\n\n  if (self.instance.showCPComments !== undefined || self.instance.isTask || self.instance.isTask === undefined && self.instance.showSolutions !== undefined) {\n    // Mark slide as task in CP navigation bar\n    self.instance.coursePresentationIndexOnSlide = self.parent.parent.elementInstances[self.parent.index].length - 1;\n\n    if (self.parent.parent.slidesWithSolutions[self.parent.index] === undefined) {\n      self.parent.parent.slidesWithSolutions[self.parent.index] = [];\n    }\n\n    self.parent.parent.slidesWithSolutions[self.parent.index].push(self.instance);\n  } // Check for comments to show after solution button is pressed\n  else if (parameters.solution) {\n    if (self.parent.parent.showCommentsAfterSolution[self.parent.index] === undefined) {\n      self.parent.parent.showCommentsAfterSolution[self.parent.index] = [];\n    }\n\n    self.parent.parent.showCommentsAfterSolution[self.parent.index].push(self.instance);\n  } // Check if this is an Exportable Text Area\n\n\n  if (self.instance.exportAnswers !== undefined && self.instance.exportAnswers) {\n    self.parent.parent.hasAnswerElements = true;\n  }\n\n  if (!self.parent.parent.isTask && !self.parent.parent.hideSummarySlide) {\n    // CP is not a task by default, but it will be if one of the elements is task or have a solution\n    if (self.instance.isTask || self.instance.isTask === undefined && self.instance.showSolutions !== undefined) {\n      self.parent.parent.isTask = true; // (checking for showSolutions will not work for compound content types, which is why we added isTask instead.)\n    }\n  }\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Element);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUFDQSxJQUFJSCxJQUFJLENBQUNHLFFBQUwsQ0FBY2tDLGFBQWQsS0FBZ0NuQyxTQUFoQyxJQUE2Q0YsSUFBSSxDQUFDRyxRQUFMLENBQWNrQyxhQUEvRCxFQUE4RTtJQUM1RXJDLElBQUksQ0FBQ0ssTUFBTCxDQUFZQSxNQUFaLENBQW1CaUMsaUJBQW5CLEdBQXVDLElBQXZDO0VBQ0Q7O0VBRUQsSUFBSSxDQUFDdEMsSUFBSSxDQUFDSyxNQUFMLENBQVlBLE1BQVosQ0FBbUIwQixNQUFwQixJQUE4QixDQUFDL0IsSUFBSSxDQUFDSyxNQUFMLENBQVlBLE1BQVosQ0FBbUJrQyxnQkFBdEQsRUFBd0U7SUFDdEU7SUFDQSxJQUFJdkMsSUFBSSxDQUFDRyxRQUFMLENBQWM0QixNQUFkLElBQXlCL0IsSUFBSSxDQUFDRyxRQUFMLENBQWM0QixNQUFkLEtBQXlCN0IsU0FBekIsSUFBc0NGLElBQUksQ0FBQ0csUUFBTCxDQUFjNkIsYUFBZCxLQUFnQzlCLFNBQW5HLEVBQStHO01BQzdHRixJQUFJLENBQUNLLE1BQUwsQ0FBWUEsTUFBWixDQUFtQjBCLE1BQW5CLEdBQTRCLElBQTVCLENBRDZHLENBQzNFO0lBQ25DO0VBQ0Y7QUFDRjs7QUFFRCxpRUFBZWpDLE9BQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHRzL2VsZW1lbnQuanM/Y2MxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29Ub1NsaWRlIGZyb20gJy4vZ28tdG8tc2xpZGUnO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gRWxlbWVudChwYXJhbWV0ZXJzKSB7XHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcblxyXG4gIGlmIChwYXJhbWV0ZXJzLmFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAvLyBnb1RvU2xpZGUsIGludGVybmFsIGVsZW1lbnRcclxuICAgIHNlbGYuaW5zdGFuY2UgPSBuZXcgR29Ub1NsaWRlKHBhcmFtZXRlcnMsIHtcclxuICAgICAgbDEwbjogc2VsZi5wYXJlbnQucGFyZW50LmwxMG4sXHJcbiAgICAgIGN1cnJlbnRJbmRleDogc2VsZi5wYXJlbnQuaW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICghc2VsZi5wYXJlbnQucGFyZW50LmlzRWRpdG9yKCkpIHtcclxuICAgICAgc2VsZi5pbnN0YW5jZS5vbignbmF2aWdhdGUnLCBldmVudCA9PiB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudC5kYXRhO1xyXG4gICAgICAgIHNlbGYucGFyZW50LnBhcmVudC5qdW1wVG9TbGlkZShpbmRleCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBlbHNlIHtcclxuICAgIC8vIEg1UCBsaWJyYXJ5XHJcbiAgICB2YXIgbGlicmFyeTtcclxuICAgIGlmIChzZWxmLnBhcmVudC5wYXJlbnQuaXNFZGl0b3IoKSkge1xyXG4gICAgICAvLyBDbG9uZSB0aGUgd2hvbGUgdHJlZSB0byBhdm9pZCBsaWJyYXJpZXMgYWNjaWRlbnRhbGx5IGNoYW5naW5nIHBhcmFtcyB3aGlsZSBydW5uaW5nLlxyXG4gICAgICBsaWJyYXJ5ID0gSDVQLmpRdWVyeS5leHRlbmQodHJ1ZSwge30sIHBhcmFtZXRlcnMuYWN0aW9uLCBzZWxmLnBhcmVudC5wYXJlbnQuZWxlbWVudHNPdmVycmlkZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgLy8gQWRkIGRlZmF1bHRzXHJcbiAgICAgIGxpYnJhcnkgPSBINVAualF1ZXJ5LmV4dGVuZCh0cnVlLCBwYXJhbWV0ZXJzLmFjdGlvbiwgc2VsZi5wYXJlbnQucGFyZW50LmVsZW1lbnRzT3ZlcnJpZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBpbnRlcm5hbFNsaWRlSWQgPSBzZWxmLnBhcmVudC5wYXJlbnQuZWxlbWVudEluc3RhbmNlc1tzZWxmLnBhcmVudC5pbmRleF0gPyBzZWxmLnBhcmVudC5wYXJlbnQuZWxlbWVudEluc3RhbmNlc1tzZWxmLnBhcmVudC5pbmRleF0ubGVuZ3RoIDogMDtcclxuICAgIGlmIChzZWxmLnBhcmVudC5wYXJlbnQucHJldmlvdXNTdGF0ZSAmJiBzZWxmLnBhcmVudC5wYXJlbnQucHJldmlvdXNTdGF0ZS5hbnN3ZXJzICYmIHNlbGYucGFyZW50LnBhcmVudC5wcmV2aW91c1N0YXRlLmFuc3dlcnNbc2VsZi5wYXJlbnQuaW5kZXhdICYmIHNlbGYucGFyZW50LnBhcmVudC5wcmV2aW91c1N0YXRlLmFuc3dlcnNbc2VsZi5wYXJlbnQuaW5kZXhdW2ludGVybmFsU2xpZGVJZF0pIHtcclxuICAgICAgLy8gUmVzdG9yZSBwcmV2aW91cyBzdGF0ZVxyXG4gICAgICBsaWJyYXJ5LnVzZXJEYXRhcyA9IHtcclxuICAgICAgICBzdGF0ZTogc2VsZi5wYXJlbnQucGFyZW50LnByZXZpb3VzU3RhdGUuYW5zd2Vyc1tzZWxmLnBhcmVudC5pbmRleF1baW50ZXJuYWxTbGlkZUlkXVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE92ZXJyaWRlIGNoaWxkIHNldHRpbmdzXHJcbiAgICBsaWJyYXJ5LnBhcmFtcyA9IGxpYnJhcnkucGFyYW1zIHx8IHt9O1xyXG4gICAgc2VsZi5pbnN0YW5jZSA9IEg1UC5uZXdSdW5uYWJsZShsaWJyYXJ5LCBzZWxmLnBhcmVudC5wYXJlbnQuY29udGVudElkLCB1bmRlZmluZWQsIHRydWUsIHtwYXJlbnQ6IHNlbGYucGFyZW50LnBhcmVudH0pO1xyXG4gICAgaWYgKHNlbGYuaW5zdGFuY2UucHJldmVudFJlc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHNlbGYuaW5zdGFuY2UucHJldmVudFJlc2l6ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBpZiAoc2VsZi5wYXJlbnQucGFyZW50LmVsZW1lbnRJbnN0YW5jZXNbc2VsZi5wYXJlbnQuaW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgIHNlbGYucGFyZW50LnBhcmVudC5lbGVtZW50SW5zdGFuY2VzW3NlbGYucGFyZW50LmluZGV4XSA9IFtzZWxmLmluc3RhbmNlXTtcclxuICB9XHJcbiAgZWxzZSB7XHJcbiAgICBzZWxmLnBhcmVudC5wYXJlbnQuZWxlbWVudEluc3RhbmNlc1tzZWxmLnBhcmVudC5pbmRleF0ucHVzaChzZWxmLmluc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIGlmIChzZWxmLmluc3RhbmNlLnNob3dDUENvbW1lbnRzICE9PSB1bmRlZmluZWQgfHwgc2VsZi5pbnN0YW5jZS5pc1Rhc2sgfHwgKHNlbGYuaW5zdGFuY2UuaXNUYXNrID09PSB1bmRlZmluZWQgJiYgc2VsZi5pbnN0YW5jZS5zaG93U29sdXRpb25zICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAvLyBNYXJrIHNsaWRlIGFzIHRhc2sgaW4gQ1AgbmF2aWdhdGlvbiBiYXJcclxuICAgIHNlbGYuaW5zdGFuY2UuY291cnNlUHJlc2VudGF0aW9uSW5kZXhPblNsaWRlID0gc2VsZi5wYXJlbnQucGFyZW50LmVsZW1lbnRJbnN0YW5jZXNbc2VsZi5wYXJlbnQuaW5kZXhdLmxlbmd0aCAtIDE7XHJcbiAgICBpZiAoc2VsZi5wYXJlbnQucGFyZW50LnNsaWRlc1dpdGhTb2x1dGlvbnNbc2VsZi5wYXJlbnQuaW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2VsZi5wYXJlbnQucGFyZW50LnNsaWRlc1dpdGhTb2x1dGlvbnNbc2VsZi5wYXJlbnQuaW5kZXhdID0gW107XHJcbiAgICB9XHJcbiAgICBzZWxmLnBhcmVudC5wYXJlbnQuc2xpZGVzV2l0aFNvbHV0aW9uc1tzZWxmLnBhcmVudC5pbmRleF0ucHVzaChzZWxmLmluc3RhbmNlKTtcclxuICB9XHJcbiAgLy8gQ2hlY2sgZm9yIGNvbW1lbnRzIHRvIHNob3cgYWZ0ZXIgc29sdXRpb24gYnV0dG9uIGlzIHByZXNzZWRcclxuICBlbHNlIGlmIChwYXJhbWV0ZXJzLnNvbHV0aW9uKSB7XHJcbiAgICBpZiAoc2VsZi5wYXJlbnQucGFyZW50LnNob3dDb21tZW50c0FmdGVyU29sdXRpb25bc2VsZi5wYXJlbnQuaW5kZXhdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgc2VsZi5wYXJlbnQucGFyZW50LnNob3dDb21tZW50c0FmdGVyU29sdXRpb25bc2VsZi5wYXJlbnQuaW5kZXhdID0gW107XHJcbiAgICB9XHJcbiAgICBzZWxmLnBhcmVudC5wYXJlbnQuc2hvd0NvbW1lbnRzQWZ0ZXJTb2x1dGlvbltzZWxmLnBhcmVudC5pbmRleF0ucHVzaChzZWxmLmluc3RhbmNlKTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gRXhwb3J0YWJsZSBUZXh0IEFyZWFcclxuICBpZiAoc2VsZi5pbnN0YW5jZS5leHBvcnRBbnN3ZXJzICE9PSB1bmRlZmluZWQgJiYgc2VsZi5pbnN0YW5jZS5leHBvcnRBbnN3ZXJzKSB7XHJcbiAgICBzZWxmLnBhcmVudC5wYXJlbnQuaGFzQW5zd2VyRWxlbWVudHMgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgaWYgKCFzZWxmLnBhcmVudC5wYXJlbnQuaXNUYXNrICYmICFzZWxmLnBhcmVudC5wYXJlbnQuaGlkZVN1bW1hcnlTbGlkZSkge1xyXG4gICAgLy8gQ1AgaXMgbm90IGEgdGFzayBieSBkZWZhdWx0LCBidXQgaXQgd2lsbCBiZSBpZiBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzIHRhc2sgb3IgaGF2ZSBhIHNvbHV0aW9uXHJcbiAgICBpZiAoc2VsZi5pbnN0YW5jZS5pc1Rhc2sgfHwgKHNlbGYuaW5zdGFuY2UuaXNUYXNrID09PSB1bmRlZmluZWQgJiYgc2VsZi5pbnN0YW5jZS5zaG93U29sdXRpb25zICE9PSB1bmRlZmluZWQpKSB7XHJcbiAgICAgIHNlbGYucGFyZW50LnBhcmVudC5pc1Rhc2sgPSB0cnVlOyAvLyAoY2hlY2tpbmcgZm9yIHNob3dTb2x1dGlvbnMgd2lsbCBub3Qgd29yayBmb3IgY29tcG91bmQgY29udGVudCB0eXBlcywgd2hpY2ggaXMgd2h5IHdlIGFkZGVkIGlzVGFzayBpbnN0ZWFkLilcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEVsZW1lbnQ7XHJcbiJdLCJuYW1lcyI6WyJHb1RvU2xpZGUiLCJFbGVtZW50IiwicGFyYW1ldGVycyIsInNlbGYiLCJhY3Rpb24iLCJ1bmRlZmluZWQiLCJpbnN0YW5jZSIsImwxMG4iLCJwYXJlbnQiLCJjdXJyZW50SW5kZXgiLCJpbmRleCIsImlzRWRpdG9yIiwib24iLCJldmVudCIsImRhdGEiLCJqdW1wVG9TbGlkZSIsImxpYnJhcnkiLCJINVAiLCJqUXVlcnkiLCJleHRlbmQiLCJlbGVtZW50c092ZXJyaWRlIiwiaW50ZXJuYWxTbGlkZUlkIiwiZWxlbWVudEluc3RhbmNlcyIsImxlbmd0aCIsInByZXZpb3VzU3RhdGUiLCJhbnN3ZXJzIiwidXNlckRhdGFzIiwic3RhdGUiLCJwYXJhbXMiLCJuZXdSdW5uYWJsZSIsImNvbnRlbnRJZCIsInByZXZlbnRSZXNpemUiLCJwdXNoIiwic2hvd0NQQ29tbWVudHMiLCJpc1Rhc2siLCJzaG93U29sdXRpb25zIiwiY291cnNlUHJlc2VudGF0aW9uSW5kZXhPblNsaWRlIiwic2xpZGVzV2l0aFNvbHV0aW9ucyIsInNvbHV0aW9uIiwic2hvd0NvbW1lbnRzQWZ0ZXJTb2x1dGlvbiIsImV4cG9ydEFuc3dlcnMiLCJoYXNBbnN3ZXJFbGVtZW50cyIsImhpZGVTdW1tYXJ5U2xpZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/element.js\n");

/***/ }),

/***/ "./scripts/globals.js":
/*!****************************!*\
  !*** ./scripts/globals.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EventDispatcher\": () => (/* binding */ EventDispatcher),\n/* harmony export */   \"JoubelUI\": () => (/* binding */ JoubelUI),\n/* harmony export */   \"jQuery\": () => (/* binding */ jQuery)\n/* harmony export */ });\nvar jQuery = H5P.jQuery;\nvar EventDispatcher = H5P.EventDispatcher;\nvar JoubelUI = H5P.JoubelUI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zY3JpcHRzL2dsb2JhbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQU8sSUFBTUEsTUFBTSxHQUFHQyxHQUFHLENBQUNELE1BQW5CO0FBQ0EsSUFBTUUsZUFBZSxHQUFHRCxHQUFHLENBQUNDLGVBQTVCO0FBQ0EsSUFBTUMsUUFBUSxHQUFHRixHQUFHLENBQUNFLFFBQXJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9nbG9iYWxzLmpzPzc3NjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGpRdWVyeSA9IEg1UC5qUXVlcnk7XHJcbmV4cG9ydCBjb25zdCBFdmVudERpc3BhdGNoZXIgPSBINVAuRXZlbnREaXNwYXRjaGVyO1xyXG5leHBvcnQgY29uc3QgSm91YmVsVUkgPSBINVAuSm91YmVsVUk7XHJcbiJdLCJuYW1lcyI6WyJqUXVlcnkiLCJINVAiLCJFdmVudERpc3BhdGNoZXIiLCJKb3ViZWxVSSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./scripts/globals.js\n");

/***/ }),

/***/ "./scripts/go-to-slide.js":
/*!********************************!*\
  !*** ./scripts/go-to-slide.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoToSlide)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n\n\n/**\r\n * Enum containing possible navigation types\r\n * @readonly\r\n * @enum {string}\r\n */\n\nvar navigationType = {\n  SPECIFIED: 'specified',\n  NEXT: 'next',\n  PREVIOUS: 'previous'\n};\n/**\r\n * @class\r\n */\n\nvar GoToSlide = /*#__PURE__*/function () {\n  /**\r\n   * Element for linking between slides in presentations.\r\n   *\r\n   * @constructor\r\n   * @param {string} title\r\n   * @param {number} goToSlide\r\n   * @param {boolean} invisible\r\n   * @param {string} goToSlideType\r\n   * @param {object} l10n\r\n   * @param {number} currentIndex\r\n   */\n  function GoToSlide(_ref, _ref2) {\n    var _this = this;\n\n    var title = _ref.title,\n        _ref$goToSlide = _ref.goToSlide,\n        goToSlide = _ref$goToSlide === void 0 ? 1 : _ref$goToSlide,\n        invisible = _ref.invisible,\n        _ref$goToSlideType = _ref.goToSlideType,\n        goToSlideType = _ref$goToSlideType === void 0 ? navigationType.SPECIFIED : _ref$goToSlideType;\n    var l10n = _ref2.l10n,\n        currentIndex = _ref2.currentIndex;\n    this.eventDispatcher = new _globals__WEBPACK_IMPORTED_MODULE_1__.EventDispatcher();\n    var classes = 'h5p-press-to-go';\n    var tabindex = 0;\n\n    if (invisible) {\n      title = undefined;\n      tabindex = -1;\n    } else {\n      if (!title) {\n        // No title so use the slide number, prev, or next.\n        switch (goToSlideType) {\n          case navigationType.SPECIFIED:\n            title = l10n.goToSlide.replace(':num', goToSlide.toString());\n            break;\n\n          case navigationType.NEXT:\n            title = l10n.goToSlide.replace(':num', l10n.nextSlide);\n            break;\n\n          case navigationType.PREVIOUS:\n            title = l10n.goToSlide.replace(':num', l10n.prevSlide);\n            break;\n        }\n      }\n\n      classes += ' h5p-visible';\n    } // Default goes to the set number\n\n\n    var goTo = goToSlide - 1; // Check if previous or next is selected.\n\n    if (goToSlideType === navigationType.NEXT) {\n      goTo = currentIndex + 1;\n    } else if (goToSlideType === navigationType.PREVIOUS) {\n      goTo = currentIndex - 1;\n    } // Create button that leads to another slide\n\n\n    this.$element = (0,_globals__WEBPACK_IMPORTED_MODULE_1__.jQuery)('<a/>', {\n      href: '#',\n      'class': classes,\n      tabindex: tabindex,\n      title: title\n    });\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addClickAndKeyboardListeners)(this.$element, function (event) {\n      _this.eventDispatcher.trigger('navigate', goTo);\n\n      event.preventDefault();\n    });\n  }\n  /**\r\n   * Attach element to the given container.\r\n   *\r\n   * @public\r\n   * @param {jQuery} $container\r\n   */\n\n\n  var _proto = GoToSlide.prototype;\n\n  _proto.attach = function attach($container) {\n    $container.html('').addClass('h5p-go-to-slide').append(this.$element);\n  }\n  /**\r\n   * Register an event listener\r\n   *\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   */\n  ;\n\n  _proto.on = function on(name, callback) {\n    this.eventDispatcher.on(name, callback);\n  };\n\n  return GoToSlide;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVgsQ0FBZ0IsRUFBaEIsRUFBb0JDLFFBQXBCLENBQTZCLGlCQUE3QixFQUFnREMsTUFBaEQsQ0FBdUQsS0FBS1QsUUFBNUQ7RUFDRDtFQUVEO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0VVLEtBQUEsWUFBR0MsSUFBSCxFQUFTQyxRQUFULEVBQW1CO0lBQ2pCLEtBQUtyQixlQUFMLENBQXFCbUIsRUFBckIsQ0FBd0JDLElBQXhCLEVBQThCQyxRQUE5QjtFQUNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9nby10by1zbGlkZS5qcz8xM2VlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgalF1ZXJ5IGFzICQsIEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vZ2xvYmFscyc7XHJcblxyXG4vKipcclxuICogRW51bSBjb250YWluaW5nIHBvc3NpYmxlIG5hdmlnYXRpb24gdHlwZXNcclxuICogQHJlYWRvbmx5XHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqL1xyXG5jb25zdCBuYXZpZ2F0aW9uVHlwZSA9IHtcclxuICBTUEVDSUZJRUQ6ICdzcGVjaWZpZWQnLFxyXG4gIE5FWFQ6ICduZXh0JyxcclxuICBQUkVWSU9VUzogJ3ByZXZpb3VzJ1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR29Ub1NsaWRlIHtcclxuICAvKipcclxuICAgKiBFbGVtZW50IGZvciBsaW5raW5nIGJldHdlZW4gc2xpZGVzIGluIHByZXNlbnRhdGlvbnMuXHJcbiAgICpcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZ29Ub1NsaWRlXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpbnZpc2libGVcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZ29Ub1NsaWRlVHlwZVxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBsMTBuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRJbmRleFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHsgdGl0bGUsIGdvVG9TbGlkZSA9IDEsIGludmlzaWJsZSwgZ29Ub1NsaWRlVHlwZSAgPSBuYXZpZ2F0aW9uVHlwZS5TUEVDSUZJRUQgfSwgeyBsMTBuLCBjdXJyZW50SW5kZXggfSkge1xyXG4gICAgdGhpcy5ldmVudERpc3BhdGNoZXIgPSBuZXcgRXZlbnREaXNwYXRjaGVyKCk7XHJcbiAgICBsZXQgY2xhc3NlcyA9ICdoNXAtcHJlc3MtdG8tZ28nO1xyXG4gICAgbGV0IHRhYmluZGV4ID0gMDtcclxuXHJcbiAgICBpZiAoaW52aXNpYmxlKSB7XHJcbiAgICAgIHRpdGxlID0gdW5kZWZpbmVkO1xyXG4gICAgICB0YWJpbmRleCA9IC0xO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGlmICghdGl0bGUpIHtcclxuICAgICAgICAvLyBObyB0aXRsZSBzbyB1c2UgdGhlIHNsaWRlIG51bWJlciwgcHJldiwgb3IgbmV4dC5cclxuICAgICAgICBzd2l0Y2ggKGdvVG9TbGlkZVR5cGUpIHtcclxuICAgICAgICAgIGNhc2UgbmF2aWdhdGlvblR5cGUuU1BFQ0lGSUVEOlxyXG4gICAgICAgICAgICB0aXRsZSA9IGwxMG4uZ29Ub1NsaWRlLnJlcGxhY2UoJzpudW0nLCBnb1RvU2xpZGUudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBuYXZpZ2F0aW9uVHlwZS5ORVhUOlxyXG4gICAgICAgICAgICB0aXRsZSA9IGwxMG4uZ29Ub1NsaWRlLnJlcGxhY2UoJzpudW0nLCBsMTBuLm5leHRTbGlkZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgY2FzZSBuYXZpZ2F0aW9uVHlwZS5QUkVWSU9VUzpcclxuICAgICAgICAgICAgdGl0bGUgPSBsMTBuLmdvVG9TbGlkZS5yZXBsYWNlKCc6bnVtJywgbDEwbi5wcmV2U2xpZGUpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY2xhc3NlcyArPSAnIGg1cC12aXNpYmxlJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZWZhdWx0IGdvZXMgdG8gdGhlIHNldCBudW1iZXJcclxuICAgIGxldCBnb1RvID0gZ29Ub1NsaWRlIC0gMTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBvciBuZXh0IGlzIHNlbGVjdGVkLlxyXG4gICAgaWYgKGdvVG9TbGlkZVR5cGUgPT09IG5hdmlnYXRpb25UeXBlLk5FWFQpIHtcclxuICAgICAgZ29UbyA9IGN1cnJlbnRJbmRleCArIDE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChnb1RvU2xpZGVUeXBlID09PSBuYXZpZ2F0aW9uVHlwZS5QUkVWSU9VUykge1xyXG4gICAgICBnb1RvID0gY3VycmVudEluZGV4IC0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgYnV0dG9uIHRoYXQgbGVhZHMgdG8gYW5vdGhlciBzbGlkZVxyXG4gICAgdGhpcy4kZWxlbWVudCA9ICQoJzxhLz4nLCB7XHJcbiAgICAgIGhyZWY6ICcjJyxcclxuICAgICAgJ2NsYXNzJzogY2xhc3NlcyxcclxuICAgICAgdGFiaW5kZXg6IHRhYmluZGV4LFxyXG4gICAgICB0aXRsZTogdGl0bGVcclxuICAgIH0pO1xyXG5cclxuICAgIGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnModGhpcy4kZWxlbWVudCwgZXZlbnQgPT4ge1xyXG4gICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci50cmlnZ2VyKCduYXZpZ2F0ZScsIGdvVG8pO1xyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBdHRhY2ggZWxlbWVudCB0byB0aGUgZ2l2ZW4gY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBwYXJhbSB7alF1ZXJ5fSAkY29udGFpbmVyXHJcbiAgICovXHJcbiAgYXR0YWNoKCRjb250YWluZXIpIHtcclxuICAgICRjb250YWluZXIuaHRtbCgnJykuYWRkQ2xhc3MoJ2g1cC1nby10by1zbGlkZScpLmFwcGVuZCh0aGlzLiRlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICovXHJcbiAgb24obmFtZSwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uKG5hbWUsIGNhbGxiYWNrKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMiLCJqUXVlcnkiLCIkIiwiRXZlbnREaXNwYXRjaGVyIiwibmF2aWdhdGlvblR5cGUiLCJTUEVDSUZJRUQiLCJORVhUIiwiUFJFVklPVVMiLCJHb1RvU2xpZGUiLCJ0aXRsZSIsImdvVG9TbGlkZSIsImludmlzaWJsZSIsImdvVG9TbGlkZVR5cGUiLCJsMTBuIiwiY3VycmVudEluZGV4IiwiZXZlbnREaXNwYXRjaGVyIiwiY2xhc3NlcyIsInRhYmluZGV4IiwidW5kZWZpbmVkIiwicmVwbGFjZSIsInRvU3RyaW5nIiwibmV4dFNsaWRlIiwicHJldlNsaWRlIiwiZ29UbyIsIiRlbGVtZW50IiwiaHJlZiIsImV2ZW50IiwidHJpZ2dlciIsInByZXZlbnREZWZhdWx0IiwiYXR0YWNoIiwiJGNvbnRhaW5lciIsImh0bWwiLCJhZGRDbGFzcyIsImFwcGVuZCIsIm9uIiwibmFtZSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./scripts/go-to-slide.js\n");

/***/ }),

/***/ "./scripts/keyword-menu.js":
/*!*********************************!*\
  !*** ./scripts/keyword-menu.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ KeywordMenu)\n/* harmony export */ });\n/* harmony import */ var h5p_lib_controls_src_scripts_controls__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! h5p-lib-controls/src/scripts/controls */ \"../node_modules/h5p-lib-controls/src/scripts/controls.js\");\n/* harmony import */ var h5p_lib_controls_src_scripts_ui_keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! h5p-lib-controls/src/scripts/ui/keyboard */ \"../node_modules/h5p-lib-controls/src/scripts/ui/keyboard.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n\n\n\n\n/**\r\n * Select event.\r\n * @event KeywordMenu#select\r\n * @type {object}\r\n * @property {number} index The index of the selected menuitem\r\n */\n\n/**\r\n * @typedef {object} KeywordMenuItemConfig\r\n * @property {string} title\r\n * @property {string} subtitle\r\n * @property {number} index\r\n */\n\n/**\r\n * @typedef {object} KeywordMenuState\r\n * @property {number} currentIndex\r\n */\n\n/**\r\n * Returns the index stored in a elements dataset\r\n *\r\n * @param {Element|EventTarget} element\r\n * @return {number}\r\n */\n\nvar getElementsDatasetIndex = function getElementsDatasetIndex(element) {\n  return parseInt(element.dataset.index);\n};\n/**\r\n * @class\r\n */\n\n\nvar KeywordMenu = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   * @param {object} l10n\r\n   * @param {number} currentIndex\r\n   */\n  function KeywordMenu(_ref) {\n    var _this = this;\n\n    var l10n = _ref.l10n,\n        currentIndex = _ref.currentIndex;\n    this.l10n = l10n;\n    /**\r\n     * @type {KeywordMenuState}\r\n     */\n\n    this.state = {\n      currentIndex: (0,_utils__WEBPACK_IMPORTED_MODULE_2__.defaultValue)(currentIndex, 0)\n    };\n    this.eventDispatcher = new _globals__WEBPACK_IMPORTED_MODULE_3__.EventDispatcher();\n    this.controls = new h5p_lib_controls_src_scripts_controls__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([new h5p_lib_controls_src_scripts_ui_keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"]()]); // on keyboard select\n\n    this.controls.on('select', function (event) {\n      _this.onMenuItemSelect(getElementsDatasetIndex(event.element));\n    }); // propagate ESC event\n\n    this.controls.on('close', function () {\n      return _this.eventDispatcher.trigger('close');\n    });\n    this.menuElement = this.createMenuElement();\n    this.currentSlideMarkerElement = this.createCurrentSlideMarkerElement();\n  }\n  /**\r\n   * Initializes the config\r\n   *\r\n   * @param {KeywordMenuItemConfig[]} keywordConfigs\r\n   * @returns {Element[]}\r\n   */\n\n\n  var _proto = KeywordMenu.prototype;\n\n  _proto.init = function init(keywordConfigs) {\n    var _this2 = this;\n\n    this.menuItemElements = keywordConfigs.map(function (config) {\n      return _this2.createMenuItemElement(config);\n    });\n    this.menuItemElements.forEach(function (element) {\n      return _this2.menuElement.appendChild(element);\n    });\n    this.menuItemElements.forEach(function (element) {\n      return _this2.controls.addElement(element);\n    });\n    this.setCurrentSlideIndex(this.state.currentIndex);\n    return this.menuItemElements;\n  }\n  /**\r\n   * Register an event listener\r\n   *\r\n   * @param {string} name\r\n   * @param {function} callback\r\n   */\n  ;\n\n  _proto.on = function on(name, callback) {\n    this.eventDispatcher.on(name, callback);\n  }\n  /**\r\n   * Returns the menu element\r\n   *\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.getElement = function getElement() {\n    return this.menuElement;\n  }\n  /**\r\n   * Removes all menu items\r\n   */\n  ;\n\n  _proto.removeAllMenuItemElements = function removeAllMenuItemElements() {\n    var _this3 = this;\n\n    this.menuItemElements.forEach(function (element) {\n      _this3.controls.removeElement(element);\n\n      _this3.menuElement.removeChild(element);\n    });\n    this.menuItemElements = [];\n  }\n  /**\r\n   * Creates a menu element\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.createMenuElement = function createMenuElement() {\n    var element = this.menuElement = document.createElement('ol');\n    element.setAttribute('role', 'menu');\n    element.classList.add('list-unstyled');\n    return element;\n  }\n  /**\r\n   * Creates a menuitem\r\n   *\r\n   * @param {KeywordMenuItemConfig} config\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.createMenuItemElement = function createMenuItemElement(config) {\n    var _this4 = this;\n\n    var element = document.createElement('li');\n    element.setAttribute('role', 'menuitem');\n    element.addEventListener('click', function (event) {\n      _this4.onMenuItemSelect(getElementsDatasetIndex(event.currentTarget));\n    });\n    this.applyConfigToMenuItemElement(element, config);\n    return element;\n  }\n  /**\r\n   * Applies a config to a menu item element\r\n   *\r\n   * @param {Element} element\r\n   * @param {KeywordMenuItemConfig} config\r\n   */\n  ;\n\n  _proto.applyConfigToMenuItemElement = function applyConfigToMenuItemElement(element, config) {\n    element.innerHTML = \"<div class=\\\"h5p-keyword-subtitle\\\">\".concat(config.subtitle, \"</div><span class=\\\"h5p-keyword-title\\\">\").concat(config.title, \"</span>\");\n    element.dataset.index = config.index;\n  }\n  /**\r\n   * Handles selecting menu item\r\n   *\r\n   * @param {number} index\r\n   * @fires KeywordMenu#select\r\n   */\n  ;\n\n  _proto.onMenuItemSelect = function onMenuItemSelect(index) {\n    this.setCurrentSlideIndex(index);\n    this.eventDispatcher.trigger('select', {\n      index: index\n    });\n  }\n  /**\r\n   * Sets the current slide index\r\n   *\r\n   * @param {number} index\r\n   */\n  ;\n\n  _proto.setCurrentSlideIndex = function setCurrentSlideIndex(index) {\n    var selectedElement = this.getElementByIndex(this.menuItemElements, index);\n\n    if (selectedElement) {\n      this.state.currentIndex = index;\n      this.updateCurrentlySelected(this.menuItemElements, this.state);\n      this.controls.setTabbable(selectedElement);\n    }\n  }\n  /**\r\n   * Updates the h5p-current class on the element list\r\n   *\r\n   * @param {Element[]} elements\r\n   * @param {KeywordMenuState} state\r\n   */\n  ;\n\n  _proto.updateCurrentlySelected = function updateCurrentlySelected(elements, state) {\n    var _this5 = this;\n\n    elements.forEach(function (element) {\n      var isSelected = state.currentIndex === getElementsDatasetIndex(element);\n      element.classList.toggle('h5p-current', isSelected);\n\n      if (isSelected) {\n        element.appendChild(_this5.currentSlideMarkerElement);\n      }\n    });\n  }\n  /**\r\n   * Scroll to current keywords.\r\n   *\r\n   * @param {number} index\r\n   */\n  ;\n\n  _proto.scrollToKeywords = function scrollToKeywords(index) {\n    var elementToScrollTo = this.getFirstElementAfter(index);\n\n    if (elementToScrollTo) {\n      var $menu = (0,_globals__WEBPACK_IMPORTED_MODULE_3__.jQuery)(this.menuElement);\n      var move = $menu.scrollTop() + (0,_globals__WEBPACK_IMPORTED_MODULE_3__.jQuery)(elementToScrollTo).position().top - 8;\n\n      if (_utils__WEBPACK_IMPORTED_MODULE_2__.isIPad) {\n        $menu.scrollTop(move);\n      } else {\n        $menu.stop().animate({\n          scrollTop: move\n        }, 250);\n      }\n    }\n  }\n  /**\r\n   * Returns the first element with an index larger then value\r\n   *\r\n   * @param {number} index\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.getFirstElementAfter = function getFirstElementAfter(index) {\n    return this.menuItemElements.filter(function (element) {\n      return getElementsDatasetIndex(element) >= index;\n    })[0];\n  }\n  /**\r\n   * Returns the element with a given index\r\n   *\r\n   * @param {Element[]} elements\r\n   * @param {number} index\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.getElementByIndex = function getElementByIndex(elements, index) {\n    return elements.filter(function (element) {\n      return getElementsDatasetIndex(element) === index;\n    })[0];\n  }\n  /**\r\n   * Creates a hidden element, that will read \"Current slide\"\r\n   *\r\n   * @return {Element}\r\n   */\n  ;\n\n  _proto.createCurrentSlideMarkerElement = function createCurrentSlideMarkerElement() {\n    var element = document.createElement('div');\n    element.classList.add('hidden-but-read');\n    element.innerHTML = this.l10n.currentSlide;\n    return element;\n  };\n\n  return KeywordMenu;\n}();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUQsQ0FBdkIsS0FBcUNHLEtBQXpDO0lBQUEsQ0FBdkIsRUFBdUUsQ0FBdkUsQ0FBUDtFQUNEO0VBRUQ7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7O1NBQ0VjLGtDQUFBLDJDQUFrQztJQUNoQyxJQUFNakIsT0FBTyxHQUFHa0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQWhCO0lBQ0FuQyxPQUFPLENBQUNxQyxTQUFSLENBQWtCQyxHQUFsQixDQUFzQixpQkFBdEI7SUFDQXRDLE9BQU8sQ0FBQzBDLFNBQVIsR0FBb0IsS0FBS3JDLElBQUwsQ0FBVTBELFlBQTlCO0lBQ0EsT0FBTy9ELE9BQVA7RUFDRCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NjcmlwdHMva2V5d29yZC1tZW51LmpzPzQ2NjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IENvbnRyb2xzIGZyb20gJ2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvY29udHJvbHMnO1xyXG5pbXBvcnQgVUlLZXlib2FyZCBmcm9tICdoNXAtbGliLWNvbnRyb2xzL3NyYy9zY3JpcHRzL3VpL2tleWJvYXJkJztcclxuaW1wb3J0IHsgaXNJUGFkLCBkZWZhdWx0VmFsdWUgfSBmcm9tICcuL3V0aWxzJztcclxuaW1wb3J0IHsgalF1ZXJ5IGFzICQsIEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4vZ2xvYmFscyc7XHJcblxyXG4vKipcclxuICogU2VsZWN0IGV2ZW50LlxyXG4gKiBAZXZlbnQgS2V5d29yZE1lbnUjc2VsZWN0XHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHNlbGVjdGVkIG1lbnVpdGVtXHJcbiAqL1xyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gS2V5d29yZE1lbnVJdGVtQ29uZmlnXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aXRsZVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3VidGl0bGVcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XHJcbiAqL1xyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gS2V5d29yZE1lbnVTdGF0ZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gY3VycmVudEluZGV4XHJcbiAqL1xyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5kZXggc3RvcmVkIGluIGEgZWxlbWVudHMgZGF0YXNldFxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8RXZlbnRUYXJnZXR9IGVsZW1lbnRcclxuICogQHJldHVybiB7bnVtYmVyfVxyXG4gKi9cclxuY29uc3QgZ2V0RWxlbWVudHNEYXRhc2V0SW5kZXggPSBlbGVtZW50ID0+IHBhcnNlSW50KGVsZW1lbnQuZGF0YXNldC5pbmRleCk7XHJcblxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXl3b3JkTWVudSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IGwxMG5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudEluZGV4XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoeyBsMTBuLCBjdXJyZW50SW5kZXggfSkge1xyXG4gICAgdGhpcy5sMTBuID0gbDEwbjtcclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0tleXdvcmRNZW51U3RhdGV9XHJcbiAgICAgKi9cclxuICAgIHRoaXMuc3RhdGUgPSB7XHJcbiAgICAgIGN1cnJlbnRJbmRleDogZGVmYXVsdFZhbHVlKGN1cnJlbnRJbmRleCwgMClcclxuICAgIH07XHJcbiAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIoKTtcclxuICAgIHRoaXMuY29udHJvbHMgPSBuZXcgQ29udHJvbHMoW25ldyBVSUtleWJvYXJkKCldKTtcclxuXHJcbiAgICAvLyBvbiBrZXlib2FyZCBzZWxlY3RcclxuICAgIHRoaXMuY29udHJvbHMub24oJ3NlbGVjdCcsIGV2ZW50ID0+IHtcclxuICAgICAgdGhpcy5vbk1lbnVJdGVtU2VsZWN0KGdldEVsZW1lbnRzRGF0YXNldEluZGV4KGV2ZW50LmVsZW1lbnQpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHByb3BhZ2F0ZSBFU0MgZXZlbnRcclxuICAgIHRoaXMuY29udHJvbHMub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5ldmVudERpc3BhdGNoZXIudHJpZ2dlcignY2xvc2UnKSk7XHJcblxyXG4gICAgdGhpcy5tZW51RWxlbWVudCA9IHRoaXMuY3JlYXRlTWVudUVsZW1lbnQoKTtcclxuICAgIHRoaXMuY3VycmVudFNsaWRlTWFya2VyRWxlbWVudCA9IHRoaXMuY3JlYXRlQ3VycmVudFNsaWRlTWFya2VyRWxlbWVudCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbmZpZ1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtLZXl3b3JkTWVudUl0ZW1Db25maWdbXX0ga2V5d29yZENvbmZpZ3NcclxuICAgKiBAcmV0dXJucyB7RWxlbWVudFtdfVxyXG4gICAqL1xyXG4gIGluaXQoa2V5d29yZENvbmZpZ3MpIHtcclxuICAgIHRoaXMubWVudUl0ZW1FbGVtZW50cyA9IGtleXdvcmRDb25maWdzLm1hcChjb25maWcgPT4gdGhpcy5jcmVhdGVNZW51SXRlbUVsZW1lbnQoY29uZmlnKSk7XHJcbiAgICB0aGlzLm1lbnVJdGVtRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHRoaXMubWVudUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCkpO1xyXG4gICAgdGhpcy5tZW51SXRlbUVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB0aGlzLmNvbnRyb2xzLmFkZEVsZW1lbnQoZWxlbWVudCkpO1xyXG5cclxuICAgIHRoaXMuc2V0Q3VycmVudFNsaWRlSW5kZXgodGhpcy5zdGF0ZS5jdXJyZW50SW5kZXgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLm1lbnVJdGVtRWxlbWVudHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudCBsaXN0ZW5lclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcclxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAqL1xyXG4gIG9uKG5hbWUsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihuYW1lLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBtZW51IGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0RWxlbWVudCgpIHtcclxuICAgIHJldHVybiB0aGlzLm1lbnVFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBhbGwgbWVudSBpdGVtc1xyXG4gICAqL1xyXG4gIHJlbW92ZUFsbE1lbnVJdGVtRWxlbWVudHMoKSB7XHJcbiAgICB0aGlzLm1lbnVJdGVtRWxlbWVudHNcclxuICAgICAgLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgICAgdGhpcy5jb250cm9scy5yZW1vdmVFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMubWVudUVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHRoaXMubWVudUl0ZW1FbGVtZW50cyA9IFtdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG1lbnUgZWxlbWVudFxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgY3JlYXRlTWVudUVsZW1lbnQoKSB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5tZW51RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51Jyk7XHJcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2xpc3QtdW5zdHlsZWQnKTtcclxuICAgIHJldHVybiBlbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIG1lbnVpdGVtXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0tleXdvcmRNZW51SXRlbUNvbmZpZ30gY29uZmlnXHJcbiAgICogQHJldHVybiB7RWxlbWVudH1cclxuICAgKi9cclxuICBjcmVhdGVNZW51SXRlbUVsZW1lbnQoY29uZmlnKSB7XHJcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcclxuXHJcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdtZW51aXRlbScpO1xyXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGV2ZW50ID0+IHtcclxuICAgICAgdGhpcy5vbk1lbnVJdGVtU2VsZWN0KGdldEVsZW1lbnRzRGF0YXNldEluZGV4KGV2ZW50LmN1cnJlbnRUYXJnZXQpKTtcclxuICAgIH0pO1xyXG4gICAgdGhpcy5hcHBseUNvbmZpZ1RvTWVudUl0ZW1FbGVtZW50KGVsZW1lbnQsIGNvbmZpZyk7XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBcHBsaWVzIGEgY29uZmlnIHRvIGEgbWVudSBpdGVtIGVsZW1lbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7S2V5d29yZE1lbnVJdGVtQ29uZmlnfSBjb25maWdcclxuICAgKi9cclxuICBhcHBseUNvbmZpZ1RvTWVudUl0ZW1FbGVtZW50KGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImg1cC1rZXl3b3JkLXN1YnRpdGxlXCI+JHtjb25maWcuc3VidGl0bGV9PC9kaXY+PHNwYW4gY2xhc3M9XCJoNXAta2V5d29yZC10aXRsZVwiPiR7Y29uZmlnLnRpdGxlfTwvc3Bhbj5gO1xyXG4gICAgZWxlbWVudC5kYXRhc2V0LmluZGV4ID0gY29uZmlnLmluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGFuZGxlcyBzZWxlY3RpbmcgbWVudSBpdGVtXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAZmlyZXMgS2V5d29yZE1lbnUjc2VsZWN0XHJcbiAgICovXHJcbiAgb25NZW51SXRlbVNlbGVjdChpbmRleCkge1xyXG4gICAgdGhpcy5zZXRDdXJyZW50U2xpZGVJbmRleChpbmRleCk7XHJcbiAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci50cmlnZ2VyKCdzZWxlY3QnLCB7IGluZGV4IH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgY3VycmVudCBzbGlkZSBpbmRleFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgc2V0Q3VycmVudFNsaWRlSW5kZXgoaW5kZXgpIHtcclxuICAgIGNvbnN0IHNlbGVjdGVkRWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudEJ5SW5kZXgodGhpcy5tZW51SXRlbUVsZW1lbnRzLCBpbmRleCk7XHJcblxyXG4gICAgaWYgKHNlbGVjdGVkRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnN0YXRlLmN1cnJlbnRJbmRleCA9IGluZGV4O1xyXG4gICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRseVNlbGVjdGVkKHRoaXMubWVudUl0ZW1FbGVtZW50cywgdGhpcy5zdGF0ZSk7XHJcbiAgICAgIHRoaXMuY29udHJvbHMuc2V0VGFiYmFibGUoc2VsZWN0ZWRFbGVtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGg1cC1jdXJyZW50IGNsYXNzIG9uIHRoZSBlbGVtZW50IGxpc3RcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSB7S2V5d29yZE1lbnVTdGF0ZX0gc3RhdGVcclxuICAgKi9cclxuICB1cGRhdGVDdXJyZW50bHlTZWxlY3RlZChlbGVtZW50cywgc3RhdGUpIHtcclxuICAgIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XHJcbiAgICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSBzdGF0ZS5jdXJyZW50SW5kZXggPT09IGdldEVsZW1lbnRzRGF0YXNldEluZGV4KGVsZW1lbnQpO1xyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ2g1cC1jdXJyZW50JywgaXNTZWxlY3RlZCk7XHJcblxyXG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xyXG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50U2xpZGVNYXJrZXJFbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgdG8gY3VycmVudCBrZXl3b3Jkcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIHNjcm9sbFRvS2V5d29yZHMoaW5kZXgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnRUb1Njcm9sbFRvID0gdGhpcy5nZXRGaXJzdEVsZW1lbnRBZnRlcihpbmRleCk7XHJcblxyXG4gICAgaWYgKGVsZW1lbnRUb1Njcm9sbFRvKSB7XHJcbiAgICAgIGNvbnN0ICRtZW51ID0gJCh0aGlzLm1lbnVFbGVtZW50KTtcclxuICAgICAgY29uc3QgbW92ZSA9ICRtZW51LnNjcm9sbFRvcCgpICsgJChlbGVtZW50VG9TY3JvbGxUbykucG9zaXRpb24oKS50b3AgLSA4O1xyXG5cclxuICAgICAgaWYgKGlzSVBhZCkge1xyXG4gICAgICAgICRtZW51LnNjcm9sbFRvcChtb3ZlKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICAkbWVudS5zdG9wKCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogbW92ZSB9LCAyNTApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggYW4gaW5kZXggbGFyZ2VyIHRoZW4gdmFsdWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0Rmlyc3RFbGVtZW50QWZ0ZXIoaW5kZXgpIHtcclxuICAgIHJldHVybiB0aGlzLm1lbnVJdGVtRWxlbWVudHMuZmlsdGVyKGVsZW1lbnQgPT4gZ2V0RWxlbWVudHNEYXRhc2V0SW5kZXgoZWxlbWVudCkgPj0gaW5kZXgpWzBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZWxlbWVudCB3aXRoIGEgZ2l2ZW4gaW5kZXhcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgZ2V0RWxlbWVudEJ5SW5kZXgoZWxlbWVudHMsIGluZGV4KSB7XHJcbiAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKGVsZW1lbnQgPT4gZ2V0RWxlbWVudHNEYXRhc2V0SW5kZXgoZWxlbWVudCkgPT09IGluZGV4KVswXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBoaWRkZW4gZWxlbWVudCwgdGhhdCB3aWxsIHJlYWQgXCJDdXJyZW50IHNsaWRlXCJcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9XHJcbiAgICovXHJcbiAgY3JlYXRlQ3VycmVudFNsaWRlTWFya2VyRWxlbWVudCgpIHtcclxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaGlkZGVuLWJ1dC1yZWFkJyk7XHJcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRoaXMubDEwbi5jdXJyZW50U2xpZGU7XHJcbiAgICByZXR1cm4gZWxlbWVudDtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIkNvbnRyb2xzIiwiVUlLZXlib2FyZCIsImlzSVBhZCIsImRlZmF1bHRWYWx1ZSIsImpRdWVyeSIsIiQiLCJFdmVudERpc3BhdGNoZXIiLCJnZXRFbGVtZW50c0RhdGFzZXRJbmRleCIsImVsZW1lbnQiLCJwYXJzZUludCIsImRhdGFzZXQiLCJpbmRleCIsIktleXdvcmRNZW51IiwibDEwbiIsImN1cnJlbnRJbmRleCIsInN0YXRlIiwiZXZlbnREaXNwYXRjaGVyIiwiY29udHJvbHMiLCJvbiIsImV2ZW50Iiwib25NZW51SXRlbVNlbGVjdCIsInRyaWdnZXIiLCJtZW51RWxlbWVudCIsImNyZWF0ZU1lbnVFbGVtZW50IiwiY3VycmVudFNsaWRlTWFya2VyRWxlbWVudCIsImNyZWF0ZUN1cnJlbnRTbGlkZU1hcmtlckVsZW1lbnQiLCJpbml0Iiwia2V5d29yZENvbmZpZ3MiLCJtZW51SXRlbUVsZW1lbnRzIiwibWFwIiwiY29uZmlnIiwiY3JlYXRlTWVudUl0ZW1FbGVtZW50IiwiZm9yRWFjaCIsImFwcGVuZENoaWxkIiwiYWRkRWxlbWVudCIsInNldEN1cnJlbnRTbGlkZUluZGV4IiwibmFtZSIsImNhbGxiYWNrIiwiZ2V0RWxlbWVudCIsInJlbW92ZUFsbE1lbnVJdGVtRWxlbWVudHMiLCJyZW1vdmVFbGVtZW50IiwicmVtb3ZlQ2hpbGQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJjbGFzc0xpc3QiLCJhZGQiLCJhZGRFdmVudExpc3RlbmVyIiwiY3VycmVudFRhcmdldCIsImFwcGx5Q29uZmlnVG9NZW51SXRlbUVsZW1lbnQiLCJpbm5lckhUTUwiLCJzdWJ0aXRsZSIsInRpdGxlIiwic2VsZWN0ZWRFbGVtZW50IiwiZ2V0RWxlbWVudEJ5SW5kZXgiLCJ1cGRhdGVDdXJyZW50bHlTZWxlY3RlZCIsInNldFRhYmJhYmxlIiwiZWxlbWVudHMiLCJpc1NlbGVjdGVkIiwidG9nZ2xlIiwic2Nyb2xsVG9LZXl3b3JkcyIsImVsZW1lbnRUb1Njcm9sbFRvIiwiZ2V0Rmlyc3RFbGVtZW50QWZ0ZXIiLCIkbWVudSIsIm1vdmUiLCJzY3JvbGxUb3AiLCJwb3NpdGlvbiIsInRvcCIsInN0b3AiLCJhbmltYXRlIiwiZmlsdGVyIiwiY3VycmVudFNsaWRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./scripts/keyword-menu.js\n");

/***/ }),

/***/ "./scripts/navigation-line.js":
/*!************************************!*\
  !*** ./scripts/navigation-line.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _printer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./printer */ \"./scripts/printer.js\");\n/* harmony import */ var h5p_lib_controls_src_scripts_controls__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! h5p-lib-controls/src/scripts/controls */ \"../node_modules/h5p-lib-controls/src/scripts/controls.js\");\n/* harmony import */ var h5p_lib_controls_src_scripts_ui_keyboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! h5p-lib-controls/src/scripts/ui/keyboard */ \"../node_modules/h5p-lib-controls/src/scripts/ui/keyboard.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n/**\r\n * Enum indicating which state a navigation bar part is in\r\n * @enum {string}\r\n */\n\nvar answeredState = {\n  NO_INTERACTIONS: 'none',\n  NOT_ANSWERED: 'not-answered',\n  ANSWERED: 'answered',\n  CORRECT: 'has-only-correct',\n  INCORRECT: 'has-incorrect'\n};\n/**\r\n * @class\r\n */\n\nvar NavigationLine = function ($) {\n  function NavigationLine(coursePresentation) {\n    var _this$answeredLabels;\n\n    this.cp = coursePresentation;\n    /**\r\n     * Mapping for labels indicating the answered state of a part\r\n     * @property {Object.<answeredState, string>} answeredLabels\r\n     */\n\n    this.answeredLabels = (_this$answeredLabels = {}, _defineProperty(_this$answeredLabels, answeredState.NOT_ANSWERED, this.cp.l10n.containsNotCompleted + '.'), _defineProperty(_this$answeredLabels, answeredState.ANSWERED, this.cp.l10n.containsCompleted + '.'), _defineProperty(_this$answeredLabels, answeredState.CORRECT, this.cp.l10n.containsOnlyCorrect + '.'), _defineProperty(_this$answeredLabels, answeredState.INCORRECT, this.cp.l10n.containsIncorrectAnswers + '.'), _defineProperty(_this$answeredLabels, answeredState.NO_INTERACTIONS, ''), _this$answeredLabels);\n    this.initProgressbar(this.cp.slidesWithSolutions);\n    this.initFooter();\n    this.initTaskAnsweredListener();\n    this.toggleNextAndPreviousButtonDisabled(this.cp.getCurrentSlideIndex());\n  }\n  /**\r\n   * Initializes xAPI event listener, updates progressbar when a task is changed.\r\n   */\n\n\n  NavigationLine.prototype.initTaskAnsweredListener = function () {\n    var _this = this;\n\n    this.cp.elementInstances.forEach(function (slide, index) {\n      slide.filter(function (interaction) {\n        return (0,_utils__WEBPACK_IMPORTED_MODULE_3__.isFunction)(interaction.on);\n      }).forEach(function (interaction) {\n        interaction.on('xAPI', function (event) {\n          var shortVerb = event.getVerb();\n\n          if ((0,_utils__WEBPACK_IMPORTED_MODULE_3__.contains)(['interacted', 'answered', 'attempted'], shortVerb)) {\n            var isAnswered = _this.cp.slideHasAnsweredTask(index);\n\n            _this.setTaskAnswered(index, isAnswered);\n          } else if (shortVerb === 'completed') {\n            event.setVerb('answered');\n          }\n\n          if (event.data.statement.context.extensions === undefined) {\n            event.data.statement.context.extensions = {};\n          }\n\n          event.data.statement.context.extensions['http://id.tincanapi.com/extension/ending-point'] = index + 1;\n        });\n      });\n    });\n  };\n  /**\r\n   * Initialize progress bar\r\n   */\n\n\n  NavigationLine.prototype.initProgressbar = function (slidesWithSolutions) {\n    var that = this;\n    var currentSlideIndex = that.cp.previousState && that.cp.previousState.progress || 0;\n    this.progresbarKeyboardControls = new h5p_lib_controls_src_scripts_controls__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([new h5p_lib_controls_src_scripts_ui_keyboard__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()]);\n    this.progresbarKeyboardControls.negativeTabIndexAllowed = true;\n    this.progresbarKeyboardControls.on('select', function (event) {\n      that.displaySlide($(event.element).data('slideNumber'));\n    }); // if last element, prevent next progression\n\n    this.progresbarKeyboardControls.on('beforeNextElement', function (event) {\n      return event.index !== event.elements.length - 1;\n    }); // if first element, prevent previous progression\n\n    this.progresbarKeyboardControls.on('beforePreviousElement', function (event) {\n      return event.index !== 0;\n    }); // Remove existing progressbar\n\n    if (this.cp.progressbarParts !== undefined && this.cp.progressbarParts) {\n      this.cp.progressbarParts.forEach(function (part) {\n        that.progresbarKeyboardControls.removeElement(part.children('a').get(0));\n        part.remove();\n      });\n    }\n\n    that.cp.progressbarParts = [];\n\n    var clickProgressbar = function clickProgressbar(event) {\n      event.preventDefault();\n      var index = $(this).data('slideNumber');\n      that.progresbarKeyboardControls.setTabbableByIndex(index);\n      that.displaySlide(index);\n      that.cp.focus();\n    };\n\n    for (var i = 0; i < this.cp.slides.length; i += 1) {\n      var slide = this.cp.slides[i];\n      var progressbarPartTitle = this.createSlideTitle(i); // create tab item\n\n      var $li = $('<div>', {\n        'class': 'h5p-progressbar-part',\n        'id': 'progressbar-part-' + i,\n        'role': 'tab',\n        'aria-label': progressbarPartTitle,\n        'aria-controls': 'slide-' + i,\n        'aria-selected': false\n      }).appendTo(that.cp.$progressbar); // create link\n\n      var $link = $('<a>', {\n        href: '#',\n        html: '<span class=\"h5p-progressbar-part-title hidden-but-read\">' + progressbarPartTitle + '</span>',\n        tabindex: '-1'\n      }).data('slideNumber', i).click(clickProgressbar).appendTo($li);\n      this.progresbarKeyboardControls.addElement($link.get(0));\n\n      if (this.isSummarySlide(i)) {\n        $li.addClass('progressbar-part-summary-slide');\n      } // Add hover effect if not an ipad or iphone.\n\n\n      if (!_utils__WEBPACK_IMPORTED_MODULE_3__.isIOS) {\n        H5P.Tooltip($li.get(0), {\n          position: 'top'\n        });\n      }\n\n      if (i === 0) {\n        $li.addClass('h5p-progressbar-part-show');\n      }\n\n      if (i === currentSlideIndex) {\n        $li.addClass('h5p-progressbar-part-selected').attr('aria-selected', true);\n      }\n\n      that.cp.progressbarParts.push($li);\n      this.updateSlideTitle(i); // Create task indicator if less than 60 slides and not in editor\n\n      if (this.cp.slides.length <= 60 && slide.elements && slide.elements.length > 0) {\n        var hasTask = slidesWithSolutions[i] && slidesWithSolutions[i].length > 0;\n        var isAnswered = !!(that.cp.previousState && that.cp.previousState.answered && that.cp.previousState.answered[i]);\n\n        if (hasTask) {\n          // Add task indicator\n          $('<div>', {\n            'class': 'h5p-progressbar-part-has-task'\n          }).appendTo($link);\n          this.setTaskAnswered(i, isAnswered);\n        }\n      }\n    }\n  };\n  /**\r\n   * Displays a slide\r\n   *\r\n   * @param {number} index\r\n   */\n\n\n  NavigationLine.prototype.displaySlide = function (index) {\n    var self = this; // navigate to slide\n\n    this.cp.jumpToSlide(index, false, function () {\n      var oldIndex = self.cp.getCurrentSlideIndex(); // update current progress task\n\n      self.updateSlideTitle(index, {\n        isCurrent: true\n      }); // update old progress task\n\n      self.updateSlideTitle(oldIndex, {\n        isCurrent: false\n      }); // toggle next and prev buttons\n\n      self.toggleNextAndPreviousButtonDisabled(index);\n    });\n  };\n  /**\r\n   * Generate tooltip for progress bar slides\r\n   *\r\n   * @param {number} slideNumber\r\n   * @return {string}\r\n   */\n\n\n  NavigationLine.prototype.createSlideTitle = function (slideNumber) {\n    var slide = this.cp.slides[slideNumber];\n    var hasKeyWords = slide.keywords && slide.keywords.length > 0;\n\n    if (hasKeyWords) {\n      return slide.keywords[0].main;\n    } else if (this.isSummarySlide(slideNumber)) {\n      return this.cp.l10n.summary;\n    } else {\n      return this.cp.l10n.slide + ' ' + (slideNumber + 1);\n    }\n  };\n  /**\r\n   *\r\n   * Returns true if slide with given index is summary slide\r\n   *\r\n   * @param {number} index\r\n   * @return {boolean}\r\n   */\n\n\n  NavigationLine.prototype.isSummarySlide = function (index) {\n    return !!(this.cp.editor === undefined && index === this.cp.slides.length - 1 && this.cp.showSummarySlide);\n  };\n  /**\r\n   * Initialize footer.\r\n   */\n\n\n  NavigationLine.prototype.initFooter = function () {\n    var _this2 = this;\n\n    var that = this;\n    var $footer = this.cp.$footer; // Inner footer adjustment containers\n\n    var $leftFooter = $('<div/>', {\n      'class': 'h5p-footer-left-adjusted'\n    }).appendTo($footer);\n    var $centerFooter = $('<div/>', {\n      'class': 'h5p-footer-center-adjusted'\n    }).appendTo($footer);\n    var $rightFooter = $('<div/>', {\n      'role': 'toolbar',\n      'class': 'h5p-footer-right-adjusted'\n    }).appendTo($footer); // Left footer elements\n    // Toggle keywords menu\n\n    this.cp.$keywordsButton = $('<div/>', {\n      'class': \"h5p-footer-button h5p-footer-toggle-keywords\",\n      'aria-expanded': 'false',\n      'aria-label': this.cp.l10n.showKeywords,\n      'role': 'button',\n      'tabindex': '0',\n      'html': '<span class=\"h5p-icon-menu\"></span><span class=\"current-slide-title\"></span>'\n    }).appendTo($leftFooter);\n    H5P.Tooltip(this.cp.$keywordsButton.get(0));\n    (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$keywordsButton, function (event) {\n      if (!that.cp.presentation.keywordListAlwaysShow) {\n        that.cp.toggleKeywords();\n        event.stopPropagation();\n      }\n    });\n\n    if (this.cp.presentation.keywordListAlwaysShow || !this.cp.initKeywords) {\n      this.cp.$keywordsButton.hide();\n    }\n\n    if (!this.cp.presentation.keywordListEnabled) {\n      // Hide in editor when disabled.\n      this.cp.$keywordsWrapper.add(this.$keywordsButton).hide();\n    } // Update keyword for first slide.\n\n\n    this.updateFooterKeyword(0); // Center footer elements\n    // Previous slide\n\n    this.cp.$prevSlideButton = $('<div/>', {\n      'class': 'h5p-footer-button h5p-footer-previous-slide',\n      'aria-label': this.cp.l10n.prevSlide,\n      'role': 'button',\n      'tabindex': '-1',\n      'aria-disabled': 'true'\n    }).appendTo($centerFooter);\n    new H5P.Tooltip(this.cp.$prevSlideButton.get(0), {\n      position: 'left'\n    });\n    (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$prevSlideButton, function () {\n      return _this2.cp.previousSlide(undefined, false);\n    });\n    var $slideNumbering = $('<div/>', {\n      'class': 'h5p-footer-slide-count'\n    }).appendTo($centerFooter); // Current slide count\n\n    this.cp.$footerCurrentSlide = $('<div/>', {\n      'html': '1',\n      'class': 'h5p-footer-slide-count-current',\n      'title': this.cp.l10n.currentSlide,\n      'aria-hidden': 'true'\n    }).appendTo($slideNumbering);\n    this.cp.$footerCounter = $('<div/>', {\n      'class': 'hidden-but-read',\n      'html': this.cp.l10n.slideCount.replace('@index', '1').replace('@total', this.cp.slides.length.toString())\n    }).appendTo($centerFooter); // Count delimiter, content configurable in css\n\n    $('<div/>', {\n      'html': '/',\n      'class': 'h5p-footer-slide-count-delimiter',\n      'aria-hidden': 'true'\n    }).appendTo($slideNumbering); // Max slide count\n\n    this.cp.$footerMaxSlide = $('<div/>', {\n      'html': this.cp.slides.length,\n      'class': 'h5p-footer-slide-count-max',\n      'title': this.cp.l10n.lastSlide,\n      'aria-hidden': 'true'\n    }).appendTo($slideNumbering); // Next slide\n\n    this.cp.$nextSlideButton = $('<div/>', {\n      'class': 'h5p-footer-button h5p-footer-next-slide',\n      'aria-label': this.cp.l10n.nextSlide,\n      'role': 'button',\n      'tabindex': '0'\n    }).appendTo($centerFooter);\n    H5P.Tooltip(this.cp.$nextSlideButton.get(0), {\n      position: 'right'\n    });\n    (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$nextSlideButton, function () {\n      return _this2.cp.nextSlide(undefined, false);\n    }); // *********************\n    // Right footer elements\n    // *********************\n    // Do not add these buttons in editor mode\n\n    if (this.cp.editor === undefined) {\n      // Exit solution mode button\n      this.cp.$exitSolutionModeButton = $('<div/>', {\n        'role': 'button',\n        'class': 'h5p-footer-exit-solution-mode',\n        'aria-label': this.cp.l10n.solutionModeTitle,\n        'tabindex': '0'\n      }).appendTo($rightFooter);\n      H5P.Tooltip(this.cp.$exitSolutionModeButton.get(0));\n      (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$exitSolutionModeButton, function () {\n        return that.cp.jumpToSlide(that.cp.slides.length - 1);\n      });\n\n      if (this.cp.enablePrintButton && _printer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supported()) {\n        this.cp.$printButton = $('<div/>', {\n          'class': 'h5p-footer-button h5p-footer-print',\n          'aria-label': this.cp.l10n.printTitle,\n          'role': 'button',\n          'tabindex': '0'\n        }).appendTo($rightFooter);\n        H5P.Tooltip(this.cp.$printButton.get(0));\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$printButton, function () {\n          return that.openPrintDialog();\n        });\n      }\n\n      if (H5P.fullscreenSupported) {\n        // Toggle full screen button\n        this.cp.$fullScreenButton = $('<div/>', {\n          'class': 'h5p-footer-button h5p-footer-toggle-full-screen',\n          'aria-label': this.cp.l10n.fullscreen,\n          'role': 'button',\n          'tabindex': '0'\n        });\n        H5P.Tooltip(this.cp.$fullScreenButton.get(0), {\n          position: 'left'\n        });\n        (0,_utils__WEBPACK_IMPORTED_MODULE_3__.addClickAndKeyboardListeners)(this.cp.$fullScreenButton, function () {\n          return that.cp.toggleFullScreen();\n        });\n        this.cp.$fullScreenButton.appendTo($rightFooter);\n      }\n    } // Solution mode text\n\n\n    this.cp.$exitSolutionModeText = $('<div/>', {\n      'html': '',\n      'class': 'h5p-footer-exit-solution-mode-text'\n    }).appendTo(this.cp.$exitSolutionModeButton);\n  };\n\n  NavigationLine.prototype.openPrintDialog = function () {\n    var _this3 = this;\n\n    var $h5pWrapper = $('.h5p-wrapper');\n    var $dialog = _printer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].showDialog(this.cp.l10n, $h5pWrapper, function (printAllSlides) {\n      _printer__WEBPACK_IMPORTED_MODULE_0__[\"default\"].print(_this3.cp, $h5pWrapper, printAllSlides);\n    });\n    $dialog.children('[role=\"dialog\"]').focus();\n  };\n  /**\r\n   * Updates progress bar.\r\n   */\n\n\n  NavigationLine.prototype.updateProgressBar = function (slideNumber, prevSlideNumber, solutionMode) {\n    var that = this; // Updates progress bar progress (blue line)\n\n    var i;\n\n    for (i = 0; i < that.cp.progressbarParts.length; i += 1) {\n      if (slideNumber + 1 > i) {\n        that.cp.progressbarParts[i].addClass('h5p-progressbar-part-show');\n      } else {\n        that.cp.progressbarParts[i].removeClass('h5p-progressbar-part-show');\n      }\n    }\n\n    that.progresbarKeyboardControls.setTabbableByIndex(slideNumber);\n    that.cp.progressbarParts[slideNumber].addClass(\"h5p-progressbar-part-selected\").attr('aria-selected', true).siblings().removeClass(\"h5p-progressbar-part-selected\").attr('aria-selected', false);\n\n    if (prevSlideNumber === undefined) {\n      that.cp.progressbarParts.forEach(function (part, i) {\n        that.setTaskAnswered(i, false);\n      });\n      return;\n    } // Don't mark answers as answered if in solution mode or editor mode.\n\n\n    if (solutionMode || that.cp.editor !== undefined) {\n      return;\n    }\n  };\n  /**\r\n   * Sets a part to be answered, or un answered\r\n   *\r\n   * @param {number} index\r\n   * @param {boolean} isAnswered\r\n   */\n\n\n  NavigationLine.prototype.setTaskAnswered = function (index, isAnswered) {\n    var $answeredIndicator = this.cp.progressbarParts[index].find('.h5p-progressbar-part-has-task');\n    $answeredIndicator.toggleClass('h5p-answered', isAnswered);\n    this.updateSlideTitle(index, {\n      state: isAnswered ? answeredState.ANSWERED : answeredState.NOT_ANSWERED\n    });\n  };\n  /**\r\n   * Updates a slides title with values from state, if overrides are not provided\r\n   *\r\n   * @param {number} index\r\n   * @param {object} [config]\r\n   * @param {answeredState} [config.state]\r\n   * @param {boolean} [config.isCurrent]\r\n   */\n\n\n  NavigationLine.prototype.updateSlideTitle = function (index) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        state = _ref.state;\n\n    this.setSlideTitle(index, {\n      state: (0,_utils__WEBPACK_IMPORTED_MODULE_3__.defaultValue)(state, this.getAnsweredState(index))\n    });\n  };\n  /**\r\n   * Sets a part to be answered, or un answered\r\n   *\r\n   * @param {number} index\r\n   * @param {answeredState} [state]\r\n   * @param {boolean} [isCurrent]\r\n   */\n\n\n  NavigationLine.prototype.setSlideTitle = function (index, _ref2) {\n    var _ref2$state = _ref2.state,\n        state = _ref2$state === void 0 ? answeredState.NO_INTERACTIONS : _ref2$state;\n    var $part = this.cp.progressbarParts[index];\n    var $partTitle = $part.find('.h5p-progressbar-part-title');\n    var answeredLabel = this.answeredLabels[state].replace('@slideName', this.createSlideTitle(index));\n    $partTitle.html(\"\".concat(answeredLabel));\n  };\n  /**\r\n   * Returns the answered state of a given slide\r\n   *\r\n   * @param {number} index\r\n   * @return {answeredState}\r\n   */\n\n\n  NavigationLine.prototype.getAnsweredState = function (index) {\n    var $part = this.cp.progressbarParts[index];\n    var hasTask = this.slideHasInteraction(index);\n    var isAnswered = this.cp.slideHasAnsweredTask(index);\n\n    if (!hasTask) {\n      return answeredState.NO_INTERACTIONS;\n    } else if ($part.find('.h5p-is-correct').length > 0) {\n      return answeredState.CORRECT;\n    } else if ($part.find('.h5p-is-wrong').length > 0) {\n      return answeredState.INCORRECT;\n    } else if (isAnswered) {\n      return answeredState.ANSWERED;\n    } else {\n      return answeredState.NOT_ANSWERED;\n    }\n  };\n  /**\r\n   * Returns true if a slide was initiated with an interaction\r\n   *\r\n   * @param {number} index\r\n   * @return {boolean}\r\n   */\n\n\n  NavigationLine.prototype.slideHasInteraction = function (index) {\n    return this.cp.progressbarParts[index].find('.h5p-progressbar-part-has-task').length > 0;\n  };\n  /**\r\n   * Update footer with current slide data\r\n   *\r\n   * @param {Number} slideNumber Current slide number\r\n   */\n\n\n  NavigationLine.prototype.updateFooter = function (slideNumber) {\n    // Update current slide number in footer\n    this.cp.$footerCurrentSlide.html(slideNumber + 1);\n    this.cp.$footerMaxSlide.html(this.cp.slides.length);\n    this.cp.$footerCounter.html(this.cp.l10n.slideCount.replace('@index', (slideNumber + 1).toString()).replace('@total', this.cp.slides.length.toString())); // Hide exit solution mode button on summary slide\n\n    if (this.cp.isSolutionMode && slideNumber === this.cp.slides.length - 1) {\n      this.cp.$footer.addClass('summary-slide');\n    } else {\n      this.cp.$footer.removeClass('summary-slide');\n    }\n\n    this.toggleNextAndPreviousButtonDisabled(slideNumber); // Update keyword in footer\n\n    this.updateFooterKeyword(slideNumber);\n  };\n  /**\r\n   * Disables previous button if on the first slide,\r\n   * and disables the next button if on the last slide\r\n   *\r\n   * @param {number} index\r\n   */\n\n\n  NavigationLine.prototype.toggleNextAndPreviousButtonDisabled = function (index) {\n    var lastSlideIndex = this.cp.slides.length - 1;\n    this.cp.$prevSlideButton.attr('aria-disabled', (index === 0).toString());\n    this.cp.$nextSlideButton.attr('aria-disabled', (index === lastSlideIndex).toString());\n    this.cp.$prevSlideButton.attr('tabindex', index === 0 ? '-1' : '0');\n    this.cp.$nextSlideButton.attr('tabindex', index === lastSlideIndex ? '-1' : '0');\n  };\n  /**\r\n   * Update keyword in footer with current slide data\r\n   *\r\n   * @param {Number} slideNumber Current slide number\r\n   */\n\n\n  NavigationLine.prototype.updateFooterKeyword = function (slideNumber) {\n    var currentSlide = this.cp.slides[slideNumber];\n    var keywordString = ''; // Get current keyword\n\n    if (currentSlide && currentSlide.keywords && currentSlide.keywords[0]) {\n      keywordString = currentSlide.keywords[0].main;\n    } // Summary slide keyword\n\n\n    if (!this.cp.isEditor() && this.cp.showSummarySlide && slideNumber >= this.cp.slides.length - 1) {\n      keywordString = this.cp.l10n.summary;\n    } // Set footer keyword\n\n\n    this.cp.$keywordsButton.children('.current-slide-title').html((0,_utils__WEBPACK_IMPORTED_MODULE_3__.defaultValue)(keywordString, ''));\n  };\n\n  return NavigationLine;\n}(H5P.jQuery);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavigationLine);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z2F0aW9uLWxpbmUuanM/YmQwNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUHJpbnRlciBmcm9tICcuL3ByaW50ZXInO1xyXG5pbXBvcnQgQ29udHJvbHMgZnJvbSAnaDVwLWxpYi1jb250cm9scy9zcmMvc2NyaXB0cy9jb250cm9scyc7XHJcbmltcG9ydCBVSUtleWJvYXJkIGZyb20gJ2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvdWkva2V5Ym9hcmQnO1xyXG5pbXBvcnQgeyBkZWZhdWx0VmFsdWUsIGNvbnRhaW5zLCBpc0Z1bmN0aW9uLCBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzLCBpc0lPUyB9IGZyb20gJy4vdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEVudW0gaW5kaWNhdGluZyB3aGljaCBzdGF0ZSBhIG5hdmlnYXRpb24gYmFyIHBhcnQgaXMgaW5cclxuICogQGVudW0ge3N0cmluZ31cclxuICovXHJcbmNvbnN0IGFuc3dlcmVkU3RhdGUgPSB7XHJcbiAgTk9fSU5URVJBQ1RJT05TOiAnbm9uZScsXHJcbiAgTk9UX0FOU1dFUkVEOiAnbm90LWFuc3dlcmVkJyxcclxuICBBTlNXRVJFRDogJ2Fuc3dlcmVkJyxcclxuICBDT1JSRUNUOiAnaGFzLW9ubHktY29ycmVjdCcsXHJcbiAgSU5DT1JSRUNUOiAnaGFzLWluY29ycmVjdCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmNvbnN0IE5hdmlnYXRpb25MaW5lID0gKGZ1bmN0aW9uICgkKSB7XHJcbiAgZnVuY3Rpb24gTmF2aWdhdGlvbkxpbmUoY291cnNlUHJlc2VudGF0aW9uKSB7XHJcbiAgICB0aGlzLmNwID0gY291cnNlUHJlc2VudGF0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcGluZyBmb3IgbGFiZWxzIGluZGljYXRpbmcgdGhlIGFuc3dlcmVkIHN0YXRlIG9mIGEgcGFydFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3QuPGFuc3dlcmVkU3RhdGUsIHN0cmluZz59IGFuc3dlcmVkTGFiZWxzXHJcbiAgICAgKi9cclxuICAgIHRoaXMuYW5zd2VyZWRMYWJlbHMgPSB7XHJcbiAgICAgIFthbnN3ZXJlZFN0YXRlLk5PVF9BTlNXRVJFRF06IHRoaXMuY3AubDEwbi5jb250YWluc05vdENvbXBsZXRlZCArICcuJyxcclxuICAgICAgW2Fuc3dlcmVkU3RhdGUuQU5TV0VSRURdOiB0aGlzLmNwLmwxMG4uY29udGFpbnNDb21wbGV0ZWQgKyAnLicsXHJcbiAgICAgIFthbnN3ZXJlZFN0YXRlLkNPUlJFQ1RdOiB0aGlzLmNwLmwxMG4uY29udGFpbnNPbmx5Q29ycmVjdCArICcuJyxcclxuICAgICAgW2Fuc3dlcmVkU3RhdGUuSU5DT1JSRUNUXTogdGhpcy5jcC5sMTBuLmNvbnRhaW5zSW5jb3JyZWN0QW5zd2VycyArICcuJyxcclxuICAgICAgW2Fuc3dlcmVkU3RhdGUuTk9fSU5URVJBQ1RJT05TXTogJycsXHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuaW5pdFByb2dyZXNzYmFyKHRoaXMuY3Auc2xpZGVzV2l0aFNvbHV0aW9ucyk7XHJcbiAgICB0aGlzLmluaXRGb290ZXIoKTtcclxuICAgIHRoaXMuaW5pdFRhc2tBbnN3ZXJlZExpc3RlbmVyKCk7XHJcbiAgICB0aGlzLnRvZ2dsZU5leHRBbmRQcmV2aW91c0J1dHRvbkRpc2FibGVkKHRoaXMuY3AuZ2V0Q3VycmVudFNsaWRlSW5kZXgoKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbml0aWFsaXplcyB4QVBJIGV2ZW50IGxpc3RlbmVyLCB1cGRhdGVzIHByb2dyZXNzYmFyIHdoZW4gYSB0YXNrIGlzIGNoYW5nZWQuXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLmluaXRUYXNrQW5zd2VyZWRMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuY3AuZWxlbWVudEluc3RhbmNlcy5mb3JFYWNoKChzbGlkZSwgaW5kZXgpID0+IHtcclxuICAgICAgc2xpZGVcclxuICAgICAgICAuZmlsdGVyKGludGVyYWN0aW9uID0+IGlzRnVuY3Rpb24oaW50ZXJhY3Rpb24ub24pKVxyXG4gICAgICAgIC5mb3JFYWNoKGludGVyYWN0aW9uID0+IHtcclxuICAgICAgICAgIGludGVyYWN0aW9uLm9uKCd4QVBJJywgKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNob3J0VmVyYiA9IGV2ZW50LmdldFZlcmIoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjb250YWlucyhbJ2ludGVyYWN0ZWQnLCAnYW5zd2VyZWQnLCAnYXR0ZW1wdGVkJ10sIHNob3J0VmVyYikpIHtcclxuICAgICAgICAgICAgICBjb25zdCBpc0Fuc3dlcmVkID0gdGhpcy5jcC5zbGlkZUhhc0Fuc3dlcmVkVGFzayhpbmRleCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXRUYXNrQW5zd2VyZWQoaW5kZXgsIGlzQW5zd2VyZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNob3J0VmVyYiA9PT0gJ2NvbXBsZXRlZCcpIHtcclxuICAgICAgICAgICAgICBldmVudC5zZXRWZXJiKCdhbnN3ZXJlZCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoZXZlbnQuZGF0YS5zdGF0ZW1lbnQuY29udGV4dC5leHRlbnNpb25zID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICBldmVudC5kYXRhLnN0YXRlbWVudC5jb250ZXh0LmV4dGVuc2lvbnMgPSB7fTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZXZlbnQuZGF0YS5zdGF0ZW1lbnQuY29udGV4dC5leHRlbnNpb25zWydodHRwOi8vaWQudGluY2FuYXBpLmNvbS9leHRlbnNpb24vZW5kaW5nLXBvaW50J10gPSBpbmRleCArIDE7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEluaXRpYWxpemUgcHJvZ3Jlc3MgYmFyXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLmluaXRQcm9ncmVzc2JhciA9IGZ1bmN0aW9uIChzbGlkZXNXaXRoU29sdXRpb25zKSB7XHJcbiAgICBjb25zdCB0aGF0ID0gdGhpcztcclxuICAgIGNvbnN0IGN1cnJlbnRTbGlkZUluZGV4ID0gKHRoYXQuY3AucHJldmlvdXNTdGF0ZSAmJiB0aGF0LmNwLnByZXZpb3VzU3RhdGUucHJvZ3Jlc3MpIHx8IDA7XHJcblxyXG4gICAgdGhpcy5wcm9ncmVzYmFyS2V5Ym9hcmRDb250cm9scyA9IG5ldyBDb250cm9scyhbbmV3IFVJS2V5Ym9hcmQoKV0pO1xyXG4gICAgdGhpcy5wcm9ncmVzYmFyS2V5Ym9hcmRDb250cm9scy5uZWdhdGl2ZVRhYkluZGV4QWxsb3dlZCA9IHRydWU7XHJcbiAgICB0aGlzLnByb2dyZXNiYXJLZXlib2FyZENvbnRyb2xzLm9uKCdzZWxlY3QnLCBldmVudCA9PiB7XHJcbiAgICAgIHRoYXQuZGlzcGxheVNsaWRlKCQoZXZlbnQuZWxlbWVudCkuZGF0YSgnc2xpZGVOdW1iZXInKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBpZiBsYXN0IGVsZW1lbnQsIHByZXZlbnQgbmV4dCBwcm9ncmVzc2lvblxyXG4gICAgdGhpcy5wcm9ncmVzYmFyS2V5Ym9hcmRDb250cm9scy5vbignYmVmb3JlTmV4dEVsZW1lbnQnLCBldmVudCA9PiBldmVudC5pbmRleCAhPT0gKGV2ZW50LmVsZW1lbnRzLmxlbmd0aCAtIDEpKTtcclxuXHJcbiAgICAvLyBpZiBmaXJzdCBlbGVtZW50LCBwcmV2ZW50IHByZXZpb3VzIHByb2dyZXNzaW9uXHJcbiAgICB0aGlzLnByb2dyZXNiYXJLZXlib2FyZENvbnRyb2xzLm9uKCdiZWZvcmVQcmV2aW91c0VsZW1lbnQnLCBldmVudCA9PiBldmVudC5pbmRleCAhPT0gMCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHByb2dyZXNzYmFyXHJcbiAgICBpZiAodGhpcy5jcC5wcm9ncmVzc2JhclBhcnRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5jcC5wcm9ncmVzc2JhclBhcnRzKSB7XHJcbiAgICAgIHRoaXMuY3AucHJvZ3Jlc3NiYXJQYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJ0KSB7XHJcbiAgICAgICAgdGhhdC5wcm9ncmVzYmFyS2V5Ym9hcmRDb250cm9scy5yZW1vdmVFbGVtZW50KHBhcnQuY2hpbGRyZW4oJ2EnKS5nZXQoMCkpO1xyXG4gICAgICAgIHBhcnQucmVtb3ZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHRoYXQuY3AucHJvZ3Jlc3NiYXJQYXJ0cyA9IFtdO1xyXG5cclxuICAgIGNvbnN0IGNsaWNrUHJvZ3Jlc3NiYXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgY29uc3QgaW5kZXggPSAkKHRoaXMpLmRhdGEoJ3NsaWRlTnVtYmVyJyk7XHJcbiAgICAgIHRoYXQucHJvZ3Jlc2JhcktleWJvYXJkQ29udHJvbHMuc2V0VGFiYmFibGVCeUluZGV4KGluZGV4KTtcclxuICAgICAgdGhhdC5kaXNwbGF5U2xpZGUoaW5kZXgpO1xyXG4gICAgICB0aGF0LmNwLmZvY3VzKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jcC5zbGlkZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLmNwLnNsaWRlc1tpXTtcclxuICAgICAgY29uc3QgcHJvZ3Jlc3NiYXJQYXJ0VGl0bGUgPSB0aGlzLmNyZWF0ZVNsaWRlVGl0bGUoaSk7XHJcblxyXG4gICAgICAvLyBjcmVhdGUgdGFiIGl0ZW1cclxuICAgICAgY29uc3QgJGxpID0gJCgnPGRpdj4nLCB7XHJcbiAgICAgICAgJ2NsYXNzJzogJ2g1cC1wcm9ncmVzc2Jhci1wYXJ0JyxcclxuICAgICAgICAnaWQnOiAncHJvZ3Jlc3NiYXItcGFydC0nICsgaSxcclxuICAgICAgICAncm9sZSc6ICd0YWInLFxyXG4gICAgICAgICdhcmlhLWxhYmVsJzogcHJvZ3Jlc3NiYXJQYXJ0VGl0bGUsXHJcbiAgICAgICAgJ2FyaWEtY29udHJvbHMnOiAnc2xpZGUtJyArIGksXHJcbiAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBmYWxzZSxcclxuICAgICAgfSlcclxuICAgICAgICAuYXBwZW5kVG8odGhhdC5jcC4kcHJvZ3Jlc3NiYXIpO1xyXG5cclxuICAgICAgLy8gY3JlYXRlIGxpbmtcclxuICAgICAgY29uc3QgJGxpbmsgPSAkKCc8YT4nLCB7XHJcbiAgICAgICAgaHJlZjogJyMnLFxyXG4gICAgICAgIGh0bWw6ICc8c3BhbiBjbGFzcz1cImg1cC1wcm9ncmVzc2Jhci1wYXJ0LXRpdGxlIGhpZGRlbi1idXQtcmVhZFwiPicgKyBwcm9ncmVzc2JhclBhcnRUaXRsZSArICc8L3NwYW4+JyxcclxuICAgICAgICB0YWJpbmRleDogJy0xJ1xyXG4gICAgICB9KS5kYXRhKCdzbGlkZU51bWJlcicsIGkpXHJcbiAgICAgICAgLmNsaWNrKGNsaWNrUHJvZ3Jlc3NiYXIpXHJcbiAgICAgICAgLmFwcGVuZFRvKCRsaSk7XHJcblxyXG4gICAgICB0aGlzLnByb2dyZXNiYXJLZXlib2FyZENvbnRyb2xzLmFkZEVsZW1lbnQoJGxpbmsuZ2V0KDApKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmlzU3VtbWFyeVNsaWRlKGkpKSB7XHJcbiAgICAgICAgJGxpLmFkZENsYXNzKCdwcm9ncmVzc2Jhci1wYXJ0LXN1bW1hcnktc2xpZGUnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQWRkIGhvdmVyIGVmZmVjdCBpZiBub3QgYW4gaXBhZCBvciBpcGhvbmUuXHJcbiAgICAgIGlmICghaXNJT1MpIHtcclxuICAgICAgICBINVAuVG9vbHRpcCgkbGkuZ2V0KDApLCB7cG9zaXRpb246ICd0b3AnfSk7XHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBpZiAoaSA9PT0gMCkge1xyXG4gICAgICAgICRsaS5hZGRDbGFzcygnaDVwLXByb2dyZXNzYmFyLXBhcnQtc2hvdycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaSA9PT0gY3VycmVudFNsaWRlSW5kZXgpIHtcclxuICAgICAgICAkbGkuYWRkQ2xhc3MoJ2g1cC1wcm9ncmVzc2Jhci1wYXJ0LXNlbGVjdGVkJylcclxuICAgICAgICAgIC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoYXQuY3AucHJvZ3Jlc3NiYXJQYXJ0cy5wdXNoKCRsaSk7XHJcblxyXG4gICAgICB0aGlzLnVwZGF0ZVNsaWRlVGl0bGUoaSk7XHJcblxyXG4gICAgICAvLyBDcmVhdGUgdGFzayBpbmRpY2F0b3IgaWYgbGVzcyB0aGFuIDYwIHNsaWRlcyBhbmQgbm90IGluIGVkaXRvclxyXG4gICAgICBpZiAodGhpcy5jcC5zbGlkZXMubGVuZ3RoIDw9IDYwICYmIHNsaWRlLmVsZW1lbnRzICYmIHNsaWRlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICB2YXIgaGFzVGFzayA9IHNsaWRlc1dpdGhTb2x1dGlvbnNbaV0gJiYgc2xpZGVzV2l0aFNvbHV0aW9uc1tpXS5sZW5ndGggPiAwO1xyXG4gICAgICAgIHZhciBpc0Fuc3dlcmVkID0gISEodGhhdC5jcC5wcmV2aW91c1N0YXRlICYmIHRoYXQuY3AucHJldmlvdXNTdGF0ZS5hbnN3ZXJlZCAmJiB0aGF0LmNwLnByZXZpb3VzU3RhdGUuYW5zd2VyZWRbaV0pO1xyXG5cclxuICAgICAgICBpZiAoaGFzVGFzaykge1xyXG4gICAgICAgICAgLy8gQWRkIHRhc2sgaW5kaWNhdG9yXHJcbiAgICAgICAgICAkKCc8ZGl2PicsIHtcclxuICAgICAgICAgICAgJ2NsYXNzJzogJ2g1cC1wcm9ncmVzc2Jhci1wYXJ0LWhhcy10YXNrJ1xyXG4gICAgICAgICAgfSkuYXBwZW5kVG8oJGxpbmspO1xyXG5cclxuICAgICAgICAgIHRoaXMuc2V0VGFza0Fuc3dlcmVkKGksIGlzQW5zd2VyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BsYXlzIGEgc2xpZGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS5kaXNwbGF5U2xpZGUgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIC8vIG5hdmlnYXRlIHRvIHNsaWRlXHJcbiAgICB0aGlzLmNwLmp1bXBUb1NsaWRlKGluZGV4LCBmYWxzZSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBjb25zdCBvbGRJbmRleCA9IHNlbGYuY3AuZ2V0Q3VycmVudFNsaWRlSW5kZXgoKTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBjdXJyZW50IHByb2dyZXNzIHRhc2tcclxuICAgICAgc2VsZi51cGRhdGVTbGlkZVRpdGxlKGluZGV4LCB7IGlzQ3VycmVudDogdHJ1ZSB9KTtcclxuXHJcbiAgICAgIC8vIHVwZGF0ZSBvbGQgcHJvZ3Jlc3MgdGFza1xyXG4gICAgICBzZWxmLnVwZGF0ZVNsaWRlVGl0bGUob2xkSW5kZXgsIHsgaXNDdXJyZW50OiBmYWxzZSB9KTtcclxuXHJcbiAgICAgIC8vIHRvZ2dsZSBuZXh0IGFuZCBwcmV2IGJ1dHRvbnNcclxuICAgICAgc2VsZi50b2dnbGVOZXh0QW5kUHJldmlvdXNCdXR0b25EaXNhYmxlZChpbmRleCk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSB0b29sdGlwIGZvciBwcm9ncmVzcyBiYXIgc2xpZGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2xpZGVOdW1iZXJcclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLmNyZWF0ZVNsaWRlVGl0bGUgPSBmdW5jdGlvbiAoc2xpZGVOdW1iZXIpIHtcclxuICAgIGNvbnN0IHNsaWRlID0gdGhpcy5jcC5zbGlkZXNbc2xpZGVOdW1iZXJdO1xyXG4gICAgY29uc3QgaGFzS2V5V29yZHMgPSBzbGlkZS5rZXl3b3JkcyAmJiBzbGlkZS5rZXl3b3Jkcy5sZW5ndGggPiAwO1xyXG5cclxuICAgIGlmIChoYXNLZXlXb3Jkcykge1xyXG4gICAgICByZXR1cm4gc2xpZGUua2V5d29yZHNbMF0ubWFpbjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRoaXMuaXNTdW1tYXJ5U2xpZGUoc2xpZGVOdW1iZXIpKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNwLmwxMG4uc3VtbWFyeTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcC5sMTBuLnNsaWRlICsgJyAnICsgKHNsaWRlTnVtYmVyICsgMSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICpcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgc2xpZGUgd2l0aCBnaXZlbiBpbmRleCBpcyBzdW1tYXJ5IHNsaWRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS5pc1N1bW1hcnlTbGlkZSA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgcmV0dXJuICEhKCh0aGlzLmNwLmVkaXRvciA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAmJiAoaW5kZXggPT09IHRoaXMuY3Auc2xpZGVzLmxlbmd0aCAtIDEpXHJcbiAgICAgICYmIHRoaXMuY3Auc2hvd1N1bW1hcnlTbGlkZSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBmb290ZXIuXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLmluaXRGb290ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICB2YXIgJGZvb3RlciA9IHRoaXMuY3AuJGZvb3RlcjtcclxuXHJcbiAgICAvLyBJbm5lciBmb290ZXIgYWRqdXN0bWVudCBjb250YWluZXJzXHJcbiAgICB2YXIgJGxlZnRGb290ZXIgPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICdjbGFzcyc6ICdoNXAtZm9vdGVyLWxlZnQtYWRqdXN0ZWQnXHJcbiAgICB9KS5hcHBlbmRUbygkZm9vdGVyKTtcclxuXHJcbiAgICB2YXIgJGNlbnRlckZvb3RlciA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItY2VudGVyLWFkanVzdGVkJ1xyXG4gICAgfSkuYXBwZW5kVG8oJGZvb3Rlcik7XHJcblxyXG4gICAgdmFyICRyaWdodEZvb3RlciA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgJ3JvbGUnOiAndG9vbGJhcicsXHJcbiAgICAgICdjbGFzcyc6ICdoNXAtZm9vdGVyLXJpZ2h0LWFkanVzdGVkJ1xyXG4gICAgfSkuYXBwZW5kVG8oJGZvb3Rlcik7XHJcblxyXG4gICAgLy8gTGVmdCBmb290ZXIgZWxlbWVudHNcclxuXHJcbiAgICAvLyBUb2dnbGUga2V5d29yZHMgbWVudVxyXG4gICAgdGhpcy5jcC4ka2V5d29yZHNCdXR0b24gPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICdjbGFzcyc6IFwiaDVwLWZvb3Rlci1idXR0b24gaDVwLWZvb3Rlci10b2dnbGUta2V5d29yZHNcIixcclxuICAgICAgJ2FyaWEtZXhwYW5kZWQnOiAnZmFsc2UnLFxyXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuY3AubDEwbi5zaG93S2V5d29yZHMsXHJcbiAgICAgICdyb2xlJzogJ2J1dHRvbicsXHJcbiAgICAgICd0YWJpbmRleCc6ICcwJyxcclxuICAgICAgJ2h0bWwnOiAnPHNwYW4gY2xhc3M9XCJoNXAtaWNvbi1tZW51XCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwiY3VycmVudC1zbGlkZS10aXRsZVwiPjwvc3Bhbj4nXHJcbiAgICB9KS5hcHBlbmRUbygkbGVmdEZvb3Rlcik7XHJcblxyXG4gICAgSDVQLlRvb2x0aXAodGhpcy5jcC4ka2V5d29yZHNCdXR0b24uZ2V0KDApKTtcclxuXHJcbiAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKHRoaXMuY3AuJGtleXdvcmRzQnV0dG9uLCBldmVudCA9PiB7XHJcbiAgICAgIGlmICghdGhhdC5jcC5wcmVzZW50YXRpb24ua2V5d29yZExpc3RBbHdheXNTaG93KSB7XHJcbiAgICAgICAgdGhhdC5jcC50b2dnbGVLZXl3b3JkcygpO1xyXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5jcC5wcmVzZW50YXRpb24ua2V5d29yZExpc3RBbHdheXNTaG93IHx8ICF0aGlzLmNwLmluaXRLZXl3b3Jkcykge1xyXG4gICAgICB0aGlzLmNwLiRrZXl3b3Jkc0J1dHRvbi5oaWRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmNwLnByZXNlbnRhdGlvbi5rZXl3b3JkTGlzdEVuYWJsZWQpIHtcclxuICAgICAgLy8gSGlkZSBpbiBlZGl0b3Igd2hlbiBkaXNhYmxlZC5cclxuICAgICAgdGhpcy5jcC4ka2V5d29yZHNXcmFwcGVyLmFkZCh0aGlzLiRrZXl3b3Jkc0J1dHRvbikuaGlkZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBrZXl3b3JkIGZvciBmaXJzdCBzbGlkZS5cclxuICAgIHRoaXMudXBkYXRlRm9vdGVyS2V5d29yZCgwKTtcclxuXHJcbiAgICAvLyBDZW50ZXIgZm9vdGVyIGVsZW1lbnRzXHJcblxyXG4gICAgLy8gUHJldmlvdXMgc2xpZGVcclxuICAgIHRoaXMuY3AuJHByZXZTbGlkZUJ1dHRvbiA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItYnV0dG9uIGg1cC1mb290ZXItcHJldmlvdXMtc2xpZGUnLFxyXG4gICAgICAnYXJpYS1sYWJlbCc6IHRoaXMuY3AubDEwbi5wcmV2U2xpZGUsXHJcbiAgICAgICdyb2xlJzogJ2J1dHRvbicsXHJcbiAgICAgICd0YWJpbmRleCc6ICctMScsXHJcbiAgICAgICdhcmlhLWRpc2FibGVkJzogJ3RydWUnXHJcbiAgICB9KS5hcHBlbmRUbygkY2VudGVyRm9vdGVyKTtcclxuXHJcbiAgICBuZXcgSDVQLlRvb2x0aXAodGhpcy5jcC4kcHJldlNsaWRlQnV0dG9uLmdldCgwKSwge3Bvc2l0aW9uOiAnbGVmdCd9KTtcclxuXHJcbiAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKHRoaXMuY3AuJHByZXZTbGlkZUJ1dHRvbiwgKCkgPT4gdGhpcy5jcC5wcmV2aW91c1NsaWRlKHVuZGVmaW5lZCwgZmFsc2UpKTtcclxuXHJcbiAgICBjb25zdCAkc2xpZGVOdW1iZXJpbmcgPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICdjbGFzcyc6ICdoNXAtZm9vdGVyLXNsaWRlLWNvdW50J1xyXG4gICAgfSkuYXBwZW5kVG8oJGNlbnRlckZvb3Rlcik7XHJcblxyXG4gICAgLy8gQ3VycmVudCBzbGlkZSBjb3VudFxyXG4gICAgdGhpcy5jcC4kZm9vdGVyQ3VycmVudFNsaWRlID0gJCgnPGRpdi8+Jywge1xyXG4gICAgICAnaHRtbCc6ICcxJyxcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItc2xpZGUtY291bnQtY3VycmVudCcsXHJcbiAgICAgICd0aXRsZSc6IHRoaXMuY3AubDEwbi5jdXJyZW50U2xpZGUsXHJcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xyXG4gICAgfSkuYXBwZW5kVG8oJHNsaWRlTnVtYmVyaW5nKTtcclxuXHJcbiAgICB0aGlzLmNwLiRmb290ZXJDb3VudGVyID0gJCgnPGRpdi8+Jywge1xyXG4gICAgICAnY2xhc3MnOiAnaGlkZGVuLWJ1dC1yZWFkJyxcclxuICAgICAgJ2h0bWwnOiB0aGlzLmNwLmwxMG4uc2xpZGVDb3VudFxyXG4gICAgICAgIC5yZXBsYWNlKCdAaW5kZXgnLCAnMScpXHJcbiAgICAgICAgLnJlcGxhY2UoJ0B0b3RhbCcsIHRoaXMuY3Auc2xpZGVzLmxlbmd0aC50b1N0cmluZygpKVxyXG4gICAgfSkuYXBwZW5kVG8oJGNlbnRlckZvb3Rlcik7XHJcblxyXG4gICAgLy8gQ291bnQgZGVsaW1pdGVyLCBjb250ZW50IGNvbmZpZ3VyYWJsZSBpbiBjc3NcclxuICAgICQoJzxkaXYvPicsIHtcclxuICAgICAgJ2h0bWwnOiAnLycsXHJcbiAgICAgICdjbGFzcyc6ICdoNXAtZm9vdGVyLXNsaWRlLWNvdW50LWRlbGltaXRlcicsXHJcbiAgICAgICdhcmlhLWhpZGRlbic6ICd0cnVlJ1xyXG4gICAgfSkuYXBwZW5kVG8oJHNsaWRlTnVtYmVyaW5nKTtcclxuXHJcbiAgICAvLyBNYXggc2xpZGUgY291bnRcclxuICAgIHRoaXMuY3AuJGZvb3Rlck1heFNsaWRlID0gJCgnPGRpdi8+Jywge1xyXG4gICAgICAnaHRtbCc6IHRoaXMuY3Auc2xpZGVzLmxlbmd0aCxcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItc2xpZGUtY291bnQtbWF4JyxcclxuICAgICAgJ3RpdGxlJzogdGhpcy5jcC5sMTBuLmxhc3RTbGlkZSxcclxuICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnXHJcbiAgICB9KS5hcHBlbmRUbygkc2xpZGVOdW1iZXJpbmcpO1xyXG5cclxuICAgIC8vIE5leHQgc2xpZGVcclxuICAgIHRoaXMuY3AuJG5leHRTbGlkZUJ1dHRvbiA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItYnV0dG9uIGg1cC1mb290ZXItbmV4dC1zbGlkZScsXHJcbiAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5jcC5sMTBuLm5leHRTbGlkZSxcclxuICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcclxuICAgICAgJ3RhYmluZGV4JzogJzAnXHJcbiAgICB9KS5hcHBlbmRUbygkY2VudGVyRm9vdGVyKTtcclxuXHJcbiAgICBINVAuVG9vbHRpcCh0aGlzLmNwLiRuZXh0U2xpZGVCdXR0b24uZ2V0KDApLCB7cG9zaXRpb246ICdyaWdodCd9KTtcclxuXHJcbiAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKHRoaXMuY3AuJG5leHRTbGlkZUJ1dHRvbiwgKCkgPT4gdGhpcy5jcC5uZXh0U2xpZGUodW5kZWZpbmVkLCBmYWxzZSkpO1xyXG5cclxuICAgIC8vICoqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgLy8gUmlnaHQgZm9vdGVyIGVsZW1lbnRzXHJcbiAgICAvLyAqKioqKioqKioqKioqKioqKioqKipcclxuXHJcbiAgICAvLyBEbyBub3QgYWRkIHRoZXNlIGJ1dHRvbnMgaW4gZWRpdG9yIG1vZGVcclxuICAgIGlmICh0aGlzLmNwLmVkaXRvciA9PT0gdW5kZWZpbmVkKSB7XHJcblxyXG4gICAgICAvLyBFeGl0IHNvbHV0aW9uIG1vZGUgYnV0dG9uXHJcbiAgICAgIHRoaXMuY3AuJGV4aXRTb2x1dGlvbk1vZGVCdXR0b24gPSAkKCc8ZGl2Lz4nLCB7XHJcbiAgICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcclxuICAgICAgICAnY2xhc3MnOiAnaDVwLWZvb3Rlci1leGl0LXNvbHV0aW9uLW1vZGUnLFxyXG4gICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5jcC5sMTBuLnNvbHV0aW9uTW9kZVRpdGxlLFxyXG4gICAgICAgICd0YWJpbmRleCc6ICcwJ1xyXG4gICAgICB9KS5hcHBlbmRUbygkcmlnaHRGb290ZXIpO1xyXG5cclxuICAgICAgSDVQLlRvb2x0aXAodGhpcy5jcC4kZXhpdFNvbHV0aW9uTW9kZUJ1dHRvbi5nZXQoMCkpO1xyXG5cclxuICAgICAgYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyh0aGlzLmNwLiRleGl0U29sdXRpb25Nb2RlQnV0dG9uLCAoKSA9PiB0aGF0LmNwLmp1bXBUb1NsaWRlKHRoYXQuY3Auc2xpZGVzLmxlbmd0aCAtIDEpKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmNwLmVuYWJsZVByaW50QnV0dG9uICYmIFByaW50ZXIuc3VwcG9ydGVkKCkpIHtcclxuICAgICAgICB0aGlzLmNwLiRwcmludEJ1dHRvbiA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgICAgICdjbGFzcyc6ICdoNXAtZm9vdGVyLWJ1dHRvbiBoNXAtZm9vdGVyLXByaW50JyxcclxuICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5jcC5sMTBuLnByaW50VGl0bGUsXHJcbiAgICAgICAgICAncm9sZSc6ICdidXR0b24nLFxyXG4gICAgICAgICAgJ3RhYmluZGV4JzogJzAnXHJcbiAgICAgICAgfSkuYXBwZW5kVG8oJHJpZ2h0Rm9vdGVyKTtcclxuXHJcbiAgICAgICAgSDVQLlRvb2x0aXAodGhpcy5jcC4kcHJpbnRCdXR0b24uZ2V0KDApKTtcclxuXHJcbiAgICAgICAgYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyh0aGlzLmNwLiRwcmludEJ1dHRvbiwgKCkgPT4gdGhhdC5vcGVuUHJpbnREaWFsb2coKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChINVAuZnVsbHNjcmVlblN1cHBvcnRlZCkge1xyXG4gICAgICAgIC8vIFRvZ2dsZSBmdWxsIHNjcmVlbiBidXR0b25cclxuICAgICAgICB0aGlzLmNwLiRmdWxsU2NyZWVuQnV0dG9uID0gJCgnPGRpdi8+Jywge1xyXG4gICAgICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItYnV0dG9uIGg1cC1mb290ZXItdG9nZ2xlLWZ1bGwtc2NyZWVuJyxcclxuICAgICAgICAgICdhcmlhLWxhYmVsJzogdGhpcy5jcC5sMTBuLmZ1bGxzY3JlZW4sXHJcbiAgICAgICAgICAncm9sZSc6ICdidXR0b24nLFxyXG4gICAgICAgICAgJ3RhYmluZGV4JzogJzAnXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIEg1UC5Ub29sdGlwKHRoaXMuY3AuJGZ1bGxTY3JlZW5CdXR0b24uZ2V0KDApLCB7cG9zaXRpb246ICdsZWZ0J30pO1xyXG5cclxuICAgICAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKHRoaXMuY3AuJGZ1bGxTY3JlZW5CdXR0b24sICgpID0+IHRoYXQuY3AudG9nZ2xlRnVsbFNjcmVlbigpKTtcclxuXHJcbiAgICAgICAgdGhpcy5jcC4kZnVsbFNjcmVlbkJ1dHRvbi5hcHBlbmRUbygkcmlnaHRGb290ZXIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29sdXRpb24gbW9kZSB0ZXh0XHJcbiAgICB0aGlzLmNwLiRleGl0U29sdXRpb25Nb2RlVGV4dCA9ICQoJzxkaXYvPicsIHtcclxuICAgICAgJ2h0bWwnOiAnJyxcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1mb290ZXItZXhpdC1zb2x1dGlvbi1tb2RlLXRleHQnXHJcbiAgICB9KS5hcHBlbmRUbyh0aGlzLmNwLiRleGl0U29sdXRpb25Nb2RlQnV0dG9uKTtcclxuICB9O1xyXG5cclxuXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLm9wZW5QcmludERpYWxvZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGNvbnN0ICRoNXBXcmFwcGVyID0gJCgnLmg1cC13cmFwcGVyJyk7XHJcbiAgICBjb25zdCAkZGlhbG9nID0gUHJpbnRlci5zaG93RGlhbG9nKHRoaXMuY3AubDEwbiwgJGg1cFdyYXBwZXIsIChwcmludEFsbFNsaWRlcykgPT4ge1xyXG4gICAgICBQcmludGVyLnByaW50KHRoaXMuY3AsICRoNXBXcmFwcGVyLCBwcmludEFsbFNsaWRlcyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAkZGlhbG9nLmNoaWxkcmVuKCdbcm9sZT1cImRpYWxvZ1wiXScpLmZvY3VzKCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyBwcm9ncmVzcyBiYXIuXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLnVwZGF0ZVByb2dyZXNzQmFyID0gZnVuY3Rpb24gKHNsaWRlTnVtYmVyLCBwcmV2U2xpZGVOdW1iZXIsIHNvbHV0aW9uTW9kZSkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8vIFVwZGF0ZXMgcHJvZ3Jlc3MgYmFyIHByb2dyZXNzIChibHVlIGxpbmUpXHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCB0aGF0LmNwLnByb2dyZXNzYmFyUGFydHMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgaWYgKHNsaWRlTnVtYmVyICsgMSA+IGkpIHtcclxuICAgICAgICB0aGF0LmNwLnByb2dyZXNzYmFyUGFydHNbaV0uYWRkQ2xhc3MoJ2g1cC1wcm9ncmVzc2Jhci1wYXJ0LXNob3cnKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGF0LmNwLnByb2dyZXNzYmFyUGFydHNbaV0ucmVtb3ZlQ2xhc3MoJ2g1cC1wcm9ncmVzc2Jhci1wYXJ0LXNob3cnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoYXQucHJvZ3Jlc2JhcktleWJvYXJkQ29udHJvbHMuc2V0VGFiYmFibGVCeUluZGV4KHNsaWRlTnVtYmVyKTtcclxuXHJcbiAgICB0aGF0LmNwLnByb2dyZXNzYmFyUGFydHNbc2xpZGVOdW1iZXJdXHJcbiAgICAgIC5hZGRDbGFzcyhcImg1cC1wcm9ncmVzc2Jhci1wYXJ0LXNlbGVjdGVkXCIpXHJcbiAgICAgIC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSlcclxuICAgICAgLnNpYmxpbmdzKClcclxuICAgICAgICAucmVtb3ZlQ2xhc3MoXCJoNXAtcHJvZ3Jlc3NiYXItcGFydC1zZWxlY3RlZFwiKVxyXG4gICAgICAgIC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xyXG5cclxuICAgIGlmIChwcmV2U2xpZGVOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGF0LmNwLnByb2dyZXNzYmFyUGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCwgaSkge1xyXG4gICAgICAgIHRoYXQuc2V0VGFza0Fuc3dlcmVkKGksIGZhbHNlKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIERvbid0IG1hcmsgYW5zd2VycyBhcyBhbnN3ZXJlZCBpZiBpbiBzb2x1dGlvbiBtb2RlIG9yIGVkaXRvciBtb2RlLlxyXG4gICAgaWYgKHNvbHV0aW9uTW9kZSB8fCAodGhhdC5jcC5lZGl0b3IgIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYSBwYXJ0IHRvIGJlIGFuc3dlcmVkLCBvciB1biBhbnN3ZXJlZFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0Fuc3dlcmVkXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLnNldFRhc2tBbnN3ZXJlZCA9IGZ1bmN0aW9uIChpbmRleCwgaXNBbnN3ZXJlZCkge1xyXG4gICAgY29uc3QgJGFuc3dlcmVkSW5kaWNhdG9yID0gdGhpcy5jcC5wcm9ncmVzc2JhclBhcnRzW2luZGV4XS5maW5kKCcuaDVwLXByb2dyZXNzYmFyLXBhcnQtaGFzLXRhc2snKTtcclxuXHJcbiAgICAkYW5zd2VyZWRJbmRpY2F0b3IudG9nZ2xlQ2xhc3MoJ2g1cC1hbnN3ZXJlZCcsIGlzQW5zd2VyZWQpO1xyXG4gICAgdGhpcy51cGRhdGVTbGlkZVRpdGxlKGluZGV4LCB7IHN0YXRlOiBpc0Fuc3dlcmVkID8gYW5zd2VyZWRTdGF0ZS5BTlNXRVJFRCA6IGFuc3dlcmVkU3RhdGUuTk9UX0FOU1dFUkVEIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgYSBzbGlkZXMgdGl0bGUgd2l0aCB2YWx1ZXMgZnJvbSBzdGF0ZSwgaWYgb3ZlcnJpZGVzIGFyZSBub3QgcHJvdmlkZWRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnXVxyXG4gICAqIEBwYXJhbSB7YW5zd2VyZWRTdGF0ZX0gW2NvbmZpZy5zdGF0ZV1cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb25maWcuaXNDdXJyZW50XVxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS51cGRhdGVTbGlkZVRpdGxlID0gZnVuY3Rpb24gKGluZGV4LCB7IHN0YXRlIH0gPSB7fSkge1xyXG4gICAgdGhpcy5zZXRTbGlkZVRpdGxlKGluZGV4LCB7XHJcbiAgICAgIHN0YXRlOiBkZWZhdWx0VmFsdWUoc3RhdGUsIHRoaXMuZ2V0QW5zd2VyZWRTdGF0ZShpbmRleCkpLFxyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIHBhcnQgdG8gYmUgYW5zd2VyZWQsIG9yIHVuIGFuc3dlcmVkXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcGFyYW0ge2Fuc3dlcmVkU3RhdGV9IFtzdGF0ZV1cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0N1cnJlbnRdXHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLnNldFNsaWRlVGl0bGUgPSBmdW5jdGlvbiAoaW5kZXgsIHsgc3RhdGUgPSBhbnN3ZXJlZFN0YXRlLk5PX0lOVEVSQUNUSU9OUyB9KSB7XHJcbiAgICBjb25zdCAkcGFydCA9IHRoaXMuY3AucHJvZ3Jlc3NiYXJQYXJ0c1tpbmRleF07XHJcbiAgICBjb25zdCAkcGFydFRpdGxlID0gJHBhcnQuZmluZCgnLmg1cC1wcm9ncmVzc2Jhci1wYXJ0LXRpdGxlJyk7XHJcbiAgICBjb25zdCBhbnN3ZXJlZExhYmVsID0gdGhpcy5hbnN3ZXJlZExhYmVsc1tzdGF0ZV0ucmVwbGFjZSgnQHNsaWRlTmFtZScsIHRoaXMuY3JlYXRlU2xpZGVUaXRsZShpbmRleCkpO1xyXG4gICAgXHJcbiAgICAkcGFydFRpdGxlLmh0bWwoYCR7YW5zd2VyZWRMYWJlbH1gKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBhbnN3ZXJlZCBzdGF0ZSBvZiBhIGdpdmVuIHNsaWRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJuIHthbnN3ZXJlZFN0YXRlfVxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS5nZXRBbnN3ZXJlZFN0YXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICBjb25zdCAkcGFydCA9IHRoaXMuY3AucHJvZ3Jlc3NiYXJQYXJ0c1tpbmRleF07XHJcbiAgICBjb25zdCBoYXNUYXNrID0gdGhpcy5zbGlkZUhhc0ludGVyYWN0aW9uKGluZGV4KTtcclxuICAgIGNvbnN0IGlzQW5zd2VyZWQgPSB0aGlzLmNwLnNsaWRlSGFzQW5zd2VyZWRUYXNrKGluZGV4KTtcclxuXHJcbiAgICBpZiAoIWhhc1Rhc2spIHtcclxuICAgICAgcmV0dXJuIGFuc3dlcmVkU3RhdGUuTk9fSU5URVJBQ1RJT05TO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJHBhcnQuZmluZCgnLmg1cC1pcy1jb3JyZWN0JykubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gYW5zd2VyZWRTdGF0ZS5DT1JSRUNUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJHBhcnQuZmluZCgnLmg1cC1pcy13cm9uZycpLmxlbmd0aCA+IDApIHtcclxuICAgICAgcmV0dXJuIGFuc3dlcmVkU3RhdGUuSU5DT1JSRUNUO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNBbnN3ZXJlZCkge1xyXG4gICAgICByZXR1cm4gYW5zd2VyZWRTdGF0ZS5BTlNXRVJFRDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICByZXR1cm4gYW5zd2VyZWRTdGF0ZS5OT1RfQU5TV0VSRUQ7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0cnVlIGlmIGEgc2xpZGUgd2FzIGluaXRpYXRlZCB3aXRoIGFuIGludGVyYWN0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJuIHtib29sZWFufVxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS5zbGlkZUhhc0ludGVyYWN0aW9uID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jcC5wcm9ncmVzc2JhclBhcnRzW2luZGV4XS5maW5kKCcuaDVwLXByb2dyZXNzYmFyLXBhcnQtaGFzLXRhc2snKS5sZW5ndGggPiAwO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBmb290ZXIgd2l0aCBjdXJyZW50IHNsaWRlIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzbGlkZU51bWJlciBDdXJyZW50IHNsaWRlIG51bWJlclxyXG4gICAqL1xyXG4gIE5hdmlnYXRpb25MaW5lLnByb3RvdHlwZS51cGRhdGVGb290ZXIgPSBmdW5jdGlvbiAoc2xpZGVOdW1iZXIpIHtcclxuICAgIC8vIFVwZGF0ZSBjdXJyZW50IHNsaWRlIG51bWJlciBpbiBmb290ZXJcclxuICAgIHRoaXMuY3AuJGZvb3RlckN1cnJlbnRTbGlkZS5odG1sKHNsaWRlTnVtYmVyICsgMSk7XHJcbiAgICB0aGlzLmNwLiRmb290ZXJNYXhTbGlkZS5odG1sKHRoaXMuY3Auc2xpZGVzLmxlbmd0aCk7XHJcblxyXG4gICAgdGhpcy5jcC4kZm9vdGVyQ291bnRlci5odG1sKHRoaXMuY3AubDEwbi5zbGlkZUNvdW50XHJcbiAgICAgIC5yZXBsYWNlKCdAaW5kZXgnLCAoc2xpZGVOdW1iZXIgKyAxKS50b1N0cmluZygpKVxyXG4gICAgICAucmVwbGFjZSgnQHRvdGFsJywgdGhpcy5jcC5zbGlkZXMubGVuZ3RoLnRvU3RyaW5nKCkpKTtcclxuXHJcbiAgICAvLyBIaWRlIGV4aXQgc29sdXRpb24gbW9kZSBidXR0b24gb24gc3VtbWFyeSBzbGlkZVxyXG4gICAgaWYgKHRoaXMuY3AuaXNTb2x1dGlvbk1vZGUgJiYgc2xpZGVOdW1iZXIgPT09IHRoaXMuY3Auc2xpZGVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgdGhpcy5jcC4kZm9vdGVyLmFkZENsYXNzKCdzdW1tYXJ5LXNsaWRlJyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5jcC4kZm9vdGVyLnJlbW92ZUNsYXNzKCdzdW1tYXJ5LXNsaWRlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy50b2dnbGVOZXh0QW5kUHJldmlvdXNCdXR0b25EaXNhYmxlZChzbGlkZU51bWJlcik7XHJcblxyXG4gICAgLy8gVXBkYXRlIGtleXdvcmQgaW4gZm9vdGVyXHJcbiAgICB0aGlzLnVwZGF0ZUZvb3RlcktleXdvcmQoc2xpZGVOdW1iZXIpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2FibGVzIHByZXZpb3VzIGJ1dHRvbiBpZiBvbiB0aGUgZmlyc3Qgc2xpZGUsXHJcbiAgICogYW5kIGRpc2FibGVzIHRoZSBuZXh0IGJ1dHRvbiBpZiBvbiB0aGUgbGFzdCBzbGlkZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgTmF2aWdhdGlvbkxpbmUucHJvdG90eXBlLnRvZ2dsZU5leHRBbmRQcmV2aW91c0J1dHRvbkRpc2FibGVkID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICBjb25zdCBsYXN0U2xpZGVJbmRleCA9IHRoaXMuY3Auc2xpZGVzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgdGhpcy5jcC4kcHJldlNsaWRlQnV0dG9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAoaW5kZXggPT09IDApLnRvU3RyaW5nKCkpO1xyXG4gICAgdGhpcy5jcC4kbmV4dFNsaWRlQnV0dG9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAoaW5kZXggPT09IGxhc3RTbGlkZUluZGV4KS50b1N0cmluZygpKTtcclxuICAgIHRoaXMuY3AuJHByZXZTbGlkZUJ1dHRvbi5hdHRyKCd0YWJpbmRleCcsIChpbmRleCA9PT0gMCkgPyAnLTEnIDogJzAnKTtcclxuICAgIHRoaXMuY3AuJG5leHRTbGlkZUJ1dHRvbi5hdHRyKCd0YWJpbmRleCcsIChpbmRleCA9PT0gbGFzdFNsaWRlSW5kZXgpID8gJy0xJyA6ICcwJyk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGtleXdvcmQgaW4gZm9vdGVyIHdpdGggY3VycmVudCBzbGlkZSBkYXRhXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge051bWJlcn0gc2xpZGVOdW1iZXIgQ3VycmVudCBzbGlkZSBudW1iZXJcclxuICAgKi9cclxuICBOYXZpZ2F0aW9uTGluZS5wcm90b3R5cGUudXBkYXRlRm9vdGVyS2V5d29yZCA9IGZ1bmN0aW9uIChzbGlkZU51bWJlcikge1xyXG4gICAgY29uc3QgY3VycmVudFNsaWRlID0gdGhpcy5jcC5zbGlkZXNbc2xpZGVOdW1iZXJdO1xyXG4gICAgbGV0IGtleXdvcmRTdHJpbmcgPSAnJztcclxuXHJcbiAgICAvLyBHZXQgY3VycmVudCBrZXl3b3JkXHJcbiAgICBpZiAoY3VycmVudFNsaWRlICYmIGN1cnJlbnRTbGlkZS5rZXl3b3JkcyAmJiBjdXJyZW50U2xpZGUua2V5d29yZHNbMF0pIHtcclxuICAgICAga2V5d29yZFN0cmluZyA9IGN1cnJlbnRTbGlkZS5rZXl3b3Jkc1swXS5tYWluO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN1bW1hcnkgc2xpZGUga2V5d29yZFxyXG4gICAgaWYgKCF0aGlzLmNwLmlzRWRpdG9yKCkgJiYgdGhpcy5jcC5zaG93U3VtbWFyeVNsaWRlICYmIChzbGlkZU51bWJlciA+PSB0aGlzLmNwLnNsaWRlcy5sZW5ndGggLSAxKSkge1xyXG4gICAgICBrZXl3b3JkU3RyaW5nID0gdGhpcy5jcC5sMTBuLnN1bW1hcnk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IGZvb3RlciBrZXl3b3JkXHJcbiAgICB0aGlzLmNwLiRrZXl3b3Jkc0J1dHRvblxyXG4gICAgICAuY2hpbGRyZW4oJy5jdXJyZW50LXNsaWRlLXRpdGxlJylcclxuICAgICAgLmh0bWwoZGVmYXVsdFZhbHVlKGtleXdvcmRTdHJpbmcsICcnKSk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIE5hdmlnYXRpb25MaW5lO1xyXG59KShINVAualF1ZXJ5KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE5hdmlnYXRpb25MaW5lO1xyXG4iXSwibmFtZXMiOlsiUHJpbnRlciIsIkNvbnRyb2xzIiwiVUlLZXlib2FyZCIsImRlZmF1bHRWYWx1ZSIsImNvbnRhaW5zIiwiaXNGdW5jdGlvbiIsImFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMiLCJpc0lPUyIsImFuc3dlcmVkU3RhdGUiLCJOT19JTlRFUkFDVElPTlMiLCJOT1RfQU5TV0VSRUQiLCJBTlNXRVJFRCIsIkNPUlJFQ1QiLCJJTkNPUlJFQ1QiLCJOYXZpZ2F0aW9uTGluZSIsIiQiLCJjb3Vyc2VQcmVzZW50YXRpb24iLCJjcCIsImFuc3dlcmVkTGFiZWxzIiwibDEwbiIsImNvbnRhaW5zTm90Q29tcGxldGVkIiwiY29udGFpbnNDb21wbGV0ZWQiLCJjb250YWluc09ubHlDb3JyZWN0IiwiY29udGFpbnNJbmNvcnJlY3RBbnN3ZXJzIiwiaW5pdFByb2dyZXNzYmFyIiwic2xpZGVzV2l0aFNvbHV0aW9ucyIsImluaXRGb290ZXIiLCJpbml0VGFza0Fuc3dlcmVkTGlzdGVuZXIiLCJ0b2dnbGVOZXh0QW5kUHJldmlvdXNCdXR0b25EaXNhYmxlZCIsImdldEN1cnJlbnRTbGlkZUluZGV4IiwicHJvdG90eXBlIiwiZWxlbWVudEluc3RhbmNlcyIsImZvckVhY2giLCJzbGlkZSIsImluZGV4IiwiZmlsdGVyIiwiaW50ZXJhY3Rpb24iLCJvbiIsImV2ZW50Iiwic2hvcnRWZXJiIiwiZ2V0VmVyYiIsImlzQW5zd2VyZWQiLCJzbGlkZUhhc0Fuc3dlcmVkVGFzayIsInNldFRhc2tBbnN3ZXJlZCIsInNldFZlcmIiLCJkYXRhIiwic3RhdGVtZW50IiwiY29udGV4dCIsImV4dGVuc2lvbnMiLCJ1bmRlZmluZWQiLCJ0aGF0IiwiY3VycmVudFNsaWRlSW5kZXgiLCJwcmV2aW91c1N0YXRlIiwicHJvZ3Jlc3MiLCJwcm9ncmVzYmFyS2V5Ym9hcmRDb250cm9scyIsIm5lZ2F0aXZlVGFiSW5kZXhBbGxvd2VkIiwiZGlzcGxheVNsaWRlIiwiZWxlbWVudCIsImVsZW1lbnRzIiwibGVuZ3RoIiwicHJvZ3Jlc3NiYXJQYXJ0cyIsInBhcnQiLCJyZW1vdmVFbGVtZW50IiwiY2hpbGRyZW4iLCJnZXQiLCJyZW1vdmUiLCJjbGlja1Byb2dyZXNzYmFyIiwicHJldmVudERlZmF1bHQiLCJzZXRUYWJiYWJsZUJ5SW5kZXgiLCJmb2N1cyIsImkiLCJzbGlkZXMiLCJwcm9ncmVzc2JhclBhcnRUaXRsZSIsImNyZWF0ZVNsaWRlVGl0bGUiLCIkbGkiLCJhcHBlbmRUbyIsIiRwcm9ncmVzc2JhciIsIiRsaW5rIiwiaHJlZiIsImh0bWwiLCJ0YWJpbmRleCIsImNsaWNrIiwiYWRkRWxlbWVudCIsImlzU3VtbWFyeVNsaWRlIiwiYWRkQ2xhc3MiLCJINVAiLCJUb29sdGlwIiwicG9zaXRpb24iLCJhdHRyIiwicHVzaCIsInVwZGF0ZVNsaWRlVGl0bGUiLCJoYXNUYXNrIiwiYW5zd2VyZWQiLCJzZWxmIiwianVtcFRvU2xpZGUiLCJvbGRJbmRleCIsImlzQ3VycmVudCIsInNsaWRlTnVtYmVyIiwiaGFzS2V5V29yZHMiLCJrZXl3b3JkcyIsIm1haW4iLCJzdW1tYXJ5IiwiZWRpdG9yIiwic2hvd1N1bW1hcnlTbGlkZSIsIiRmb290ZXIiLCIkbGVmdEZvb3RlciIsIiRjZW50ZXJGb290ZXIiLCIkcmlnaHRGb290ZXIiLCIka2V5d29yZHNCdXR0b24iLCJzaG93S2V5d29yZHMiLCJwcmVzZW50YXRpb24iLCJrZXl3b3JkTGlzdEFsd2F5c1Nob3ciLCJ0b2dnbGVLZXl3b3JkcyIsInN0b3BQcm9wYWdhdGlvbiIsImluaXRLZXl3b3JkcyIsImhpZGUiLCJrZXl3b3JkTGlzdEVuYWJsZWQiLCIka2V5d29yZHNXcmFwcGVyIiwiYWRkIiwidXBkYXRlRm9vdGVyS2V5d29yZCIsIiRwcmV2U2xpZGVCdXR0b24iLCJwcmV2U2xpZGUiLCJwcmV2aW91c1NsaWRlIiwiJHNsaWRlTnVtYmVyaW5nIiwiJGZvb3RlckN1cnJlbnRTbGlkZSIsImN1cnJlbnRTbGlkZSIsIiRmb290ZXJDb3VudGVyIiwic2xpZGVDb3VudCIsInJlcGxhY2UiLCJ0b1N0cmluZyIsIiRmb290ZXJNYXhTbGlkZSIsImxhc3RTbGlkZSIsIiRuZXh0U2xpZGVCdXR0b24iLCJuZXh0U2xpZGUiLCIkZXhpdFNvbHV0aW9uTW9kZUJ1dHRvbiIsInNvbHV0aW9uTW9kZVRpdGxlIiwiZW5hYmxlUHJpbnRCdXR0b24iLCJzdXBwb3J0ZWQiLCIkcHJpbnRCdXR0b24iLCJwcmludFRpdGxlIiwib3BlblByaW50RGlhbG9nIiwiZnVsbHNjcmVlblN1cHBvcnRlZCIsIiRmdWxsU2NyZWVuQnV0dG9uIiwiZnVsbHNjcmVlbiIsInRvZ2dsZUZ1bGxTY3JlZW4iLCIkZXhpdFNvbHV0aW9uTW9kZVRleHQiLCIkaDVwV3JhcHBlciIsIiRkaWFsb2ciLCJzaG93RGlhbG9nIiwicHJpbnRBbGxTbGlkZXMiLCJwcmludCIsInVwZGF0ZVByb2dyZXNzQmFyIiwicHJldlNsaWRlTnVtYmVyIiwic29sdXRpb25Nb2RlIiwicmVtb3ZlQ2xhc3MiLCJzaWJsaW5ncyIsIiRhbnN3ZXJlZEluZGljYXRvciIsImZpbmQiLCJ0b2dnbGVDbGFzcyIsInN0YXRlIiwic2V0U2xpZGVUaXRsZSIsImdldEFuc3dlcmVkU3RhdGUiLCIkcGFydCIsIiRwYXJ0VGl0bGUiLCJhbnN3ZXJlZExhYmVsIiwic2xpZGVIYXNJbnRlcmFjdGlvbiIsInVwZGF0ZUZvb3RlciIsImlzU29sdXRpb25Nb2RlIiwibGFzdFNsaWRlSW5kZXgiLCJrZXl3b3JkU3RyaW5nIiwiaXNFZGl0b3IiLCJqUXVlcnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/navigation-line.js\n");

/***/ }),

/***/ "./scripts/printer.js":
/*!****************************!*\
  !*** ./scripts/printer.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\n\n\nvar Printer = function ($) {\n  var nextPrinterDialogId = 0;\n  /**\r\n   * Printer class\r\n   * @class Printer\r\n   */\n\n  function Printer() {}\n  /**\r\n   * Check if printing is supported\r\n   *\r\n   * @method supported\r\n   * @static\r\n   * @return {boolean} True if supported, else false.\r\n   */\n\n\n  Printer.supported = function () {\n    // Need window.print to be available\n    return typeof window.print === 'function';\n  };\n  /**\r\n   * Do the actual printing\r\n   *\r\n   * @method print\r\n   * @static\r\n   * @param  {H5P.CoursePresentation} cp Reference to cp instance\r\n   * @param  {H5P.jQuery} $wrapper  The CP dom wrapper\r\n   * @param  {boolean} allSlides If true, all slides are printed. If false or\r\n   *                             undefined, the currentSlide is printed.\r\n   */\n\n\n  Printer.print = function (cp, $wrapper, allSlides) {\n    // Let CP know we are about to print\n    cp.trigger('printing', {\n      finished: false,\n      allSlides: allSlides\n    }); // Find height of a slide:\n\n    var $currentSlide = $('.h5p-slide.h5p-current');\n    var slideHeight = $currentSlide.height();\n    var slideWidth = $currentSlide.width(); // Use 670px as width when printing. We can't use 100% percent, since user can\n    // change between landscape and portrait without us ever knowing about it.\n    // More info: http://stackoverflow.com/a/11084797/2797106\n\n    var ratio = slideWidth / 670;\n    var $slides = $('.h5p-slide');\n    $slides.css({\n      height: slideHeight / ratio + 'px',\n      width: '670px',\n      fontSize: Math.floor(100 / ratio) + '%'\n    });\n    var wrapperHeight = $wrapper.height();\n    $wrapper.css('height', 'auto'); // Let printer css know which slides to print:\n\n    $slides.toggleClass('doprint', allSlides === true);\n    $currentSlide.addClass('doprint'); // Need timeout for some browsers.\n\n    setTimeout(function () {\n      // Do the actual printing of the iframe content\n      window.print(); // Reset CSS\n\n      $slides.css({\n        height: '',\n        width: '',\n        fontSize: ''\n      });\n      $wrapper.css('height', wrapperHeight + 'px'); // Let CP know we are finished printing\n\n      cp.trigger('printing', {\n        finished: true\n      });\n    }, 500);\n  };\n  /**\r\n   * Show the print dialog. Wanted to use H5P.Dialog, but it does not support getting a jQuery object as the content\r\n   *\r\n   * @method showDialog\r\n   * @param  {object}       texts    Translated texts\r\n   * @param  {H5P.jQuery}   $element Dom object to insert dialog after\r\n   * @param  {Function}     callback Function invoked when printing is done.\r\n   */\n\n\n  Printer.showDialog = function (texts, $element, callback) {\n    var self = this;\n    var instanceId = nextPrinterDialogId++;\n    var dialogTitleId = \"h5p-cp-print-dialog-\".concat(instanceId, \"-title\");\n    var ingressId = \"h5p-cp-print-dialog-\".concat(instanceId, \"-ingress\");\n    var $dialog = $(\"<div class=\\\"h5p-popup-dialog h5p-print-dialog\\\">\\n                      <div role=\\\"dialog\\\" aria-labelledby=\\\"\".concat(dialogTitleId, \"\\\" aria-describedby=\\\"\").concat(ingressId, \"\\\" tabindex=\\\"-1\\\" class=\\\"h5p-inner\\\">\\n                        <h2 id=\\\"\").concat(dialogTitleId, \"\\\">\").concat(texts.printTitle, \"</h2>\\n                        <div class=\\\"h5p-scroll-content\\\"></div>\\n                        <div class=\\\"h5p-close\\\" role=\\\"button\\\" tabindex=\\\"0\\\" title=\\\"\").concat(H5P.t('close'), \"\\\">\\n                      </div>\\n                    </div>\")).insertAfter($element).click(function () {\n      self.close();\n    }) // prevent propagation inside inner\n    .children('.h5p-inner').click(function () {\n      return false;\n    }).end();\n    (0,_utils__WEBPACK_IMPORTED_MODULE_0__.addClickAndKeyboardListeners)($dialog.find('.h5p-close'), function () {\n      return self.close();\n    });\n    var $content = $dialog.find('.h5p-scroll-content');\n    $content.append($('<div>', {\n      'class': 'h5p-cp-print-ingress',\n      id: ingressId,\n      html: texts.printIngress\n    }));\n    H5P.JoubelUI.createButton({\n      html: texts.printAllSlides,\n      'class': 'h5p-cp-print-all-slides',\n      click: function click() {\n        self.close();\n        callback(true);\n      }\n    }).appendTo($content);\n    H5P.JoubelUI.createButton({\n      html: texts.printCurrentSlide,\n      'class': 'h5p-cp-print-current-slide',\n      click: function click() {\n        self.close();\n        callback(false);\n      }\n    }).appendTo($content);\n\n    this.open = function () {\n      setTimeout(function () {\n        $dialog.addClass('h5p-open'); // Fade in\n        // Triggering an event, in case something has to be done after dialog has been opened.\n\n        H5P.jQuery(self).trigger('dialog-opened', [$dialog]);\n      }, 1);\n    };\n\n    this.close = function () {\n      $dialog.removeClass('h5p-open'); // Fade out\n\n      setTimeout(function () {\n        $dialog.remove();\n      }, 200);\n    };\n\n    this.open();\n    return $dialog;\n  };\n\n  return Printer;\n}(H5P.jQuery);\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Printer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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S0FBRCxDQUFSO01BQ0Q7SUFOdUIsQ0FBMUIsRUFPR3VCLFFBUEgsQ0FPWVIsUUFQWjs7SUFTQSxLQUFLVSxJQUFMLEdBQVksWUFBWTtNQUN0QjdCLFVBQVUsQ0FBQyxZQUFZO1FBQ3JCUyxPQUFPLENBQUNWLFFBQVIsQ0FBaUIsVUFBakIsRUFEcUIsQ0FDUztRQUM5Qjs7UUFDQVksR0FBRyxDQUFDbUIsTUFBSixDQUFXekIsSUFBWCxFQUFpQnJCLE9BQWpCLENBQXlCLGVBQXpCLEVBQTBDLENBQUN5QixPQUFELENBQTFDO01BQ0QsQ0FKUyxFQUlQLENBSk8sQ0FBVjtJQUtELENBTkQ7O0lBUUEsS0FBS00sS0FBTCxHQUFhLFlBQVk7TUFDdkJOLE9BQU8sQ0FBQ3NCLFdBQVIsQ0FBb0IsVUFBcEIsRUFEdUIsQ0FDVTs7TUFDakMvQixVQUFVLENBQUMsWUFBWTtRQUNyQlMsT0FBTyxDQUFDdUIsTUFBUjtNQUNELENBRlMsRUFFUCxHQUZPLENBQVY7SUFHRCxDQUxEOztJQU9BLEtBQUtILElBQUw7SUFFQSxPQUFPcEIsT0FBUDtFQUNELENBdEVEOztFQXdFQSxPQUFPbEMsT0FBUDtBQUVELENBaEtlLENBZ0tib0MsR0FBRyxDQUFDbUIsTUFoS1MsQ0FBaEI7O0FBa0tBLGlFQUFldkQsT0FBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NjcmlwdHMvcHJpbnRlci5qcz9jNWU1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMgfSBmcm9tICcuL3V0aWxzJztcclxuXHJcbmNvbnN0IFByaW50ZXIgPSAoZnVuY3Rpb24gKCQpIHtcclxuICBsZXQgbmV4dFByaW50ZXJEaWFsb2dJZCA9IDA7XHJcblxyXG4gIC8qKlxyXG4gICAqIFByaW50ZXIgY2xhc3NcclxuICAgKiBAY2xhc3MgUHJpbnRlclxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIFByaW50ZXIoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayBpZiBwcmludGluZyBpcyBzdXBwb3J0ZWRcclxuICAgKlxyXG4gICAqIEBtZXRob2Qgc3VwcG9ydGVkXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgc3VwcG9ydGVkLCBlbHNlIGZhbHNlLlxyXG4gICAqL1xyXG4gIFByaW50ZXIuc3VwcG9ydGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gTmVlZCB3aW5kb3cucHJpbnQgdG8gYmUgYXZhaWxhYmxlXHJcbiAgICByZXR1cm4gKHR5cGVvZiB3aW5kb3cucHJpbnQgPT09ICdmdW5jdGlvbicpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIERvIHRoZSBhY3R1YWwgcHJpbnRpbmdcclxuICAgKlxyXG4gICAqIEBtZXRob2QgcHJpbnRcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtICB7SDVQLkNvdXJzZVByZXNlbnRhdGlvbn0gY3AgUmVmZXJlbmNlIHRvIGNwIGluc3RhbmNlXHJcbiAgICogQHBhcmFtICB7SDVQLmpRdWVyeX0gJHdyYXBwZXIgIFRoZSBDUCBkb20gd3JhcHBlclxyXG4gICAqIEBwYXJhbSAge2Jvb2xlYW59IGFsbFNsaWRlcyBJZiB0cnVlLCBhbGwgc2xpZGVzIGFyZSBwcmludGVkLiBJZiBmYWxzZSBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHRoZSBjdXJyZW50U2xpZGUgaXMgcHJpbnRlZC5cclxuICAgKi9cclxuICBQcmludGVyLnByaW50ID0gZnVuY3Rpb24gKGNwLCAkd3JhcHBlciwgYWxsU2xpZGVzKSB7XHJcbiAgICAvLyBMZXQgQ1Aga25vdyB3ZSBhcmUgYWJvdXQgdG8gcHJpbnRcclxuICAgIGNwLnRyaWdnZXIoJ3ByaW50aW5nJywge2ZpbmlzaGVkOiBmYWxzZSwgYWxsU2xpZGVzOiBhbGxTbGlkZXN9KTtcclxuXHJcbiAgICAvLyBGaW5kIGhlaWdodCBvZiBhIHNsaWRlOlxyXG4gICAgdmFyICRjdXJyZW50U2xpZGUgPSAkKCcuaDVwLXNsaWRlLmg1cC1jdXJyZW50Jyk7XHJcbiAgICB2YXIgc2xpZGVIZWlnaHQgPSAkY3VycmVudFNsaWRlLmhlaWdodCgpO1xyXG4gICAgdmFyIHNsaWRlV2lkdGggPSAkY3VycmVudFNsaWRlLndpZHRoKCk7XHJcblxyXG4gICAgLy8gVXNlIDY3MHB4IGFzIHdpZHRoIHdoZW4gcHJpbnRpbmcuIFdlIGNhbid0IHVzZSAxMDAlIHBlcmNlbnQsIHNpbmNlIHVzZXIgY2FuXHJcbiAgICAvLyBjaGFuZ2UgYmV0d2VlbiBsYW5kc2NhcGUgYW5kIHBvcnRyYWl0IHdpdGhvdXQgdXMgZXZlciBrbm93aW5nIGFib3V0IGl0LlxyXG4gICAgLy8gTW9yZSBpbmZvOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTA4NDc5Ny8yNzk3MTA2XHJcbiAgICB2YXIgcmF0aW8gPSBzbGlkZVdpZHRoLzY3MDtcclxuXHJcbiAgICB2YXIgJHNsaWRlcyA9ICQoJy5oNXAtc2xpZGUnKTtcclxuXHJcbiAgICAkc2xpZGVzLmNzcyh7XHJcbiAgICAgIGhlaWdodDogc2xpZGVIZWlnaHQvcmF0aW8gKyAncHgnLFxyXG4gICAgICB3aWR0aDogJzY3MHB4JyxcclxuICAgICAgZm9udFNpemU6IE1hdGguZmxvb3IoMTAwL3JhdGlvKSArICclJ1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHdyYXBwZXJIZWlnaHQgPSAkd3JhcHBlci5oZWlnaHQoKTtcclxuICAgICR3cmFwcGVyLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcclxuXHJcbiAgICAvLyBMZXQgcHJpbnRlciBjc3Mga25vdyB3aGljaCBzbGlkZXMgdG8gcHJpbnQ6XHJcbiAgICAkc2xpZGVzLnRvZ2dsZUNsYXNzKCdkb3ByaW50JywgYWxsU2xpZGVzID09PSB0cnVlKTtcclxuICAgICRjdXJyZW50U2xpZGUuYWRkQ2xhc3MoJ2RvcHJpbnQnKTtcclxuXHJcbiAgICAvLyBOZWVkIHRpbWVvdXQgZm9yIHNvbWUgYnJvd3NlcnMuXHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgLy8gRG8gdGhlIGFjdHVhbCBwcmludGluZyBvZiB0aGUgaWZyYW1lIGNvbnRlbnRcclxuICAgICAgd2luZG93LnByaW50KCk7XHJcblxyXG4gICAgICAvLyBSZXNldCBDU1NcclxuICAgICAgJHNsaWRlcy5jc3Moe1xyXG4gICAgICAgIGhlaWdodDogJycsXHJcbiAgICAgICAgd2lkdGg6ICcnLFxyXG4gICAgICAgIGZvbnRTaXplOiAnJ1xyXG4gICAgICB9KTtcclxuICAgICAgJHdyYXBwZXIuY3NzKCdoZWlnaHQnLCB3cmFwcGVySGVpZ2h0KydweCcpO1xyXG5cclxuICAgICAgLy8gTGV0IENQIGtub3cgd2UgYXJlIGZpbmlzaGVkIHByaW50aW5nXHJcbiAgICAgIGNwLnRyaWdnZXIoJ3ByaW50aW5nJywge2ZpbmlzaGVkOiB0cnVlfSk7XHJcbiAgICB9LCA1MDApO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNob3cgdGhlIHByaW50IGRpYWxvZy4gV2FudGVkIHRvIHVzZSBINVAuRGlhbG9nLCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydCBnZXR0aW5nIGEgalF1ZXJ5IG9iamVjdCBhcyB0aGUgY29udGVudFxyXG4gICAqXHJcbiAgICogQG1ldGhvZCBzaG93RGlhbG9nXHJcbiAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICB0ZXh0cyAgICBUcmFuc2xhdGVkIHRleHRzXHJcbiAgICogQHBhcmFtICB7SDVQLmpRdWVyeX0gICAkZWxlbWVudCBEb20gb2JqZWN0IHRvIGluc2VydCBkaWFsb2cgYWZ0ZXJcclxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgIGNhbGxiYWNrIEZ1bmN0aW9uIGludm9rZWQgd2hlbiBwcmludGluZyBpcyBkb25lLlxyXG4gICAqL1xyXG4gIFByaW50ZXIuc2hvd0RpYWxvZyA9IGZ1bmN0aW9uICh0ZXh0cywgJGVsZW1lbnQsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBjb25zdCBpbnN0YW5jZUlkID0gbmV4dFByaW50ZXJEaWFsb2dJZCsrO1xyXG4gICAgY29uc3QgZGlhbG9nVGl0bGVJZCA9IGBoNXAtY3AtcHJpbnQtZGlhbG9nLSR7aW5zdGFuY2VJZH0tdGl0bGVgO1xyXG4gICAgY29uc3QgaW5ncmVzc0lkID0gYGg1cC1jcC1wcmludC1kaWFsb2ctJHtpbnN0YW5jZUlkfS1pbmdyZXNzYDtcclxuXHJcbiAgICB2YXIgJGRpYWxvZyA9ICQoYDxkaXYgY2xhc3M9XCJoNXAtcG9wdXAtZGlhbG9nIGg1cC1wcmludC1kaWFsb2dcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxkaXYgcm9sZT1cImRpYWxvZ1wiIGFyaWEtbGFiZWxsZWRieT1cIiR7ZGlhbG9nVGl0bGVJZH1cIiBhcmlhLWRlc2NyaWJlZGJ5PVwiJHtpbmdyZXNzSWR9XCIgdGFiaW5kZXg9XCItMVwiIGNsYXNzPVwiaDVwLWlubmVyXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBpZD1cIiR7ZGlhbG9nVGl0bGVJZH1cIj4ke3RleHRzLnByaW50VGl0bGV9PC9oMj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImg1cC1zY3JvbGwtY29udGVudFwiPjwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiaDVwLWNsb3NlXCIgcm9sZT1cImJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIHRpdGxlPVwiJHtINVAudCgnY2xvc2UnKX1cIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PmApXHJcbiAgICAgIC5pbnNlcnRBZnRlcigkZWxlbWVudClcclxuICAgICAgLmNsaWNrKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICAgIH0pXHJcbiAgICAgIC8vIHByZXZlbnQgcHJvcGFnYXRpb24gaW5zaWRlIGlubmVyXHJcbiAgICAgIC5jaGlsZHJlbignLmg1cC1pbm5lcicpXHJcbiAgICAgIC5jbGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9KVxyXG4gICAgICAuZW5kKCk7XHJcblxyXG4gICAgYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycygkZGlhbG9nLmZpbmQoJy5oNXAtY2xvc2UnKSwgKCkgPT4gc2VsZi5jbG9zZSgpKTtcclxuXHJcbiAgICB2YXIgJGNvbnRlbnQgPSAkZGlhbG9nLmZpbmQoJy5oNXAtc2Nyb2xsLWNvbnRlbnQnKTtcclxuXHJcbiAgICAkY29udGVudC5hcHBlbmQoJCgnPGRpdj4nLCB7XHJcbiAgICAgICdjbGFzcyc6ICdoNXAtY3AtcHJpbnQtaW5ncmVzcycsXHJcbiAgICAgIGlkOiBpbmdyZXNzSWQsXHJcbiAgICAgIGh0bWw6IHRleHRzLnByaW50SW5ncmVzc1xyXG4gICAgfSkpO1xyXG5cclxuICAgIEg1UC5Kb3ViZWxVSS5jcmVhdGVCdXR0b24oe1xyXG4gICAgICBodG1sOiB0ZXh0cy5wcmludEFsbFNsaWRlcyxcclxuICAgICAgJ2NsYXNzJzogJ2g1cC1jcC1wcmludC1hbGwtc2xpZGVzJyxcclxuICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBzZWxmLmNsb3NlKCk7XHJcbiAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pLmFwcGVuZFRvKCRjb250ZW50KTtcclxuXHJcbiAgICBINVAuSm91YmVsVUkuY3JlYXRlQnV0dG9uKHtcclxuICAgICAgaHRtbDogdGV4dHMucHJpbnRDdXJyZW50U2xpZGUsXHJcbiAgICAgICdjbGFzcyc6ICdoNXAtY3AtcHJpbnQtY3VycmVudC1zbGlkZScsXHJcbiAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xyXG4gICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfSkuYXBwZW5kVG8oJGNvbnRlbnQpO1xyXG5cclxuICAgIHRoaXMub3BlbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgJGRpYWxvZy5hZGRDbGFzcygnaDVwLW9wZW4nKTsgLy8gRmFkZSBpblxyXG4gICAgICAgIC8vIFRyaWdnZXJpbmcgYW4gZXZlbnQsIGluIGNhc2Ugc29tZXRoaW5nIGhhcyB0byBiZSBkb25lIGFmdGVyIGRpYWxvZyBoYXMgYmVlbiBvcGVuZWQuXHJcbiAgICAgICAgSDVQLmpRdWVyeShzZWxmKS50cmlnZ2VyKCdkaWFsb2ctb3BlbmVkJywgWyRkaWFsb2ddKTtcclxuICAgICAgfSwgMSk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICRkaWFsb2cucmVtb3ZlQ2xhc3MoJ2g1cC1vcGVuJyk7IC8vIEZhZGUgb3V0XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICRkaWFsb2cucmVtb3ZlKCk7XHJcbiAgICAgIH0sIDIwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMub3BlbigpO1xyXG5cclxuICAgIHJldHVybiAkZGlhbG9nO1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBQcmludGVyO1xyXG5cclxufSkoSDVQLmpRdWVyeSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBQcmludGVyO1xyXG4iXSwibmFtZXMiOlsiYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyIsIlByaW50ZXIiLCIkIiwibmV4dFByaW50ZXJEaWFsb2dJZCIsInN1cHBvcnRlZCIsIndpbmRvdyIsInByaW50IiwiY3AiLCIkd3JhcHBlciIsImFsbFNsaWRlcyIsInRyaWdnZXIiLCJmaW5pc2hlZCIsIiRjdXJyZW50U2xpZGUiLCJzbGlkZUhlaWdodCIsImhlaWdodCIsInNsaWRlV2lkdGgiLCJ3aWR0aCIsInJhdGlvIiwiJHNsaWRlcyIsImNzcyIsImZvbnRTaXplIiwiTWF0aCIsImZsb29yIiwid3JhcHBlckhlaWdodCIsInRvZ2dsZUNsYXNzIiwiYWRkQ2xhc3MiLCJzZXRUaW1lb3V0Iiwic2hvd0RpYWxvZyIsInRleHRzIiwiJGVsZW1lbnQiLCJjYWxsYmFjayIsInNlbGYiLCJpbnN0YW5jZUlkIiwiZGlhbG9nVGl0bGVJZCIsImluZ3Jlc3NJZCIsIiRkaWFsb2ciLCJwcmludFRpdGxlIiwiSDVQIiwidCIsImluc2VydEFmdGVyIiwiY2xpY2siLCJjbG9zZSIsImNoaWxkcmVuIiwiZW5kIiwiZmluZCIsIiRjb250ZW50IiwiYXBwZW5kIiwiaWQiLCJodG1sIiwicHJpbnRJbmdyZXNzIiwiSm91YmVsVUkiLCJjcmVhdGVCdXR0b24iLCJwcmludEFsbFNsaWRlcyIsImFwcGVuZFRvIiwicHJpbnRDdXJyZW50U2xpZGUiLCJvcGVuIiwialF1ZXJ5IiwicmVtb3ZlQ2xhc3MiLCJyZW1vdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/printer.js\n");

/***/ }),

/***/ "./scripts/slide-backgrounds.js":
/*!**************************************!*\
  !*** ./scripts/slide-backgrounds.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SlideBackground)\n/* harmony export */ });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n\n/**\r\n * @class\r\n */\n\nvar SlideBackground =\n/**\r\n * Create a Slide specific background selector\r\n *\r\n * @param {H5P.CoursePresentation} cp Course Presentation instance\r\n */\nfunction SlideBackground(cp) {\n  var params = cp.presentation; // Extend defaults\n\n  params = _globals__WEBPACK_IMPORTED_MODULE_0__.jQuery.extend(true, {\n    globalBackgroundSelector: {\n      fillGlobalBackground: \"\",\n      imageGlobalBackground: {}\n    },\n    slides: [{\n      slideBackgroundSelector: {\n        fillSlideBackground: \"\",\n        imageSlideBackground: {}\n      }\n    }]\n  }, params);\n  /**\r\n   * Set global background\r\n   * @private\r\n   */\n\n  var setGlobalBackground = function setGlobalBackground() {\n    var globalSettings = params.globalBackgroundSelector;\n    setBackground(globalSettings.fillGlobalBackground, globalSettings.imageGlobalBackground);\n  };\n  /**\r\n   * Set single slide background\r\n   * @private\r\n   */\n\n\n  var setSlideBackgrounds = function setSlideBackgrounds() {\n    params.slides.forEach(function (slideParams, idx) {\n      var bgParams = slideParams.slideBackgroundSelector;\n\n      if (bgParams) {\n        setBackground(bgParams.fillSlideBackground, bgParams.imageSlideBackground, idx);\n      }\n    });\n  };\n  /**\r\n   * Set background of slide(s)\r\n   *\r\n   * @private\r\n   * @param {Object} fillSettings Background color settings\r\n   * @param {Object} imageSettings Image background settings\r\n   * @param {number} [index] Optional target slide index, otherwise all slides.\r\n   */\n\n\n  var setBackground = function setBackground(fillSettings, imageSettings, index) {\n    var $updateSlides = cp.$slidesWrapper.children().filter(':not(.h5p-summary-slide)');\n\n    if (index !== undefined) {\n      $updateSlides = $updateSlides.eq(index);\n    }\n\n    if (fillSettings && fillSettings !== \"\") {\n      // Fill with background color\n      $updateSlides.addClass('has-background').css('background-image', '').css('background-color', fillSettings);\n    } else if (imageSettings && imageSettings.path) {\n      // Fill with image\n      $updateSlides.addClass('has-background').css('background-color', '').css('background-image', 'url(' + H5P.getPath(imageSettings.path, cp.contentId) + ')');\n    }\n  }; // Set backgrounds\n\n\n  setGlobalBackground();\n  setSlideBackgrounds();\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zY3JpcHRzL3NsaWRlLWJhY2tncm91bmRzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFFQTtBQUNBO0FBQ0E7O0lBQ3FCRTtBQUNuQjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UseUJBQVlDLEVBQVosRUFBZ0I7RUFDZCxJQUFJQyxNQUFNLEdBQUdELEVBQUUsQ0FBQ0UsWUFBaEIsQ0FEYyxDQUdkOztFQUNBRCxNQUFNLEdBQUdILG1EQUFBLENBQVMsSUFBVCxFQUFlO0lBQ3RCTSx3QkFBd0IsRUFBRTtNQUN4QkMsb0JBQW9CLEVBQUUsRUFERTtNQUV4QkMscUJBQXFCLEVBQUU7SUFGQyxDQURKO0lBS3RCQyxNQUFNLEVBQUUsQ0FDTjtNQUNFQyx1QkFBdUIsRUFBRTtRQUN2QkMsbUJBQW1CLEVBQUUsRUFERTtRQUV2QkMsb0JBQW9CLEVBQUU7TUFGQztJQUQzQixDQURNO0VBTGMsQ0FBZixFQWFOVCxNQWJNLENBQVQ7RUFlQTtBQUNKO0FBQ0E7QUFDQTs7RUFDSSxJQUFJVSxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLEdBQVk7SUFDcEMsSUFBSUMsY0FBYyxHQUFHWCxNQUFNLENBQUNHLHdCQUE1QjtJQUNBUyxhQUFhLENBQUNELGNBQWMsQ0FBQ1Asb0JBQWhCLEVBQXNDTyxjQUFjLENBQUNOLHFCQUFyRCxDQUFiO0VBQ0QsQ0FIRDtFQUtBO0FBQ0o7QUFDQTtBQUNBOzs7RUFDSSxJQUFJUSxtQkFBbUIsR0FBRyxTQUF0QkEsbUJBQXNCLEdBQVk7SUFDcENiLE1BQU0sQ0FBQ00sTUFBUCxDQUFjUSxPQUFkLENBQXNCLFVBQVVDLFdBQVYsRUFBdUJDLEdBQXZCLEVBQTRCO01BQ2hELElBQUlDLFFBQVEsR0FBR0YsV0FBVyxDQUFDUix1QkFBM0I7O01BQ0EsSUFBSVUsUUFBSixFQUFjO1FBQ1pMLGFBQWEsQ0FBQ0ssUUFBUSxDQUFDVCxtQkFBVixFQUErQlMsUUFBUSxDQUFDUixvQkFBeEMsRUFBOERPLEdBQTlELENBQWI7TUFDRDtJQUNGLENBTEQ7RUFNRCxDQVBEO0VBU0E7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0VBQ0ksSUFBSUosYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFVTSxZQUFWLEVBQXdCQyxhQUF4QixFQUF1Q0MsS0FBdkMsRUFBOEM7SUFDaEUsSUFBSUMsYUFBYSxHQUFHdEIsRUFBRSxDQUFDdUIsY0FBSCxDQUFrQkMsUUFBbEIsR0FBNkJDLE1BQTdCLENBQW9DLDBCQUFwQyxDQUFwQjs7SUFFQSxJQUFJSixLQUFLLEtBQUtLLFNBQWQsRUFBeUI7TUFDdkJKLGFBQWEsR0FBR0EsYUFBYSxDQUFDSyxFQUFkLENBQWlCTixLQUFqQixDQUFoQjtJQUNEOztJQUVELElBQUlGLFlBQVksSUFBSUEsWUFBWSxLQUFLLEVBQXJDLEVBQXlDO01BRXZDO01BQ0FHLGFBQWEsQ0FBQ00sUUFBZCxDQUF1QixnQkFBdkIsRUFDR0MsR0FESCxDQUNPLGtCQURQLEVBQzJCLEVBRDNCLEVBRUdBLEdBRkgsQ0FFTyxrQkFGUCxFQUUyQlYsWUFGM0I7SUFHRCxDQU5ELE1BT0ssSUFBSUMsYUFBYSxJQUFJQSxhQUFhLENBQUNVLElBQW5DLEVBQXlDO01BRTVDO01BQ0FSLGFBQWEsQ0FBQ00sUUFBZCxDQUF1QixnQkFBdkIsRUFDR0MsR0FESCxDQUNPLGtCQURQLEVBQzJCLEVBRDNCLEVBRUdBLEdBRkgsQ0FFTyxrQkFGUCxFQUUyQixTQUFTRSxHQUFHLENBQUNDLE9BQUosQ0FBWVosYUFBYSxDQUFDVSxJQUExQixFQUFnQzlCLEVBQUUsQ0FBQ2lDLFNBQW5DLENBQVQsR0FBeUQsR0FGcEY7SUFHRDtFQUNGLENBckJELENBakRjLENBd0VkOzs7RUFDQXRCLG1CQUFtQjtFQUNuQkcsbUJBQW1CO0FBQ3BCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy9zbGlkZS1iYWNrZ3JvdW5kcy5qcz81MmI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpRdWVyeSBhcyAkIH0gZnJvbSAnLi9nbG9iYWxzJztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWRlQmFja2dyb3VuZCB7XHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgU2xpZGUgc3BlY2lmaWMgYmFja2dyb3VuZCBzZWxlY3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtINVAuQ291cnNlUHJlc2VudGF0aW9ufSBjcCBDb3Vyc2UgUHJlc2VudGF0aW9uIGluc3RhbmNlXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoY3ApIHtcclxuICAgIHZhciBwYXJhbXMgPSBjcC5wcmVzZW50YXRpb247XHJcblxyXG4gICAgLy8gRXh0ZW5kIGRlZmF1bHRzXHJcbiAgICBwYXJhbXMgPSAkLmV4dGVuZCh0cnVlLCB7XHJcbiAgICAgIGdsb2JhbEJhY2tncm91bmRTZWxlY3Rvcjoge1xyXG4gICAgICAgIGZpbGxHbG9iYWxCYWNrZ3JvdW5kOiBcIlwiLFxyXG4gICAgICAgIGltYWdlR2xvYmFsQmFja2dyb3VuZDoge31cclxuICAgICAgfSxcclxuICAgICAgc2xpZGVzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgc2xpZGVCYWNrZ3JvdW5kU2VsZWN0b3I6IHtcclxuICAgICAgICAgICAgZmlsbFNsaWRlQmFja2dyb3VuZDogXCJcIixcclxuICAgICAgICAgICAgaW1hZ2VTbGlkZUJhY2tncm91bmQ6IHt9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICBdXHJcbiAgICB9LCBwYXJhbXMpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGdsb2JhbCBiYWNrZ3JvdW5kXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB2YXIgc2V0R2xvYmFsQmFja2dyb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGdsb2JhbFNldHRpbmdzID0gcGFyYW1zLmdsb2JhbEJhY2tncm91bmRTZWxlY3RvcjtcclxuICAgICAgc2V0QmFja2dyb3VuZChnbG9iYWxTZXR0aW5ncy5maWxsR2xvYmFsQmFja2dyb3VuZCwgZ2xvYmFsU2V0dGluZ3MuaW1hZ2VHbG9iYWxCYWNrZ3JvdW5kKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc2luZ2xlIHNsaWRlIGJhY2tncm91bmRcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHZhciBzZXRTbGlkZUJhY2tncm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBwYXJhbXMuc2xpZGVzLmZvckVhY2goZnVuY3Rpb24gKHNsaWRlUGFyYW1zLCBpZHgpIHtcclxuICAgICAgICB2YXIgYmdQYXJhbXMgPSBzbGlkZVBhcmFtcy5zbGlkZUJhY2tncm91bmRTZWxlY3RvcjtcclxuICAgICAgICBpZiAoYmdQYXJhbXMpIHtcclxuICAgICAgICAgIHNldEJhY2tncm91bmQoYmdQYXJhbXMuZmlsbFNsaWRlQmFja2dyb3VuZCwgYmdQYXJhbXMuaW1hZ2VTbGlkZUJhY2tncm91bmQsIGlkeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYmFja2dyb3VuZCBvZiBzbGlkZShzKVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZmlsbFNldHRpbmdzIEJhY2tncm91bmQgY29sb3Igc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZVNldHRpbmdzIEltYWdlIGJhY2tncm91bmQgc2V0dGluZ3NcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXhdIE9wdGlvbmFsIHRhcmdldCBzbGlkZSBpbmRleCwgb3RoZXJ3aXNlIGFsbCBzbGlkZXMuXHJcbiAgICAgKi9cclxuICAgIHZhciBzZXRCYWNrZ3JvdW5kID0gZnVuY3Rpb24gKGZpbGxTZXR0aW5ncywgaW1hZ2VTZXR0aW5ncywgaW5kZXgpIHtcclxuICAgICAgdmFyICR1cGRhdGVTbGlkZXMgPSBjcC4kc2xpZGVzV3JhcHBlci5jaGlsZHJlbigpLmZpbHRlcignOm5vdCguaDVwLXN1bW1hcnktc2xpZGUpJyk7XHJcblxyXG4gICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICR1cGRhdGVTbGlkZXMgPSAkdXBkYXRlU2xpZGVzLmVxKGluZGV4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGZpbGxTZXR0aW5ncyAmJiBmaWxsU2V0dGluZ3MgIT09IFwiXCIpIHtcclxuXHJcbiAgICAgICAgLy8gRmlsbCB3aXRoIGJhY2tncm91bmQgY29sb3JcclxuICAgICAgICAkdXBkYXRlU2xpZGVzLmFkZENsYXNzKCdoYXMtYmFja2dyb3VuZCcpXHJcbiAgICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgJycpXHJcbiAgICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgZmlsbFNldHRpbmdzKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChpbWFnZVNldHRpbmdzICYmIGltYWdlU2V0dGluZ3MucGF0aCkge1xyXG5cclxuICAgICAgICAvLyBGaWxsIHdpdGggaW1hZ2VcclxuICAgICAgICAkdXBkYXRlU2xpZGVzLmFkZENsYXNzKCdoYXMtYmFja2dyb3VuZCcpXHJcbiAgICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJycpXHJcbiAgICAgICAgICAuY3NzKCdiYWNrZ3JvdW5kLWltYWdlJywgJ3VybCgnICsgSDVQLmdldFBhdGgoaW1hZ2VTZXR0aW5ncy5wYXRoLCBjcC5jb250ZW50SWQpICsgJyknKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBTZXQgYmFja2dyb3VuZHNcclxuICAgIHNldEdsb2JhbEJhY2tncm91bmQoKTtcclxuICAgIHNldFNsaWRlQmFja2dyb3VuZHMoKTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImpRdWVyeSIsIiQiLCJTbGlkZUJhY2tncm91bmQiLCJjcCIsInBhcmFtcyIsInByZXNlbnRhdGlvbiIsImV4dGVuZCIsImdsb2JhbEJhY2tncm91bmRTZWxlY3RvciIsImZpbGxHbG9iYWxCYWNrZ3JvdW5kIiwiaW1hZ2VHbG9iYWxCYWNrZ3JvdW5kIiwic2xpZGVzIiwic2xpZGVCYWNrZ3JvdW5kU2VsZWN0b3IiLCJmaWxsU2xpZGVCYWNrZ3JvdW5kIiwiaW1hZ2VTbGlkZUJhY2tncm91bmQiLCJzZXRHbG9iYWxCYWNrZ3JvdW5kIiwiZ2xvYmFsU2V0dGluZ3MiLCJzZXRCYWNrZ3JvdW5kIiwic2V0U2xpZGVCYWNrZ3JvdW5kcyIsImZvckVhY2giLCJzbGlkZVBhcmFtcyIsImlkeCIsImJnUGFyYW1zIiwiZmlsbFNldHRpbmdzIiwiaW1hZ2VTZXR0aW5ncyIsImluZGV4IiwiJHVwZGF0ZVNsaWRlcyIsIiRzbGlkZXNXcmFwcGVyIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJ1bmRlZmluZWQiLCJlcSIsImFkZENsYXNzIiwiY3NzIiwicGF0aCIsIkg1UCIsImdldFBhdGgiLCJjb250ZW50SWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/slide-backgrounds.js\n");

/***/ }),

/***/ "./scripts/slide.js":
/*!**************************!*\
  !*** ./scripts/slide.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _element_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./element.js */ \"./scripts/element.js\");\n/* harmony import */ var h5p_parent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! h5p-parent */ \"../node_modules/h5p-parent/src/parent.js\");\n/* harmony import */ var h5p_parent__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(h5p_parent__WEBPACK_IMPORTED_MODULE_1__);\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n/**\r\n * @class\r\n */\n\nfunction Slide(parameters) {\n  var self = this;\n  h5p_parent__WEBPACK_IMPORTED_MODULE_1___default().call(self, _element_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], parameters.elements); // The slide DOM element when attached\n\n  var $wrapper;\n  /**\r\n   * Create HTML\r\n   *\r\n   * @return {jQuery} Element\r\n   */\n\n  self.getElement = function () {\n    if (!$wrapper) {\n      $wrapper = H5P.jQuery(Slide.createHTML(_objectSpread(_objectSpread({}, parameters), {}, {\n        index: self.index\n      })));\n    }\n\n    return $wrapper;\n  };\n  /**\r\n   * Make current slide\r\n   */\n\n\n  self.setCurrent = function () {\n    this.parent.$current = $wrapper.addClass('h5p-current');\n  };\n  /**\r\n   * Append all of the elements to the slide.\r\n   */\n\n\n  self.appendElements = function () {\n    for (var i = 0; i < self.children.length; i++) {\n      self.parent.attachElement(parameters.elements[i], self.children[i].instance, $wrapper, self.index);\n    }\n\n    self.parent.elementsAttached[self.index] = true;\n    self.parent.trigger('domChanged', {\n      '$target': $wrapper,\n      'library': 'CoursePresentation',\n      'key': 'newSlide'\n    }, {\n      'bubbles': true,\n      'external': true\n    });\n  };\n}\n/**\r\n * Creates the HTML for a single slide.\r\n *\r\n * @param {Object} params Slide parameters.\r\n * @returns {string} HTML.\r\n */\n\n\nSlide.createHTML = function (parameters) {\n  return '<div ' + 'role=\"tabpanel\" ' + 'id=\"slide-' + parameters.index + '\" ' + 'aria-labelledby=\"progressbar-part-' + parameters.index + '\" ' + 'class=\"h5p-slide\"> ' + '<div ' + 'role=\"document\" ' + 'tabindex=\"0\" ' + (parameters.background !== undefined ? ' style=\"background:' + parameters.background + '\"' : '') + '>' + '</div>' + '</div>';\n};\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slide);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zY3JpcHRzL3NsaWRlLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUNBLFNBQVNFLEtBQVQsQ0FBZUMsVUFBZixFQUEyQjtFQUN6QixJQUFNQyxJQUFJLEdBQUcsSUFBYjtFQUNBSCxzREFBQSxDQUFZRyxJQUFaLEVBQWtCSixtREFBbEIsRUFBMkJHLFVBQVUsQ0FBQ0csUUFBdEMsRUFGeUIsQ0FJekI7O0VBQ0EsSUFBSUMsUUFBSjtFQUVBO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0VBQ0VILElBQUksQ0FBQ0ksVUFBTCxHQUFrQixZQUFZO0lBQzVCLElBQUksQ0FBQ0QsUUFBTCxFQUFlO01BQ2JBLFFBQVEsR0FBR0UsR0FBRyxDQUFDQyxNQUFKLENBQVdSLEtBQUssQ0FBQ1MsVUFBTixpQ0FBcUJSLFVBQXJCO1FBQWlDUyxLQUFLLEVBQUVSLElBQUksQ0FBQ1E7TUFBN0MsR0FBWCxDQUFYO0lBQ0Q7O0lBQ0QsT0FBT0wsUUFBUDtFQUNELENBTEQ7RUFPQTtBQUNGO0FBQ0E7OztFQUNFSCxJQUFJLENBQUNTLFVBQUwsR0FBa0IsWUFBWTtJQUM1QixLQUFLQyxNQUFMLENBQVlDLFFBQVosR0FBdUJSLFFBQVEsQ0FBQ1MsUUFBVCxDQUFrQixhQUFsQixDQUF2QjtFQUNELENBRkQ7RUFJQTtBQUNGO0FBQ0E7OztFQUNFWixJQUFJLENBQUNhLGNBQUwsR0FBc0IsWUFBWTtJQUVoQyxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdkLElBQUksQ0FBQ2UsUUFBTCxDQUFjQyxNQUFsQyxFQUEwQ0YsQ0FBQyxFQUEzQyxFQUErQztNQUM3Q2QsSUFBSSxDQUFDVSxNQUFMLENBQVlPLGFBQVosQ0FBMEJsQixVQUFVLENBQUNHLFFBQVgsQ0FBb0JZLENBQXBCLENBQTFCLEVBQWtEZCxJQUFJLENBQUNlLFFBQUwsQ0FBY0QsQ0FBZCxFQUFpQkksUUFBbkUsRUFBNkVmLFFBQTdFLEVBQXVGSCxJQUFJLENBQUNRLEtBQTVGO0lBQ0Q7O0lBRURSLElBQUksQ0FBQ1UsTUFBTCxDQUFZUyxnQkFBWixDQUE2Qm5CLElBQUksQ0FBQ1EsS0FBbEMsSUFBMkMsSUFBM0M7SUFDQVIsSUFBSSxDQUFDVSxNQUFMLENBQVlVLE9BQVosQ0FBb0IsWUFBcEIsRUFBa0M7TUFDaEMsV0FBV2pCLFFBRHFCO01BRWhDLFdBQVcsb0JBRnFCO01BR2hDLE9BQU87SUFIeUIsQ0FBbEMsRUFJRztNQUFDLFdBQVcsSUFBWjtNQUFrQixZQUFZO0lBQTlCLENBSkg7RUFLRCxDQVpEO0FBYUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBTCxLQUFLLENBQUNTLFVBQU4sR0FBbUIsVUFBVVIsVUFBVixFQUFzQjtFQUN2QyxPQUFPLFVBQ0gsa0JBREcsR0FFSCxZQUZHLEdBRVlBLFVBQVUsQ0FBQ1MsS0FGdkIsR0FFK0IsSUFGL0IsR0FHSCxvQ0FIRyxHQUdvQ1QsVUFBVSxDQUFDUyxLQUgvQyxHQUd1RCxJQUh2RCxHQUlILHFCQUpHLEdBS0gsT0FMRyxHQU1ELGtCQU5DLEdBT0QsZUFQQyxJQVFBVCxVQUFVLENBQUNzQixVQUFYLEtBQTBCQyxTQUExQixHQUFzQyx3QkFBd0J2QixVQUFVLENBQUNzQixVQUFuQyxHQUFnRCxHQUF0RixHQUE0RixFQVI1RixJQVFrRyxHQVJsRyxHQVNILFFBVEcsR0FVTCxRQVZGO0FBV0QsQ0FaRDs7QUFjQSxpRUFBZXZCLEtBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHRzL3NsaWRlLmpzP2YxNTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVsZW1lbnQgZnJvbSAnLi9lbGVtZW50LmpzJztcclxuaW1wb3J0IFBhcmVudCBmcm9tICdoNXAtcGFyZW50JztcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICovXHJcbmZ1bmN0aW9uIFNsaWRlKHBhcmFtZXRlcnMpIHtcclxuICBjb25zdCBzZWxmID0gdGhpcztcclxuICBQYXJlbnQuY2FsbChzZWxmLCBFbGVtZW50LCBwYXJhbWV0ZXJzLmVsZW1lbnRzKTtcclxuXHJcbiAgLy8gVGhlIHNsaWRlIERPTSBlbGVtZW50IHdoZW4gYXR0YWNoZWRcclxuICBsZXQgJHdyYXBwZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBIVE1MXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtqUXVlcnl9IEVsZW1lbnRcclxuICAgKi9cclxuICBzZWxmLmdldEVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoISR3cmFwcGVyKSB7XHJcbiAgICAgICR3cmFwcGVyID0gSDVQLmpRdWVyeShTbGlkZS5jcmVhdGVIVE1MKHsuLi5wYXJhbWV0ZXJzLCBpbmRleDogc2VsZi5pbmRleH0pKTtcclxuICAgIH1cclxuICAgIHJldHVybiAkd3JhcHBlcjtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBNYWtlIGN1cnJlbnQgc2xpZGVcclxuICAgKi9cclxuICBzZWxmLnNldEN1cnJlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnBhcmVudC4kY3VycmVudCA9ICR3cmFwcGVyLmFkZENsYXNzKCdoNXAtY3VycmVudCcpO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZCBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvIHRoZSBzbGlkZS5cclxuICAgKi9cclxuICBzZWxmLmFwcGVuZEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZi5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzZWxmLnBhcmVudC5hdHRhY2hFbGVtZW50KHBhcmFtZXRlcnMuZWxlbWVudHNbaV0sIHNlbGYuY2hpbGRyZW5baV0uaW5zdGFuY2UsICR3cmFwcGVyLCBzZWxmLmluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLnBhcmVudC5lbGVtZW50c0F0dGFjaGVkW3NlbGYuaW5kZXhdID0gdHJ1ZTtcclxuICAgIHNlbGYucGFyZW50LnRyaWdnZXIoJ2RvbUNoYW5nZWQnLCB7XHJcbiAgICAgICckdGFyZ2V0JzogJHdyYXBwZXIsXHJcbiAgICAgICdsaWJyYXJ5JzogJ0NvdXJzZVByZXNlbnRhdGlvbicsXHJcbiAgICAgICdrZXknOiAnbmV3U2xpZGUnXHJcbiAgICB9LCB7J2J1YmJsZXMnOiB0cnVlLCAnZXh0ZXJuYWwnOiB0cnVlfSk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIHNsaWRlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFNsaWRlIHBhcmFtZXRlcnMuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhUTUwuXHJcbiAqL1xyXG5TbGlkZS5jcmVhdGVIVE1MID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICByZXR1cm4gJzxkaXYgJyArXHJcbiAgICAgICdyb2xlPVwidGFicGFuZWxcIiAnICtcclxuICAgICAgJ2lkPVwic2xpZGUtJyArIHBhcmFtZXRlcnMuaW5kZXggKyAnXCIgJyArXHJcbiAgICAgICdhcmlhLWxhYmVsbGVkYnk9XCJwcm9ncmVzc2Jhci1wYXJ0LScgKyBwYXJhbWV0ZXJzLmluZGV4ICsgJ1wiICcgK1xyXG4gICAgICAnY2xhc3M9XCJoNXAtc2xpZGVcIj4gJyArXHJcbiAgICAgICc8ZGl2ICcgK1xyXG4gICAgICAgICdyb2xlPVwiZG9jdW1lbnRcIiAnICtcclxuICAgICAgICAndGFiaW5kZXg9XCIwXCIgJyArXHJcbiAgICAgICAgKHBhcmFtZXRlcnMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkID8gJyBzdHlsZT1cImJhY2tncm91bmQ6JyArIHBhcmFtZXRlcnMuYmFja2dyb3VuZCArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAnPC9kaXY+JztcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNsaWRlO1xyXG4iXSwibmFtZXMiOlsiRWxlbWVudCIsIlBhcmVudCIsIlNsaWRlIiwicGFyYW1ldGVycyIsInNlbGYiLCJjYWxsIiwiZWxlbWVudHMiLCIkd3JhcHBlciIsImdldEVsZW1lbnQiLCJINVAiLCJqUXVlcnkiLCJjcmVhdGVIVE1MIiwiaW5kZXgiLCJzZXRDdXJyZW50IiwicGFyZW50IiwiJGN1cnJlbnQiLCJhZGRDbGFzcyIsImFwcGVuZEVsZW1lbnRzIiwiaSIsImNoaWxkcmVuIiwibGVuZ3RoIiwiYXR0YWNoRWxlbWVudCIsImluc3RhbmNlIiwiZWxlbWVudHNBdHRhY2hlZCIsInRyaWdnZXIiLCJiYWNrZ3JvdW5kIiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./scripts/slide.js\n");

/***/ }),

/***/ "./scripts/summary-slide.js":
/*!**********************************!*\
  !*** ./scripts/summary-slide.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./scripts/utils.js\");\n\n\n\nvar SummarySlide = function () {\n  /**\r\n   * Constructor for summary slide\r\n   * @param {H5P.CoursePresentation} coursePresentation Course presentation parent of summary slide\r\n   * @param {$} $summarySlide Summary slide element\r\n   * @constructor\r\n   */\n  function SummarySlide(coursePresentation, $summarySlide) {\n    // Create summary slide if not an editor\n    this.$summarySlide = $summarySlide;\n    this.cp = coursePresentation;\n  }\n  /**\r\n   * Updates the provided summary slide with current values.\r\n   *\r\n   * @param {$} $summarySlide Summary slide that will be updated\r\n   */\n\n\n  SummarySlide.prototype.updateSummarySlide = function (slideNumber, noJump) {\n    var that = this; // Validate update.\n\n    var isValidUpdate = this.cp.editor === undefined && this.$summarySlide !== undefined && slideNumber >= this.cp.slides.length - 1;\n    var isExportSlide = !this.cp.showSummarySlide && this.cp.hasAnswerElements;\n\n    if (!isValidUpdate) {\n      return;\n    } // Hide keywordlist on summary slide\n\n\n    if (that.cp.presentation.keywordListEnabled && that.cp.presentation.keywordListAlwaysShow) {\n      that.cp.hideKeywords();\n    } // Remove old content\n\n\n    this.$summarySlide.children().remove(); // Get scores and updated html for summary slide\n\n    var slideScores = that.cp.getSlideScores(noJump);\n    var htmlText = that.outputScoreStats(slideScores);\n    (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)(htmlText).appendTo(that.$summarySlide);\n\n    if (!isExportSlide) {\n      // Get total scores and construct progress circle\n      var totalScores = that.totalScores(slideScores);\n\n      if (!isNaN(totalScores.totalPercentage)) {\n        var totalScoreBar = _globals__WEBPACK_IMPORTED_MODULE_0__.JoubelUI.createScoreBar(totalScores.totalMaxScore, \"\", \"\", \"\");\n        totalScoreBar.setScore(totalScores.totalScore);\n        var $totalScore = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('.h5p-summary-total-score', that.$summarySlide);\n        totalScoreBar.appendTo($totalScore);\n        setTimeout(function () {\n          // Announce total score\n          $totalScore.append((0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('<div/>', {\n            'aria-live': 'polite',\n            'class': 'hidden-but-read',\n            'html': that.cp.l10n.summary + '. ' + that.cp.l10n.accessibilityTotalScore.replace('@score', totalScores.totalScore).replace('@maxScore', totalScores.totalMaxScore)\n          }));\n        }, 100);\n      } // Construct twitter share score link\n\n\n      if (that.cp.enableTwitterShare == true) {\n        var $twitterContainer = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('.h5p-summary-twitter-message', that.$summarySlide);\n        this.addTwitterScoreLinkTo($twitterContainer, totalScores);\n      } // Construct facebook share score link\n\n\n      if (that.cp.enableFacebookShare == true) {\n        var $facebookContainer = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('.h5p-summary-facebook-message', that.$summarySlide);\n        this.addFacebookScoreLinkTo($facebookContainer, totalScores);\n      } // Construct google share score link\n\n\n      if (that.cp.enableGoogleShare == true) {\n        var $googleContainer = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('.h5p-summary-google-message', that.$summarySlide);\n        this.addGoogleScoreLinkTo($googleContainer);\n      } // Update slide links\n\n\n      var links = that.$summarySlide.find('.h5p-td > .h5p-slide-link');\n      links.each(function () {\n        var slideLink = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)(this);\n        slideLink.click(function (event) {\n          that.cp.jumpToSlide(parseInt(slideLink.data('slide'), 10) - 1);\n          event.preventDefault();\n        });\n      });\n    } // Button container ref\n\n\n    var $summaryFooter = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('.h5p-summary-footer', that.$summarySlide); // Show solutions button\n\n    if (this.cp.showSummarySlideSolutionButton) {\n      _globals__WEBPACK_IMPORTED_MODULE_0__.JoubelUI.createButton({\n        'class': 'h5p-show-solutions',\n        html: that.cp.l10n.showSolutions,\n        on: {\n          click: function click() {\n            // Enable solution mode\n            that.toggleSolutionMode(true);\n          }\n        },\n        appendTo: $summaryFooter\n      });\n    } // Show solutions button\n\n\n    if (this.cp.showSummarySlideRetryButton) {\n      _globals__WEBPACK_IMPORTED_MODULE_0__.JoubelUI.createButton({\n        'class': 'h5p-cp-retry-button',\n        html: that.cp.l10n.retry,\n        on: {\n          click: function click() {\n            that.cp.resetTask(); // event.preventDefault();\n          }\n        },\n        appendTo: $summaryFooter\n      });\n    } // Only make export button if there is an export area in CP\n\n\n    if (that.cp.hasAnswerElements) {\n      _globals__WEBPACK_IMPORTED_MODULE_0__.JoubelUI.createButton({\n        'class': 'h5p-eta-export',\n        html: that.cp.l10n.exportAnswers,\n        on: {\n          click: function click() {\n            H5P.ExportableTextArea.Exporter.run(that.cp.slides, that.cp.elementInstances); // event.preventDefault();\n          }\n        },\n        appendTo: $summaryFooter\n      });\n    }\n  };\n  /**\r\n   * Gets html for summary slide.\r\n   *\r\n   * @param slideScores Scores for all pages\r\n   * @returns {string} html\r\n   */\n\n\n  SummarySlide.prototype.outputScoreStats = function (slideScores) {\n    var self = this;\n\n    if (slideScores === undefined) {\n      this.$summarySlide.addClass('h5p-summary-only-export');\n      return '<div class=\"h5p-summary-footer\"></div>';\n    }\n\n    var that = this;\n    var totalScore = 0;\n    var totalMaxScore = 0;\n    var tds = ''; // For saving the main table rows\n\n    var i;\n    var slidePercentageScore = 0;\n    var slideDescription = '';\n\n    for (i = 0; i < slideScores.length; i += 1) {\n      slideDescription = self.getSlideDescription(slideScores[i]); // Get percentage score for slide\n\n      slidePercentageScore = Math.round(slideScores[i].score / slideScores[i].maxScore * 100);\n\n      if (isNaN(slidePercentageScore)) {\n        slidePercentageScore = 0;\n      }\n\n      tds += '<tr>' + '<td class=\"h5p-td h5p-summary-task-title\">' + '<a href=\"#\" class=\"h5p-slide-link\"  aria-label=\" ' + that.cp.l10n.slide + ' ' + slideScores[i].slide + ': ' + slideDescription.replace(/(<([^>]+)>)/ig, \"\") + ' ' + slidePercentageScore + '%' + '\" data-slide=\"' + slideScores[i].slide + '\">' + that.cp.l10n.slide + ' ' + slideScores[i].slide + ': ' + slideDescription.replace(/(<([^>]+)>)/ig, \"\") + '</a>' + '</td>' + '<td class=\"h5p-td h5p-summary-score-bar\">' + '<p class=\"hidden-but-read\">' + slidePercentageScore + '%' + '</p>' + '<p>' + slideScores[i].score + '<span>/</span>' + slideScores[i].maxScore + '</p>' + '</td>' + '</tr>';\n      totalScore += slideScores[i].score;\n      totalMaxScore += slideScores[i].maxScore;\n    }\n\n    if (!this.cp.isSolutionMode) {\n      that.cp.triggerXAPICompleted(totalScore, totalMaxScore);\n    }\n\n    var shareResultContainer = that.cp.enableTwitterShare || that.cp.enableFacebookShare || that.cp.enableGoogleShare ? '<span class=\"h5p-show-results-text\">' + that.cp.l10n.shareResult + '</span>' : '';\n    var twitterContainer = that.cp.enableTwitterShare == true ? '<span class=\"h5p-summary-twitter-message\" aria-label=\"' + that.cp.l10n.shareTwitter + '\"></span>' : '';\n    var facebookContainer = that.cp.enableFacebookShare == true ? '<span class=\"h5p-summary-facebook-message\" aria-label=\"' + that.cp.l10n.shareFacebook + '\"></span>' : '';\n    var googleContainer = that.cp.enableGoogleShare == true ? '<span class=\"h5p-summary-google-message\" aria-label=\"' + that.cp.l10n.shareGoogle + '\"></span>' : '';\n    var html = '<div class=\"h5p-summary-table-holder\">' + '<div class=\"h5p-summary-table-pages\">' + '<table class=\"h5p-score-table\">' + '<thead><tr>' + '<th class=\"h5p-summary-table-header slide\">' + that.cp.l10n.slide + '</th>' + '<th class=\"h5p-summary-table-header score\">' + that.cp.l10n.score + '<span>/</span>' + that.cp.l10n.total.toLowerCase() + '</th>' + '</tr></thead>' + '<tbody>' + tds + '</tbody>' + '</table>' + '</div>' + '<div class=\"h5p-summary-total-table\">' + '<div class=\"h5p-summary-social\">' + shareResultContainer + facebookContainer + twitterContainer + googleContainer + '</div>' + '<div class=\"h5p-summary-total-score\">' + '<p>' + that.cp.l10n.totalScore + '</p>' + '</div>' + '</div>' + '</div>' + '<div class=\"h5p-summary-footer\">' + '</div>';\n    return html;\n  };\n\n  SummarySlide.prototype.getSlideDescription = function (slideScoresSlide) {\n    var self = this; // Get task description, task name or identify multiple tasks:\n\n    var slideDescription, action;\n    var slideElements = self.cp.slides[slideScoresSlide.slide - 1].elements;\n\n    if (slideScoresSlide.indexes.length > 1) {\n      slideDescription = self.cp.l10n.summaryMultipleTaskText;\n    } else if (slideElements[slideScoresSlide.indexes[0]] !== undefined && slideElements[0]) {\n      action = slideElements[slideScoresSlide.indexes[0]].action;\n\n      if (typeof self.cp.elementInstances[slideScoresSlide.slide - 1][slideScoresSlide.indexes[0]].getTitle === 'function') {\n        slideDescription = self.cp.elementInstances[slideScoresSlide.slide - 1][slideScoresSlide.indexes[0]].getTitle();\n      } else if (action.library !== undefined && action.library) {\n        // Remove major, minor version and h5p prefix, Split on uppercase\n        var humanReadableLibrary = action.library.split(' ')[0].split('.')[1].split(/(?=[A-Z])/);\n        var humanReadableString = ''; // Make library human readable\n\n        humanReadableLibrary.forEach(function (readableWord, index) {\n          // Make sequential words lowercase\n          if (index !== 0) {\n            readableWord = readableWord.toLowerCase();\n          }\n\n          humanReadableString += readableWord; // Add space between words\n\n          if (index <= humanReadableLibrary.length - 1) {\n            humanReadableString += ' ';\n          }\n        });\n        slideDescription = humanReadableString;\n      }\n    }\n\n    return slideDescription;\n  };\n  /**\r\n   * Adds a link to the given container which will link achieved score to twitter.\r\n   *\r\n   * @param {jQuery} $twitterContainer Container that should hold the twitter link.\r\n   * @param {Object} scores totalScores object to pull data from.\r\n   */\n\n\n  SummarySlide.prototype.addTwitterScoreLinkTo = function ($twitterContainer, scores) {\n    var that = this; // Get data from the localization object.\n\n    var twitterShareStatement = that.cp.twitterShareStatement || '';\n    var twitterHashtagList = that.cp.twitterShareHashtags || '';\n    var twitterShareUrl = that.cp.twitterShareUrl || ''; // Replace any placeholders with variables.\n\n    twitterShareUrl = twitterShareUrl.replace('@currentpageurl', window.location.href);\n    twitterShareStatement = twitterShareStatement.replace('@score', scores.totalScore).replace('@maxScore', scores.totalMaxScore).replace('@percentage', scores.totalPercentage + '%').replace('@currentpageurl', window.location.href); // Parse data from the localization object.\n\n    twitterHashtagList = twitterHashtagList.trim().replace(' ', ''); // Encode components that may contain breaking characters.\n\n    twitterShareStatement = encodeURIComponent(twitterShareStatement);\n    twitterHashtagList = encodeURIComponent(twitterHashtagList);\n    twitterShareUrl = encodeURIComponent(twitterShareUrl); // Add query strings to the URL based on settings.\n\n    var twitterString = 'https://twitter.com/intent/tweet?';\n    twitterString += twitterShareStatement.length > 0 ? \"text=\" + twitterShareStatement + \"&\" : \"\";\n    twitterString += twitterShareUrl.length > 0 ? \"url=\" + twitterShareUrl + \"&\" : \"\";\n    twitterString += twitterHashtagList.length > 0 ? \"hashtags=\" + twitterHashtagList : \"\";\n    var leftPos = window.innerWidth / 2;\n    var topPos = window.innerHeight / 2;\n    var popupWidth = 800;\n    var popupHeight = 300; // Create the new Twitter window.\n\n    $twitterContainer.attr('tabindex', '0').attr('role', 'button');\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.addClickAndKeyboardListeners)($twitterContainer, function () {\n      window.open(twitterString, that.cp.l10n.shareTwitter, 'width=' + popupWidth + ',height=' + popupHeight + ',left=' + leftPos + ',top=' + topPos);\n      return false;\n    });\n  };\n  /**\r\n   * Adds a link to the given container which will link achieved score to facebook.\r\n   *\r\n   * @param {jQuery} $facebookContainer Container that should hold the facebook link.\r\n   * @param {Object} scores totalScores object to pull data from.\r\n   */\n\n\n  SummarySlide.prototype.addFacebookScoreLinkTo = function ($facebookContainer, scores) {\n    var that = this; // Get data from the localization object.\n\n    var facebookShareUrl = that.cp.facebookShareUrl || '';\n    var facebookShareQuote = that.cp.facebookShareQuote || ''; // Replace any placeholders with variables.\n\n    facebookShareUrl = facebookShareUrl.replace('@currentpageurl', window.location.href);\n    facebookShareQuote = facebookShareQuote.replace('@currentpageurl', window.location.href).replace(\"@percentage\", scores.totalPercentage + '%').replace('@score', scores.totalScore).replace('@maxScore', scores.totalMaxScore); // Parse data from the localization object.\n\n    facebookShareUrl = encodeURIComponent(facebookShareUrl);\n    facebookShareQuote = encodeURIComponent(facebookShareQuote); // Add query strings to the URL based on settings.\n\n    var facebookUrl = 'https://www.facebook.com/sharer/sharer.php?';\n    facebookUrl += facebookShareUrl.length > 0 ? \"u=\" + facebookShareUrl + \"&\" : \"\";\n    facebookUrl += facebookShareQuote.length > 0 ? \"quote=\" + facebookShareQuote : '';\n    var popupWidth = 800;\n    var popupHeight = 300;\n    var leftPos = window.innerWidth / 2;\n    var topPos = window.innerHeight / 2; // Create the new Facebook window.\n\n    $facebookContainer.attr('tabindex', '0').attr('role', 'button');\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.addClickAndKeyboardListeners)($facebookContainer, function () {\n      window.open(facebookUrl, that.cp.l10n.shareFacebook, 'width=' + popupWidth + ',height=' + popupHeight + ',left=' + leftPos + ',top=' + topPos);\n      return false;\n    });\n  };\n  /**\r\n   * Adds a link to the given container which will link achieved score to google.\r\n   *\r\n   * @param {jQuery} $googleContainer Container that should hold the google link.\r\n   */\n\n\n  SummarySlide.prototype.addGoogleScoreLinkTo = function ($googleContainer) {\n    var that = this; // Get data from the localization object.\n\n    var googleShareUrl = that.cp.googleShareUrl || ''; // Replace any placeholders with variables.\n\n    googleShareUrl = googleShareUrl.replace('@currentpageurl', window.location.href); // Parse data from the localization object.\n\n    googleShareUrl = encodeURIComponent(googleShareUrl); // Add query strings to the URL based on settings.\n\n    var googleUrl = \"https://plus.google.com/share?\";\n    googleUrl += googleShareUrl.length > 0 ? \"url=\" + googleShareUrl + \"\" : \"\";\n    var popupWidth = 401;\n    var popupHeight = 437;\n    var leftPos = window.innerWidth / 2;\n    var topPos = window.innerHeight / 2; // Create the new Google+ window.\n\n    $googleContainer.attr('tabindex', '0').attr('role', 'button');\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.addClickAndKeyboardListeners)($googleContainer, function () {\n      window.open(googleUrl, that.cp.l10n.shareGoogle, 'width=' + popupWidth + ',height=' + popupHeight + ',left=' + leftPos + ',top=' + topPos);\n      return false;\n    });\n  };\n  /**\r\n   * Gets total scores for all slides\r\n   * @param {Array} slideScores\r\n   * @returns {{totalScore: number, totalMaxScore: number, totalPercentage: number}} totalScores Total scores object\r\n   */\n\n\n  SummarySlide.prototype.totalScores = function (slideScores) {\n    if (slideScores === undefined) {\n      return {\n        totalScore: 0,\n        totalMaxScore: 0,\n        totalPercentage: 0\n      };\n    }\n\n    var totalScore = 0;\n    var totalMaxScore = 0;\n    var i;\n\n    for (i = 0; i < slideScores.length; i += 1) {\n      // Get percentage score for slide\n      totalScore += slideScores[i].score;\n      totalMaxScore += slideScores[i].maxScore;\n    }\n\n    var totalPercentage = Math.round(totalScore / totalMaxScore * 100);\n\n    if (isNaN(totalPercentage)) {\n      totalPercentage = 0;\n    }\n\n    return {\n      totalScore: totalScore,\n      totalMaxScore: totalMaxScore,\n      totalPercentage: totalPercentage\n    };\n  };\n  /**\r\n   * Toggles solution mode on/off.\r\n   *\r\n   * @params {Boolean} enableSolutionMode Enable/disable solution mode\r\n   */\n\n\n  SummarySlide.prototype.toggleSolutionMode = function (enableSolutionMode) {\n    var that = this;\n    this.cp.isSolutionMode = enableSolutionMode;\n\n    if (enableSolutionMode) {\n      // Get scores for summary slide\n      var slideScores = that.cp.showSolutions(); // Update feedback icons in solution mode\n\n      this.cp.setProgressBarFeedback(slideScores);\n      this.cp.$footer.addClass('h5p-footer-solution-mode');\n      this.setFooterSolutionModeText(this.cp.l10n.solutionModeText);\n    } else {\n      this.cp.$footer.removeClass('h5p-footer-solution-mode');\n      this.setFooterSolutionModeText();\n      this.cp.setProgressBarFeedback();\n    }\n  };\n  /**\r\n   * Sets the solution mode button text in footer.\r\n   *\r\n   * @param solutionModeText\r\n   */\n\n\n  SummarySlide.prototype.setFooterSolutionModeText = function (solutionModeText) {\n    if (solutionModeText !== undefined && solutionModeText) {\n      this.cp.$exitSolutionModeText.html(solutionModeText);\n    } else if (this.cp.$exitSolutionModeText) {\n      this.cp.$exitSolutionModeText.html('');\n    }\n  };\n\n  return SummarySlide;\n}();\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SummarySlide);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FGc0IsQ0FJdEI7O01BQ0EsS0FBSy9ELEVBQUwsQ0FBUTBJLHNCQUFSLENBQStCdEgsV0FBL0I7TUFDQSxLQUFLcEIsRUFBTCxDQUFRMkksT0FBUixDQUFnQi9ELFFBQWhCLENBQXlCLDBCQUF6QjtNQUNBLEtBQUtnRSx5QkFBTCxDQUErQixLQUFLNUksRUFBTCxDQUFRb0MsSUFBUixDQUFheUcsZ0JBQTVDO0lBQ0QsQ0FSRCxNQVNLO01BQ0gsS0FBSzdJLEVBQUwsQ0FBUTJJLE9BQVIsQ0FBZ0JHLFdBQWhCLENBQTRCLDBCQUE1QjtNQUNBLEtBQUtGLHlCQUFMO01BQ0EsS0FBSzVJLEVBQUwsQ0FBUTBJLHNCQUFSO0lBQ0Q7RUFDRixDQWxCRDtFQW9CQTtBQUNGO0FBQ0E7QUFDQTtBQUNBOzs7RUFDRTdJLFlBQVksQ0FBQ0ksU0FBYixDQUF1QjJJLHlCQUF2QixHQUFtRCxVQUFVQyxnQkFBVixFQUE0QjtJQUM3RSxJQUFJQSxnQkFBZ0IsS0FBS3JJLFNBQXJCLElBQWtDcUksZ0JBQXRDLEVBQXdEO01BQ3RELEtBQUs3SSxFQUFMLENBQVErSSxxQkFBUixDQUE4QmpGLElBQTlCLENBQW1DK0UsZ0JBQW5DO0lBQ0QsQ0FGRCxNQUdLLElBQUksS0FBSzdJLEVBQUwsQ0FBUStJLHFCQUFaLEVBQW1DO01BQ3RDLEtBQUsvSSxFQUFMLENBQVErSSxxQkFBUixDQUE4QmpGLElBQTlCLENBQW1DLEVBQW5DO0lBQ0Q7RUFDRixDQVBEOztFQVNBLE9BQU9qRSxZQUFQO0FBQ0QsQ0F6ZW9CLEVBQXJCOztBQTJlQSxpRUFBZUEsWUFBZiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NjcmlwdHMvc3VtbWFyeS1zbGlkZS5qcz8xZjgxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpRdWVyeSBhcyAkLCBKb3ViZWxVSSB9IGZyb20gJy4vZ2xvYmFscyc7XHJcbmltcG9ydCB7YWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVyc30gZnJvbSBcIi4vdXRpbHNcIjtcclxuXHJcbmNvbnN0IFN1bW1hcnlTbGlkZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yIGZvciBzdW1tYXJ5IHNsaWRlXHJcbiAgICogQHBhcmFtIHtINVAuQ291cnNlUHJlc2VudGF0aW9ufSBjb3Vyc2VQcmVzZW50YXRpb24gQ291cnNlIHByZXNlbnRhdGlvbiBwYXJlbnQgb2Ygc3VtbWFyeSBzbGlkZVxyXG4gICAqIEBwYXJhbSB7JH0gJHN1bW1hcnlTbGlkZSBTdW1tYXJ5IHNsaWRlIGVsZW1lbnRcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKi9cclxuICBmdW5jdGlvbiBTdW1tYXJ5U2xpZGUoY291cnNlUHJlc2VudGF0aW9uLCAkc3VtbWFyeVNsaWRlKSB7XHJcbiAgICAvLyBDcmVhdGUgc3VtbWFyeSBzbGlkZSBpZiBub3QgYW4gZWRpdG9yXHJcbiAgICB0aGlzLiRzdW1tYXJ5U2xpZGUgPSAkc3VtbWFyeVNsaWRlO1xyXG4gICAgdGhpcy5jcCA9IGNvdXJzZVByZXNlbnRhdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHByb3ZpZGVkIHN1bW1hcnkgc2xpZGUgd2l0aCBjdXJyZW50IHZhbHVlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7JH0gJHN1bW1hcnlTbGlkZSBTdW1tYXJ5IHNsaWRlIHRoYXQgd2lsbCBiZSB1cGRhdGVkXHJcbiAgICovXHJcbiAgU3VtbWFyeVNsaWRlLnByb3RvdHlwZS51cGRhdGVTdW1tYXJ5U2xpZGUgPSBmdW5jdGlvbiAoc2xpZGVOdW1iZXIsIG5vSnVtcCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgLy8gVmFsaWRhdGUgdXBkYXRlLlxyXG4gICAgdmFyIGlzVmFsaWRVcGRhdGUgPSAodGhpcy5jcC5lZGl0b3IgPT09IHVuZGVmaW5lZCkgJiYgKHRoaXMuJHN1bW1hcnlTbGlkZSAhPT0gdW5kZWZpbmVkKSAmJiAoc2xpZGVOdW1iZXIgPj0gdGhpcy5jcC5zbGlkZXMubGVuZ3RoIC0gMSk7XHJcbiAgICB2YXIgaXNFeHBvcnRTbGlkZSA9ICghdGhpcy5jcC5zaG93U3VtbWFyeVNsaWRlICYmIHRoaXMuY3AuaGFzQW5zd2VyRWxlbWVudHMpO1xyXG4gICAgaWYgKCFpc1ZhbGlkVXBkYXRlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBIaWRlIGtleXdvcmRsaXN0IG9uIHN1bW1hcnkgc2xpZGVcclxuICAgIGlmICh0aGF0LmNwLnByZXNlbnRhdGlvbi5rZXl3b3JkTGlzdEVuYWJsZWQgJiYgdGhhdC5jcC5wcmVzZW50YXRpb24ua2V5d29yZExpc3RBbHdheXNTaG93KSB7XHJcbiAgICAgIHRoYXQuY3AuaGlkZUtleXdvcmRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIG9sZCBjb250ZW50XHJcbiAgICB0aGlzLiRzdW1tYXJ5U2xpZGUuY2hpbGRyZW4oKS5yZW1vdmUoKTtcclxuXHJcbiAgICAvLyBHZXQgc2NvcmVzIGFuZCB1cGRhdGVkIGh0bWwgZm9yIHN1bW1hcnkgc2xpZGVcclxuICAgIHZhciBzbGlkZVNjb3JlcyA9IHRoYXQuY3AuZ2V0U2xpZGVTY29yZXMobm9KdW1wKTtcclxuICAgIHZhciBodG1sVGV4dCA9IHRoYXQub3V0cHV0U2NvcmVTdGF0cyhzbGlkZVNjb3Jlcyk7XHJcbiAgICAkKGh0bWxUZXh0KS5hcHBlbmRUbyh0aGF0LiRzdW1tYXJ5U2xpZGUpO1xyXG5cclxuICAgIGlmICghaXNFeHBvcnRTbGlkZSkge1xyXG4gICAgICAvLyBHZXQgdG90YWwgc2NvcmVzIGFuZCBjb25zdHJ1Y3QgcHJvZ3Jlc3MgY2lyY2xlXHJcbiAgICAgIHZhciB0b3RhbFNjb3JlcyA9IHRoYXQudG90YWxTY29yZXMoc2xpZGVTY29yZXMpO1xyXG4gICAgICBpZiAoIWlzTmFOKHRvdGFsU2NvcmVzLnRvdGFsUGVyY2VudGFnZSkpIHtcclxuICAgICAgICB2YXIgdG90YWxTY29yZUJhciA9IEpvdWJlbFVJLmNyZWF0ZVNjb3JlQmFyKHRvdGFsU2NvcmVzLnRvdGFsTWF4U2NvcmUsIFwiXCIsIFwiXCIsIFwiXCIpO1xyXG4gICAgICAgIHRvdGFsU2NvcmVCYXIuc2V0U2NvcmUodG90YWxTY29yZXMudG90YWxTY29yZSk7XHJcbiAgICAgICAgdmFyICR0b3RhbFNjb3JlID0gJCgnLmg1cC1zdW1tYXJ5LXRvdGFsLXNjb3JlJywgdGhhdC4kc3VtbWFyeVNsaWRlKTtcclxuICAgICAgICB0b3RhbFNjb3JlQmFyLmFwcGVuZFRvKCR0b3RhbFNjb3JlKTtcclxuXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAvLyBBbm5vdW5jZSB0b3RhbCBzY29yZVxyXG4gICAgICAgICAgJHRvdGFsU2NvcmUuYXBwZW5kKCQoJzxkaXYvPicsIHtcclxuICAgICAgICAgICAgJ2FyaWEtbGl2ZSc6ICdwb2xpdGUnLFxyXG4gICAgICAgICAgICAnY2xhc3MnOiAnaGlkZGVuLWJ1dC1yZWFkJyxcclxuICAgICAgICAgICAgJ2h0bWwnOiB0aGF0LmNwLmwxMG4uc3VtbWFyeSArICcuICcgK1xyXG4gICAgICAgICAgICAgIHRoYXQuY3AubDEwbi5hY2Nlc3NpYmlsaXR5VG90YWxTY29yZVxyXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ0BzY29yZScsIHRvdGFsU2NvcmVzLnRvdGFsU2NvcmUpXHJcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgnQG1heFNjb3JlJywgdG90YWxTY29yZXMudG90YWxNYXhTY29yZSlcclxuICAgICAgICAgIH0pKTtcclxuICAgICAgICB9LCAxMDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb25zdHJ1Y3QgdHdpdHRlciBzaGFyZSBzY29yZSBsaW5rXHJcbiAgICAgIGlmICh0aGF0LmNwLmVuYWJsZVR3aXR0ZXJTaGFyZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgdmFyICR0d2l0dGVyQ29udGFpbmVyID0gJCgnLmg1cC1zdW1tYXJ5LXR3aXR0ZXItbWVzc2FnZScsIHRoYXQuJHN1bW1hcnlTbGlkZSk7XHJcbiAgICAgICAgdGhpcy5hZGRUd2l0dGVyU2NvcmVMaW5rVG8oJHR3aXR0ZXJDb250YWluZXIsIHRvdGFsU2NvcmVzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29uc3RydWN0IGZhY2Vib29rIHNoYXJlIHNjb3JlIGxpbmtcclxuICAgICAgaWYgKHRoYXQuY3AuZW5hYmxlRmFjZWJvb2tTaGFyZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgdmFyICRmYWNlYm9va0NvbnRhaW5lciA9ICQoJy5oNXAtc3VtbWFyeS1mYWNlYm9vay1tZXNzYWdlJywgdGhhdC4kc3VtbWFyeVNsaWRlKTtcclxuICAgICAgICB0aGlzLmFkZEZhY2Vib29rU2NvcmVMaW5rVG8oJGZhY2Vib29rQ29udGFpbmVyLCB0b3RhbFNjb3Jlcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnN0cnVjdCBnb29nbGUgc2hhcmUgc2NvcmUgbGlua1xyXG4gICAgICBpZiAodGhhdC5jcC5lbmFibGVHb29nbGVTaGFyZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgdmFyICRnb29nbGVDb250YWluZXIgPSAkKCcuaDVwLXN1bW1hcnktZ29vZ2xlLW1lc3NhZ2UnLCB0aGF0LiRzdW1tYXJ5U2xpZGUpO1xyXG4gICAgICAgIHRoaXMuYWRkR29vZ2xlU2NvcmVMaW5rVG8oJGdvb2dsZUNvbnRhaW5lcik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBzbGlkZSBsaW5rc1xyXG4gICAgICB2YXIgbGlua3MgPSB0aGF0LiRzdW1tYXJ5U2xpZGUuZmluZCgnLmg1cC10ZCA+IC5oNXAtc2xpZGUtbGluaycpO1xyXG4gICAgICBsaW5rcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2xpZGVMaW5rID0gJCh0aGlzKTtcclxuICAgICAgICBzbGlkZUxpbmsuY2xpY2soZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICB0aGF0LmNwLmp1bXBUb1NsaWRlKHBhcnNlSW50KHNsaWRlTGluay5kYXRhKCdzbGlkZScpLCAxMCkgLSAxKTtcclxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1dHRvbiBjb250YWluZXIgcmVmXHJcbiAgICB2YXIgJHN1bW1hcnlGb290ZXIgPSAkKCcuaDVwLXN1bW1hcnktZm9vdGVyJywgdGhhdC4kc3VtbWFyeVNsaWRlKTtcclxuXHJcbiAgICAvLyBTaG93IHNvbHV0aW9ucyBidXR0b25cclxuICAgIGlmICh0aGlzLmNwLnNob3dTdW1tYXJ5U2xpZGVTb2x1dGlvbkJ1dHRvbikge1xyXG4gICAgICBKb3ViZWxVSS5jcmVhdGVCdXR0b24oe1xyXG4gICAgICAgICdjbGFzcyc6ICdoNXAtc2hvdy1zb2x1dGlvbnMnLFxyXG4gICAgICAgIGh0bWw6IHRoYXQuY3AubDEwbi5zaG93U29sdXRpb25zLFxyXG4gICAgICAgIG9uOiB7XHJcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBFbmFibGUgc29sdXRpb24gbW9kZVxyXG4gICAgICAgICAgICB0aGF0LnRvZ2dsZVNvbHV0aW9uTW9kZSh0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFwcGVuZFRvOiAkc3VtbWFyeUZvb3RlclxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTaG93IHNvbHV0aW9ucyBidXR0b25cclxuICAgIGlmICh0aGlzLmNwLnNob3dTdW1tYXJ5U2xpZGVSZXRyeUJ1dHRvbikge1xyXG4gICAgICBKb3ViZWxVSS5jcmVhdGVCdXR0b24oe1xyXG4gICAgICAgICdjbGFzcyc6ICdoNXAtY3AtcmV0cnktYnV0dG9uJyxcclxuICAgICAgICBodG1sOiB0aGF0LmNwLmwxMG4ucmV0cnksXHJcbiAgICAgICAgb246IHtcclxuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoYXQuY3AucmVzZXRUYXNrKCk7XHJcbiAgICAgICAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcHBlbmRUbzogJHN1bW1hcnlGb290ZXJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBtYWtlIGV4cG9ydCBidXR0b24gaWYgdGhlcmUgaXMgYW4gZXhwb3J0IGFyZWEgaW4gQ1BcclxuICAgIGlmICh0aGF0LmNwLmhhc0Fuc3dlckVsZW1lbnRzKSB7XHJcbiAgICAgIEpvdWJlbFVJLmNyZWF0ZUJ1dHRvbih7XHJcbiAgICAgICAgJ2NsYXNzJzogJ2g1cC1ldGEtZXhwb3J0JyxcclxuICAgICAgICBodG1sOiB0aGF0LmNwLmwxMG4uZXhwb3J0QW5zd2VycyxcclxuICAgICAgICBvbjoge1xyXG4gICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgSDVQLkV4cG9ydGFibGVUZXh0QXJlYS5FeHBvcnRlci5ydW4odGhhdC5jcC5zbGlkZXMsIHRoYXQuY3AuZWxlbWVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgIC8vIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhcHBlbmRUbzogJHN1bW1hcnlGb290ZXJcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBodG1sIGZvciBzdW1tYXJ5IHNsaWRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNsaWRlU2NvcmVzIFNjb3JlcyBmb3IgYWxsIHBhZ2VzXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gaHRtbFxyXG4gICAqL1xyXG4gIFN1bW1hcnlTbGlkZS5wcm90b3R5cGUub3V0cHV0U2NvcmVTdGF0cyA9IGZ1bmN0aW9uIChzbGlkZVNjb3Jlcykge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgaWYgKHNsaWRlU2NvcmVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy4kc3VtbWFyeVNsaWRlLmFkZENsYXNzKCdoNXAtc3VtbWFyeS1vbmx5LWV4cG9ydCcpO1xyXG4gICAgICByZXR1cm4gJzxkaXYgY2xhc3M9XCJoNXAtc3VtbWFyeS1mb290ZXJcIj48L2Rpdj4nO1xyXG4gICAgfVxyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG4gICAgdmFyIHRvdGFsU2NvcmUgPSAwO1xyXG4gICAgdmFyIHRvdGFsTWF4U2NvcmUgPSAwO1xyXG4gICAgdmFyIHRkcyA9ICcnOyAvLyBGb3Igc2F2aW5nIHRoZSBtYWluIHRhYmxlIHJvd3NcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHNsaWRlUGVyY2VudGFnZVNjb3JlID0gMDtcclxuICAgIHZhciBzbGlkZURlc2NyaXB0aW9uID0gJyc7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2xpZGVTY29yZXMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgc2xpZGVEZXNjcmlwdGlvbiA9IHNlbGYuZ2V0U2xpZGVEZXNjcmlwdGlvbihzbGlkZVNjb3Jlc1tpXSk7XHJcblxyXG4gICAgICAvLyBHZXQgcGVyY2VudGFnZSBzY29yZSBmb3Igc2xpZGVcclxuICAgICAgc2xpZGVQZXJjZW50YWdlU2NvcmUgPSBNYXRoLnJvdW5kKChzbGlkZVNjb3Jlc1tpXS5zY29yZSAvIHNsaWRlU2NvcmVzW2ldLm1heFNjb3JlKSAqIDEwMCk7XHJcbiAgICAgIGlmIChpc05hTihzbGlkZVBlcmNlbnRhZ2VTY29yZSkpIHtcclxuICAgICAgICBzbGlkZVBlcmNlbnRhZ2VTY29yZSA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgdGRzICs9XHJcbiAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICc8dGQgY2xhc3M9XCJoNXAtdGQgaDVwLXN1bW1hcnktdGFzay10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICAnPGEgaHJlZj1cIiNcIiBjbGFzcz1cImg1cC1zbGlkZS1saW5rXCIgIGFyaWEtbGFiZWw9XCIgJyArXHJcbiAgICAgICAgICAgICAgdGhhdC5jcC5sMTBuLnNsaWRlICsgJyAnICsgc2xpZGVTY29yZXNbaV0uc2xpZGUgKyAnOiAnICsgKHNsaWRlRGVzY3JpcHRpb24ucmVwbGFjZSgvKDwoW14+XSspPikvaWcsIFwiXCIpKSArICcgJyArXHJcbiAgICAgICAgICAgICAgc2xpZGVQZXJjZW50YWdlU2NvcmUgKyAnJScgK1xyXG4gICAgICAgICAgICAgICdcIiBkYXRhLXNsaWRlPVwiJyArXHJcbiAgICAgICAgICAgICAgc2xpZGVTY29yZXNbaV0uc2xpZGUgKyAnXCI+JyArIHRoYXQuY3AubDEwbi5zbGlkZSArICcgJyArIHNsaWRlU2NvcmVzW2ldLnNsaWRlICsgJzogJyArIChzbGlkZURlc2NyaXB0aW9uLnJlcGxhY2UoLyg8KFtePl0rKT4pL2lnLCBcIlwiKSkgK1xyXG4gICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAnPHRkIGNsYXNzPVwiaDVwLXRkIGg1cC1zdW1tYXJ5LXNjb3JlLWJhclwiPicgK1xyXG4gICAgICAgICAgICAnPHAgY2xhc3M9XCJoaWRkZW4tYnV0LXJlYWRcIj4nICsgc2xpZGVQZXJjZW50YWdlU2NvcmUgKyAnJScgKyAnPC9wPicgK1xyXG4gICAgICAgICAgICAnPHA+JyArIHNsaWRlU2NvcmVzW2ldLnNjb3JlICsgJzxzcGFuPi88L3NwYW4+JyArIHNsaWRlU2NvcmVzW2ldLm1heFNjb3JlICsgJzwvcD4nICtcclxuICAgICAgICAgICc8L3RkPicgK1xyXG4gICAgICAgICc8L3RyPic7XHJcbiAgICAgIHRvdGFsU2NvcmUgKz0gc2xpZGVTY29yZXNbaV0uc2NvcmU7XHJcbiAgICAgIHRvdGFsTWF4U2NvcmUgKz0gc2xpZGVTY29yZXNbaV0ubWF4U2NvcmU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmNwLmlzU29sdXRpb25Nb2RlKSB7XHJcbiAgICAgIHRoYXQuY3AudHJpZ2dlclhBUElDb21wbGV0ZWQodG90YWxTY29yZSwgdG90YWxNYXhTY29yZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgc2hhcmVSZXN1bHRDb250YWluZXIgPSAodGhhdC5jcC5lbmFibGVUd2l0dGVyU2hhcmUgfHwgdGhhdC5jcC5lbmFibGVGYWNlYm9va1NoYXJlIHx8IHRoYXQuY3AuZW5hYmxlR29vZ2xlU2hhcmUpID8gJzxzcGFuIGNsYXNzPVwiaDVwLXNob3ctcmVzdWx0cy10ZXh0XCI+JyArIHRoYXQuY3AubDEwbi5zaGFyZVJlc3VsdCArICc8L3NwYW4+JyA6ICcnO1xyXG4gICAgdmFyIHR3aXR0ZXJDb250YWluZXIgPSAodGhhdC5jcC5lbmFibGVUd2l0dGVyU2hhcmUgPT0gdHJ1ZSkgPyAnPHNwYW4gY2xhc3M9XCJoNXAtc3VtbWFyeS10d2l0dGVyLW1lc3NhZ2VcIiBhcmlhLWxhYmVsPVwiJyArIHRoYXQuY3AubDEwbi5zaGFyZVR3aXR0ZXIgKyAnXCI+PC9zcGFuPic6ICcnO1xyXG4gICAgdmFyIGZhY2Vib29rQ29udGFpbmVyID0gKHRoYXQuY3AuZW5hYmxlRmFjZWJvb2tTaGFyZSA9PSB0cnVlKSA/ICc8c3BhbiBjbGFzcz1cImg1cC1zdW1tYXJ5LWZhY2Vib29rLW1lc3NhZ2VcIiBhcmlhLWxhYmVsPVwiJyArIHRoYXQuY3AubDEwbi5zaGFyZUZhY2Vib29rICsgJ1wiPjwvc3Bhbj4nOiAnJztcclxuICAgIHZhciBnb29nbGVDb250YWluZXIgPSAodGhhdC5jcC5lbmFibGVHb29nbGVTaGFyZSA9PSB0cnVlKSA/ICc8c3BhbiBjbGFzcz1cImg1cC1zdW1tYXJ5LWdvb2dsZS1tZXNzYWdlXCIgYXJpYS1sYWJlbD1cIicgKyB0aGF0LmNwLmwxMG4uc2hhcmVHb29nbGUgKyAnXCI+PC9zcGFuPicgOiAnJztcclxuXHJcbiAgICB2YXIgaHRtbCA9XHJcbiAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLXN1bW1hcnktdGFibGUtaG9sZGVyXCI+JyArXHJcbiAgICAgICAgJzxkaXYgY2xhc3M9XCJoNXAtc3VtbWFyeS10YWJsZS1wYWdlc1wiPicgK1xyXG4gICAgICAgICAgJzx0YWJsZSBjbGFzcz1cImg1cC1zY29yZS10YWJsZVwiPicgK1xyXG4gICAgICAgICAgICAnPHRoZWFkPjx0cj4nICtcclxuICAgICAgICAgICAgICAnPHRoIGNsYXNzPVwiaDVwLXN1bW1hcnktdGFibGUtaGVhZGVyIHNsaWRlXCI+JyArIHRoYXQuY3AubDEwbi5zbGlkZSArICc8L3RoPicgK1xyXG4gICAgICAgICAgICAgICc8dGggY2xhc3M9XCJoNXAtc3VtbWFyeS10YWJsZS1oZWFkZXIgc2NvcmVcIj4nICsgdGhhdC5jcC5sMTBuLnNjb3JlICsgJzxzcGFuPi88L3NwYW4+JyArIHRoYXQuY3AubDEwbi50b3RhbC50b0xvd2VyQ2FzZSgpICsgJzwvdGg+JyArXHJcbiAgICAgICAgICAgICc8L3RyPjwvdGhlYWQ+JyArXHJcbiAgICAgICAgICAgICc8dGJvZHk+JyArIHRkcyArICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLXN1bW1hcnktdG90YWwtdGFibGVcIj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLXN1bW1hcnktc29jaWFsXCI+JyArXHJcbiAgICAgICAgICAgIHNoYXJlUmVzdWx0Q29udGFpbmVyICtcclxuICAgICAgICAgICAgZmFjZWJvb2tDb250YWluZXIgK1xyXG4gICAgICAgICAgICB0d2l0dGVyQ29udGFpbmVyICtcclxuICAgICAgICAgICAgZ29vZ2xlQ29udGFpbmVyICtcclxuICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLXN1bW1hcnktdG90YWwtc2NvcmVcIj4nICtcclxuICAgICAgICAgICAgJzxwPicgKyB0aGF0LmNwLmwxMG4udG90YWxTY29yZSArICc8L3A+JyArXHJcbiAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAnPC9kaXY+JyArXHJcbiAgICAgICc8ZGl2IGNsYXNzPVwiaDVwLXN1bW1hcnktZm9vdGVyXCI+JyArXHJcbiAgICAgICc8L2Rpdj4nO1xyXG5cclxuICAgIHJldHVybiBodG1sO1xyXG4gIH07XHJcblxyXG4gIFN1bW1hcnlTbGlkZS5wcm90b3R5cGUuZ2V0U2xpZGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChzbGlkZVNjb3Jlc1NsaWRlKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy8gR2V0IHRhc2sgZGVzY3JpcHRpb24sIHRhc2sgbmFtZSBvciBpZGVudGlmeSBtdWx0aXBsZSB0YXNrczpcclxuICAgIHZhciBzbGlkZURlc2NyaXB0aW9uLCBhY3Rpb247XHJcbiAgICB2YXIgc2xpZGVFbGVtZW50cyA9IHNlbGYuY3Auc2xpZGVzW3NsaWRlU2NvcmVzU2xpZGUuc2xpZGUgLSAxXS5lbGVtZW50cztcclxuICAgIGlmIChzbGlkZVNjb3Jlc1NsaWRlLmluZGV4ZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICBzbGlkZURlc2NyaXB0aW9uID0gc2VsZi5jcC5sMTBuLnN1bW1hcnlNdWx0aXBsZVRhc2tUZXh0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2xpZGVFbGVtZW50c1tzbGlkZVNjb3Jlc1NsaWRlLmluZGV4ZXNbMF1dICE9PSB1bmRlZmluZWQgJiYgc2xpZGVFbGVtZW50c1swXSkge1xyXG4gICAgICBhY3Rpb24gPSBzbGlkZUVsZW1lbnRzW3NsaWRlU2NvcmVzU2xpZGUuaW5kZXhlc1swXV0uYWN0aW9uO1xyXG4gICAgICBpZiAodHlwZW9mIHNlbGYuY3AuZWxlbWVudEluc3RhbmNlc1tzbGlkZVNjb3Jlc1NsaWRlLnNsaWRlIC0gMV1bc2xpZGVTY29yZXNTbGlkZS5pbmRleGVzWzBdXS5nZXRUaXRsZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHNsaWRlRGVzY3JpcHRpb24gPSBzZWxmLmNwLmVsZW1lbnRJbnN0YW5jZXNbc2xpZGVTY29yZXNTbGlkZS5zbGlkZSAtIDFdW3NsaWRlU2NvcmVzU2xpZGUuaW5kZXhlc1swXV0uZ2V0VGl0bGUoKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChhY3Rpb24ubGlicmFyeSAhPT0gdW5kZWZpbmVkICYmIGFjdGlvbi5saWJyYXJ5KSB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBtYWpvciwgbWlub3IgdmVyc2lvbiBhbmQgaDVwIHByZWZpeCwgU3BsaXQgb24gdXBwZXJjYXNlXHJcbiAgICAgICAgdmFyIGh1bWFuUmVhZGFibGVMaWJyYXJ5ID0gYWN0aW9uLmxpYnJhcnlcclxuICAgICAgICAgIC5zcGxpdCgnICcpWzBdXHJcbiAgICAgICAgICAuc3BsaXQoJy4nKVsxXVxyXG4gICAgICAgICAgLnNwbGl0KC8oPz1bQS1aXSkvKTtcclxuICAgICAgICB2YXIgaHVtYW5SZWFkYWJsZVN0cmluZyA9ICcnO1xyXG5cclxuICAgICAgICAvLyBNYWtlIGxpYnJhcnkgaHVtYW4gcmVhZGFibGVcclxuICAgICAgICBodW1hblJlYWRhYmxlTGlicmFyeS5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkYWJsZVdvcmQsIGluZGV4KSB7XHJcblxyXG4gICAgICAgICAgLy8gTWFrZSBzZXF1ZW50aWFsIHdvcmRzIGxvd2VyY2FzZVxyXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJlYWRhYmxlV29yZCA9IHJlYWRhYmxlV29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaHVtYW5SZWFkYWJsZVN0cmluZyArPSByZWFkYWJsZVdvcmQ7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHNwYWNlIGJldHdlZW4gd29yZHNcclxuICAgICAgICAgIGlmIChpbmRleCA8PSBodW1hblJlYWRhYmxlTGlicmFyeS5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgIGh1bWFuUmVhZGFibGVTdHJpbmcgKz0gJyAnO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNsaWRlRGVzY3JpcHRpb24gPSBodW1hblJlYWRhYmxlU3RyaW5nO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2xpZGVEZXNjcmlwdGlvbjtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbGluayB0byB0aGUgZ2l2ZW4gY29udGFpbmVyIHdoaWNoIHdpbGwgbGluayBhY2hpZXZlZCBzY29yZSB0byB0d2l0dGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtqUXVlcnl9ICR0d2l0dGVyQ29udGFpbmVyIENvbnRhaW5lciB0aGF0IHNob3VsZCBob2xkIHRoZSB0d2l0dGVyIGxpbmsuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjb3JlcyB0b3RhbFNjb3JlcyBvYmplY3QgdG8gcHVsbCBkYXRhIGZyb20uXHJcbiAgICovXHJcbiAgU3VtbWFyeVNsaWRlLnByb3RvdHlwZS5hZGRUd2l0dGVyU2NvcmVMaW5rVG8gPSBmdW5jdGlvbiAoJHR3aXR0ZXJDb250YWluZXIsIHNjb3Jlcykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8vIEdldCBkYXRhIGZyb20gdGhlIGxvY2FsaXphdGlvbiBvYmplY3QuXHJcbiAgICB2YXIgdHdpdHRlclNoYXJlU3RhdGVtZW50ID0gdGhhdC5jcC50d2l0dGVyU2hhcmVTdGF0ZW1lbnQgfHwgJyc7XHJcbiAgICB2YXIgdHdpdHRlckhhc2h0YWdMaXN0ID0gdGhhdC5jcC50d2l0dGVyU2hhcmVIYXNodGFncyB8fCAnJztcclxuICAgIHZhciB0d2l0dGVyU2hhcmVVcmwgPSB0aGF0LmNwLnR3aXR0ZXJTaGFyZVVybCB8fCAnJztcclxuXHJcbiAgICAvLyBSZXBsYWNlIGFueSBwbGFjZWhvbGRlcnMgd2l0aCB2YXJpYWJsZXMuXHJcbiAgICB0d2l0dGVyU2hhcmVVcmwgPSB0d2l0dGVyU2hhcmVVcmwucmVwbGFjZSgnQGN1cnJlbnRwYWdldXJsJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG4gICAgdHdpdHRlclNoYXJlU3RhdGVtZW50ID0gdHdpdHRlclNoYXJlU3RhdGVtZW50XHJcbiAgICAgIC5yZXBsYWNlKCdAc2NvcmUnLCBzY29yZXMudG90YWxTY29yZSlcclxuICAgICAgLnJlcGxhY2UoJ0BtYXhTY29yZScsIHNjb3Jlcy50b3RhbE1heFNjb3JlKVxyXG4gICAgICAucmVwbGFjZSgnQHBlcmNlbnRhZ2UnLCBzY29yZXMudG90YWxQZXJjZW50YWdlICsgJyUnKVxyXG4gICAgICAucmVwbGFjZSgnQGN1cnJlbnRwYWdldXJsJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG5cclxuICAgIC8vIFBhcnNlIGRhdGEgZnJvbSB0aGUgbG9jYWxpemF0aW9uIG9iamVjdC5cclxuICAgIHR3aXR0ZXJIYXNodGFnTGlzdCA9IHR3aXR0ZXJIYXNodGFnTGlzdC50cmltKCkucmVwbGFjZSgnICcsICcnKTtcclxuXHJcbiAgICAvLyBFbmNvZGUgY29tcG9uZW50cyB0aGF0IG1heSBjb250YWluIGJyZWFraW5nIGNoYXJhY3RlcnMuXHJcbiAgICB0d2l0dGVyU2hhcmVTdGF0ZW1lbnQgPSBlbmNvZGVVUklDb21wb25lbnQodHdpdHRlclNoYXJlU3RhdGVtZW50KTtcclxuICAgIHR3aXR0ZXJIYXNodGFnTGlzdCA9IGVuY29kZVVSSUNvbXBvbmVudCh0d2l0dGVySGFzaHRhZ0xpc3QpO1xyXG4gICAgdHdpdHRlclNoYXJlVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KHR3aXR0ZXJTaGFyZVVybCk7XHJcblxyXG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZ3MgdG8gdGhlIFVSTCBiYXNlZCBvbiBzZXR0aW5ncy5cclxuICAgIHZhciB0d2l0dGVyU3RyaW5nID0gJ2h0dHBzOi8vdHdpdHRlci5jb20vaW50ZW50L3R3ZWV0Pyc7XHJcbiAgICB0d2l0dGVyU3RyaW5nICs9ICh0d2l0dGVyU2hhcmVTdGF0ZW1lbnQubGVuZ3RoID4gMCkgPyBcInRleHQ9XCIrdHdpdHRlclNoYXJlU3RhdGVtZW50K1wiJlwiIDogXCJcIjtcclxuICAgIHR3aXR0ZXJTdHJpbmcgKz0gKHR3aXR0ZXJTaGFyZVVybC5sZW5ndGggPiAwKSA/IFwidXJsPVwiK3R3aXR0ZXJTaGFyZVVybCtcIiZcIiA6IFwiXCI7XHJcbiAgICB0d2l0dGVyU3RyaW5nICs9ICh0d2l0dGVySGFzaHRhZ0xpc3QubGVuZ3RoID4gMCkgPyBcImhhc2h0YWdzPVwiK3R3aXR0ZXJIYXNodGFnTGlzdCA6IFwiXCI7XHJcblxyXG4gICAgdmFyIGxlZnRQb3MgPSAod2luZG93LmlubmVyV2lkdGggLyAyKTtcclxuICAgIHZhciB0b3BQb3MgPSAod2luZG93LmlubmVySGVpZ2h0IC8gMik7XHJcbiAgICB2YXIgcG9wdXBXaWR0aCA9IDgwMDtcclxuICAgIHZhciBwb3B1cEhlaWdodCA9IDMwMDtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIG5ldyBUd2l0dGVyIHdpbmRvdy5cclxuICAgICR0d2l0dGVyQ29udGFpbmVyLmF0dHIoJ3RhYmluZGV4JywgJzAnKVxyXG4gICAgICAuYXR0cigncm9sZScsICdidXR0b24nKTtcclxuXHJcbiAgICBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzKCR0d2l0dGVyQ29udGFpbmVyLCAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5vcGVuKHR3aXR0ZXJTdHJpbmcsXHJcbiAgICAgICAgdGhhdC5jcC5sMTBuLnNoYXJlVHdpdHRlcixcclxuICAgICAgICAnd2lkdGg9JyArIHBvcHVwV2lkdGggK1xyXG4gICAgICAgICcsaGVpZ2h0PScgKyBwb3B1cEhlaWdodCArXHJcbiAgICAgICAgJyxsZWZ0PScgKyBsZWZ0UG9zICtcclxuICAgICAgICAnLHRvcD0nICsgdG9wUG9zKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGdpdmVuIGNvbnRhaW5lciB3aGljaCB3aWxsIGxpbmsgYWNoaWV2ZWQgc2NvcmUgdG8gZmFjZWJvb2suXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2pRdWVyeX0gJGZhY2Vib29rQ29udGFpbmVyIENvbnRhaW5lciB0aGF0IHNob3VsZCBob2xkIHRoZSBmYWNlYm9vayBsaW5rLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY29yZXMgdG90YWxTY29yZXMgb2JqZWN0IHRvIHB1bGwgZGF0YSBmcm9tLlxyXG4gICAqL1xyXG4gIFN1bW1hcnlTbGlkZS5wcm90b3R5cGUuYWRkRmFjZWJvb2tTY29yZUxpbmtUbyA9IGZ1bmN0aW9uICgkZmFjZWJvb2tDb250YWluZXIsIHNjb3Jlcykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8vIEdldCBkYXRhIGZyb20gdGhlIGxvY2FsaXphdGlvbiBvYmplY3QuXHJcbiAgICB2YXIgZmFjZWJvb2tTaGFyZVVybCA9IHRoYXQuY3AuZmFjZWJvb2tTaGFyZVVybCB8fCAnJztcclxuICAgIHZhciBmYWNlYm9va1NoYXJlUXVvdGUgPSB0aGF0LmNwLmZhY2Vib29rU2hhcmVRdW90ZSB8fCAnJztcclxuXHJcbiAgICAvLyBSZXBsYWNlIGFueSBwbGFjZWhvbGRlcnMgd2l0aCB2YXJpYWJsZXMuXHJcbiAgICBmYWNlYm9va1NoYXJlVXJsID0gZmFjZWJvb2tTaGFyZVVybC5yZXBsYWNlKCdAY3VycmVudHBhZ2V1cmwnLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XHJcblxyXG4gICAgZmFjZWJvb2tTaGFyZVF1b3RlID0gZmFjZWJvb2tTaGFyZVF1b3RlLnJlcGxhY2UoJ0BjdXJyZW50cGFnZXVybCcsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxyXG4gICAgICAucmVwbGFjZShcIkBwZXJjZW50YWdlXCIsIHNjb3Jlcy50b3RhbFBlcmNlbnRhZ2UgKyAnJScpXHJcbiAgICAgIC5yZXBsYWNlKCdAc2NvcmUnLCBzY29yZXMudG90YWxTY29yZSlcclxuICAgICAgLnJlcGxhY2UoJ0BtYXhTY29yZScsIHNjb3Jlcy50b3RhbE1heFNjb3JlKTtcclxuXHJcbiAgICAvLyBQYXJzZSBkYXRhIGZyb20gdGhlIGxvY2FsaXphdGlvbiBvYmplY3QuXHJcbiAgICBmYWNlYm9va1NoYXJlVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KGZhY2Vib29rU2hhcmVVcmwpO1xyXG4gICAgZmFjZWJvb2tTaGFyZVF1b3RlID0gZW5jb2RlVVJJQ29tcG9uZW50KGZhY2Vib29rU2hhcmVRdW90ZSk7XHJcblxyXG4gICAgLy8gQWRkIHF1ZXJ5IHN0cmluZ3MgdG8gdGhlIFVSTCBiYXNlZCBvbiBzZXR0aW5ncy5cclxuICAgIHZhciBmYWNlYm9va1VybCA9ICdodHRwczovL3d3dy5mYWNlYm9vay5jb20vc2hhcmVyL3NoYXJlci5waHA/JztcclxuICAgIGZhY2Vib29rVXJsICs9IChmYWNlYm9va1NoYXJlVXJsLmxlbmd0aCA+IDApID8gXCJ1PVwiK2ZhY2Vib29rU2hhcmVVcmwrXCImXCIgOiBcIlwiO1xyXG4gICAgZmFjZWJvb2tVcmwgKz0gKGZhY2Vib29rU2hhcmVRdW90ZS5sZW5ndGggPiAwKSA/IFwicXVvdGU9XCIrZmFjZWJvb2tTaGFyZVF1b3RlIDogJyc7XHJcblxyXG4gICAgdmFyIHBvcHVwV2lkdGggPSA4MDA7XHJcbiAgICB2YXIgcG9wdXBIZWlnaHQgPSAzMDA7XHJcbiAgICB2YXIgbGVmdFBvcyA9ICh3aW5kb3cuaW5uZXJXaWR0aCAvIDIpO1xyXG4gICAgdmFyIHRvcFBvcyA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIG5ldyBGYWNlYm9vayB3aW5kb3cuXHJcbiAgICAkZmFjZWJvb2tDb250YWluZXIuYXR0cigndGFiaW5kZXgnLCAnMCcpXHJcbiAgICAgIC5hdHRyKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuICAgIGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMoJGZhY2Vib29rQ29udGFpbmVyLCAoKSA9PiB7XHJcbiAgICAgIHdpbmRvdy5vcGVuKGZhY2Vib29rVXJsLFxyXG4gICAgICAgIHRoYXQuY3AubDEwbi5zaGFyZUZhY2Vib29rLFxyXG4gICAgICAgICd3aWR0aD0nICsgcG9wdXBXaWR0aCArXHJcbiAgICAgICAgJyxoZWlnaHQ9JyArIHBvcHVwSGVpZ2h0ICtcclxuICAgICAgICAnLGxlZnQ9JyArIGxlZnRQb3MgK1xyXG4gICAgICAgICcsdG9wPScgKyB0b3BQb3MpO1xyXG5cclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIGxpbmsgdG8gdGhlIGdpdmVuIGNvbnRhaW5lciB3aGljaCB3aWxsIGxpbmsgYWNoaWV2ZWQgc2NvcmUgdG8gZ29vZ2xlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtqUXVlcnl9ICRnb29nbGVDb250YWluZXIgQ29udGFpbmVyIHRoYXQgc2hvdWxkIGhvbGQgdGhlIGdvb2dsZSBsaW5rLlxyXG4gICAqL1xyXG4gIFN1bW1hcnlTbGlkZS5wcm90b3R5cGUuYWRkR29vZ2xlU2NvcmVMaW5rVG8gPSBmdW5jdGlvbiAoJGdvb2dsZUNvbnRhaW5lcikge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xyXG5cclxuICAgIC8vIEdldCBkYXRhIGZyb20gdGhlIGxvY2FsaXphdGlvbiBvYmplY3QuXHJcbiAgICB2YXIgZ29vZ2xlU2hhcmVVcmwgPSB0aGF0LmNwLmdvb2dsZVNoYXJlVXJsIHx8ICcnO1xyXG5cclxuICAgIC8vIFJlcGxhY2UgYW55IHBsYWNlaG9sZGVycyB3aXRoIHZhcmlhYmxlcy5cclxuICAgIGdvb2dsZVNoYXJlVXJsID0gZ29vZ2xlU2hhcmVVcmwucmVwbGFjZSgnQGN1cnJlbnRwYWdldXJsJywgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xyXG5cclxuICAgIC8vIFBhcnNlIGRhdGEgZnJvbSB0aGUgbG9jYWxpemF0aW9uIG9iamVjdC5cclxuICAgIGdvb2dsZVNoYXJlVXJsID0gZW5jb2RlVVJJQ29tcG9uZW50KGdvb2dsZVNoYXJlVXJsKTtcclxuXHJcbiAgICAvLyBBZGQgcXVlcnkgc3RyaW5ncyB0byB0aGUgVVJMIGJhc2VkIG9uIHNldHRpbmdzLlxyXG4gICAgdmFyIGdvb2dsZVVybCA9IFwiaHR0cHM6Ly9wbHVzLmdvb2dsZS5jb20vc2hhcmU/XCI7XHJcbiAgICBnb29nbGVVcmwgKz0gKGdvb2dsZVNoYXJlVXJsLmxlbmd0aCA+IDApID8gXCJ1cmw9XCIrZ29vZ2xlU2hhcmVVcmwrXCJcIiA6IFwiXCI7XHJcblxyXG4gICAgdmFyIHBvcHVwV2lkdGggPSA0MDE7XHJcbiAgICB2YXIgcG9wdXBIZWlnaHQgPSA0Mzc7XHJcbiAgICB2YXIgbGVmdFBvcyA9ICh3aW5kb3cuaW5uZXJXaWR0aCAvIDIpO1xyXG4gICAgdmFyIHRvcFBvcyA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLyAyKTtcclxuXHJcbiAgICAvLyBDcmVhdGUgdGhlIG5ldyBHb29nbGUrIHdpbmRvdy5cclxuICAgICRnb29nbGVDb250YWluZXIuYXR0cigndGFiaW5kZXgnLCAnMCcpXHJcbiAgICAgIC5hdHRyKCdyb2xlJywgJ2J1dHRvbicpO1xyXG5cclxuICAgIGFkZENsaWNrQW5kS2V5Ym9hcmRMaXN0ZW5lcnMoJGdvb2dsZUNvbnRhaW5lciwgKCkgPT4ge1xyXG4gICAgICB3aW5kb3cub3Blbihnb29nbGVVcmwsXHJcbiAgICAgICAgdGhhdC5jcC5sMTBuLnNoYXJlR29vZ2xlLFxyXG4gICAgICAgICd3aWR0aD0nICsgcG9wdXBXaWR0aCArXHJcbiAgICAgICAgJyxoZWlnaHQ9JyArIHBvcHVwSGVpZ2h0ICtcclxuICAgICAgICAnLGxlZnQ9JyArIGxlZnRQb3MgK1xyXG4gICAgICAgICcsdG9wPScgKyB0b3BQb3MpO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRvdGFsIHNjb3JlcyBmb3IgYWxsIHNsaWRlc1xyXG4gICAqIEBwYXJhbSB7QXJyYXl9IHNsaWRlU2NvcmVzXHJcbiAgICogQHJldHVybnMge3t0b3RhbFNjb3JlOiBudW1iZXIsIHRvdGFsTWF4U2NvcmU6IG51bWJlciwgdG90YWxQZXJjZW50YWdlOiBudW1iZXJ9fSB0b3RhbFNjb3JlcyBUb3RhbCBzY29yZXMgb2JqZWN0XHJcbiAgICovXHJcbiAgU3VtbWFyeVNsaWRlLnByb3RvdHlwZS50b3RhbFNjb3JlcyA9IGZ1bmN0aW9uIChzbGlkZVNjb3Jlcykge1xyXG4gICAgaWYgKHNsaWRlU2NvcmVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbFNjb3JlOiAwLFxyXG4gICAgICAgIHRvdGFsTWF4U2NvcmU6IDAsXHJcbiAgICAgICAgdG90YWxQZXJjZW50YWdlOiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgdG90YWxTY29yZSA9IDA7XHJcbiAgICB2YXIgdG90YWxNYXhTY29yZSA9IDA7XHJcbiAgICB2YXIgaTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzbGlkZVNjb3Jlcy5sZW5ndGg7IGkgKz0gMSkge1xyXG4gICAgICAvLyBHZXQgcGVyY2VudGFnZSBzY29yZSBmb3Igc2xpZGVcclxuICAgICAgdG90YWxTY29yZSArPSBzbGlkZVNjb3Jlc1tpXS5zY29yZTtcclxuICAgICAgdG90YWxNYXhTY29yZSArPSBzbGlkZVNjb3Jlc1tpXS5tYXhTY29yZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdG90YWxQZXJjZW50YWdlID0gTWF0aC5yb3VuZCgodG90YWxTY29yZSAvIHRvdGFsTWF4U2NvcmUpICogMTAwKTtcclxuICAgIGlmIChpc05hTih0b3RhbFBlcmNlbnRhZ2UpKSB7XHJcbiAgICAgIHRvdGFsUGVyY2VudGFnZSA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxTY29yZTogdG90YWxTY29yZSxcclxuICAgICAgdG90YWxNYXhTY29yZTogdG90YWxNYXhTY29yZSxcclxuICAgICAgdG90YWxQZXJjZW50YWdlOiB0b3RhbFBlcmNlbnRhZ2VcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlcyBzb2x1dGlvbiBtb2RlIG9uL29mZi5cclxuICAgKlxyXG4gICAqIEBwYXJhbXMge0Jvb2xlYW59IGVuYWJsZVNvbHV0aW9uTW9kZSBFbmFibGUvZGlzYWJsZSBzb2x1dGlvbiBtb2RlXHJcbiAgICovXHJcbiAgU3VtbWFyeVNsaWRlLnByb3RvdHlwZS50b2dnbGVTb2x1dGlvbk1vZGUgPSBmdW5jdGlvbiAoZW5hYmxlU29sdXRpb25Nb2RlKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5jcC5pc1NvbHV0aW9uTW9kZSA9IGVuYWJsZVNvbHV0aW9uTW9kZTtcclxuICAgIGlmIChlbmFibGVTb2x1dGlvbk1vZGUpIHtcclxuICAgICAgLy8gR2V0IHNjb3JlcyBmb3Igc3VtbWFyeSBzbGlkZVxyXG4gICAgICB2YXIgc2xpZGVTY29yZXMgPSB0aGF0LmNwLnNob3dTb2x1dGlvbnMoKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSBmZWVkYmFjayBpY29ucyBpbiBzb2x1dGlvbiBtb2RlXHJcbiAgICAgIHRoaXMuY3Auc2V0UHJvZ3Jlc3NCYXJGZWVkYmFjayhzbGlkZVNjb3Jlcyk7XHJcbiAgICAgIHRoaXMuY3AuJGZvb3Rlci5hZGRDbGFzcygnaDVwLWZvb3Rlci1zb2x1dGlvbi1tb2RlJyk7XHJcbiAgICAgIHRoaXMuc2V0Rm9vdGVyU29sdXRpb25Nb2RlVGV4dCh0aGlzLmNwLmwxMG4uc29sdXRpb25Nb2RlVGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdGhpcy5jcC4kZm9vdGVyLnJlbW92ZUNsYXNzKCdoNXAtZm9vdGVyLXNvbHV0aW9uLW1vZGUnKTtcclxuICAgICAgdGhpcy5zZXRGb290ZXJTb2x1dGlvbk1vZGVUZXh0KCk7XHJcbiAgICAgIHRoaXMuY3Auc2V0UHJvZ3Jlc3NCYXJGZWVkYmFjaygpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIHNvbHV0aW9uIG1vZGUgYnV0dG9uIHRleHQgaW4gZm9vdGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNvbHV0aW9uTW9kZVRleHRcclxuICAgKi9cclxuICBTdW1tYXJ5U2xpZGUucHJvdG90eXBlLnNldEZvb3RlclNvbHV0aW9uTW9kZVRleHQgPSBmdW5jdGlvbiAoc29sdXRpb25Nb2RlVGV4dCkge1xyXG4gICAgaWYgKHNvbHV0aW9uTW9kZVRleHQgIT09IHVuZGVmaW5lZCAmJiBzb2x1dGlvbk1vZGVUZXh0KSB7XHJcbiAgICAgIHRoaXMuY3AuJGV4aXRTb2x1dGlvbk1vZGVUZXh0Lmh0bWwoc29sdXRpb25Nb2RlVGV4dCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0aGlzLmNwLiRleGl0U29sdXRpb25Nb2RlVGV4dCkge1xyXG4gICAgICB0aGlzLmNwLiRleGl0U29sdXRpb25Nb2RlVGV4dC5odG1sKCcnKTtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gU3VtbWFyeVNsaWRlO1xyXG59KSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgU3VtbWFyeVNsaWRlO1xyXG4iXSwibmFtZXMiOlsialF1ZXJ5IiwiJCIsIkpvdWJlbFVJIiwiYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyIsIlN1bW1hcnlTbGlkZSIsImNvdXJzZVByZXNlbnRhdGlvbiIsIiRzdW1tYXJ5U2xpZGUiLCJjcCIsInByb3RvdHlwZSIsInVwZGF0ZVN1bW1hcnlTbGlkZSIsInNsaWRlTnVtYmVyIiwibm9KdW1wIiwidGhhdCIsImlzVmFsaWRVcGRhdGUiLCJlZGl0b3IiLCJ1bmRlZmluZWQiLCJzbGlkZXMiLCJsZW5ndGgiLCJpc0V4cG9ydFNsaWRlIiwic2hvd1N1bW1hcnlTbGlkZSIsImhhc0Fuc3dlckVsZW1lbnRzIiwicHJlc2VudGF0aW9uIiwia2V5d29yZExpc3RFbmFibGVkIiwia2V5d29yZExpc3RBbHdheXNTaG93IiwiaGlkZUtleXdvcmRzIiwiY2hpbGRyZW4iLCJyZW1vdmUiLCJzbGlkZVNjb3JlcyIsImdldFNsaWRlU2NvcmVzIiwiaHRtbFRleHQiLCJvdXRwdXRTY29yZVN0YXRzIiwiYXBwZW5kVG8iLCJ0b3RhbFNjb3JlcyIsImlzTmFOIiwidG90YWxQZXJjZW50YWdlIiwidG90YWxTY29yZUJhciIsImNyZWF0ZVNjb3JlQmFyIiwidG90YWxNYXhTY29yZSIsInNldFNjb3JlIiwidG90YWxTY29yZSIsIiR0b3RhbFNjb3JlIiwic2V0VGltZW91dCIsImFwcGVuZCIsImwxMG4iLCJzdW1tYXJ5IiwiYWNjZXNzaWJpbGl0eVRvdGFsU2NvcmUiLCJyZXBsYWNlIiwiZW5hYmxlVHdpdHRlclNoYXJlIiwiJHR3aXR0ZXJDb250YWluZXIiLCJhZGRUd2l0dGVyU2NvcmVMaW5rVG8iLCJlbmFibGVGYWNlYm9va1NoYXJlIiwiJGZhY2Vib29rQ29udGFpbmVyIiwiYWRkRmFjZWJvb2tTY29yZUxpbmtUbyIsImVuYWJsZUdvb2dsZVNoYXJlIiwiJGdvb2dsZUNvbnRhaW5lciIsImFkZEdvb2dsZVNjb3JlTGlua1RvIiwibGlua3MiLCJmaW5kIiwiZWFjaCIsInNsaWRlTGluayIsImNsaWNrIiwiZXZlbnQiLCJqdW1wVG9TbGlkZSIsInBhcnNlSW50IiwiZGF0YSIsInByZXZlbnREZWZhdWx0IiwiJHN1bW1hcnlGb290ZXIiLCJzaG93U3VtbWFyeVNsaWRlU29sdXRpb25CdXR0b24iLCJjcmVhdGVCdXR0b24iLCJodG1sIiwic2hvd1NvbHV0aW9ucyIsIm9uIiwidG9nZ2xlU29sdXRpb25Nb2RlIiwic2hvd1N1bW1hcnlTbGlkZVJldHJ5QnV0dG9uIiwicmV0cnkiLCJyZXNldFRhc2siLCJleHBvcnRBbnN3ZXJzIiwiSDVQIiwiRXhwb3J0YWJsZVRleHRBcmVhIiwiRXhwb3J0ZXIiLCJydW4iLCJlbGVtZW50SW5zdGFuY2VzIiwic2VsZiIsImFkZENsYXNzIiwidGRzIiwiaSIsInNsaWRlUGVyY2VudGFnZVNjb3JlIiwic2xpZGVEZXNjcmlwdGlvbiIsImdldFNsaWRlRGVzY3JpcHRpb24iLCJNYXRoIiwicm91bmQiLCJzY29yZSIsIm1heFNjb3JlIiwic2xpZGUiLCJpc1NvbHV0aW9uTW9kZSIsInRyaWdnZXJYQVBJQ29tcGxldGVkIiwic2hhcmVSZXN1bHRDb250YWluZXIiLCJzaGFyZVJlc3VsdCIsInR3aXR0ZXJDb250YWluZXIiLCJzaGFyZVR3aXR0ZXIiLCJmYWNlYm9va0NvbnRhaW5lciIsInNoYXJlRmFjZWJvb2siLCJnb29nbGVDb250YWluZXIiLCJzaGFyZUdvb2dsZSIsInRvdGFsIiwidG9Mb3dlckNhc2UiLCJzbGlkZVNjb3Jlc1NsaWRlIiwiYWN0aW9uIiwic2xpZGVFbGVtZW50cyIsImVsZW1lbnRzIiwiaW5kZXhlcyIsInN1bW1hcnlNdWx0aXBsZVRhc2tUZXh0IiwiZ2V0VGl0bGUiLCJsaWJyYXJ5IiwiaHVtYW5SZWFkYWJsZUxpYnJhcnkiLCJzcGxpdCIsImh1bWFuUmVhZGFibGVTdHJpbmciLCJmb3JFYWNoIiwicmVhZGFibGVXb3JkIiwiaW5kZXgiLCJzY29yZXMiLCJ0d2l0dGVyU2hhcmVTdGF0ZW1lbnQiLCJ0d2l0dGVySGFzaHRhZ0xpc3QiLCJ0d2l0dGVyU2hhcmVIYXNodGFncyIsInR3aXR0ZXJTaGFyZVVybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsInRyaW0iLCJlbmNvZGVVUklDb21wb25lbnQiLCJ0d2l0dGVyU3RyaW5nIiwibGVmdFBvcyIsImlubmVyV2lkdGgiLCJ0b3BQb3MiLCJpbm5lckhlaWdodCIsInBvcHVwV2lkdGgiLCJwb3B1cEhlaWdodCIsImF0dHIiLCJvcGVuIiwiZmFjZWJvb2tTaGFyZVVybCIsImZhY2Vib29rU2hhcmVRdW90ZSIsImZhY2Vib29rVXJsIiwiZ29vZ2xlU2hhcmVVcmwiLCJnb29nbGVVcmwiLCJlbmFibGVTb2x1dGlvbk1vZGUiLCJzZXRQcm9ncmVzc0JhckZlZWRiYWNrIiwiJGZvb3RlciIsInNldEZvb3RlclNvbHV0aW9uTW9kZVRleHQiLCJzb2x1dGlvbk1vZGVUZXh0IiwicmVtb3ZlQ2xhc3MiLCIkZXhpdFNvbHV0aW9uTW9kZVRleHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/summary-slide.js\n");

/***/ }),

/***/ "./scripts/utils.js":
/*!**************************!*\
  !*** ./scripts/utils.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClickAndKeyboardListeners\": () => (/* binding */ addClickAndKeyboardListeners),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"defaultValue\": () => (/* binding */ defaultValue),\n/* harmony export */   \"flattenArray\": () => (/* binding */ flattenArray),\n/* harmony export */   \"isFunction\": () => (/* binding */ isFunction),\n/* harmony export */   \"isIOS\": () => (/* binding */ isIOS),\n/* harmony export */   \"isIPad\": () => (/* binding */ isIPad),\n/* harmony export */   \"kebabCase\": () => (/* binding */ kebabCase),\n/* harmony export */   \"keyCode\": () => (/* binding */ keyCode),\n/* harmony export */   \"stripHTML\": () => (/* binding */ stripHTML)\n/* harmony export */ });\n/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ \"./scripts/globals.js\");\n\n/**\r\n * Flattens a nested array\r\n *\r\n * Example:\r\n * [['a'], ['b']].flatten() -> ['a', 'b']\r\n *\r\n * @param {Array} arr A nested array\r\n * @returns {Array} A flattened array\r\n */\n\nvar flattenArray = function flattenArray(arr) {\n  return arr.concat.apply([], arr);\n};\n/**\r\n * Returns true if the argument is a function\r\n *\r\n * @param {Function|*} f\r\n */\n\nvar isFunction = function isFunction(f) {\n  return typeof f === 'function';\n};\n/**\r\n * Makes a string kebab case\r\n *\r\n * @param {string} str\r\n * @return {string}\r\n */\n\nvar kebabCase = function kebabCase(str) {\n  return str.replace(/[\\W]/g, '-');\n};\n/**\r\n * Is true if the users device is an ipad\r\n *\r\n * @const {boolean}\r\n */\n\nvar isIPad = navigator.userAgent.match(/iPad/i) !== null;\n/**\r\n * Is true if the users device is an iOS device\r\n *\r\n * @const {boolean}\r\n */\n\nvar isIOS = navigator.userAgent.match(/iPad|iPod|iPhone/i) !== null;\n/**\r\n * Returns true if the array contains the value\r\n *\r\n * @template T\r\n * @param {Array.<T>} arr\r\n * @param {T} val\r\n * @return {boolean}\r\n */\n\nvar contains = function contains(arr, val) {\n  return arr.indexOf(val) !== -1;\n};\n/**\r\n * Returns a default value if provided value is undefined\r\n *\r\n * @template T\r\n * @param {T} value\r\n * @param {T} fallback\r\n * @return {T}\r\n */\n\nvar defaultValue = function defaultValue(value, fallback) {\n  return value !== undefined ? value : fallback;\n};\n/**\r\n * Enum for keyboard key codes\r\n * @readonly\r\n * @enum {number}\r\n */\n\nvar keyCode = {\n  ENTER: 13,\n  ESC: 27,\n  SPACE: 32\n};\n/**\r\n * Make a non-button element behave as a button. I.e handle enter and space\r\n * keydowns as click\r\n *\r\n * @param  {H5P.jQuery} $element The \"button\" element\r\n * @param  {function(Event)} callback\r\n * @param  {*} [scope]\r\n */\n\nvar addClickAndKeyboardListeners = function addClickAndKeyboardListeners($element, callback, scope) {\n  $element.click(function (event) {\n    callback.call(scope || this, event);\n  });\n  $element.keydown(function (event) {\n    if (contains([keyCode.ENTER, keyCode.SPACE], event.which)) {\n      event.preventDefault();\n      callback.call(scope || this, event);\n    }\n  });\n};\n/**\r\n * @const {H5P.jQuery}\r\n */\n\nvar $STRIP_HTML_HELPER = (0,_globals__WEBPACK_IMPORTED_MODULE_0__.jQuery)('<div>');\n/**\r\n * Strips the html from a string, using jquery\r\n *\r\n * @param {string} str\r\n * @return {string}\r\n */\n\nvar stripHTML = function stripHTML(str) {\n  return $STRIP_HTML_HELPER.html(str).text().trim();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQXdCOUIsR0FBeEIsRUFBNkIrQixJQUE3QixHQUFvQ0MsSUFBcEMsRUFBSjtBQUFBLENBQXJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy91dGlscy5qcz85ZDczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGpRdWVyeSBhcyAkIH0gZnJvbSAnLi9nbG9iYWxzJztcclxuXHJcbi8qKlxyXG4gKiBGbGF0dGVucyBhIG5lc3RlZCBhcnJheVxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKiBbWydhJ10sIFsnYiddXS5mbGF0dGVuKCkgLT4gWydhJywgJ2InXVxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnIgQSBuZXN0ZWQgYXJyYXlcclxuICogQHJldHVybnMge0FycmF5fSBBIGZsYXR0ZW5lZCBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGZsYXR0ZW5BcnJheSA9IGFyciA9PiBhcnIuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYXJndW1lbnQgaXMgYSBmdW5jdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufCp9IGZcclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gZiA9PiB0eXBlb2YgZiA9PT0gJ2Z1bmN0aW9uJztcclxuXHJcblxyXG4vKipcclxuICogTWFrZXMgYSBzdHJpbmcga2ViYWIgY2FzZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBrZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tcXFddL2csICctJyk7XHJcblxyXG4vKipcclxuICogSXMgdHJ1ZSBpZiB0aGUgdXNlcnMgZGV2aWNlIGlzIGFuIGlwYWRcclxuICpcclxuICogQGNvbnN0IHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGlzSVBhZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQYWQvaSkgIT09IG51bGw7XHJcblxyXG5cclxuLyoqXHJcbiAqIElzIHRydWUgaWYgdGhlIHVzZXJzIGRldmljZSBpcyBhbiBpT1MgZGV2aWNlXHJcbiAqXHJcbiAqIEBjb25zdCB7Ym9vbGVhbn1cclxuICovXHJcbmV4cG9ydCBjb25zdCBpc0lPUyA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQYWR8aVBvZHxpUGhvbmUvaSkgIT09IG51bGw7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBhcnJheSBjb250YWlucyB0aGUgdmFsdWVcclxuICpcclxuICogQHRlbXBsYXRlIFRcclxuICogQHBhcmFtIHtBcnJheS48VD59IGFyclxyXG4gKiBAcGFyYW0ge1R9IHZhbFxyXG4gKiBAcmV0dXJuIHtib29sZWFufVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IGNvbnRhaW5zID0gKGFyciwgdmFsKSA9PiBhcnIuaW5kZXhPZih2YWwpICE9PSAtMTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZGVmYXVsdCB2YWx1ZSBpZiBwcm92aWRlZCB2YWx1ZSBpcyB1bmRlZmluZWRcclxuICpcclxuICogQHRlbXBsYXRlIFRcclxuICogQHBhcmFtIHtUfSB2YWx1ZVxyXG4gKiBAcGFyYW0ge1R9IGZhbGxiYWNrXHJcbiAqIEByZXR1cm4ge1R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgZGVmYXVsdFZhbHVlID0gKHZhbHVlLCBmYWxsYmFjaykgPT4gKHZhbHVlICE9PSB1bmRlZmluZWQpID8gdmFsdWUgOiBmYWxsYmFjaztcclxuXHJcbi8qKlxyXG4gKiBFbnVtIGZvciBrZXlib2FyZCBrZXkgY29kZXNcclxuICogQHJlYWRvbmx5XHJcbiAqIEBlbnVtIHtudW1iZXJ9XHJcbiAqL1xyXG5leHBvcnQgY29uc3Qga2V5Q29kZSA9IHtcclxuICBFTlRFUjogMTMsXHJcbiAgRVNDOiAyNyxcclxuICBTUEFDRTogMzJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlIGEgbm9uLWJ1dHRvbiBlbGVtZW50IGJlaGF2ZSBhcyBhIGJ1dHRvbi4gSS5lIGhhbmRsZSBlbnRlciBhbmQgc3BhY2VcclxuICoga2V5ZG93bnMgYXMgY2xpY2tcclxuICpcclxuICogQHBhcmFtICB7SDVQLmpRdWVyeX0gJGVsZW1lbnQgVGhlIFwiYnV0dG9uXCIgZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtmdW5jdGlvbihFdmVudCl9IGNhbGxiYWNrXHJcbiAqIEBwYXJhbSAgeyp9IFtzY29wZV1cclxuICovXHJcbmV4cG9ydCBjb25zdCBhZGRDbGlja0FuZEtleWJvYXJkTGlzdGVuZXJzID0gZnVuY3Rpb24gKCRlbGVtZW50LCBjYWxsYmFjaywgc2NvcGUpIHtcclxuICAkZWxlbWVudC5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUgfHwgdGhpcywgZXZlbnQpO1xyXG4gIH0pO1xyXG5cclxuICAkZWxlbWVudC5rZXlkb3duKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgaWYgKGNvbnRhaW5zKFtrZXlDb2RlLkVOVEVSLCBrZXlDb2RlLlNQQUNFXSwgZXZlbnQud2hpY2gpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGNhbGxiYWNrLmNhbGwoc2NvcGUgfHwgdGhpcywgZXZlbnQpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBjb25zdCB7SDVQLmpRdWVyeX1cclxuICovXHJcbmNvbnN0ICRTVFJJUF9IVE1MX0hFTFBFUiA9ICQoJzxkaXY+Jyk7XHJcblxyXG4vKipcclxuICogU3RyaXBzIHRoZSBodG1sIGZyb20gYSBzdHJpbmcsIHVzaW5nIGpxdWVyeVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge3N0cmluZ31cclxuICovXHJcbmV4cG9ydCBjb25zdCBzdHJpcEhUTUwgPSBzdHIgPT4gJFNUUklQX0hUTUxfSEVMUEVSLmh0bWwoc3RyKS50ZXh0KCkudHJpbSgpOyJdLCJuYW1lcyI6WyJqUXVlcnkiLCIkIiwiZmxhdHRlbkFycmF5IiwiYXJyIiwiY29uY2F0IiwiYXBwbHkiLCJpc0Z1bmN0aW9uIiwiZiIsImtlYmFiQ2FzZSIsInN0ciIsInJlcGxhY2UiLCJpc0lQYWQiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtYXRjaCIsImlzSU9TIiwiY29udGFpbnMiLCJ2YWwiLCJpbmRleE9mIiwiZGVmYXVsdFZhbHVlIiwidmFsdWUiLCJmYWxsYmFjayIsInVuZGVmaW5lZCIsImtleUNvZGUiLCJFTlRFUiIsIkVTQyIsIlNQQUNFIiwiYWRkQ2xpY2tBbmRLZXlib2FyZExpc3RlbmVycyIsIiRlbGVtZW50IiwiY2FsbGJhY2siLCJzY29wZSIsImNsaWNrIiwiZXZlbnQiLCJjYWxsIiwia2V5ZG93biIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCIkU1RSSVBfSFRNTF9IRUxQRVIiLCJzdHJpcEhUTUwiLCJodG1sIiwidGV4dCIsInRyaW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scripts/utils.js\n");

/***/ }),

/***/ "../node_modules/h5p-lib-controls/src/scripts/controls.js":
/*!****************************************************************!*\
  !*** ../node_modules/h5p-lib-controls/src/scripts/controls.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Controls)\n/* harmony export */ });\n/* harmony import */ var _utils_elements__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/elements */ \"../node_modules/h5p-lib-controls/src/scripts/utils/elements.js\");\n/* harmony import */ var _utils_functional__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/functional */ \"../node_modules/h5p-lib-controls/src/scripts/utils/functional.js\");\n/* harmony import */ var _mixins_eventful__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/eventful */ \"../node_modules/h5p-lib-controls/src/scripts/mixins/eventful.js\");\n\n\n\n\n/**\n * Controls Event\n * @typedef {Object} ControlsEvent\n * @property {HTMLElement} element\n * @property {number} index\n * @property {HTMLElement[]} elements\n * @property {HTMLElement} oldElement\n */\n/**\n * Add element event\n * @event Controls#addElement\n * @type ControlsEvent\n */\n/**\n * Remove element event\n * @event Controls#removeElement\n * @type ControlsEvent\n */\n/**\n * Previous element event\n * @event Controls#previousElement\n * @type ControlsEvent\n */\n/**\n * Next element event\n * @event Controls#nextElement\n * @type ControlsEvent\n */\n/**\n * Select option event\n * @event Controls#select\n * @type ControlsEvent\n */\n/**\n * Close event\n * @event Controls#close\n * @type ControlsEvent\n */\n/**\n * Drag element event\n * @event Controls#drag\n * @type ControlsEvent\n */\n\n/**\n * @type {function} removeTabIndex\n */\nconst removeTabIndex = (0,_utils_elements__WEBPACK_IMPORTED_MODULE_0__.removeAttribute)('tabindex');\n/**\n * @type {function} removeTabIndexForAll\n */\nconst removeTabIndexForAll = (0,_utils_functional__WEBPACK_IMPORTED_MODULE_1__.forEach)(removeTabIndex);\n/**\n * @type {function} setTabIndexZero\n */\nconst setTabIndexZero = (0,_utils_elements__WEBPACK_IMPORTED_MODULE_0__.setAttribute)('tabindex', '0');\n/**\n * @type {function} setTabIndexMinusOne\n */\nconst setTabIndexMinusOne = (0,_utils_elements__WEBPACK_IMPORTED_MODULE_0__.setAttribute)('tabindex', '-1');\n/**\n * @type {function} hasTabIndex\n */\nconst hasTabIndex = (0,_utils_elements__WEBPACK_IMPORTED_MODULE_0__.hasAttribute)('tabindex');\n\n/**\n * @class\n * @mixes Eventful\n */\nclass Controls {\n  constructor(plugins) {\n    // add event system\n    Object.assign(this, (0,_mixins_eventful__WEBPACK_IMPORTED_MODULE_2__.Eventful)());\n\n    /**\n     *@property {HTMLElement} tabbableElement\n     */\n    /**\n     * @property {object[]} plugins\n     */\n    this.plugins = plugins || [];\n\n    /**\n     * @property {HTMLElement[]} elements\n     */\n    this.elements = [];\n\n    /**\n     * @property {boolean} useNegativeTabIndex\n     */\n    this.negativeTabIndexAllowed = false;\n\n    // move tabindex to next element\n    this.on('nextElement', this.nextElement, this);\n\n    // move tabindex to previous element\n    this.on('previousElement', this.previousElement, this);\n\n    // move tabindex for fist element\n    this.on('firstElement', this.firstElement, this);\n\n    // move tabindex for last element\n    this.on('lastElement', this.lastElement, this);\n\n    // init plugins\n    this.initPlugins();\n  }\n\n  /**\n   * Add controls to an element\n   *\n   * @param {HTMLElement} el\n   *\n   * @fires Controls#addElement\n   * @public\n   */\n  addElement(el){\n    this.elements.push(el);\n\n    this.firesEvent('addElement', el);\n\n    if (this.elements.length === 1) { // if first\n      this.setTabbable(el);\n    }\n  };\n\n  /**\n   * Add controls to an element\n   *\n   * @param {HTMLElement} el\n   * @param {number} position\n   *\n   * @fires Controls#addElement\n   * @public\n   */\n  insertElementAt(el, position) {\n    this.elements.splice(position, 0, el);\n\n    this.firesEvent('addElement', el);\n\n    if (this.elements.length === 1) { // if first\n      this.setTabbable(el);\n    }\n  }\n\n  /**\n   * Add controls to an element\n   *\n   * @param {HTMLElement} el\n   *\n   * @fires Controls#addElement\n   * @public\n   */\n  removeElement(el){\n    this.elements = (0,_utils_functional__WEBPACK_IMPORTED_MODULE_1__.without)([el], this.elements);\n\n    // if removed element was selected\n    if(hasTabIndex(el)) {\n      this.setUntabbable(el);\n\n      // set first element selected if exists\n      if(this.elements[0]) {\n        this.setTabbable(this.elements[0]);\n      }\n    }\n\n    this.firesEvent('removeElement', el);\n  };\n\n  /**\n   * Returns the number of elements is controlled by this object\n   *\n   * @return {number}\n   */\n  count() {\n    return this.elements.length;\n  }\n\n  /**\n   * Fire event\n   *\n   * @param {string} type\n   * @param {HTMLElement|EventTarget} el\n   *\n   * @public\n   */\n  firesEvent(type, el) {\n    const index = this.elements.indexOf(el);\n\n    return this.fire(type, {\n      element: el,\n      index: index,\n      elements: this.elements,\n      oldElement: this.tabbableElement\n    });\n  }\n\n  /**\n   * Sets tabindex on an element, remove it from all others\n   *\n   * @param {number} index\n   *\n   * @private\n   */\n  nextElement({index}) {\n    const isLastElement = index === (this.elements.length - 1);\n    const nextEl = this.elements[isLastElement ? 0 : (index + 1)];\n\n    this.setTabbable(nextEl);\n    nextEl.focus();\n  }\n\n  /**\n   * Sets tabindex on the first element, remove it from all others\n   *\n   * @private\n   */\n  firstElement() {\n    const element = this.elements[0];\n    this.setTabbable(element);\n    element.focus();\n  }\n\n  /**\n   * Sets tabindex on the first element, remove it from all others\n   *\n   * @private\n   */\n  lastElement() {\n    const element = this.elements[this.elements.length - 1];\n    this.setTabbable(element);\n    element.focus();\n  }\n\n  /**\n   * Selects the element at a position given by argument\n   *\n   * @param {number} index\n   * @public\n   */\n  setTabbableByIndex(index) {\n    const nextEl = this.elements[index];\n\n    if (nextEl){\n      this.setTabbable(nextEl);\n    }\n  }\n\n  /**\n   * Sets tabindex on an element, remove it from all others\n   *\n   * @param {HTMLElement} el\n   * @public\n   */\n  setTabbable(el) {\n    (0,_utils_functional__WEBPACK_IMPORTED_MODULE_1__.forEach)(this.setUntabbable.bind(this), this.elements);\n    setTabIndexZero(el);\n    this.tabbableElement = el;\n  }\n\n  /**\n   * Removes tabbability from an element\n   *\n   * @param {HTMLElement} el\n   */\n  setUntabbable(el) {\n    if (el === document.activeElement) {\n      return;\n    }\n\n    if(this.negativeTabIndexAllowed) {\n      setTabIndexMinusOne(el);\n    }\n    else {\n      removeTabIndex(el);\n    }\n  }\n\n  /**\n   * Sets tabindex on an element, remove it from all others\n   *\n   * @param {number} index\n   *\n   * @private\n   */\n  previousElement({index}) {\n    const isFirstElement = index === 0;\n    const prevEl = this.elements[isFirstElement ? (this.elements.length - 1) : (index - 1)];\n\n    this.setTabbable(prevEl);\n    prevEl.focus();\n  }\n\n  /**\n   * Use tabindex=\"-1\" instead of removing tabindex for non-focused elements\n   */\n  useNegativeTabIndex() {\n    this.negativeTabIndexAllowed = true;\n    this.elements.forEach(element => {\n      if(!element.hasAttribute('tabindex')){\n        setTabIndexMinusOne(element);\n      }\n    })\n  }\n\n  /**\n   * Initializes the plugins\n   *\n   * @private\n   */\n  initPlugins(){\n    this.plugins.forEach(function(plugin){\n      if(plugin.init !== undefined){\n        plugin.init(this);\n      }\n    }, this);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvY29udHJvbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRTtBQUN6QjtBQUNUOztBQUU3QztBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsYUFBYTtBQUMzQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxlQUFlO0FBQzdCLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSx1QkFBdUIsZ0VBQWU7QUFDdEM7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSw2QkFBNkIsMERBQU87QUFDcEM7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSx3QkFBd0IsNkRBQVk7QUFDcEM7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSw0QkFBNEIsNkRBQVk7QUFDeEM7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQSxvQkFBb0IsNkRBQVk7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFROztBQUVoQztBQUNBLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMERBQU87O0FBRTNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQU87QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oNXAtbGliLWNvbnRyb2xzL3NyYy9zY3JpcHRzL2NvbnRyb2xzLmpzPzE4MTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2V0QXR0cmlidXRlLCByZW1vdmVBdHRyaWJ1dGUsIGhhc0F0dHJpYnV0ZSB9IGZyb20gJy4vdXRpbHMvZWxlbWVudHMnO1xuaW1wb3J0IHsgZm9yRWFjaCwgd2l0aG91dCB9IGZyb20gJy4vdXRpbHMvZnVuY3Rpb25hbCc7XG5pbXBvcnQgeyBFdmVudGZ1bCB9IGZyb20gJy4vbWl4aW5zL2V2ZW50ZnVsJztcblxuLyoqXG4gKiBDb250cm9scyBFdmVudFxuICogQHR5cGVkZWYge09iamVjdH0gQ29udHJvbHNFdmVudFxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGluZGV4XG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBvbGRFbGVtZW50XG4gKi9cbi8qKlxuICogQWRkIGVsZW1lbnQgZXZlbnRcbiAqIEBldmVudCBDb250cm9scyNhZGRFbGVtZW50XG4gKiBAdHlwZSBDb250cm9sc0V2ZW50XG4gKi9cbi8qKlxuICogUmVtb3ZlIGVsZW1lbnQgZXZlbnRcbiAqIEBldmVudCBDb250cm9scyNyZW1vdmVFbGVtZW50XG4gKiBAdHlwZSBDb250cm9sc0V2ZW50XG4gKi9cbi8qKlxuICogUHJldmlvdXMgZWxlbWVudCBldmVudFxuICogQGV2ZW50IENvbnRyb2xzI3ByZXZpb3VzRWxlbWVudFxuICogQHR5cGUgQ29udHJvbHNFdmVudFxuICovXG4vKipcbiAqIE5leHQgZWxlbWVudCBldmVudFxuICogQGV2ZW50IENvbnRyb2xzI25leHRFbGVtZW50XG4gKiBAdHlwZSBDb250cm9sc0V2ZW50XG4gKi9cbi8qKlxuICogU2VsZWN0IG9wdGlvbiBldmVudFxuICogQGV2ZW50IENvbnRyb2xzI3NlbGVjdFxuICogQHR5cGUgQ29udHJvbHNFdmVudFxuICovXG4vKipcbiAqIENsb3NlIGV2ZW50XG4gKiBAZXZlbnQgQ29udHJvbHMjY2xvc2VcbiAqIEB0eXBlIENvbnRyb2xzRXZlbnRcbiAqL1xuLyoqXG4gKiBEcmFnIGVsZW1lbnQgZXZlbnRcbiAqIEBldmVudCBDb250cm9scyNkcmFnXG4gKiBAdHlwZSBDb250cm9sc0V2ZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb259IHJlbW92ZVRhYkluZGV4XG4gKi9cbmNvbnN0IHJlbW92ZVRhYkluZGV4ID0gcmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb259IHJlbW92ZVRhYkluZGV4Rm9yQWxsXG4gKi9cbmNvbnN0IHJlbW92ZVRhYkluZGV4Rm9yQWxsID0gZm9yRWFjaChyZW1vdmVUYWJJbmRleCk7XG4vKipcbiAqIEB0eXBlIHtmdW5jdGlvbn0gc2V0VGFiSW5kZXhaZXJvXG4gKi9cbmNvbnN0IHNldFRhYkluZGV4WmVybyA9IHNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnMCcpO1xuLyoqXG4gKiBAdHlwZSB7ZnVuY3Rpb259IHNldFRhYkluZGV4TWludXNPbmVcbiAqL1xuY29uc3Qgc2V0VGFiSW5kZXhNaW51c09uZSA9IHNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbi8qKlxuICogQHR5cGUge2Z1bmN0aW9ufSBoYXNUYWJJbmRleFxuICovXG5jb25zdCBoYXNUYWJJbmRleCA9IGhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBtaXhlcyBFdmVudGZ1bFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb250cm9scyB7XG4gIGNvbnN0cnVjdG9yKHBsdWdpbnMpIHtcbiAgICAvLyBhZGQgZXZlbnQgc3lzdGVtXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBFdmVudGZ1bCgpKTtcblxuICAgIC8qKlxuICAgICAqQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gdGFiYmFibGVFbGVtZW50XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtvYmplY3RbXX0gcGx1Z2luc1xuICAgICAqL1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnMgfHwgW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50W119IGVsZW1lbnRzXG4gICAgICovXG4gICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSB1c2VOZWdhdGl2ZVRhYkluZGV4XG4gICAgICovXG4gICAgdGhpcy5uZWdhdGl2ZVRhYkluZGV4QWxsb3dlZCA9IGZhbHNlO1xuXG4gICAgLy8gbW92ZSB0YWJpbmRleCB0byBuZXh0IGVsZW1lbnRcbiAgICB0aGlzLm9uKCduZXh0RWxlbWVudCcsIHRoaXMubmV4dEVsZW1lbnQsIHRoaXMpO1xuXG4gICAgLy8gbW92ZSB0YWJpbmRleCB0byBwcmV2aW91cyBlbGVtZW50XG4gICAgdGhpcy5vbigncHJldmlvdXNFbGVtZW50JywgdGhpcy5wcmV2aW91c0VsZW1lbnQsIHRoaXMpO1xuXG4gICAgLy8gbW92ZSB0YWJpbmRleCBmb3IgZmlzdCBlbGVtZW50XG4gICAgdGhpcy5vbignZmlyc3RFbGVtZW50JywgdGhpcy5maXJzdEVsZW1lbnQsIHRoaXMpO1xuXG4gICAgLy8gbW92ZSB0YWJpbmRleCBmb3IgbGFzdCBlbGVtZW50XG4gICAgdGhpcy5vbignbGFzdEVsZW1lbnQnLCB0aGlzLmxhc3RFbGVtZW50LCB0aGlzKTtcblxuICAgIC8vIGluaXQgcGx1Z2luc1xuICAgIHRoaXMuaW5pdFBsdWdpbnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgY29udHJvbHMgdG8gYW4gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICAgKlxuICAgKiBAZmlyZXMgQ29udHJvbHMjYWRkRWxlbWVudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFbGVtZW50KGVsKcKge1xuICAgIHRoaXMuZWxlbWVudHMucHVzaChlbCk7XG5cbiAgICB0aGlzLmZpcmVzRXZlbnQoJ2FkZEVsZW1lbnQnLCBlbCk7XG5cbiAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggPT09IDEpIHsgLy8gaWYgZmlyc3RcbiAgICAgIHRoaXMuc2V0VGFiYmFibGUoZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQWRkIGNvbnRyb2xzIHRvIGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uXG4gICAqXG4gICAqIEBmaXJlcyBDb250cm9scyNhZGRFbGVtZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydEVsZW1lbnRBdChlbCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmVsZW1lbnRzLnNwbGljZShwb3NpdGlvbiwgMCwgZWwpO1xuXG4gICAgdGhpcy5maXJlc0V2ZW50KCdhZGRFbGVtZW50JywgZWwpO1xuXG4gICAgaWYgKHRoaXMuZWxlbWVudHMubGVuZ3RoID09PSAxKSB7IC8vIGlmIGZpcnN0XG4gICAgICB0aGlzLnNldFRhYmJhYmxlKGVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGNvbnRyb2xzIHRvIGFuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAgICpcbiAgICogQGZpcmVzIENvbnRyb2xzI2FkZEVsZW1lbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRWxlbWVudChlbCnCoHtcbiAgICB0aGlzLmVsZW1lbnRzID0gd2l0aG91dChbZWxdLCB0aGlzLmVsZW1lbnRzKTtcblxuICAgIC8vIGlmIHJlbW92ZWQgZWxlbWVudCB3YXMgc2VsZWN0ZWRcbiAgICBpZihoYXNUYWJJbmRleChlbCkpIHtcbiAgICAgIHRoaXMuc2V0VW50YWJiYWJsZShlbCk7XG5cbiAgICAgIC8vIHNldCBmaXJzdCBlbGVtZW50IHNlbGVjdGVkIGlmIGV4aXN0c1xuICAgICAgaWYodGhpcy5lbGVtZW50c1swXSkge1xuICAgICAgICB0aGlzLnNldFRhYmJhYmxlKHRoaXMuZWxlbWVudHNbMF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZmlyZXNFdmVudCgncmVtb3ZlRWxlbWVudCcsIGVsKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGlzIGNvbnRyb2xsZWQgYnkgdGhpcyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmUgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gZWxcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZmlyZXNFdmVudCh0eXBlLCBlbCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5lbGVtZW50cy5pbmRleE9mKGVsKTtcblxuICAgIHJldHVybiB0aGlzLmZpcmUodHlwZSwge1xuICAgICAgZWxlbWVudDogZWwsXG4gICAgICBpbmRleDogaW5kZXgsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cyxcbiAgICAgIG9sZEVsZW1lbnQ6IHRoaXMudGFiYmFibGVFbGVtZW50XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0YWJpbmRleCBvbiBhbiBlbGVtZW50LCByZW1vdmUgaXQgZnJvbSBhbGwgb3RoZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbmV4dEVsZW1lbnQoe2luZGV4fSkge1xuICAgIGNvbnN0IGlzTGFzdEVsZW1lbnQgPSBpbmRleCA9PT0gKHRoaXMuZWxlbWVudHMubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgbmV4dEVsID0gdGhpcy5lbGVtZW50c1tpc0xhc3RFbGVtZW50ID8gMCA6IChpbmRleCArIDEpXTtcblxuICAgIHRoaXMuc2V0VGFiYmFibGUobmV4dEVsKTtcbiAgICBuZXh0RWwuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRhYmluZGV4IG9uIHRoZSBmaXJzdCBlbGVtZW50LCByZW1vdmUgaXQgZnJvbSBhbGwgb3RoZXJzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaXJzdEVsZW1lbnQoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbMF07XG4gICAgdGhpcy5zZXRUYWJiYWJsZShlbGVtZW50KTtcbiAgICBlbGVtZW50LmZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0YWJpbmRleCBvbiB0aGUgZmlyc3QgZWxlbWVudCwgcmVtb3ZlIGl0IGZyb20gYWxsIG90aGVyc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGFzdEVsZW1lbnQoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbdGhpcy5lbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLnNldFRhYmJhYmxlKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3RzIHRoZSBlbGVtZW50IGF0IGEgcG9zaXRpb24gZ2l2ZW4gYnkgYXJndW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldFRhYmJhYmxlQnlJbmRleChpbmRleCkge1xuICAgIGNvbnN0IG5leHRFbCA9IHRoaXMuZWxlbWVudHNbaW5kZXhdO1xuXG4gICAgaWYgKG5leHRFbCnCoHtcbiAgICAgIHRoaXMuc2V0VGFiYmFibGUobmV4dEVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0YWJpbmRleCBvbiBhbiBlbGVtZW50LCByZW1vdmUgaXQgZnJvbSBhbGwgb3RoZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldFRhYmJhYmxlKGVsKSB7XG4gICAgZm9yRWFjaCh0aGlzLnNldFVudGFiYmFibGUuYmluZCh0aGlzKSwgdGhpcy5lbGVtZW50cyk7XG4gICAgc2V0VGFiSW5kZXhaZXJvKGVsKTtcbiAgICB0aGlzLnRhYmJhYmxlRWxlbWVudCA9IGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGFiYmFiaWxpdHkgZnJvbSBhbiBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gICAqL1xuICBzZXRVbnRhYmJhYmxlKGVsKSB7XG4gICAgaWYgKGVsID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYodGhpcy5uZWdhdGl2ZVRhYkluZGV4QWxsb3dlZCkge1xuICAgICAgc2V0VGFiSW5kZXhNaW51c09uZShlbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVtb3ZlVGFiSW5kZXgoZWwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRhYmluZGV4IG9uIGFuIGVsZW1lbnQsIHJlbW92ZSBpdCBmcm9tIGFsbCBvdGhlcnNcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcmV2aW91c0VsZW1lbnQoe2luZGV4fSkge1xuICAgIGNvbnN0IGlzRmlyc3RFbGVtZW50ID0gaW5kZXggPT09IDA7XG4gICAgY29uc3QgcHJldkVsID0gdGhpcy5lbGVtZW50c1tpc0ZpcnN0RWxlbWVudCA/ICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAtIDEpIDogKGluZGV4IC0gMSldO1xuXG4gICAgdGhpcy5zZXRUYWJiYWJsZShwcmV2RWwpO1xuICAgIHByZXZFbC5mb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0YWJpbmRleD1cIi0xXCIgaW5zdGVhZCBvZiByZW1vdmluZyB0YWJpbmRleCBmb3Igbm9uLWZvY3VzZWQgZWxlbWVudHNcbiAgICovXG4gIHVzZU5lZ2F0aXZlVGFiSW5kZXgoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZVRhYkluZGV4QWxsb3dlZCA9IHRydWU7XG4gICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgaWYoIWVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKXtcbiAgICAgICAgc2V0VGFiSW5kZXhNaW51c09uZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBwbHVnaW5zXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpbml0UGx1Z2lucygpwqB7XG4gICAgdGhpcy5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKXtcbiAgICAgIGlmKHBsdWdpbi5pbml0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICBwbHVnaW4uaW5pdCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/h5p-lib-controls/src/scripts/controls.js\n");

/***/ }),

/***/ "../node_modules/h5p-lib-controls/src/scripts/mixins/eventful.js":
/*!***********************************************************************!*\
  !*** ../node_modules/h5p-lib-controls/src/scripts/mixins/eventful.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Eventful\": () => (/* binding */ Eventful)\n/* harmony export */ });\n/**\n * @mixin\n */\nconst Eventful = () => ({\n  listeners: {},\n\n  /**\n   * Listen to event\n   *\n   * @param {string} type\n   * @param {function} listener\n   * @param {object} [scope]\n   *\n   * @function\n   * @return {Eventful}\n   */\n  on: function(type, listener, scope) {\n    /**\n     * @typedef {object} Trigger\n     * @property {function} listener\n     * @property {object} scope\n     */\n    const trigger = {\n      'listener': listener,\n      'scope': scope\n    };\n\n    this.listeners[type] = this.listeners[type] || [];\n    this.listeners[type].push(trigger);\n\n    return this;\n  },\n\n  /**\n   * Fire event. If any of the listeners returns false, return false\n   *\n   * @param {string} type\n   * @param {object} [event]\n   *\n   * @function\n   * @return {boolean}\n   */\n  fire: function(type, event) {\n    const triggers = this.listeners[type] || [];\n\n    return triggers.every(function(trigger) {\n      return trigger.listener.call(trigger.scope || this, event) !== false;\n    });\n  },\n\n  /**\n   * Listens for events on another Eventful, and propagate it trough this Eventful\n   *\n   * @param {string[]} types\n   * @param {Eventful} eventful\n   */\n  propagate: function(types, eventful) {\n    let self = this;\n    types.forEach(type => eventful.on(type, event => self.fire(type, event)));\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvbWl4aW5zL2V2ZW50ZnVsLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGVBQWU7O0FBRWY7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixrQkFBa0IsVUFBVTtBQUM1QixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvbWl4aW5zL2V2ZW50ZnVsLmpzP2ZkYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbWl4aW5cbiAqL1xuZXhwb3J0IGNvbnN0IEV2ZW50ZnVsID0gKCkgPT4gKHtcbiAgbGlzdGVuZXJzOiB7fSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbc2NvcGVdXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtFdmVudGZ1bH1cbiAgICovXG4gIG9uOiBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgc2NvcGUpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmlnZ2VyXG4gICAgICogQHByb3BlcnR5IHtmdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgKiBAcHJvcGVydHkge29iamVjdH0gc2NvcGVcbiAgICAgKi9cbiAgICBjb25zdCB0cmlnZ2VyID0ge1xuICAgICAgJ2xpc3RlbmVyJzogbGlzdGVuZXIsXG4gICAgICAnc2NvcGUnOiBzY29wZVxuICAgIH07XG5cbiAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMubGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdLnB1c2godHJpZ2dlcik7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogRmlyZSBldmVudC4gSWYgYW55IG9mIHRoZSBsaXN0ZW5lcnMgcmV0dXJucyBmYWxzZSwgcmV0dXJuIGZhbHNlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbZXZlbnRdXG4gICAqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZmlyZTogZnVuY3Rpb24odHlwZSwgZXZlbnQpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMubGlzdGVuZXJzW3R5cGVdIHx8IFtdO1xuXG4gICAgcmV0dXJuIHRyaWdnZXJzLmV2ZXJ5KGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyLmxpc3RlbmVyLmNhbGwodHJpZ2dlci5zY29wZSB8fCB0aGlzLCBldmVudCkgIT09IGZhbHNlO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIGZvciBldmVudHMgb24gYW5vdGhlciBFdmVudGZ1bCwgYW5kIHByb3BhZ2F0ZSBpdCB0cm91Z2ggdGhpcyBFdmVudGZ1bFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSB0eXBlc1xuICAgKiBAcGFyYW0ge0V2ZW50ZnVsfSBldmVudGZ1bFxuICAgKi9cbiAgcHJvcGFnYXRlOiBmdW5jdGlvbih0eXBlcywgZXZlbnRmdWwpIHtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgdHlwZXMuZm9yRWFjaCh0eXBlID0+IGV2ZW50ZnVsLm9uKHR5cGUsIGV2ZW50ID0+IHNlbGYuZmlyZSh0eXBlLCBldmVudCkpKTtcbiAgfVxufSk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/h5p-lib-controls/src/scripts/mixins/eventful.js\n");

/***/ }),

/***/ "../node_modules/h5p-lib-controls/src/scripts/ui/keyboard.js":
/*!*******************************************************************!*\
  !*** ../node_modules/h5p-lib-controls/src/scripts/ui/keyboard.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Keyboard)\n/* harmony export */ });\n/**\n * @class\n * @classdesc Keyboard navigation for accessibility support\n */\nclass Keyboard {\n  constructor() {\n    /**\n     * @property {boolean} selectability\n     */\n    this.selectability = true;\n  }\n\n  /**\n   * Inits this class\n   *\n   * @param {Controls} controls\n   */\n  init(controls){\n    /**\n     * Need to have a common binding of handleKeyDown, so that it can be a\n     * common instance to be used for addEventListener and removeEventListener\n     * @type {function}\n     */\n    this.boundHandleKeyDown = this.handleKeyDown.bind(this);\n\n    /**\n     * @type {Controls}\n     */\n    this.controls = controls;\n    this.controls.on('addElement', this.listenForKeyDown, this);\n    this.controls.on('removeElement', this.removeKeyDownListener, this);\n  };\n\n  /**\n   * Listens for a keyboard press when element is focused\n   *\n   * @param {HTMLElement} element\n   * @private\n   */\n  listenForKeyDown({element}) {\n    element.addEventListener('keydown', this.boundHandleKeyDown);\n  };\n\n  /**\n   * Remove a keyboard press listener\n   *\n   * @param {HTMLElement} element\n   * @private\n   */\n  removeKeyDownListener({element}) {\n    element.removeEventListener('keydown', this.boundHandleKeyDown);\n  };\n\n  /**\n   * Handles key down\n   *\n   * @param {KeyboardEvent} event Keyboard event\n   * @private\n   */\n  handleKeyDown(event) {\n    switch (event.which) {\n      case 27: // Escape\n        this.close(event.target);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      case 35: // End\n        this.lastElement(event.target);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      case 36: // Home\n        this.firstElement(event.target);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      case 13: // Enter\n      case 32: // Space\n        this.select(event.target);\n        event.preventDefault();\n        event.stopPropagation();\n        break;\n      case 37: // Left Arrow\n      case 38: // Up Arrow\n        // ignore with modifiers, so not to interfere with Chromevox\n        if(!this.hasChromevoxModifiers(event)) {\n          this.previousElement(event.target);\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        break;\n      case 39: // Right Arrow\n      case 40: // Down Arrow\n        // ignore with modifiers, so not to interfere with Chromevox\n        if(!this.hasChromevoxModifiers(event)) {\n          this.nextElement(event.target);\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        break;\n    }\n  };\n\n  /**\n   * Checks if the Chromevox modifiers are pressed\n   *\n   * @param {KeyboardEvent} event Keyboard event\n   * @private\n   */\n  hasChromevoxModifiers(event) {\n    return event.shiftKey || event.ctrlKey;\n  }\n\n  /**\n   * Fires the previous element event\n   *\n   * @param {HTMLElement|EventTarget} el\n   * @fires Controls#previousElement\n   */\n  previousElement(el) {\n    if(this.controls.firesEvent('beforePreviousElement', el) !== false) {\n      this.controls.firesEvent('previousElement', el);\n      this.controls.firesEvent('afterPreviousElement', el);\n    }\n  };\n\n  /**\n   * Fire the next element event\n   *\n   * @param {HTMLElement|EventTarget} el\n   * @fires Controls#nextElement\n   */\n  nextElement(el) {\n    if(this.controls.firesEvent('beforeNextElement', el) !== false) {\n      this.controls.firesEvent('nextElement', el);\n      this.controls.firesEvent('afterNextElement', el);\n    }\n  };\n\n  /**\n   * Fires the select event\n   *\n   * @param {EventTarget|HTMLElement} el\n   * @fires Controls#select\n   */\n  select(el){\n    if(this.selectability) {\n      if(this.controls.firesEvent('before-select', el) !== false) {\n        this.controls.firesEvent('select', el);\n        this.controls.firesEvent('after-select', el)\n      }\n    }\n  };\n\n  /**\n   * Fire the next element event\n   *\n   * @param {HTMLElement|EventTarget} el\n   * @fires Controls#nextElement\n   */\n  firstElement(el) {\n    if(this.controls.firesEvent('beforeFirstElement', el) !== false) {\n      this.controls.firesEvent('firstElement', el);\n      this.controls.firesEvent('afterFirstElement', el);\n    }\n  };\n\n  /**\n   * Fire the next element event\n   *\n   * @param {HTMLElement|EventTarget} el\n   * @fires Controls#nextElement\n   */\n  lastElement(el) {\n    if(this.controls.firesEvent('beforeLastElement', el) !== false) {\n      this.controls.firesEvent('lastElement', el);\n      this.controls.firesEvent('afterLastElement', el);\n    }\n  };\n\n  /**\n   * Disable possibility to select a word trough click and space or enter\n   *\n   * @public\n   */\n  disableSelectability() {\n    this.selectability = false;\n  };\n\n  /**\n   * Enable possibility to select a word trough click and space or enter\n   *\n   * @public\n   */\n  enableSelectability() {\n    this.selectability = true;\n  }\n\n  /**\n   * Fires the close event\n   *\n   * @param {HTMLElement|EventTarget} el\n   * @fires Controls#close\n   */\n  close(el) {\n    if(this.controls.firesEvent('before-close', el) !== false) {\n      this.controls.firesEvent('close', el);\n      this.controls.firesEvent('after-close', el)\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvdWkva2V5Ym9hcmQuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oNXAtbGliLWNvbnRyb2xzL3NyYy9zY3JpcHRzL3VpL2tleWJvYXJkLmpzPzYwZWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAY2xhc3NcbiAqIEBjbGFzc2Rlc2MgS2V5Ym9hcmQgbmF2aWdhdGlvbiBmb3IgYWNjZXNzaWJpbGl0eSBzdXBwb3J0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEtleWJvYXJkIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtib29sZWFufSBzZWxlY3RhYmlsaXR5XG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RhYmlsaXR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0cyB0aGlzIGNsYXNzXG4gICAqXG4gICAqIEBwYXJhbSB7Q29udHJvbHN9IGNvbnRyb2xzXG4gICAqL1xuICBpbml0KGNvbnRyb2xzKcKge1xuICAgIC8qKlxuICAgICAqIE5lZWQgdG8gaGF2ZSBhIGNvbW1vbiBiaW5kaW5nIG9mIGhhbmRsZUtleURvd24sIHNvIHRoYXQgaXQgY2FuIGJlIGFcbiAgICAgKiBjb21tb24gaW5zdGFuY2UgdG8gYmUgdXNlZCBmb3IgYWRkRXZlbnRMaXN0ZW5lciBhbmQgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biA9IHRoaXMuaGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0NvbnRyb2xzfVxuICAgICAqL1xuICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICB0aGlzLmNvbnRyb2xzLm9uKCdhZGRFbGVtZW50JywgdGhpcy5saXN0ZW5Gb3JLZXlEb3duLCB0aGlzKTtcbiAgICB0aGlzLmNvbnRyb2xzLm9uKCdyZW1vdmVFbGVtZW50JywgdGhpcy5yZW1vdmVLZXlEb3duTGlzdGVuZXIsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIGZvciBhIGtleWJvYXJkIHByZXNzIHdoZW4gZWxlbWVudCBpcyBmb2N1c2VkXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxpc3RlbkZvcktleURvd24oe2VsZW1lbnR9KSB7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5ib3VuZEhhbmRsZUtleURvd24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBrZXlib2FyZCBwcmVzcyBsaXN0ZW5lclxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZW1vdmVLZXlEb3duTGlzdGVuZXIoe2VsZW1lbnR9KSB7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5ib3VuZEhhbmRsZUtleURvd24pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleSBkb3duXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnQgS2V5Ym9hcmQgZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICBjYXNlIDI3OiAvLyBFc2NhcGVcbiAgICAgICAgdGhpcy5jbG9zZShldmVudC50YXJnZXQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM1OiAvLyBFbmRcbiAgICAgICAgdGhpcy5sYXN0RWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM2OiAvLyBIb21lXG4gICAgICAgIHRoaXMuZmlyc3RFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTM6IC8vIEVudGVyXG4gICAgICBjYXNlIDMyOiAvLyBTcGFjZVxuICAgICAgICB0aGlzLnNlbGVjdChldmVudC50YXJnZXQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM3OiAvLyBMZWZ0IEFycm93XG4gICAgICBjYXNlIDM4OiAvLyBVcCBBcnJvd1xuICAgICAgICAvLyBpZ25vcmUgd2l0aCBtb2RpZmllcnMsIHNvIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBDaHJvbWV2b3hcbiAgICAgICAgaWYoIXRoaXMuaGFzQ2hyb21ldm94TW9kaWZpZXJzKGV2ZW50KSkge1xuICAgICAgICAgIHRoaXMucHJldmlvdXNFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6IC8vIFJpZ2h0IEFycm93XG4gICAgICBjYXNlIDQwOiAvLyBEb3duIEFycm93XG4gICAgICAgIC8vIGlnbm9yZSB3aXRoIG1vZGlmaWVycywgc28gbm90IHRvIGludGVyZmVyZSB3aXRoIENocm9tZXZveFxuICAgICAgICBpZighdGhpcy5oYXNDaHJvbWV2b3hNb2RpZmllcnMoZXZlbnQpKSB7XG4gICAgICAgICAgdGhpcy5uZXh0RWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIENocm9tZXZveCBtb2RpZmllcnMgYXJlIHByZXNzZWRcbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudCBLZXlib2FyZCBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFzQ2hyb21ldm94TW9kaWZpZXJzKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmN0cmxLZXk7XG4gIH1cblxuICAvKipcbiAgICogRmlyZXMgdGhlIHByZXZpb3VzIGVsZW1lbnQgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gZWxcbiAgICogQGZpcmVzIENvbnRyb2xzI3ByZXZpb3VzRWxlbWVudFxuICAgKi9cbiAgcHJldmlvdXNFbGVtZW50KGVsKSB7XG4gICAgaWYodGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdiZWZvcmVQcmV2aW91c0VsZW1lbnQnLCBlbCkgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNvbnRyb2xzLmZpcmVzRXZlbnQoJ3ByZXZpb3VzRWxlbWVudCcsIGVsKTtcbiAgICAgIHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYWZ0ZXJQcmV2aW91c0VsZW1lbnQnLCBlbCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBGaXJlIHRoZSBuZXh0IGVsZW1lbnQgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gZWxcbiAgICogQGZpcmVzIENvbnRyb2xzI25leHRFbGVtZW50XG4gICAqL1xuICBuZXh0RWxlbWVudChlbCkge1xuICAgIGlmKHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYmVmb3JlTmV4dEVsZW1lbnQnLCBlbCkgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmNvbnRyb2xzLmZpcmVzRXZlbnQoJ25leHRFbGVtZW50JywgZWwpO1xuICAgICAgdGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdhZnRlck5leHRFbGVtZW50JywgZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlyZXMgdGhlIHNlbGVjdCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fEhUTUxFbGVtZW50fSBlbFxuICAgKiBAZmlyZXMgQ29udHJvbHMjc2VsZWN0XG4gICAqL1xuICBzZWxlY3QoZWwpe1xuICAgIGlmKHRoaXMuc2VsZWN0YWJpbGl0eSkge1xuICAgICAgaWYodGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdiZWZvcmUtc2VsZWN0JywgZWwpICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2xzLmZpcmVzRXZlbnQoJ3NlbGVjdCcsIGVsKTtcbiAgICAgICAgdGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdhZnRlci1zZWxlY3QnLCBlbClcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZpcmUgdGhlIG5leHQgZWxlbWVudCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSBlbFxuICAgKiBAZmlyZXMgQ29udHJvbHMjbmV4dEVsZW1lbnRcbiAgICovXG4gIGZpcnN0RWxlbWVudChlbCkge1xuICAgIGlmKHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYmVmb3JlRmlyc3RFbGVtZW50JywgZWwpICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdmaXJzdEVsZW1lbnQnLCBlbCk7XG4gICAgICB0aGlzLmNvbnRyb2xzLmZpcmVzRXZlbnQoJ2FmdGVyRmlyc3RFbGVtZW50JywgZWwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRmlyZSB0aGUgbmV4dCBlbGVtZW50IGV2ZW50XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8RXZlbnRUYXJnZXR9IGVsXG4gICAqIEBmaXJlcyBDb250cm9scyNuZXh0RWxlbWVudFxuICAgKi9cbiAgbGFzdEVsZW1lbnQoZWwpIHtcbiAgICBpZih0aGlzLmNvbnRyb2xzLmZpcmVzRXZlbnQoJ2JlZm9yZUxhc3RFbGVtZW50JywgZWwpICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdsYXN0RWxlbWVudCcsIGVsKTtcbiAgICAgIHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYWZ0ZXJMYXN0RWxlbWVudCcsIGVsKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERpc2FibGUgcG9zc2liaWxpdHkgdG8gc2VsZWN0IGEgd29yZCB0cm91Z2ggY2xpY2sgYW5kIHNwYWNlIG9yIGVudGVyXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRpc2FibGVTZWxlY3RhYmlsaXR5KCkge1xuICAgIHRoaXMuc2VsZWN0YWJpbGl0eSA9IGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFbmFibGUgcG9zc2liaWxpdHkgdG8gc2VsZWN0IGEgd29yZCB0cm91Z2ggY2xpY2sgYW5kIHNwYWNlIG9yIGVudGVyXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGVuYWJsZVNlbGVjdGFiaWxpdHkoKSB7XG4gICAgdGhpcy5zZWxlY3RhYmlsaXR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyB0aGUgY2xvc2UgZXZlbnRcbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxFdmVudFRhcmdldH0gZWxcbiAgICogQGZpcmVzIENvbnRyb2xzI2Nsb3NlXG4gICAqL1xuICBjbG9zZShlbCkge1xuICAgIGlmKHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYmVmb3JlLWNsb3NlJywgZWwpICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5jb250cm9scy5maXJlc0V2ZW50KCdjbG9zZScsIGVsKTtcbiAgICAgIHRoaXMuY29udHJvbHMuZmlyZXNFdmVudCgnYWZ0ZXItY2xvc2UnLCBlbClcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/h5p-lib-controls/src/scripts/ui/keyboard.js\n");

/***/ }),

/***/ "../node_modules/h5p-lib-controls/src/scripts/utils/elements.js":
/*!**********************************************************************!*\
  !*** ../node_modules/h5p-lib-controls/src/scripts/utils/elements.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"addClass\": () => (/* binding */ addClass),\n/* harmony export */   \"appendChild\": () => (/* binding */ appendChild),\n/* harmony export */   \"attributeEquals\": () => (/* binding */ attributeEquals),\n/* harmony export */   \"classListContains\": () => (/* binding */ classListContains),\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"getAttribute\": () => (/* binding */ getAttribute),\n/* harmony export */   \"hasAttribute\": () => (/* binding */ hasAttribute),\n/* harmony export */   \"hide\": () => (/* binding */ hide),\n/* harmony export */   \"nodeListToArray\": () => (/* binding */ nodeListToArray),\n/* harmony export */   \"querySelector\": () => (/* binding */ querySelector),\n/* harmony export */   \"querySelectorAll\": () => (/* binding */ querySelectorAll),\n/* harmony export */   \"removeAttribute\": () => (/* binding */ removeAttribute),\n/* harmony export */   \"removeChild\": () => (/* binding */ removeChild),\n/* harmony export */   \"removeClass\": () => (/* binding */ removeClass),\n/* harmony export */   \"setAttribute\": () => (/* binding */ setAttribute),\n/* harmony export */   \"show\": () => (/* binding */ show),\n/* harmony export */   \"toggleAttribute\": () => (/* binding */ toggleAttribute),\n/* harmony export */   \"toggleClass\": () => (/* binding */ toggleClass),\n/* harmony export */   \"toggleVisibility\": () => (/* binding */ toggleVisibility)\n/* harmony export */ });\n/* harmony import */ var _functional__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./functional */ \"../node_modules/h5p-lib-controls/src/scripts/utils/functional.js\");\n\n\n/**\n * Get an attribute value from element\n *\n * @param {string} name\n * @param {HTMLElement} el\n *\n * @function\n * @return {string}\n */\nconst getAttribute = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, el) => el.getAttribute(name));\n\n/**\n * Set an attribute on a html element\n *\n * @param {string} name\n * @param {string} value\n * @param {HTMLElement} el\n *\n * @function\n */\nconst setAttribute = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, value, el) => el.setAttribute(name, value));\n\n/**\n * Remove attribute from html element\n *\n * @param {string} name\n * @param {HTMLElement} el\n *\n * @function\n */\nconst removeAttribute = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, el) => el.removeAttribute(name));\n\n/**\n * Check if element has an attribute\n *\n * @param {string} name\n * @param {HTMLElement} el\n *\n * @function\n * @return {boolean}\n */\nconst hasAttribute = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, el) => el.hasAttribute(name));\n\n/**\n * Check if element has an attribute that equals\n *\n * @param {string} name\n * @param {string} value\n * @param {HTMLElement} el\n *\n * @function\n * @return {boolean}\n */\nconst attributeEquals = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, value, el) => el.getAttribute(name) === value);\n\n/**\n * Toggles an attribute between 'true' and 'false';\n *\n * @param {string} name\n * @param {HTMLElement} el\n *\n * @function\n */\nconst toggleAttribute = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((name, el) => {\n  const value = getAttribute(name, el);\n  setAttribute(name, (0,_functional__WEBPACK_IMPORTED_MODULE_0__.inverseBooleanString)(value), el);\n});\n\n/**\n * The appendChild() method adds a node to the end of the list of children of a specified parent node.\n *\n * @param {HTMLElement} parent\n * @param {HTMLElement} child\n *\n * @function\n * @return {HTMLElement}\n */\nconst appendChild = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((parent, child) => parent.appendChild(child));\n\n/**\n * Returns the first element that is a descendant of the element on which it is invoked\n * that matches the specified group of selectors.\n *\n * @param {string} selector\n * @param {HTMLElement} el\n *\n * @function\n * @return {HTMLElement}\n */\nconst querySelector = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((selector, el) => el.querySelector(selector));\n\n/**\n * Transforms a NodeList to an Array\n *\n * @param {NodeList} nodeList\n *\n * @return {Node[]}\n */\nconst nodeListToArray = nodeList => Array.prototype.slice.call(nodeList);\n\n/**\n * Returns a non-live NodeList of all elements descended from the element on which it\n * is invoked that matches the specified group of CSS selectors.\n *\n * @param {string} selector\n * @param {HTMLElement} el\n *\n * @function\n * @return {Node[]}\n */\nconst querySelectorAll = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((selector, el) => nodeListToArray(el.querySelectorAll(selector)));\n\n/**\n * The removeChild() method removes a child node from the DOM. Returns removed node.\n *\n * @param {Node} parent\n * @param {Node} oldChild\n *\n * @return {Node}\n */\nconst removeChild = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((parent, oldChild) => parent.removeChild(oldChild));\n\n/**\n * Returns true if a node has a class\n *\n * @param {string} cls\n * @param {HTMLElement} el\n *\n * @function\n */\nconst classListContains = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((cls, el) => el.classList.contains(cls));\n\n/**\n * Adds a css class to an element\n *\n * @param {string} cls\n * @param {Element} element\n *\n * @function\n */\nconst addClass = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((cls, element) => element.classList.add(cls));\n\n/**\n * Removes a css class from an element\n *\n * @param {string} cls\n * @param {Element} element\n *\n * @function\n */\nconst removeClass = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((cls, element) => element.classList.remove(cls));\n\n/**\n * Adds hidden class on an element\n *\n * @param {HTMLElement} element\n * @function\n */\nconst hide = addClass('hidden');\n\n/**\n * Removes hidden class from an element\n * @function\n */\nconst show = removeClass('hidden');\n\n/**\n * Toggles hidden class on an element\n *\n * @param {boolean} visible\n * @param {HTMLElement} element\n */\nconst toggleVisibility = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((visible, element) => (visible ? show : hide)(element));\n\n/**\n * Toggles a class on an element\n *\n * @param {string} cls\n * @param {boolean} add\n * @param {HTMLElement} element\n */\nconst toggleClass = (0,_functional__WEBPACK_IMPORTED_MODULE_0__.curry)((cls, add, element) => {\n  element.classList[add ? 'add' : 'remove'](cls)\n});\n\n/**\n * Helper for creating a DOM element\n *\n * @function\n *\n * @param {string} tag\n * @param {string} [id]\n * @param {string[]} [classes] - array of strings\n * @param {Object} [attributes]\n *\n * @return {HTMLElement}\n */\nconst createElement = ({tag, id, classes, attributes}) => {\n  let element = document.createElement(tag);\n\n  if (id) {\n    element.id = id;\n  }\n  if (classes) {\n    classes.forEach(clazz => {element.classList.add(clazz)});\n  }\n  if (attributes) {\n    Object.keys(attributes).forEach(key => {element.setAttribute(key, attributes[key])})\n  }\n\n  return element;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvdXRpbHMvZWxlbWVudHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPLHFCQUFxQixrREFBSzs7QUFFakM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ08scUJBQXFCLGtEQUFLOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QixrREFBSzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ08scUJBQXFCLGtEQUFLOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ08sd0JBQXdCLGtEQUFLOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QixrREFBSztBQUNwQztBQUNBLHFCQUFxQixpRUFBb0I7QUFDekMsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTyxvQkFBb0Isa0RBQUs7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ08sc0JBQXNCLGtEQUFLOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPLHlCQUF5QixrREFBSzs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNPLG9CQUFvQixrREFBSzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDTywwQkFBMEIsa0RBQUs7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ08saUJBQWlCLGtEQUFLOztBQUU3QjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPLG9CQUFvQixrREFBSzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLGFBQWE7QUFDeEI7QUFDTyx5QkFBeUIsa0RBQUs7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxhQUFhO0FBQ3hCO0FBQ08sb0JBQW9CLGtEQUFLO0FBQ2hDO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsWUFBWTtBQUNaO0FBQ08sd0JBQXdCLDZCQUE2QjtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBLDRDQUE0QywyQ0FBMkM7QUFDdkY7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaDVwLWxpYi1jb250cm9scy9zcmMvc2NyaXB0cy91dGlscy9lbGVtZW50cy5qcz9iMDBjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Y3VycnksIGludmVyc2VCb29sZWFuU3RyaW5nfSBmcm9tICcuL2Z1bmN0aW9uYWwnXG5cbi8qKlxuICogR2V0IGFuIGF0dHJpYnV0ZSB2YWx1ZSBmcm9tIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEF0dHJpYnV0ZSA9IGN1cnJ5KChuYW1lLCBlbCkgPT4gZWwuZ2V0QXR0cmlidXRlKG5hbWUpKTtcblxuLyoqXG4gKiBTZXQgYW4gYXR0cmlidXRlIG9uIGEgaHRtbCBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZSA9IGN1cnJ5KChuYW1lLCB2YWx1ZSwgZWwpID0+IGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpO1xuXG4vKipcbiAqIFJlbW92ZSBhdHRyaWJ1dGUgZnJvbSBodG1sIGVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZUF0dHJpYnV0ZSA9IGN1cnJ5KChuYW1lLCBlbCkgPT4gZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpKTtcblxuLyoqXG4gKiBDaGVjayBpZiBlbGVtZW50IGhhcyBhbiBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNBdHRyaWJ1dGUgPSBjdXJyeSgobmFtZSwgZWwpID0+IGVsLmhhc0F0dHJpYnV0ZShuYW1lKSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgZWxlbWVudCBoYXMgYW4gYXR0cmlidXRlIHRoYXQgZXF1YWxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhdHRyaWJ1dGVFcXVhbHMgPSBjdXJyeSgobmFtZSwgdmFsdWUsIGVsKSA9PiBlbC5nZXRBdHRyaWJ1dGUobmFtZSkgPT09IHZhbHVlKTtcblxuLyoqXG4gKiBUb2dnbGVzIGFuIGF0dHJpYnV0ZSBiZXR3ZWVuICd0cnVlJyBhbmQgJ2ZhbHNlJztcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHRvZ2dsZUF0dHJpYnV0ZSA9IGN1cnJ5KChuYW1lLCBlbCkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IGdldEF0dHJpYnV0ZShuYW1lLCBlbCk7XG4gIHNldEF0dHJpYnV0ZShuYW1lLCBpbnZlcnNlQm9vbGVhblN0cmluZyh2YWx1ZSksIGVsKTtcbn0pO1xuXG4vKipcbiAqIFRoZSBhcHBlbmRDaGlsZCgpIG1ldGhvZCBhZGRzIGEgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuIG9mIGEgc3BlY2lmaWVkIHBhcmVudCBub2RlLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGQgPSBjdXJyeSgocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKSk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIGEgZGVzY2VuZGFudCBvZiB0aGUgZWxlbWVudCBvbiB3aGljaCBpdCBpcyBpbnZva2VkXG4gKiB0aGF0IG1hdGNoZXMgdGhlIHNwZWNpZmllZCBncm91cCBvZiBzZWxlY3RvcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICpcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yID0gY3VycnkoKHNlbGVjdG9yLCBlbCkgPT4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3RvcikpO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBOb2RlTGlzdCB0byBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R9IG5vZGVMaXN0XG4gKlxuICogQHJldHVybiB7Tm9kZVtdfVxuICovXG5leHBvcnQgY29uc3Qgbm9kZUxpc3RUb0FycmF5ID0gbm9kZUxpc3QgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZUxpc3QpO1xuXG4vKipcbiAqIFJldHVybnMgYSBub24tbGl2ZSBOb2RlTGlzdCBvZiBhbGwgZWxlbWVudHMgZGVzY2VuZGVkIGZyb20gdGhlIGVsZW1lbnQgb24gd2hpY2ggaXRcbiAqIGlzIGludm9rZWQgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgZ3JvdXAgb2YgQ1NTIHNlbGVjdG9ycy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtOb2RlW119XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yQWxsID0gY3VycnkoKHNlbGVjdG9yLCBlbCkgPT4gbm9kZUxpc3RUb0FycmF5KGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSk7XG5cbi8qKlxuICogVGhlIHJlbW92ZUNoaWxkKCkgbWV0aG9kIHJlbW92ZXMgYSBjaGlsZCBub2RlIGZyb20gdGhlIERPTS4gUmV0dXJucyByZW1vdmVkIG5vZGUuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gb2xkQ2hpbGRcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2hpbGQgPSBjdXJyeSgocGFyZW50LCBvbGRDaGlsZCkgPT4gcGFyZW50LnJlbW92ZUNoaWxkKG9sZENoaWxkKSk7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgbm9kZSBoYXMgYSBjbGFzc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjbGFzc0xpc3RDb250YWlucyA9IGN1cnJ5KChjbHMsIGVsKSA9PiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xzKSk7XG5cbi8qKlxuICogQWRkcyBhIGNzcyBjbGFzcyB0byBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNsc1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDbGFzcyA9IGN1cnJ5KChjbHMsIGVsZW1lbnQpID0+IGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbHMpKTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY3NzIGNsYXNzIGZyb20gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbHNcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQ2xhc3MgPSBjdXJyeSgoY2xzLCBlbGVtZW50KSA9PiBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xzKSk7XG5cbi8qKlxuICogQWRkcyBoaWRkZW4gY2xhc3Mgb24gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaGlkZSA9IGFkZENsYXNzKCdoaWRkZW4nKTtcblxuLyoqXG4gKiBSZW1vdmVzIGhpZGRlbiBjbGFzcyBmcm9tIGFuIGVsZW1lbnRcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2hvdyA9IHJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcblxuLyoqXG4gKiBUb2dnbGVzIGhpZGRlbiBjbGFzcyBvbiBhbiBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2aXNpYmxlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVWaXNpYmlsaXR5ID0gY3VycnkoKHZpc2libGUsIGVsZW1lbnQpID0+ICh2aXNpYmxlID8gc2hvdyA6IGhpZGUpKGVsZW1lbnQpKTtcblxuLyoqXG4gKiBUb2dnbGVzIGEgY2xhc3Mgb24gYW4gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjbHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYWRkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCB0b2dnbGVDbGFzcyA9IGN1cnJ5KChjbHMsIGFkZCwgZWxlbWVudCkgPT4ge1xuICBlbGVtZW50LmNsYXNzTGlzdFthZGQgPyAnYWRkJyA6ICdyZW1vdmUnXShjbHMpXG59KTtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNyZWF0aW5nIGEgRE9NIGVsZW1lbnRcbiAqXG4gKiBAZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnXG4gKiBAcGFyYW0ge3N0cmluZ30gW2lkXVxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2NsYXNzZXNdIC0gYXJyYXkgb2Ygc3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFthdHRyaWJ1dGVzXVxuICpcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRWxlbWVudCA9ICh7dGFnLCBpZCwgY2xhc3NlcywgYXR0cmlidXRlc30pID0+IHtcbiAgbGV0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG5cbiAgaWYgKGlkKSB7XG4gICAgZWxlbWVudC5pZCA9IGlkO1xuICB9XG4gIGlmIChjbGFzc2VzKSB7XG4gICAgY2xhc3Nlcy5mb3JFYWNoKGNsYXp6ID0+IHtlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhenopfSk7XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7ZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pfSlcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/h5p-lib-controls/src/scripts/utils/elements.js\n");

/***/ }),

/***/ "../node_modules/h5p-lib-controls/src/scripts/utils/functional.js":
/*!************************************************************************!*\
  !*** ../node_modules/h5p-lib-controls/src/scripts/utils/functional.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"compose\": () => (/* binding */ compose),\n/* harmony export */   \"contains\": () => (/* binding */ contains),\n/* harmony export */   \"curry\": () => (/* binding */ curry),\n/* harmony export */   \"filter\": () => (/* binding */ filter),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"inverseBooleanString\": () => (/* binding */ inverseBooleanString),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"some\": () => (/* binding */ some),\n/* harmony export */   \"without\": () => (/* binding */ without)\n/* harmony export */ });\n/**\n * Returns a curried version of a function\n *\n * @param {function} fn\n *\n * @public\n *\n * @return {function}\n */\nconst curry = function(fn) {\n  const arity = fn.length;\n\n  return function f1() {\n    const args = Array.prototype.slice.call(arguments, 0);\n    if (args.length >= arity) {\n      return fn.apply(null, args);\n    }\n    else {\n      return function f2() {\n        const args2 = Array.prototype.slice.call(arguments, 0);\n        return f1.apply(null, args.concat(args2));\n      }\n    }\n  };\n};\n\n/**\n * Compose functions together, executing from right to left\n *\n * @param {function...} fns\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));\n\n/**\n * Applies a function to each element in an array\n *\n * @param {function} fn\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst forEach = curry(function (fn, arr) {\n  arr.forEach(fn);\n});\n\n/**\n * Maps a function to an array\n *\n * @param {function} fn\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst map = curry(function (fn, arr) {\n  return arr.map(fn);\n});\n\n/**\n * Applies a filter to an array\n *\n * @param {function} fn\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst filter = curry(function (fn, arr) {\n  return arr.filter(fn);\n});\n\n/**\n * Applies a some to an array\n *\n * @param {function} fn\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst some = curry(function (fn, arr) {\n  return arr.some(fn);\n});\n\n/**\n * Returns true if an array contains a value\n *\n * @param {*} value\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst contains = curry(function (value, arr) {\n  return arr.indexOf(value) != -1;\n});\n\n/**\n * Returns an array without the supplied values\n *\n * @param {Array} values\n * @param {Array} arr\n *\n * @function\n * @public\n *\n * @return {function}\n */\nconst without = curry(function (values, arr) {\n  return filter(value => !contains(value, values), arr)\n});\n\n/**\n * Takes a string that is either 'true' or 'false' and returns the opposite\n *\n * @param {string} bool\n *\n * @public\n * @return {string}\n */\nconst inverseBooleanString = function (bool) {\n  return (bool !== 'true').toString();\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1saWItY29udHJvbHMvc3JjL3NjcmlwdHMvdXRpbHMvZnVuY3Rpb25hbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oNXAtbGliLWNvbnRyb2xzL3NyYy9zY3JpcHRzL3V0aWxzL2Z1bmN0aW9uYWwuanM/OGYxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIHZlcnNpb24gb2YgYSBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5leHBvcnQgY29uc3QgY3VycnkgPSBmdW5jdGlvbihmbikge1xuICBjb25zdCBhcml0eSA9IGZuLmxlbmd0aDtcblxuICByZXR1cm4gZnVuY3Rpb24gZjEoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID49IGFyaXR5KSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGYyKCkge1xuICAgICAgICBjb25zdCBhcmdzMiA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgICAgIHJldHVybiBmMS5hcHBseShudWxsLCBhcmdzLmNvbmNhdChhcmdzMikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogQ29tcG9zZSBmdW5jdGlvbnMgdG9nZXRoZXIsIGV4ZWN1dGluZyBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uLi4ufSBmbnNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXBvc2UgPSAoLi4uZm5zKSA9PiBmbnMucmVkdWNlKChmLCBnKSA9PiAoLi4uYXJncykgPT4gZihnKC4uLmFyZ3MpKSk7XG5cbi8qKlxuICogQXBwbGllcyBhIGZ1bmN0aW9uIHRvIGVhY2ggZWxlbWVudCBpbiBhbiBhcnJheVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwdWJsaWNcbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSBjdXJyeShmdW5jdGlvbiAoZm4sIGFycikge1xuICBhcnIuZm9yRWFjaChmbik7XG59KTtcblxuLyoqXG4gKiBNYXBzIGEgZnVuY3Rpb24gdG8gYW4gYXJyYXlcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSBjdXJyeShmdW5jdGlvbiAoZm4sIGFycikge1xuICByZXR1cm4gYXJyLm1hcChmbik7XG59KTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgZmlsdGVyIHRvIGFuIGFycmF5XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICpcbiAqIEBmdW5jdGlvblxuICogQHB1YmxpY1xuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5leHBvcnQgY29uc3QgZmlsdGVyID0gY3VycnkoZnVuY3Rpb24gKGZuLCBhcnIpIHtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZm4pO1xufSk7XG5cbi8qKlxuICogQXBwbGllcyBhIHNvbWUgdG8gYW4gYXJyYXlcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gY3VycnkoZnVuY3Rpb24gKGZuLCBhcnIpIHtcbiAgcmV0dXJuIGFyci5zb21lKGZuKTtcbn0pO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBhcnJheSBjb250YWlucyBhIHZhbHVlXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCBjb250YWlucyA9IGN1cnJ5KGZ1bmN0aW9uICh2YWx1ZSwgYXJyKSB7XG4gIHJldHVybiBhcnIuaW5kZXhPZih2YWx1ZSkgIT0gLTE7XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IHdpdGhvdXQgdGhlIHN1cHBsaWVkIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmV4cG9ydCBjb25zdCB3aXRob3V0ID0gY3VycnkoZnVuY3Rpb24gKHZhbHVlcywgYXJyKSB7XG4gIHJldHVybiBmaWx0ZXIodmFsdWUgPT4gIWNvbnRhaW5zKHZhbHVlLCB2YWx1ZXMpLCBhcnIpXG59KTtcblxuLyoqXG4gKiBUYWtlcyBhIHN0cmluZyB0aGF0IGlzIGVpdGhlciAndHJ1ZScgb3IgJ2ZhbHNlJyBhbmQgcmV0dXJucyB0aGUgb3Bwb3NpdGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYm9vbFxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGludmVyc2VCb29sZWFuU3RyaW5nID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgcmV0dXJuIChib29sICE9PSAndHJ1ZScpLnRvU3RyaW5nKCk7XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/h5p-lib-controls/src/scripts/utils/functional.js\n");

/***/ }),

/***/ "../node_modules/h5p-parent/src/child.js":
/*!***********************************************!*\
  !*** ../node_modules/h5p-parent/src/child.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/**\r\n * @class\r\n */\r\nfunction Child(index, parent) {\r\n  const self = this;\r\n\r\n  self.index = index;\r\n  self.parent = parent;\r\n}\r\n\r\nmodule.exports = Child;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL2NoaWxkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL2NoaWxkLmpzP2MzNDYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gQ2hpbGQoaW5kZXgsIHBhcmVudCkge1xyXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xyXG5cclxuICBzZWxmLmluZGV4ID0gaW5kZXg7XHJcbiAgc2VsZi5wYXJlbnQgPSBwYXJlbnQ7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2hpbGQ7XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/h5p-parent/src/child.js\n");

/***/ }),

/***/ "../node_modules/h5p-parent/src/parent.js":
/*!************************************************!*\
  !*** ../node_modules/h5p-parent/src/parent.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Child = __webpack_require__(/*! ./child.js */ \"../node_modules/h5p-parent/src/child.js\");\r\nconst EventDispatcher = H5P.EventDispatcher;\r\n\r\n/**\r\n * @class\r\n */\r\nfunction Parent(constructor, parameters) {\r\n  const self = this;\r\n  EventDispatcher.call(self);\r\n\r\n  self.children = [];\r\n\r\n  /**\r\n   * Update the internal indexes of the children.\r\n   *\r\n   * @private\r\n   * @param {number} from Where to start\r\n   */\r\n  var updateIndexes = function (from) {\r\n    for (let i = from; i < self.children.length; i++) {\r\n      self.children[i].index = i;\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Give a new child to this parent.\r\n   *\r\n   * @param {*} childParameters Launch parameters\r\n   */\r\n  self.addChild = function (childParameters, index) {\r\n    if (index === undefined) {\r\n      index = self.children.length\r\n    }\r\n\r\n    // Create a new child with the current instance as its parent\r\n    const instance = new Child(index, self);\r\n\r\n    if (index === self.children.length) {\r\n      // Added at the end\r\n      self.children.push(instance);\r\n    }\r\n    else {\r\n      // Inserted at a specific location\r\n      self.children.splice(index, 0, instance);\r\n      updateIndexes(index);\r\n    }\r\n\r\n    // Run original constructor\r\n    constructor.call(instance, childParameters);\r\n\r\n    return instance;\r\n  };\r\n\r\n  /**\r\n   * Remova a new child from its parent.\r\n   *\r\n   * @param {number} index\r\n   */\r\n  self.removeChild = function (index) {\r\n    // Remove from array\r\n    self.children.splice(index, 1);\r\n\r\n    // Update internal indexes\r\n    updateIndexes(index);\r\n  };\r\n\r\n  /**\r\n   * Move the child into a new position\r\n   *\r\n   * @param {number} oldIndex\r\n   * @param {number} newIndex\r\n   */\r\n  self.moveChild = function (oldIndex, newIndex) {\r\n    const child = self.children.splice(oldIndex, 1)[0];\r\n    self.children.splice(newIndex, 0, child);\r\n\r\n    updateIndexes(newIndex < oldIndex ? newIndex : oldIndex);\r\n  };\r\n\r\n  if (parameters) {\r\n    for (let i = 0; i < parameters.length; i++) {\r\n      self.addChild(parameters[i]);\r\n    }\r\n  }\r\n}\r\n\r\nParent.prototype = Object.create(EventDispatcher.prototype);\r\nParent.prototype.constructor = Parent;\r\n\r\nmodule.exports = Parent;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL3BhcmVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLG1CQUFPLENBQUMsMkRBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2g1cC1wYXJlbnQvc3JjL3BhcmVudC5qcz81Njg0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENoaWxkID0gcmVxdWlyZSgnLi9jaGlsZC5qcycpO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXIgPSBINVAuRXZlbnREaXNwYXRjaGVyO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gUGFyZW50KGNvbnN0cnVjdG9yLCBwYXJhbWV0ZXJzKSB7XHJcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XHJcbiAgRXZlbnREaXNwYXRjaGVyLmNhbGwoc2VsZik7XHJcblxyXG4gIHNlbGYuY2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBpbnRlcm5hbCBpbmRleGVzIG9mIHRoZSBjaGlsZHJlbi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gV2hlcmUgdG8gc3RhcnRcclxuICAgKi9cclxuICB2YXIgdXBkYXRlSW5kZXhlcyA9IGZ1bmN0aW9uIChmcm9tKSB7XHJcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHNlbGYuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgc2VsZi5jaGlsZHJlbltpXS5pbmRleCA9IGk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZSBhIG5ldyBjaGlsZCB0byB0aGlzIHBhcmVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Kn0gY2hpbGRQYXJhbWV0ZXJzIExhdW5jaCBwYXJhbWV0ZXJzXHJcbiAgICovXHJcbiAgc2VsZi5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZFBhcmFtZXRlcnMsIGluZGV4KSB7XHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBpbmRleCA9IHNlbGYuY2hpbGRyZW4ubGVuZ3RoXHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNoaWxkIHdpdGggdGhlIGN1cnJlbnQgaW5zdGFuY2UgYXMgaXRzIHBhcmVudFxyXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2hpbGQoaW5kZXgsIHNlbGYpO1xyXG5cclxuICAgIGlmIChpbmRleCA9PT0gc2VsZi5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgLy8gQWRkZWQgYXQgdGhlIGVuZFxyXG4gICAgICBzZWxmLmNoaWxkcmVuLnB1c2goaW5zdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIEluc2VydGVkIGF0IGEgc3BlY2lmaWMgbG9jYXRpb25cclxuICAgICAgc2VsZi5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGluc3RhbmNlKTtcclxuICAgICAgdXBkYXRlSW5kZXhlcyhpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUnVuIG9yaWdpbmFsIGNvbnN0cnVjdG9yXHJcbiAgICBjb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBjaGlsZFBhcmFtZXRlcnMpO1xyXG5cclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmEgYSBuZXcgY2hpbGQgZnJvbSBpdHMgcGFyZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICovXHJcbiAgc2VsZi5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChpbmRleCkge1xyXG4gICAgLy8gUmVtb3ZlIGZyb20gYXJyYXlcclxuICAgIHNlbGYuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgaW5kZXhlc1xyXG4gICAgdXBkYXRlSW5kZXhlcyhpbmRleCk7XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgY2hpbGQgaW50byBhIG5ldyBwb3NpdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9sZEluZGV4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5ld0luZGV4XHJcbiAgICovXHJcbiAgc2VsZi5tb3ZlQ2hpbGQgPSBmdW5jdGlvbiAob2xkSW5kZXgsIG5ld0luZGV4KSB7XHJcbiAgICBjb25zdCBjaGlsZCA9IHNlbGYuY2hpbGRyZW4uc3BsaWNlKG9sZEluZGV4LCAxKVswXTtcclxuICAgIHNlbGYuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBjaGlsZCk7XHJcblxyXG4gICAgdXBkYXRlSW5kZXhlcyhuZXdJbmRleCA8IG9sZEluZGV4ID8gbmV3SW5kZXggOiBvbGRJbmRleCk7XHJcbiAgfTtcclxuXHJcbiAgaWYgKHBhcmFtZXRlcnMpIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBzZWxmLmFkZENoaWxkKHBhcmFtZXRlcnNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuUGFyZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSk7XHJcblBhcmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJlbnQ7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IFBhcmVudDtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/h5p-parent/src/parent.js\n");

/***/ }),

/***/ "./styles/cp.css":
/*!***********************!*\
  !*** ./styles/cp.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvY3AuY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlcy9jcC5jc3M/MTYxYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/cp.css\n");

/***/ }),

/***/ "./styles/go-to-slide.scss":
/*!*********************************!*\
  !*** ./styles/go-to-slide.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZ28tdG8tc2xpZGUuc2Nzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvZ28tdG8tc2xpZGUuc2Nzcz8xZjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/go-to-slide.scss\n");

/***/ }),

/***/ "./styles/keyword-menu.css":
/*!*********************************!*\
  !*** ./styles/keyword-menu.css ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMva2V5d29yZC1tZW51LmNzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMva2V5d29yZC1tZW51LmNzcz8xNGNkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/keyword-menu.css\n");

/***/ }),

/***/ "./styles/navigation-line.css":
/*!************************************!*\
  !*** ./styles/navigation-line.css ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvbmF2aWdhdGlvbi1saW5lLmNzcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zdHlsZXMvbmF2aWdhdGlvbi1saW5lLmNzcz9kNGU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./styles/navigation-line.css\n");

/***/ }),

/***/ "./styles/print.css":
/*!**************************!*\
  !*** ./styles/print.css ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvcHJpbnQuY3NzLmpzIiwibWFwcGluZ3MiOiI7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0eWxlcy9wcmludC5jc3M/OTJlZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/print.css\n");

/***/ }),

/***/ "./styles/slide-background.css":
/*!*************************************!*\
  !*** ./styles/slide-background.css ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvc2xpZGUtYmFja2dyb3VuZC5jc3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3R5bGVzL3NsaWRlLWJhY2tncm91bmQuY3NzP2ZkY2QiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/slide-background.css\n");

/***/ }),

/***/ "./styles/summary-slide.css":
/*!**********************************!*\
  !*** ./styles/summary-slide.css ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvc3VtbWFyeS1zbGlkZS5jc3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3R5bGVzL3N1bW1hcnktc2xpZGUuY3NzPzJiYWYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/summary-slide.css\n");

/***/ }),

/***/ "../node_modules/@socket.io/component-emitter/index.mjs":
/*!**************************************************************!*\
  !*** ../node_modules/@socket.io/component-emitter/index.mjs ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Emitter\": () => (/* binding */ Emitter)\n/* harmony export */ });\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0Bzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0Bzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXIvaW5kZXgubWpzP2U1MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cbiAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gIH1cblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGFsaWFzIHVzZWQgZm9yIHJlc2VydmVkIGV2ZW50cyAocHJvdGVjdGVkIG1ldGhvZClcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXRSZXNlcnZlZCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@socket.io/component-emitter/index.mjs\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/contrib/has-cors.js":
/*!**********************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/contrib/has-cors.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasCORS\": () => (/* binding */ hasCORS)\n/* harmony export */ });\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nconst hasCORS = value;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvaGFzLWNvcnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvaGFzLWNvcnMuanM/MDdlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvaGFzLWNvcnNcbmxldCB2YWx1ZSA9IGZhbHNlO1xudHJ5IHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxufVxuZXhwb3J0IGNvbnN0IGhhc0NPUlMgPSB2YWx1ZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/contrib/has-cors.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/contrib/parseqs.js":
/*!*********************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/contrib/parseqs.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nfunction encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nfunction decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2Vxcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2Vxcy5qcz8wMGExIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhbGtuL3F1ZXJ5c3RyaW5nXG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iaikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyYnO1xuICAgICAgICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocXMpIHtcbiAgICBsZXQgcXJ5ID0ge307XG4gICAgbGV0IHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcXJ5O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/contrib/parseqs.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/contrib/parseuri.js":
/*!**********************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/contrib/parseuri.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nfunction parse(str) {\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2V1cmkuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILElBQUksR0FBRyxJQUFJLFNBQVMsSUFBSTtBQUMvSTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvcGFyc2V1cmkuanM/YTVhYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9wYXJzZXVyaVxuLyoqXG4gKiBQYXJzZXMgYSBVUklcbiAqXG4gKiBOb3RlOiB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCB0aGUgYnVpbHQtaW4gVVJMIG9iamVjdCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIFNlZTpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICogLSBodHRwczovL2Nhbml1c2UuY29tL3VybFxuICogLSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKlxuICogSGlzdG9yeSBvZiB0aGUgcGFyc2UoKSBtZXRob2Q6XG4gKiAtIGZpcnN0IGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQvY29tbWl0LzRlZTFkNWQ5NGIzOTA2YTljMDUyYjQ1OWYxYTgxOGIxNWYzOGY5MWNcbiAqIC0gZXhwb3J0IGludG8gaXRzIG93biBtb2R1bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZTJjNTYxZTQ1NjRlZmViNzhmMWJkYjFiYTM5ZWY4MWIyODIyY2IzXG4gKiAtIHJlaW1wb3J0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLWNsaWVudC9jb21taXQvZGYzMjI3N2MzZjZkNjIyZWVjNWVkMDlmNDkzY2FlM2YzMzkxZDI0MlxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5jb25zdCByZSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuY29uc3QgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGNvbnN0IHNyYyA9IHN0ciwgYiA9IHN0ci5pbmRleE9mKCdbJyksIGUgPSBzdHIuaW5kZXhPZignXScpO1xuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgbGV0IG0gPSByZS5leGVjKHN0ciB8fCAnJyksIHVyaSA9IHt9LCBpID0gMTQ7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG4gICAgdXJpLnBhdGhOYW1lcyA9IHBhdGhOYW1lcyh1cmksIHVyaVsncGF0aCddKTtcbiAgICB1cmkucXVlcnlLZXkgPSBxdWVyeUtleSh1cmksIHVyaVsncXVlcnknXSk7XG4gICAgcmV0dXJuIHVyaTtcbn1cbmZ1bmN0aW9uIHBhdGhOYW1lcyhvYmosIHBhdGgpIHtcbiAgICBjb25zdCByZWd4ID0gL1xcL3syLDl9L2csIG5hbWVzID0gcGF0aC5yZXBsYWNlKHJlZ3gsIFwiL1wiKS5zcGxpdChcIi9cIik7XG4gICAgaWYgKHBhdGguc2xpY2UoMCwgMSkgPT0gJy8nIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5hbWVzLnNwbGljZSgwLCAxKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc2xpY2UoLTEpID09ICcvJykge1xuICAgICAgICBuYW1lcy5zcGxpY2UobmFtZXMubGVuZ3RoIC0gMSwgMSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbn1cbmZ1bmN0aW9uIHF1ZXJ5S2V5KHVyaSwgcXVlcnkpIHtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgcXVlcnkucmVwbGFjZSgvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2csIGZ1bmN0aW9uICgkMCwgJDEsICQyKSB7XG4gICAgICAgIGlmICgkMSkge1xuICAgICAgICAgICAgZGF0YVskMV0gPSAkMjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/contrib/parseuri.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/contrib/yeast.js":
/*!*******************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/contrib/yeast.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"yeast\": () => (/* binding */ yeast)\n/* harmony export */ });\n// imported from https://github.com/unshiftio/yeast\n\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nfunction encode(num) {\n    let encoded = '';\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nfunction decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nfunction yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n}\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIveWVhc3QuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxZQUFZO0FBQ25CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL3llYXN0LmpzPzk4ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdW5zaGlmdGlvL3llYXN0XG4ndXNlIHN0cmljdCc7XG5jb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJy5zcGxpdCgnJyksIGxlbmd0aCA9IDY0LCBtYXAgPSB7fTtcbmxldCBzZWVkID0gMCwgaSA9IDAsIHByZXY7XG4vKipcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBudW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBudW1iZXIuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG51bSkge1xuICAgIGxldCBlbmNvZGVkID0gJyc7XG4gICAgZG8ge1xuICAgICAgICBlbmNvZGVkID0gYWxwaGFiZXRbbnVtICUgbGVuZ3RoXSArIGVuY29kZWQ7XG4gICAgICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gbGVuZ3RoKTtcbiAgICB9IHdoaWxlIChudW0gPiAwKTtcbiAgICByZXR1cm4gZW5jb2RlZDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBpbnRlZ2VyIHZhbHVlIHNwZWNpZmllZCBieSB0aGUgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge051bWJlcn0gVGhlIGludGVnZXIgdmFsdWUgcmVwcmVzZW50ZWQgYnkgdGhlIHN0cmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUoc3RyKSB7XG4gICAgbGV0IGRlY29kZWQgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVjb2RlZCA9IGRlY29kZWQgKiBsZW5ndGggKyBtYXBbc3RyLmNoYXJBdChpKV07XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkO1xufVxuLyoqXG4gKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IEEgdW5pcXVlIGlkLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHllYXN0KCkge1xuICAgIGNvbnN0IG5vdyA9IGVuY29kZSgrbmV3IERhdGUoKSk7XG4gICAgaWYgKG5vdyAhPT0gcHJldilcbiAgICAgICAgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuICAgIHJldHVybiBub3cgKyAnLicgKyBlbmNvZGUoc2VlZCsrKTtcbn1cbi8vXG4vLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuLy9cbmZvciAoOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgbWFwW2FscGhhYmV0W2ldXSA9IGk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/contrib/yeast.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/globalThis.browser.js":
/*!************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/globalThis.browser.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"globalThisShim\": () => (/* binding */ globalThisShim)\n/* harmony export */ });\nconst globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2dsb2JhbFRoaXMuYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9nbG9iYWxUaGlzLmJyb3dzZXIuanM/ODljNiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgZ2xvYmFsVGhpc1NoaW0gPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/globalThis.browser.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket),\n/* harmony export */   \"Transport\": () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.Transport),\n/* harmony export */   \"installTimerFunctions\": () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.installTimerFunctions),\n/* harmony export */   \"nextTick\": () => (/* reexport safe */ _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__.nextTick),\n/* harmony export */   \"parse\": () => (/* reexport safe */ _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__.parse),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol),\n/* harmony export */   \"transports\": () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_2__.transports)\n/* harmony export */ });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket.js */ \"../node_modules/engine.io-client/build/esm/socket.js\");\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transport.js */ \"../node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/index.js */ \"../node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"../node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"../node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony import */ var _transports_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./transports/websocket-constructor.js */ \"../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\");\n\n\nconst protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket.protocol;\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBcUM7QUFDbkI7QUFDWCxpQkFBaUIsdURBQWU7QUFDSTtBQUNRO0FBQ0Q7QUFDSjtBQUNtQiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vaW5kZXguanM/NGZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbmV4cG9ydCB7IFNvY2tldCB9O1xuZXhwb3J0IGNvbnN0IHByb3RvY29sID0gU29ja2V0LnByb3RvY29sO1xuZXhwb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4vdHJhbnNwb3J0LmpzXCI7XG5leHBvcnQgeyB0cmFuc3BvcnRzIH0gZnJvbSBcIi4vdHJhbnNwb3J0cy9pbmRleC5qc1wiO1xuZXhwb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IHsgcGFyc2UgfSBmcm9tIFwiLi9jb250cmliL3BhcnNldXJpLmpzXCI7XG5leHBvcnQgeyBuZXh0VGljayB9IGZyb20gXCIuL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmpzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/index.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/socket.js":
/*!************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/socket.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transports/index.js */ \"../node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"../node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contrib/parseqs.js */ \"../node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"../node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ \"../node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\n\n\n\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts = {}) {\n        super();\n        this.writeBuffer = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(opts.host).host;\n        }\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\"polling\", \"websocket\"];\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: true,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.decode)(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        });\n        return new _transports_index_js__WEBPACK_IMPORTED_MODULE_0__.transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        transport.open();\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.resetPingTimeout();\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this.getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    getWritablePackets() {\n        const shouldCheckPayloadSize = this.maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.byteLength)(data);\n            }\n            if (i > 0 && payloadSize > this.maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3NvY2tldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1EO0FBQ1c7QUFDaEI7QUFDQTtBQUNTO0FBQ1g7QUFDckMscUJBQXFCLGlFQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLFFBQVE7QUFDdkI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkRBQUs7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsMkRBQUs7QUFDakM7QUFDQSxRQUFRLCtEQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQztBQUNoQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esb0JBQW9CLHNEQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtQkFBbUIsNERBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0Isd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0EsK0JBQStCLG9EQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3NvY2tldC5qcz84ODk3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zcG9ydHMgfSBmcm9tIFwiLi90cmFuc3BvcnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpbnN0YWxsVGltZXJGdW5jdGlvbnMsIGJ5dGVMZW5ndGggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwiLi9jb250cmliL3BhcnNlcXMuanNcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXVyaS5qc1wiO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gXCJlbmdpbmUuaW8tcGFyc2VyXCI7XG5leHBvcnQgY2xhc3MgU29ja2V0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgLSB1cmkgb3Igb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgaWYgKHVyaSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXJpKSB7XG4gICAgICAgICAgICBvcHRzID0gdXJpO1xuICAgICAgICAgICAgdXJpID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgICB1cmkgPSBwYXJzZSh1cmkpO1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9IHVyaS5ob3N0O1xuICAgICAgICAgICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCB1cmkucHJvdG9jb2wgPT09IFwid3NzXCI7XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICAgICAgICAgIGlmICh1cmkucXVlcnkpXG4gICAgICAgICAgICAgICAgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRzLmhvc3QpIHtcbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgPSBwYXJzZShvcHRzLmhvc3QpLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnNlY3VyZSA9XG4gICAgICAgICAgICBudWxsICE9IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgPyBvcHRzLnNlY3VyZVxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICBpZiAob3B0cy5ob3N0bmFtZSAmJiAhb3B0cy5wb3J0KSB7XG4gICAgICAgICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9XG4gICAgICAgICAgICBvcHRzLmhvc3RuYW1lIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogXCJsb2NhbGhvc3RcIik7XG4gICAgICAgIHRoaXMucG9ydCA9XG4gICAgICAgICAgICBvcHRzLnBvcnQgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgPyBsb2NhdGlvbi5wb3J0XG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5zZWN1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCI0NDNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIjgwXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgW1wicG9sbGluZ1wiLCBcIndlYnNvY2tldFwiXTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBhdGg6IFwiL2VuZ2luZS5pb1wiLFxuICAgICAgICAgICAgYWdlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgICAgICB0aW1lc3RhbXBQYXJhbTogXCJ0XCIsXG4gICAgICAgICAgICByZW1lbWJlclVwZ3JhZGU6IGZhbHNlLFxuICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDI0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgY2xvc2VPbkJlZm9yZXVubG9hZDogdHJ1ZSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cy5wYXRoID1cbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSArXG4gICAgICAgICAgICAgICAgKHRoaXMub3B0cy5hZGRUcmFpbGluZ1NsYXNoID8gXCIvXCIgOiBcIlwiKTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMucXVlcnkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5xdWVyeSA9IGRlY29kZSh0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBvbiBoYW5kc2hha2VcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICAgIHRoaXMudXBncmFkZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAvLyBzZXQgb24gaGVhcnRiZWF0XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNsb3NlT25CZWZvcmV1bmxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNsb3NlcyB0aGUgY29ubmVjdGlvbiB3aGVuIHRoZSBcImJlZm9yZXVubG9hZFwiIGV2ZW50IGlzIGVtaXR0ZWQgYnV0IG5vdCBDaHJvbWUuIFRoaXMgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmVzIGV2ZXJ5IGJyb3dzZXIgYmVoYXZlcyB0aGUgc2FtZSAobm8gXCJkaXNjb25uZWN0XCIgZXZlbnQgYXQgdGhlIFNvY2tldC5JTyBsZXZlbCB3aGVuIHRoZSBwYWdlIGlzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VkL3JlbG9hZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaWxlbnRseSBjbG9zZSB0aGUgdHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIikge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJuZXR3b3JrIGNvbm5lY3Rpb24gbG9zdFwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY3JlYXRlVHJhbnNwb3J0KG5hbWUpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMucXVlcnkpO1xuICAgICAgICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgICAgICAgcXVlcnkuRUlPID0gcHJvdG9jb2w7XG4gICAgICAgIC8vIHRyYW5zcG9ydCBuYW1lXG4gICAgICAgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG4gICAgICAgIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICAgICAgICBpZiAodGhpcy5pZClcbiAgICAgICAgICAgIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1tuYW1lXSwgdGhpcy5vcHRzLCB7XG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIHNvY2tldDogdGhpcyxcbiAgICAgICAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgICAgICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICAgICAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNwb3J0c1tuYW1lXShvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICBsZXQgdHJhbnNwb3J0O1xuICAgICAgICBpZiAodGhpcy5vcHRzLnJlbWVtYmVyVXBncmFkZSAmJlxuICAgICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSBcIndlYnNvY2tldFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKDAgPT09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAub24oXCJkcmFpblwiLCB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcInBhY2tldFwiLCB0aGlzLm9uUGFja2V0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcImNsb3NlXCIsIChyZWFzb24pID0+IHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiLCByZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0cmFuc3BvcnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcHJvYmUobmFtZSkge1xuICAgICAgICBsZXQgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSk7XG4gICAgICAgIGxldCBmYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvblRyYW5zcG9ydE9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicGluZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJwYWNrZXRcIiwgKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoXCJwb25nXCIgPT09IG1zZy50eXBlICYmIFwicHJvYmVcIiA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5wYXVzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwidXBncmFkZVwiIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwicHJvYmUgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yOiBcIiArIGVycik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCkge1xuICAgICAgICAgICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgICAgICAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICAgICAgICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJvcGVuXCIsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBcIndlYnNvY2tldFwiID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm9wZW5cIik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAgICAgICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMub3B0cy51cGdyYWRlKSB7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBjb25zdCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGlmIChcIm9wZW5pbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAgICAgICBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8XG4gICAgICAgICAgICBcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJoZWFydGJlYXRcIik7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShKU09OLnBhcnNlKHBhY2tldC5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJwaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwb25nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicG9uZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcInNlcnZlciBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkYXRhXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJtZXNzYWdlXCIsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIGhhbmRzaGFrZSBvYmpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uSGFuZHNoYWtlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJoYW5kc2hha2VcIiwgZGF0YSk7XG4gICAgICAgIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gICAgICAgIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgICAgICAgdGhpcy5tYXhQYXlsb2FkID0gZGF0YS5tYXhQYXlsb2FkO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuZCByZXNldHMgcGluZyB0aW1lb3V0IHRpbWVyIGJhc2VkIG9uIHNlcnZlciBwaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJwaW5nIHRpbWVvdXRcIik7XG4gICAgICAgIH0sIHRoaXMucGluZ0ludGVydmFsICsgdGhpcy5waW5nVGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIudW5yZWYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRyYWluKCkge1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuICAgICAgICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAgICAgICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICAgICAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICBpZiAoMCA9PT0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgICAgICAgICAhdGhpcy51cGdyYWRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXRzID0gdGhpcy5nZXRXcml0YWJsZVBhY2tldHMoKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnNlbmQocGFja2V0cyk7XG4gICAgICAgICAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgICAgICAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICAgICAgICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJmbHVzaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIGVuY29kZWQgc2l6ZSBvZiB0aGUgd3JpdGVCdWZmZXIgaXMgYmVsb3cgdGhlIG1heFBheWxvYWQgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIChvbmx5IGZvciBIVFRQXG4gICAgICogbG9uZy1wb2xsaW5nKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRXcml0YWJsZVBhY2tldHMoKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENoZWNrUGF5bG9hZFNpemUgPSB0aGlzLm1heFBheWxvYWQgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0Lm5hbWUgPT09IFwicG9sbGluZ1wiICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+IDE7XG4gICAgICAgIGlmICghc2hvdWxkQ2hlY2tQYXlsb2FkU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBheWxvYWRTaXplID0gMTsgLy8gZmlyc3QgcGFja2V0IHR5cGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy53cml0ZUJ1ZmZlcltpXS5kYXRhO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSBieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHBheWxvYWRTaXplID4gdGhpcy5tYXhQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSAyOyAvLyBzZXBhcmF0b3IgKyBwYWNrZXQgdHlwZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICB3cml0ZShtc2csIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZW5kKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBtc2csIG9wdGlvbnMsIGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGU6IHBhY2tldCB0eXBlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGZuKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkYXRhKSB7XG4gICAgICAgICAgICBmbiA9IGRhdGE7XG4gICAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0Q3JlYXRlXCIsIHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJmbHVzaFwiLCBmbik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBBbmRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZVwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRGb3JVcGdyYWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVFcnJvclwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZW1vdmVFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICAgICAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIGJ1ZmZlcnMgYWZ0ZXIsIHNvIHVzZXJzIGNhbiBzdGlsbFxuICAgICAgICAgICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gdXBncmFkZXMgLSBzZXJ2ZXIgdXBncmFkZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZpbHRlclVwZ3JhZGVzKHVwZ3JhZGVzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBqID0gdXBncmFkZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGo7IGkrKykge1xuICAgICAgICAgICAgaWYgKH50aGlzLnRyYW5zcG9ydHMuaW5kZXhPZih1cGdyYWRlc1tpXSkpXG4gICAgICAgICAgICAgICAgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbiAgICB9XG59XG5Tb2NrZXQucHJvdG9jb2wgPSBwcm90b2NvbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/socket.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transport.js":
/*!***************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transport.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Transport\": () => (/* binding */ Transport)\n/* harmony export */ });\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-parser */ \"../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"../node_modules/engine.io-client/build/esm/util.js\");\n\n\n\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_0__.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdEO0FBQ087QUFDTDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0JBQXdCLGlFQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOERBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vdHJhbnNwb3J0LmpzPzE4ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVjb2RlUGFja2V0IH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuY2xhc3MgVHJhbnNwb3J0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVhc29uLCBkZXNjcmlwdGlvbiwgY29udGV4dCkge1xuICAgICAgICBzdXBlcihyZWFzb24pO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICAgICAgICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIHRoZSBlcnJvciBjb250ZXh0XG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25FcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIG5ldyBUcmFuc3BvcnRFcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICB0aGlzLmRvT3BlbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlbmluZ1wiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHRyYW5zcG9ydCB3YXMgc2lsZW50bHkgY2xvc2VkIGluIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgaGFuZGxlclxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIG9wZW5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IGRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZShkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIGRldGFpbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHRyYW5zcG9ydCwgaW4gb3JkZXIgbm90IHRvIGxvc2UgcGFja2V0cyBkdXJpbmcgYW4gdXBncmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvblBhdXNlXG4gICAgICovXG4gICAgcGF1c2Uob25QYXVzZSkgeyB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transport.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transports/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transports/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"transports\": () => (/* binding */ transports)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling.js */ \"../node_modules/engine.io-client/build/esm/transports/polling.js\");\n/* harmony import */ var _websocket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.js */ \"../node_modules/engine.io-client/build/esm/transports/websocket.js\");\n\n\nconst transports = {\n    websocket: _websocket_js__WEBPACK_IMPORTED_MODULE_1__.WS,\n    polling: _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ0g7QUFDN0I7QUFDUCxlQUFlLDZDQUFFO0FBQ2pCLGFBQWEsZ0RBQU87QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvaW5kZXguanM/YjM5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQb2xsaW5nIH0gZnJvbSBcIi4vcG9sbGluZy5qc1wiO1xuaW1wb3J0IHsgV1MgfSBmcm9tIFwiLi93ZWJzb2NrZXQuanNcIjtcbmV4cG9ydCBjb25zdCB0cmFuc3BvcnRzID0ge1xuICAgIHdlYnNvY2tldDogV1MsXG4gICAgcG9sbGluZzogUG9sbGluZyxcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transports/index.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transports/polling.js":
/*!************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transports/polling.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Polling\": () => (/* binding */ Polling),\n/* harmony export */   \"Request\": () => (/* binding */ Request)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"../node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contrib/yeast.js */ \"../node_modules/engine.io-client/build/esm/contrib/yeast.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contrib/parseqs.js */ \"../node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! engine.io-parser */ \"../node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./xmlhttprequest.js */ \"../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../util.js */ \"../node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../globalThis.js */ \"../node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\n\n\n\n\n\n\n\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__.XHR({\n        xdomain: false,\n    });\n    return null != xhr.responseType;\n})();\nclass Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        this.polling = false;\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n            this.xs = opts.secure !== isSSL;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_3__.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_3__.encodePayload)(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        let port = \"\";\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_1__.yeast)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n                (\"http\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.encode)(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(uri, opts) {\n        super();\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.async = false !== opts.async;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    create() {\n        const opts = (0,_util_js__WEBPACK_IMPORTED_MODULE_6__.pick)(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        opts.xscheme = !!this.opts.xs;\n        const xhr = (this.xhr = new _xmlhttprequest_js__WEBPACK_IMPORTED_MODULE_4__.XHR(opts));\n        try {\n            xhr.open(this.method, this.uri, this.async);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this.cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in _globalThis_js__WEBPACK_IMPORTED_MODULE_7__.globalThisShim ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvcG9sbGluZy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ0E7QUFDRztBQUNpQjtBQUNKO0FBQ0w7QUFDRTtBQUNPO0FBQ2hFO0FBQ0E7QUFDQSxvQkFBb0IsbURBQWM7QUFDbEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ00sc0JBQXNCLG9EQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsK0NBQStDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkRBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDhCQUE4QiwwQkFBMEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQixpRUFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw4Q0FBSTtBQUN6QjtBQUNBO0FBQ0Esb0NBQW9DLG1EQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywwRUFBMEI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvcG9sbGluZy5qcz81YTNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnQuanNcIjtcbmltcG9ydCB7IHllYXN0IH0gZnJvbSBcIi4uL2NvbnRyaWIveWVhc3QuanNcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCIuLi9jb250cmliL3BhcnNlcXMuanNcIjtcbmltcG9ydCB7IGVuY29kZVBheWxvYWQsIGRlY29kZVBheWxvYWQgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgWEhSIGFzIFhNTEh0dHBSZXF1ZXN0IH0gZnJvbSBcIi4veG1saHR0cHJlcXVlc3QuanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuaW1wb3J0IHsgaW5zdGFsbFRpbWVyRnVuY3Rpb25zLCBwaWNrIH0gZnJvbSBcIi4uL3V0aWwuanNcIjtcbmltcG9ydCB7IGdsb2JhbFRoaXNTaGltIGFzIGdsb2JhbFRoaXMgfSBmcm9tIFwiLi4vZ2xvYmFsVGhpcy5qc1wiO1xuZnVuY3Rpb24gZW1wdHkoKSB7IH1cbmNvbnN0IGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7XG4gICAgICAgIHhkb21haW46IGZhbHNlLFxuICAgIH0pO1xuICAgIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuZXhwb3J0IGNsYXNzIFBvbGxpbmcgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgc3VwZXIob3B0cyk7XG4gICAgICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1NTTCA9IFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgbGV0IHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuICAgICAgICAgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgICAgICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IGlzU1NMID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueGQgPVxuICAgICAgICAgICAgICAgICh0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICAgICAgICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPT0gaXNTU0w7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZvcmNlQmFzZTY0ID0gb3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0O1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gaGFzWEhSMiAmJiAhZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAgICAgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb09wZW4oKSB7XG4gICAgICAgIHRoaXMucG9sbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgcG9sbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uUGF1c2UgLSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIHBhdXNlKG9uUGF1c2UpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzaW5nXCI7XG4gICAgICAgIGNvbnN0IHBhdXNlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgICAgIG9uUGF1c2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcInBvbGxDb21wbGV0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiZHJhaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBwb2xsKCkge1xuICAgICAgICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRvUG9sbCgpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBvbGxcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgICAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgcGFja2V0LnR5cGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKHsgZGVzY3JpcHRpb246IFwidHJhbnNwb3J0IGNsb3NlZCBieSB0aGUgc2VydmVyXCIgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBkZWNvZGUgcGF5bG9hZFxuICAgICAgICBkZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgICAgICAgICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBvbGxDb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBjb25zdCBjbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoW3sgdHlwZTogXCJjbG9zZVwiIH1dKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgICAgICAgICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICAgICAgICAgIHRoaXMub25jZShcIm9wZW5cIiwgY2xvc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHMgLSBkYXRhIHBhY2tldHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIGVuY29kZVBheWxvYWQocGFja2V0cywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXJpKCkge1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLm9wdHMuc2VjdXJlID8gXCJodHRwc1wiIDogXCJodHRwXCI7XG4gICAgICAgIGxldCBwb3J0ID0gXCJcIjtcbiAgICAgICAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgICAgICAgaWYgKGZhbHNlICE9PSB0aGlzLm9wdHMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgICAgICAgICBxdWVyeS5iNjQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gICAgICAgIGlmICh0aGlzLm9wdHMucG9ydCAmJlxuICAgICAgICAgICAgKChcImh0dHBzXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICAgICAgICAgICAgKFwiaHR0cFwiID09PSBzY2hlbWEgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0KSAhPT0gODApKSkge1xuICAgICAgICAgICAgcG9ydCA9IFwiOlwiICsgdGhpcy5vcHRzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZFF1ZXJ5ID0gZW5jb2RlKHF1ZXJ5KTtcbiAgICAgICAgY29uc3QgaXB2NiA9IHRoaXMub3B0cy5ob3N0bmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiAoc2NoZW1hICtcbiAgICAgICAgICAgIFwiOi8vXCIgK1xuICAgICAgICAgICAgKGlwdjYgPyBcIltcIiArIHRoaXMub3B0cy5ob3N0bmFtZSArIFwiXVwiIDogdGhpcy5vcHRzLmhvc3RuYW1lKSArXG4gICAgICAgICAgICBwb3J0ICtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICtcbiAgICAgICAgICAgIChlbmNvZGVkUXVlcnkubGVuZ3RoID8gXCI/XCIgKyBlbmNvZGVkUXVlcnkgOiBcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVxdWVzdChvcHRzID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB7IHhkOiB0aGlzLnhkLCB4czogdGhpcy54cyB9LCB0aGlzLm9wdHMpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcXVlc3QodGhpcy51cmkoKSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBmbikge1xuICAgICAgICBjb25zdCByZXEgPSB0aGlzLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgICAgICByZXEub24oXCJzdWNjZXNzXCIsIGZuKTtcbiAgICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKHhoclN0YXR1cywgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwieGhyIHBvc3QgZXJyb3JcIiwgeGhyU3RhdHVzLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvUG9sbCgpIHtcbiAgICAgICAgY29uc3QgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gICAgICAgIHJlcS5vbihcImRhdGFcIiwgdGhpcy5vbkRhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHJlcS5vbihcImVycm9yXCIsICh4aHJTdGF0dXMsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInhociBwb2xsIGVycm9yXCIsIHhoclN0YXR1cywgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGxYaHIgPSByZXE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlcXVlc3QgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGluc3RhbGxUaW1lckZ1bmN0aW9ucyh0aGlzLCBvcHRzKTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCBcIkdFVFwiO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICAgICAgICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gICAgICAgIHRoaXMuY3JlYXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBwaWNrKHRoaXMub3B0cywgXCJhZ2VudFwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIsIFwiYXV0b1VucmVmXCIpO1xuICAgICAgICBvcHRzLnhkb21haW4gPSAhIXRoaXMub3B0cy54ZDtcbiAgICAgICAgb3B0cy54c2NoZW1lID0gISF0aGlzLm9wdHMueHM7XG4gICAgICAgIGNvbnN0IHhociA9ICh0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgaW4gdGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5leHRyYUhlYWRlcnMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmIChcIlBPU1RcIiA9PT0gdGhpcy5tZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIiovKlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIC8vIGllNiBjaGVja1xuICAgICAgICAgICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyKSB7XG4gICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMub3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSB0aGlzLm9wdHMucmVxdWVzdFRpbWVvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICg0ICE9PSB4aHIucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICgyMDAgPT09IHhoci5zdGF0dXMgfHwgMTIyMyA9PT0geGhyLnN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKHR5cGVvZiB4aHIuc3RhdHVzID09PSBcIm51bWJlclwiID8geGhyLnN0YXR1cyA6IDApO1xuICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICAgICAgICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkVycm9yKGVycikge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVyciwgdGhpcy54aHIpO1xuICAgICAgICB0aGlzLmNsZWFudXAodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBob3VzZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYW51cChmcm9tRXJyb3IpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICAgICAgICBpZiAoZnJvbUVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBsb2FkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkxvYWQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInN1Y2Nlc3NcIik7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICB9XG59XG5SZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgYXR0YWNoRXZlbnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGF0dGFjaEV2ZW50KFwib251bmxvYWRcIiwgdW5sb2FkSGFuZGxlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgdGVybWluYXRpb25FdmVudCA9IFwib25wYWdlaGlkZVwiIGluIGdsb2JhbFRoaXMgPyBcInBhZ2VoaWRlXCIgOiBcInVubG9hZFwiO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVyKHRlcm1pbmF0aW9uRXZlbnQsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICAgIGZvciAobGV0IGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgICAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transports/polling.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js":
/*!**********************************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WebSocket\": () => (/* binding */ WebSocket),\n/* harmony export */   \"defaultBinaryType\": () => (/* binding */ defaultBinaryType),\n/* harmony export */   \"nextTick\": () => (/* binding */ nextTick),\n/* harmony export */   \"usingBrowserWebSocket\": () => (/* binding */ usingBrowserWebSocket)\n/* harmony export */ });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../globalThis.js */ \"../node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\nconst nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nconst WebSocket = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.WebSocket || _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.MozWebSocket;\nconst usingBrowserWebSocket = true;\nconst defaultBinaryType = \"arraybuffer\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmJyb3dzZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBZ0U7QUFDekQ7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDTSxrQkFBa0Isb0VBQW9CLElBQUksdUVBQXVCO0FBQ2pFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvd2Vic29ja2V0LWNvbnN0cnVjdG9yLmJyb3dzZXIuanM/NjNiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbG9iYWxUaGlzU2hpbSBhcyBnbG9iYWxUaGlzIH0gZnJvbSBcIi4uL2dsb2JhbFRoaXMuanNcIjtcbmV4cG9ydCBjb25zdCBuZXh0VGljayA9ICgoKSA9PiB7XG4gICAgY29uc3QgaXNQcm9taXNlQXZhaWxhYmxlID0gdHlwZW9mIFByb21pc2UgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgUHJvbWlzZS5yZXNvbHZlID09PSBcImZ1bmN0aW9uXCI7XG4gICAgaWYgKGlzUHJvbWlzZUF2YWlsYWJsZSkge1xuICAgICAgICByZXR1cm4gKGNiKSA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoY2IsIHNldFRpbWVvdXRGbikgPT4gc2V0VGltZW91dEZuKGNiLCAwKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0IGNvbnN0IFdlYlNvY2tldCA9IGdsb2JhbFRoaXMuV2ViU29ja2V0IHx8IGdsb2JhbFRoaXMuTW96V2ViU29ja2V0O1xuZXhwb3J0IGNvbnN0IHVzaW5nQnJvd3NlcldlYlNvY2tldCA9IHRydWU7XG5leHBvcnQgY29uc3QgZGVmYXVsdEJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transports/websocket.js":
/*!**************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transports/websocket.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"WS\": () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"../node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contrib/parseqs.js */ \"../node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var _contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contrib/yeast.js */ \"../node_modules/engine.io-client/build/esm/contrib/yeast.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util.js */ \"../node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./websocket-constructor.js */ \"../node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ \"../node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\n\n\n\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass WS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0,_util_js__WEBPACK_IMPORTED_MODULE_3__.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.WebSocket(uri, protocols)\n                        : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.WebSocket(uri)\n                    : new _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType || _websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.defaultBinaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.encodePacket)(packet, this.supportsBinary, (data) => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \n                        // @ts-ignore\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0,_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        let query = this.query || {};\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        let port = \"\";\n        // avoid port if default for schema\n        if (this.opts.port &&\n            ((\"wss\" === schema && Number(this.opts.port) !== 443) ||\n                (\"ws\" === schema && Number(this.opts.port) !== 80))) {\n            port = \":\" + this.opts.port;\n        }\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_contrib_yeast_js__WEBPACK_IMPORTED_MODULE_2__.yeast)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_1__.encode)(query);\n        const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n        return (schema +\n            \"://\" +\n            (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n            port +\n            this.opts.path +\n            (encodedQuery.length ? \"?\" + encodedQuery : \"\"));\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @private\n     */\n    check() {\n        return !!_websocket_constructor_js__WEBPACK_IMPORTED_MODULE_4__.WebSocket;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEM7QUFDRztBQUNIO0FBQ1Y7QUFDMEU7QUFDNUQ7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQkFBaUIsb0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4Q0FBSTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRFQUFxQjtBQUNyQztBQUNBLDhCQUE4QixnRUFBUztBQUN2Qyw4QkFBOEIsZ0VBQVM7QUFDdkMsMEJBQTBCLGdFQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHdFQUFpQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsWUFBWSw4REFBWTtBQUN4QjtBQUNBO0FBQ0EscUJBQXFCLDRFQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0RUFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFRO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0RBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyREFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdFQUFTO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzP2E1MDkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydC5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIi4uL2NvbnRyaWIvcGFyc2Vxcy5qc1wiO1xuaW1wb3J0IHsgeWVhc3QgfSBmcm9tIFwiLi4vY29udHJpYi95ZWFzdC5qc1wiO1xuaW1wb3J0IHsgcGljayB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0QmluYXJ5VHlwZSwgbmV4dFRpY2ssIHVzaW5nQnJvd3NlcldlYlNvY2tldCwgV2ViU29ja2V0LCB9IGZyb20gXCIuL3dlYnNvY2tldC1jb25zdHJ1Y3Rvci5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlUGFja2V0IH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbi8vIGRldGVjdCBSZWFjdE5hdGl2ZSBlbnZpcm9ubWVudFxuY29uc3QgaXNSZWFjdE5hdGl2ZSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT09IFwic3RyaW5nXCIgJiZcbiAgICBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSBcInJlYWN0bmF0aXZlXCI7XG5leHBvcnQgY2xhc3MgV1MgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIGNvbm5lY3Rpb24gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIW9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgICAgICAgICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSB0aGlzLnVyaSgpO1xuICAgICAgICBjb25zdCBwcm90b2NvbHMgPSB0aGlzLm9wdHMucHJvdG9jb2xzO1xuICAgICAgICAvLyBSZWFjdCBOYXRpdmUgb25seSBzdXBwb3J0cyB0aGUgJ2hlYWRlcnMnIG9wdGlvbiwgYW5kIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIGFueXRoaW5nIGVsc2UgaXMgcGFzc2VkXG4gICAgICAgIGNvbnN0IG9wdHMgPSBpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICA6IHBpY2sodGhpcy5vcHRzLCBcImFnZW50XCIsIFwicGVyTWVzc2FnZURlZmxhdGVcIiwgXCJwZnhcIiwgXCJrZXlcIiwgXCJwYXNzcGhyYXNlXCIsIFwiY2VydFwiLCBcImNhXCIsIFwiY2lwaGVyc1wiLCBcInJlamVjdFVuYXV0aG9yaXplZFwiLCBcImxvY2FsQWRkcmVzc1wiLCBcInByb3RvY29sVmVyc2lvblwiLCBcIm9yaWdpblwiLCBcIm1heFBheWxvYWRcIiwgXCJmYW1pbHlcIiwgXCJjaGVja1NlcnZlcklkZW50aXR5XCIpO1xuICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0gdGhpcy5vcHRzLmV4dHJhSGVhZGVycztcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy53cyA9XG4gICAgICAgICAgICAgICAgdXNpbmdCcm93c2VyV2ViU29ja2V0ICYmICFpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICAgICAgICAgID8gcHJvdG9jb2xzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXQodXJpKVxuICAgICAgICAgICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSB8fCBkZWZhdWx0QmluYXJ5VHlwZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cy5fc29ja2V0LnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoY2xvc2VFdmVudCkgPT4gdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIndlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogY2xvc2VFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLm9uRGF0YShldi5kYXRhKTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKGUpID0+IHRoaXMub25FcnJvcihcIndlYnNvY2tldCBlcnJvclwiLCBlKTtcbiAgICB9XG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gICAgICAgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZSBhIG5ldyBvYmplY3QgKEdILTQzNylcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCF1c2luZ0Jyb3dzZXJXZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuID0gXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuIDwgdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAgICAgICAgICAgLy8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodXNpbmdCcm93c2VyV2ViU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlRXJyb3IgaXMgdGhyb3duIHdoZW4gcGFzc2luZyB0aGUgc2Vjb25kIGFyZ3VtZW50IG9uIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cy5zZW5kKGRhdGEsIG9wdHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZha2UgZHJhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgbGV0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICAgIGxldCBwb3J0ID0gXCJcIjtcbiAgICAgICAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgICAgICAgaWYgKHRoaXMub3B0cy5wb3J0ICYmXG4gICAgICAgICAgICAoKFwid3NzXCIgPT09IHNjaGVtYSAmJiBOdW1iZXIodGhpcy5vcHRzLnBvcnQpICE9PSA0NDMpIHx8XG4gICAgICAgICAgICAgICAgKFwid3NcIiA9PT0gc2NoZW1hICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCkgIT09IDgwKSkpIHtcbiAgICAgICAgICAgIHBvcnQgPSBcIjpcIiArIHRoaXMub3B0cy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gICAgICAgIGlmICh0aGlzLm9wdHMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICAgICAgICAgIHF1ZXJ5W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RlZFF1ZXJ5ID0gZW5jb2RlKHF1ZXJ5KTtcbiAgICAgICAgY29uc3QgaXB2NiA9IHRoaXMub3B0cy5ob3N0bmFtZS5pbmRleE9mKFwiOlwiKSAhPT0gLTE7XG4gICAgICAgIHJldHVybiAoc2NoZW1hICtcbiAgICAgICAgICAgIFwiOi8vXCIgK1xuICAgICAgICAgICAgKGlwdjYgPyBcIltcIiArIHRoaXMub3B0cy5ob3N0bmFtZSArIFwiXVwiIDogdGhpcy5vcHRzLmhvc3RuYW1lKSArXG4gICAgICAgICAgICBwb3J0ICtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICtcbiAgICAgICAgICAgIChlbmNvZGVkUXVlcnkubGVuZ3RoID8gXCI/XCIgKyBlbmNvZGVkUXVlcnkgOiBcIlwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICByZXR1cm4gISFXZWJTb2NrZXQ7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transports/websocket.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js":
/*!***************************************************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"XHR\": () => (/* binding */ XHR)\n/* harmony export */ });\n/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contrib/has-cors.js */ \"../node_modules/engine.io-client/build/esm/contrib/has-cors.js\");\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globalThis.js */ \"../node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n// browser shim for xmlhttprequest module\n\n\nfunction XHR(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_0__.hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new _globalThis_js__WEBPACK_IMPORTED_MODULE_1__.globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3RyYW5zcG9ydHMveG1saHR0cHJlcXVlc3QuYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNpRDtBQUNlO0FBQ3pEO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHlEQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9idWlsZC9lc20vdHJhbnNwb3J0cy94bWxodHRwcmVxdWVzdC5icm93c2VyLmpzPzRmM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbmltcG9ydCB7IGhhc0NPUlMgfSBmcm9tIFwiLi4vY29udHJpYi9oYXMtY29ycy5qc1wiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcyB9IGZyb20gXCIuLi9nbG9iYWxUaGlzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gWEhSKG9wdHMpIHtcbiAgICBjb25zdCB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICAgIHRyeSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmICgheGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzW1tcIkFjdGl2ZVwiXS5jb25jYXQoXCJPYmplY3RcIikuam9pbihcIlhcIildKFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js\n");

/***/ }),

/***/ "../node_modules/engine.io-client/build/esm/util.js":
/*!**********************************************************!*\
  !*** ../node_modules/engine.io-client/build/esm/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"byteLength\": () => (/* binding */ byteLength),\n/* harmony export */   \"installTimerFunctions\": () => (/* binding */ installTimerFunctions),\n/* harmony export */   \"pick\": () => (/* binding */ pick)\n/* harmony export */ });\n/* harmony import */ var _globalThis_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globalThis.js */ \"../node_modules/engine.io-client/build/esm/globalThis.browser.js\");\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n    else {\n        obj.setTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = _globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout.bind(_globalThis_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvYnVpbGQvZXNtL3V0aWwuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRDtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCLHFFQUFxQjtBQUNoRCw2QkFBNkIsdUVBQXVCO0FBQzdDO0FBQ1A7QUFDQSxtREFBbUQsMERBQVU7QUFDN0QsdURBQXVELDBEQUFVO0FBQ2pFO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQTBCLENBQUMsMERBQVU7QUFDaEUsNkJBQTZCLDRFQUE0QixDQUFDLDBEQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS91dGlsLmpzPzZkZDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcyB9IGZyb20gXCIuL2dsb2JhbFRoaXMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBwaWNrKG9iaiwgLi4uYXR0cikge1xuICAgIHJldHVybiBhdHRyLnJlZHVjZSgoYWNjLCBrKSA9PiB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGFjY1trXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbn1cbi8vIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHJlYWwgdGltZW91dCBmdW5jdGlvbnMgc28gdGhleSBjYW4gYmUgdXNlZCB3aGVuIG92ZXJyaWRkZW5cbmNvbnN0IE5BVElWRV9TRVRfVElNRU9VVCA9IGdsb2JhbFRoaXMuc2V0VGltZW91dDtcbmNvbnN0IE5BVElWRV9DTEVBUl9USU1FT1VUID0gZ2xvYmFsVGhpcy5jbGVhclRpbWVvdXQ7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbFRpbWVyRnVuY3Rpb25zKG9iaiwgb3B0cykge1xuICAgIGlmIChvcHRzLnVzZU5hdGl2ZVRpbWVycykge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gTkFUSVZFX1NFVF9USU1FT1VULmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgICAgIG9iai5jbGVhclRpbWVvdXRGbiA9IE5BVElWRV9DTEVBUl9USU1FT1VULmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmouc2V0VGltZW91dEZuID0gZ2xvYmFsVGhpcy5zZXRUaW1lb3V0LmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgICAgIG9iai5jbGVhclRpbWVvdXRGbiA9IGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0LmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgfVxufVxuLy8gYmFzZTY0IGVuY29kZWQgYnVmZmVycyBhcmUgYWJvdXQgMzMlIGJpZ2dlciAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0KVxuY29uc3QgQkFTRTY0X09WRVJIRUFEID0gMS4zMztcbi8vIHdlIGNvdWxkIGFsc28gaGF2ZSB1c2VkIGBuZXcgQmxvYihbb2JqXSkuc2l6ZWAsIGJ1dCBpdCBpc24ndCBzdXBwb3J0ZWQgaW4gSUU5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZUxlbmd0aChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXRmOExlbmd0aChvYmopO1xuICAgIH1cbiAgICAvLyBhcnJheWJ1ZmZlciBvciBibG9iXG4gICAgcmV0dXJuIE1hdGguY2VpbCgob2JqLmJ5dGVMZW5ndGggfHwgb2JqLnNpemUpICogQkFTRTY0X09WRVJIRUFEKTtcbn1cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgoc3RyKSB7XG4gICAgbGV0IGMgPSAwLCBsZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ODAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHhkODAwIHx8IGMgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gMztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGxlbmd0aCArPSA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW5ndGg7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-client/build/esm/util.js\n");

/***/ }),

/***/ "../node_modules/engine.io-parser/build/esm/commons.js":
/*!*************************************************************!*\
  !*** ../node_modules/engine.io-parser/build/esm/commons.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ERROR_PACKET\": () => (/* binding */ ERROR_PACKET),\n/* harmony export */   \"PACKET_TYPES\": () => (/* binding */ PACKET_TYPES),\n/* harmony export */   \"PACKET_TYPES_REVERSE\": () => (/* binding */ PACKET_TYPES_REVERSE)\n/* harmony export */ });\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2NvbW1vbnMuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUNxQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9lc20vY29tbW9ucy5qcz82NTU4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBBQ0tFVF9UWVBFUyA9IE9iamVjdC5jcmVhdGUobnVsbCk7IC8vIG5vIE1hcCA9IG5vIHBvbHlmaWxsXG5QQUNLRVRfVFlQRVNbXCJvcGVuXCJdID0gXCIwXCI7XG5QQUNLRVRfVFlQRVNbXCJjbG9zZVwiXSA9IFwiMVwiO1xuUEFDS0VUX1RZUEVTW1wicGluZ1wiXSA9IFwiMlwiO1xuUEFDS0VUX1RZUEVTW1wicG9uZ1wiXSA9IFwiM1wiO1xuUEFDS0VUX1RZUEVTW1wibWVzc2FnZVwiXSA9IFwiNFwiO1xuUEFDS0VUX1RZUEVTW1widXBncmFkZVwiXSA9IFwiNVwiO1xuUEFDS0VUX1RZUEVTW1wibm9vcFwiXSA9IFwiNlwiO1xuY29uc3QgUEFDS0VUX1RZUEVTX1JFVkVSU0UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuT2JqZWN0LmtleXMoUEFDS0VUX1RZUEVTKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgUEFDS0VUX1RZUEVTX1JFVkVSU0VbUEFDS0VUX1RZUEVTW2tleV1dID0ga2V5O1xufSk7XG5jb25zdCBFUlJPUl9QQUNLRVQgPSB7IHR5cGU6IFwiZXJyb3JcIiwgZGF0YTogXCJwYXJzZXIgZXJyb3JcIiB9O1xuZXhwb3J0IHsgUEFDS0VUX1RZUEVTLCBQQUNLRVRfVFlQRVNfUkVWRVJTRSwgRVJST1JfUEFDS0VUIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-parser/build/esm/commons.js\n");

/***/ }),

/***/ "../node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js":
/*!********************************************************************************!*\
  !*** ../node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decode\": () => (/* binding */ decode),\n/* harmony export */   \"encode\": () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nconst encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nconst decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2NvbnRyaWIvYmFzZTY0LWFycmF5YnVmZmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9lc20vY29udHJpYi9iYXNlNjQtYXJyYXlidWZmZXIuanM/NWU3MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9iYXNlNjQtYXJyYXlidWZmZXJcbmNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuY29uc3QgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGFycmF5YnVmZmVyKSA9PiB7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gKGJhc2U2NCkgPT4ge1xuICAgIGxldCBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSwgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js\n");

/***/ }),

/***/ "../node_modules/engine.io-parser/build/esm/decodePacket.browser.js":
/*!**************************************************************************!*\
  !*** ../node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ \"../node_modules/engine.io-parser/build/esm/commons.js\");\n/* harmony import */ var _contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contrib/base64-arraybuffer.js */ \"../node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js\");\n\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return _commons_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0,_contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (decodePacket);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2RlY29kZVBhY2tldC5icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrRTtBQUNUO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw2REFBb0I7QUFDM0M7QUFDQSxlQUFlLHFEQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZEQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzRUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlFQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9lc20vZGVjb2RlUGFja2V0LmJyb3dzZXIuanM/YTkyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFUlJPUl9QQUNLRVQsIFBBQ0tFVF9UWVBFU19SRVZFUlNFIH0gZnJvbSBcIi4vY29tbW9ucy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlIH0gZnJvbSBcIi4vY29udHJpYi9iYXNlNjQtYXJyYXlidWZmZXIuanNcIjtcbmNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgZGVjb2RlUGFja2V0ID0gKGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogbWFwQmluYXJ5KGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBlbmNvZGVkUGFja2V0LmNoYXJBdCgwKTtcbiAgICBpZiAodHlwZSA9PT0gXCJiXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogZGVjb2RlQmFzZTY0UGFja2V0KGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpLCBiaW5hcnlUeXBlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYWNrZXRUeXBlID0gUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV07XG4gICAgaWYgKCFwYWNrZXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBFUlJPUl9QQUNLRVQ7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkUGFja2V0Lmxlbmd0aCA+IDFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBQQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXSxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICB0eXBlOiBQQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXVxuICAgICAgICB9O1xufTtcbmNvbnN0IGRlY29kZUJhc2U2NFBhY2tldCA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlcikge1xuICAgICAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlKGRhdGEpO1xuICAgICAgICByZXR1cm4gbWFwQmluYXJ5KGRlY29kZWQsIGJpbmFyeVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgYmFzZTY0OiB0cnVlLCBkYXRhIH07IC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnNcbiAgICB9XG59O1xuY29uc3QgbWFwQmluYXJ5ID0gKGRhdGEsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBzd2l0Y2ggKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgQmxvYihbZGF0YV0pIDogZGF0YTtcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGF0YTsgLy8gYXNzdW1pbmcgdGhlIGRhdGEgaXMgYWxyZWFkeSBhbiBBcnJheUJ1ZmZlclxuICAgIH1cbn07XG5leHBvcnQgZGVmYXVsdCBkZWNvZGVQYWNrZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-parser/build/esm/decodePacket.browser.js\n");

/***/ }),

/***/ "../node_modules/engine.io-parser/build/esm/encodePacket.browser.js":
/*!**************************************************************************!*\
  !*** ../node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ \"../node_modules/engine.io-parser/build/esm/commons.js\");\n\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encodePacket);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2VuY29kZVBhY2tldC5icm93c2VyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9lc20vZW5jb2RlUGFja2V0LmJyb3dzZXIuanM/OWFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQQUNLRVRfVFlQRVMgfSBmcm9tIFwiLi9jb21tb25zLmpzXCI7XG5jb25zdCB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiKTtcbmNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuLy8gQXJyYXlCdWZmZXIuaXNWaWV3IG1ldGhvZCBpcyBub3QgZGVmaW5lZCBpbiBJRTEwXG5jb25zdCBpc1ZpZXcgPSBvYmogPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuY29uc3QgZW5jb2RlUGFja2V0ID0gKHsgdHlwZSwgZGF0YSB9LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAod2l0aE5hdGl2ZUJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiZcbiAgICAgICAgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcoZGF0YSkpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChuZXcgQmxvYihbZGF0YV0pLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgcmV0dXJuIGNhbGxiYWNrKFBBQ0tFVF9UWVBFU1t0eXBlXSArIChkYXRhIHx8IFwiXCIpKTtcbn07XG5jb25zdCBlbmNvZGVCbG9iQXNCYXNlNjQgPSAoZGF0YSwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICAgICAgY2FsbGJhY2soXCJiXCIgKyAoY29udGVudCB8fCBcIlwiKSk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGRhdGEpO1xufTtcbmV4cG9ydCBkZWZhdWx0IGVuY29kZVBhY2tldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/engine.io-parser/build/esm/encodePacket.browser.js\n");

/***/ }),

/***/ "../node_modules/engine.io-parser/build/esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/engine.io-parser/build/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"decodePacket\": () => (/* reexport safe */ _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   \"decodePayload\": () => (/* binding */ decodePayload),\n/* harmony export */   \"encodePacket\": () => (/* reexport safe */ _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   \"encodePayload\": () => (/* binding */ encodePayload),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encodePacket.js */ \"../node_modules/engine.io-parser/build/esm/encodePacket.browser.js\");\n/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decodePacket.js */ \"../node_modules/engine.io-parser/build/esm/decodePacket.browser.js\");\n\n\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nconst protocol = 4;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkM7QUFDQTtBQUM3QywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0MsOEJBQThCLDREQUFZO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDNkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvZXNtL2luZGV4LmpzP2IwYjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGVuY29kZVBhY2tldCBmcm9tIFwiLi9lbmNvZGVQYWNrZXQuanNcIjtcbmltcG9ydCBkZWNvZGVQYWNrZXQgZnJvbSBcIi4vZGVjb2RlUGFja2V0LmpzXCI7XG5jb25zdCBTRVBBUkFUT1IgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgZW5jb2RlUGF5bG9hZCA9IChwYWNrZXRzLCBjYWxsYmFjaykgPT4ge1xuICAgIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoO1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBwYWNrZXRzLmZvckVhY2goKHBhY2tldCwgaSkgPT4ge1xuICAgICAgICAvLyBmb3JjZSBiYXNlNjQgZW5jb2RpbmcgZm9yIGJpbmFyeSBwYWNrZXRzXG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIGZhbHNlLCBlbmNvZGVkUGFja2V0ID0+IHtcbiAgICAgICAgICAgIGVuY29kZWRQYWNrZXRzW2ldID0gZW5jb2RlZFBhY2tldDtcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbmNvZGVkUGFja2V0cy5qb2luKFNFUEFSQVRPUikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCBkZWNvZGVQYXlsb2FkID0gKGVuY29kZWRQYXlsb2FkLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBlbmNvZGVkUGF5bG9hZC5zcGxpdChTRVBBUkFUT1IpO1xuICAgIGNvbnN0IHBhY2tldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRQYWNrZXQgPSBkZWNvZGVQYWNrZXQoZW5jb2RlZFBhY2tldHNbaV0sIGJpbmFyeVR5cGUpO1xuICAgICAgICBwYWNrZXRzLnB1c2goZGVjb2RlZFBhY2tldCk7XG4gICAgICAgIGlmIChkZWNvZGVkUGFja2V0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhY2tldHM7XG59O1xuZXhwb3J0IGNvbnN0IHByb3RvY29sID0gNDtcbmV4cG9ydCB7IGVuY29kZVBhY2tldCwgZW5jb2RlUGF5bG9hZCwgZGVjb2RlUGFja2V0LCBkZWNvZGVQYXlsb2FkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/engine.io-parser/build/esm/index.js\n");

/***/ }),

/***/ "../node_modules/lib0/array.js":
/*!*************************************!*\
  !*** ../node_modules/lib0/array.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"appendTo\": () => (/* binding */ appendTo),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"equalFlat\": () => (/* binding */ equalFlat),\n/* harmony export */   \"every\": () => (/* binding */ every),\n/* harmony export */   \"flatten\": () => (/* binding */ flatten),\n/* harmony export */   \"fold\": () => (/* binding */ fold),\n/* harmony export */   \"from\": () => (/* binding */ from),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"last\": () => (/* binding */ last),\n/* harmony export */   \"some\": () => (/* binding */ some),\n/* harmony export */   \"unfold\": () => (/* binding */ unfold),\n/* harmony export */   \"unique\": () => (/* binding */ unique),\n/* harmony export */   \"uniqueBy\": () => (/* binding */ uniqueBy)\n/* harmony export */ });\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./set.js */ \"../node_modules/lib0/set.js\");\n/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {ArrayLike<L>} arr\n * @return {L}\n */\nconst last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nconst create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nconst copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nconst appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nconst from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n * @template {ArrayLike<ITEM>} ARR\n *\n * @param {ARR} arr\n * @param {function(ITEM, number, ARR):boolean} f\n * @return {boolean}\n */\nconst every = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (!f(arr[i], i, arr)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @template {ArrayLike<S>} ARR\n * @param {ARR} arr\n * @param {function(S, number, ARR):boolean} f\n * @return {boolean}\n */\nconst some = (arr, f) => {\n  for (let i = 0; i < arr.length; i++) {\n    if (f(arr[i], i, arr)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @template ELEM\n *\n * @param {ArrayLike<ELEM>} a\n * @param {ArrayLike<ELEM>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nconst flatten = arr => fold(arr, /** @type {Array<ELEM>} */ ([]), (acc, val) => acc.concat(val))\n\n/**\n * @template T\n * @param {number} len\n * @param {function(number, Array<T>):T} f\n * @return {Array<T>}\n */\nconst unfold = (len, f) => {\n  const array = new Array(len)\n  for (let i = 0; i < len; i++) {\n    array[i] = f(i, array)\n  }\n  return array\n}\n\n/**\n * @template T\n * @template RESULT\n * @param {Array<T>} arr\n * @param {RESULT} seed\n * @param {function(RESULT, T, number):RESULT} folder\n */\nconst fold = (arr, seed, folder) => arr.reduce(folder, seed)\n\nconst isArray = Array.isArray\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {Array<T>}\n */\nconst unique = arr => from(_set_js__WEBPACK_IMPORTED_MODULE_0__.from(arr))\n\n/**\n * @template T\n * @template M\n * @param {ArrayLike<T>} arr\n * @param {function(T):M} mapper\n * @return {Array<T>}\n */\nconst uniqueBy = (arr, mapper) => {\n  /**\n   * @type {Set<M>}\n   */\n  const happened = _set_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  /**\n   * @type {Array<T>}\n   */\n  const result = []\n  for (let i = 0; i < arr.length; i++) {\n    const el = arr[i]\n    const mapped = mapper(el)\n    if (!happened.has(mapped)) {\n      happened.add(mapped)\n      result.push(el)\n    }\n  }\n  return result\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvYXJyYXkuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTyxnQ0FBZ0MsVUFBVTs7QUFFakQ7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDTyw2QkFBNkIsVUFBVTs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ087QUFDUCxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQkFBMEI7QUFDckMsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUNBQXFDO0FBQ2hELFlBQVk7QUFDWjtBQUNPO0FBQ1Asa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QixXQUFXLEtBQUs7QUFDaEIsV0FBVyxrQ0FBa0M7QUFDN0MsWUFBWTtBQUNaO0FBQ087QUFDUCxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsWUFBWTtBQUNaO0FBQ08sNENBQTRDLGFBQWE7O0FBRWhFO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyw4QkFBOEI7QUFDekMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxvQ0FBb0M7QUFDL0M7QUFDTzs7QUFFQTs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjtBQUNPLDJCQUEyQix5Q0FBUTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsbUJBQW1CLDJDQUFVO0FBQzdCO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcz83NTEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEFycmF5cy5cbiAqXG4gKiBAbW9kdWxlIGFycmF5XG4gKi9cblxuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBUaGUgZWxlbWVudCBtdXN0IGV4aXN0XG4gKlxuICogQHRlbXBsYXRlIExcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPEw+fSBhcnJcbiAqIEByZXR1cm4ge0x9XG4gKi9cbmV4cG9ydCBjb25zdCBsYXN0ID0gYXJyID0+IGFyclthcnIubGVuZ3RoIC0gMV1cblxuLyoqXG4gKiBAdGVtcGxhdGUgQ1xuICogQHJldHVybiB7QXJyYXk8Qz59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiAvKiogQHR5cGUge0FycmF5PEM+fSAqLyAoW10pXG5cbi8qKlxuICogQHRlbXBsYXRlIERcbiAqIEBwYXJhbSB7QXJyYXk8RD59IGFcbiAqIEByZXR1cm4ge0FycmF5PEQ+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IGEgPT4gLyoqIEB0eXBlIHtBcnJheTxEPn0gKi8gKGEuc2xpY2UoKSlcblxuLyoqXG4gKiBBcHBlbmQgZWxlbWVudHMgZnJvbSBzcmMgdG8gZGVzdFxuICpcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5PE0+fSBkZXN0XG4gKiBAcGFyYW0ge0FycmF5PE0+fSBzcmNcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZFRvID0gKGRlc3QsIHNyYykgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QucHVzaChzcmNbaV0pXG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHNvbWV0aGluZyBhcnJheS1saWtlIHRvIGFuIGFjdHVhbCBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPnxJdGVyYWJsZTxUPn0gYXJyYXlsaWtlXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9IEFycmF5LmZyb21cblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gZXZlcnkgZWxlbWVudCBpbiB0aGUgQXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgSVRFTVxuICogQHRlbXBsYXRlIHtBcnJheUxpa2U8SVRFTT59IEFSUlxuICpcbiAqIEBwYXJhbSB7QVJSfSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSVRFTSwgbnVtYmVyLCBBUlIpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBldmVyeSA9IChhcnIsIGYpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWYoYXJyW2ldLCBpLCBhcnIpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBUcnVlIGlmZiBjb25kaXRpb24gaG9sZHMgb24gc29tZSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBTXG4gKiBAdGVtcGxhdGUge0FycmF5TGlrZTxTPn0gQVJSXG4gKiBAcGFyYW0ge0FSUn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFMsIG51bWJlciwgQVJSKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3Qgc29tZSA9IChhcnIsIGYpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFTEVNXG4gKlxuICogQHBhcmFtIHtBcnJheUxpa2U8RUxFTT59IGFcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPEVMRU0+fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxGbGF0ID0gKGEsIGIpID0+IGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBldmVyeShhLCAoaXRlbSwgaW5kZXgpID0+IGl0ZW0gPT09IGJbaW5kZXhdKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFTEVNXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEVMRU0+Pn0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheTxFTEVNPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGZsYXR0ZW4gPSBhcnIgPT4gZm9sZChhcnIsIC8qKiBAdHlwZSB7QXJyYXk8RUxFTT59ICovIChbXSksIChhY2MsIHZhbCkgPT4gYWNjLmNvbmNhdCh2YWwpKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgQXJyYXk8VD4pOlR9IGZcbiAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICovXG5leHBvcnQgY29uc3QgdW5mb2xkID0gKGxlbiwgZikgPT4ge1xuICBjb25zdCBhcnJheSA9IG5ldyBBcnJheShsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGYoaSwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIGFycmF5XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBSRVNVTFRcbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFyclxuICogQHBhcmFtIHtSRVNVTFR9IHNlZWRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUkVTVUxULCBULCBudW1iZXIpOlJFU1VMVH0gZm9sZGVyXG4gKi9cbmV4cG9ydCBjb25zdCBmb2xkID0gKGFyciwgc2VlZCwgZm9sZGVyKSA9PiBhcnIucmVkdWNlKGZvbGRlciwgc2VlZClcblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXk8VD59IGFyclxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmlxdWUgPSBhcnIgPT4gZnJvbShzZXQuZnJvbShhcnIpKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdGVtcGxhdGUgTVxuICogQHBhcmFtIHtBcnJheUxpa2U8VD59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpNfSBtYXBwZXJcbiAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICovXG5leHBvcnQgY29uc3QgdW5pcXVlQnkgPSAoYXJyLCBtYXBwZXIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtTZXQ8TT59XG4gICAqL1xuICBjb25zdCBoYXBwZW5lZCA9IHNldC5jcmVhdGUoKVxuICAvKipcbiAgICogQHR5cGUge0FycmF5PFQ+fVxuICAgKi9cbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbCA9IGFycltpXVxuICAgIGNvbnN0IG1hcHBlZCA9IG1hcHBlcihlbClcbiAgICBpZiAoIWhhcHBlbmVkLmhhcyhtYXBwZWQpKSB7XG4gICAgICBoYXBwZW5lZC5hZGQobWFwcGVkKVxuICAgICAgcmVzdWx0LnB1c2goZWwpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/array.js\n");

/***/ }),

/***/ "../node_modules/lib0/binary.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/binary.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BIT1\": () => (/* binding */ BIT1),\n/* harmony export */   \"BIT10\": () => (/* binding */ BIT10),\n/* harmony export */   \"BIT11\": () => (/* binding */ BIT11),\n/* harmony export */   \"BIT12\": () => (/* binding */ BIT12),\n/* harmony export */   \"BIT13\": () => (/* binding */ BIT13),\n/* harmony export */   \"BIT14\": () => (/* binding */ BIT14),\n/* harmony export */   \"BIT15\": () => (/* binding */ BIT15),\n/* harmony export */   \"BIT16\": () => (/* binding */ BIT16),\n/* harmony export */   \"BIT17\": () => (/* binding */ BIT17),\n/* harmony export */   \"BIT18\": () => (/* binding */ BIT18),\n/* harmony export */   \"BIT19\": () => (/* binding */ BIT19),\n/* harmony export */   \"BIT2\": () => (/* binding */ BIT2),\n/* harmony export */   \"BIT20\": () => (/* binding */ BIT20),\n/* harmony export */   \"BIT21\": () => (/* binding */ BIT21),\n/* harmony export */   \"BIT22\": () => (/* binding */ BIT22),\n/* harmony export */   \"BIT23\": () => (/* binding */ BIT23),\n/* harmony export */   \"BIT24\": () => (/* binding */ BIT24),\n/* harmony export */   \"BIT25\": () => (/* binding */ BIT25),\n/* harmony export */   \"BIT26\": () => (/* binding */ BIT26),\n/* harmony export */   \"BIT27\": () => (/* binding */ BIT27),\n/* harmony export */   \"BIT28\": () => (/* binding */ BIT28),\n/* harmony export */   \"BIT29\": () => (/* binding */ BIT29),\n/* harmony export */   \"BIT3\": () => (/* binding */ BIT3),\n/* harmony export */   \"BIT30\": () => (/* binding */ BIT30),\n/* harmony export */   \"BIT31\": () => (/* binding */ BIT31),\n/* harmony export */   \"BIT32\": () => (/* binding */ BIT32),\n/* harmony export */   \"BIT4\": () => (/* binding */ BIT4),\n/* harmony export */   \"BIT5\": () => (/* binding */ BIT5),\n/* harmony export */   \"BIT6\": () => (/* binding */ BIT6),\n/* harmony export */   \"BIT7\": () => (/* binding */ BIT7),\n/* harmony export */   \"BIT8\": () => (/* binding */ BIT8),\n/* harmony export */   \"BIT9\": () => (/* binding */ BIT9),\n/* harmony export */   \"BITS0\": () => (/* binding */ BITS0),\n/* harmony export */   \"BITS1\": () => (/* binding */ BITS1),\n/* harmony export */   \"BITS10\": () => (/* binding */ BITS10),\n/* harmony export */   \"BITS11\": () => (/* binding */ BITS11),\n/* harmony export */   \"BITS12\": () => (/* binding */ BITS12),\n/* harmony export */   \"BITS13\": () => (/* binding */ BITS13),\n/* harmony export */   \"BITS14\": () => (/* binding */ BITS14),\n/* harmony export */   \"BITS15\": () => (/* binding */ BITS15),\n/* harmony export */   \"BITS16\": () => (/* binding */ BITS16),\n/* harmony export */   \"BITS17\": () => (/* binding */ BITS17),\n/* harmony export */   \"BITS18\": () => (/* binding */ BITS18),\n/* harmony export */   \"BITS19\": () => (/* binding */ BITS19),\n/* harmony export */   \"BITS2\": () => (/* binding */ BITS2),\n/* harmony export */   \"BITS20\": () => (/* binding */ BITS20),\n/* harmony export */   \"BITS21\": () => (/* binding */ BITS21),\n/* harmony export */   \"BITS22\": () => (/* binding */ BITS22),\n/* harmony export */   \"BITS23\": () => (/* binding */ BITS23),\n/* harmony export */   \"BITS24\": () => (/* binding */ BITS24),\n/* harmony export */   \"BITS25\": () => (/* binding */ BITS25),\n/* harmony export */   \"BITS26\": () => (/* binding */ BITS26),\n/* harmony export */   \"BITS27\": () => (/* binding */ BITS27),\n/* harmony export */   \"BITS28\": () => (/* binding */ BITS28),\n/* harmony export */   \"BITS29\": () => (/* binding */ BITS29),\n/* harmony export */   \"BITS3\": () => (/* binding */ BITS3),\n/* harmony export */   \"BITS30\": () => (/* binding */ BITS30),\n/* harmony export */   \"BITS31\": () => (/* binding */ BITS31),\n/* harmony export */   \"BITS32\": () => (/* binding */ BITS32),\n/* harmony export */   \"BITS4\": () => (/* binding */ BITS4),\n/* harmony export */   \"BITS5\": () => (/* binding */ BITS5),\n/* harmony export */   \"BITS6\": () => (/* binding */ BITS6),\n/* harmony export */   \"BITS7\": () => (/* binding */ BITS7),\n/* harmony export */   \"BITS8\": () => (/* binding */ BITS8),\n/* harmony export */   \"BITS9\": () => (/* binding */ BITS9)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nconst BIT1 = 1\nconst BIT2 = 2\nconst BIT3 = 4\nconst BIT4 = 8\nconst BIT5 = 16\nconst BIT6 = 32\nconst BIT7 = 64\nconst BIT8 = 128\nconst BIT9 = 256\nconst BIT10 = 512\nconst BIT11 = 1024\nconst BIT12 = 2048\nconst BIT13 = 4096\nconst BIT14 = 8192\nconst BIT15 = 16384\nconst BIT16 = 32768\nconst BIT17 = 65536\nconst BIT18 = 1 << 17\nconst BIT19 = 1 << 18\nconst BIT20 = 1 << 19\nconst BIT21 = 1 << 20\nconst BIT22 = 1 << 21\nconst BIT23 = 1 << 22\nconst BIT24 = 1 << 23\nconst BIT25 = 1 << 24\nconst BIT26 = 1 << 25\nconst BIT27 = 1 << 26\nconst BIT28 = 1 << 27\nconst BIT29 = 1 << 28\nconst BIT30 = 1 << 29\nconst BIT31 = 1 << 30\nconst BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nconst BITS0 = 0\nconst BITS1 = 1\nconst BITS2 = 3\nconst BITS3 = 7\nconst BITS4 = 15\nconst BITS5 = 31\nconst BITS6 = 63\nconst BITS7 = 127\nconst BITS8 = 255\nconst BITS9 = 511\nconst BITS10 = 1023\nconst BITS11 = 2047\nconst BITS12 = 4095\nconst BITS13 = 8191\nconst BITS14 = 16383\nconst BITS15 = 32767\nconst BITS16 = 65535\nconst BITS17 = BIT18 - 1\nconst BITS18 = BIT19 - 1\nconst BITS19 = BIT20 - 1\nconst BITS20 = BIT21 - 1\nconst BITS21 = BIT22 - 1\nconst BITS22 = BIT23 - 1\nconst BITS23 = BIT24 - 1\nconst BITS24 = BIT25 - 1\nconst BITS25 = BIT26 - 1\nconst BITS26 = BIT27 - 1\nconst BITS27 = BIT28 - 1\nconst BITS28 = BIT29 - 1\nconst BITS29 = BIT30 - 1\nconst BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nconst BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nconst BITS32 = 0xFFFFFFFF\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvYmluYXJ5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1A7QUFDQSxVQUFVO0FBQ1Y7QUFDTztBQUNQO0FBQ0EsVUFBVTtBQUNWO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvYmluYXJ5LmpzP2JkYmUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogQmluYXJ5IGRhdGEgY29uc3RhbnRzLlxuICpcbiAqIEBtb2R1bGUgYmluYXJ5XG4gKi9cblxuLyoqXG4gKiBuLXRoIGJpdCBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVDEgPSAxXG5leHBvcnQgY29uc3QgQklUMiA9IDJcbmV4cG9ydCBjb25zdCBCSVQzID0gNFxuZXhwb3J0IGNvbnN0IEJJVDQgPSA4XG5leHBvcnQgY29uc3QgQklUNSA9IDE2XG5leHBvcnQgY29uc3QgQklUNiA9IDMyXG5leHBvcnQgY29uc3QgQklUNyA9IDY0XG5leHBvcnQgY29uc3QgQklUOCA9IDEyOFxuZXhwb3J0IGNvbnN0IEJJVDkgPSAyNTZcbmV4cG9ydCBjb25zdCBCSVQxMCA9IDUxMlxuZXhwb3J0IGNvbnN0IEJJVDExID0gMTAyNFxuZXhwb3J0IGNvbnN0IEJJVDEyID0gMjA0OFxuZXhwb3J0IGNvbnN0IEJJVDEzID0gNDA5NlxuZXhwb3J0IGNvbnN0IEJJVDE0ID0gODE5MlxuZXhwb3J0IGNvbnN0IEJJVDE1ID0gMTYzODRcbmV4cG9ydCBjb25zdCBCSVQxNiA9IDMyNzY4XG5leHBvcnQgY29uc3QgQklUMTcgPSA2NTUzNlxuZXhwb3J0IGNvbnN0IEJJVDE4ID0gMSA8PCAxN1xuZXhwb3J0IGNvbnN0IEJJVDE5ID0gMSA8PCAxOFxuZXhwb3J0IGNvbnN0IEJJVDIwID0gMSA8PCAxOVxuZXhwb3J0IGNvbnN0IEJJVDIxID0gMSA8PCAyMFxuZXhwb3J0IGNvbnN0IEJJVDIyID0gMSA8PCAyMVxuZXhwb3J0IGNvbnN0IEJJVDIzID0gMSA8PCAyMlxuZXhwb3J0IGNvbnN0IEJJVDI0ID0gMSA8PCAyM1xuZXhwb3J0IGNvbnN0IEJJVDI1ID0gMSA8PCAyNFxuZXhwb3J0IGNvbnN0IEJJVDI2ID0gMSA8PCAyNVxuZXhwb3J0IGNvbnN0IEJJVDI3ID0gMSA8PCAyNlxuZXhwb3J0IGNvbnN0IEJJVDI4ID0gMSA8PCAyN1xuZXhwb3J0IGNvbnN0IEJJVDI5ID0gMSA8PCAyOFxuZXhwb3J0IGNvbnN0IEJJVDMwID0gMSA8PCAyOVxuZXhwb3J0IGNvbnN0IEJJVDMxID0gMSA8PCAzMFxuZXhwb3J0IGNvbnN0IEJJVDMyID0gMSA8PCAzMVxuXG4vKipcbiAqIEZpcnN0IG4gYml0cyBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMwID0gMFxuZXhwb3J0IGNvbnN0IEJJVFMxID0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyID0gM1xuZXhwb3J0IGNvbnN0IEJJVFMzID0gN1xuZXhwb3J0IGNvbnN0IEJJVFM0ID0gMTVcbmV4cG9ydCBjb25zdCBCSVRTNSA9IDMxXG5leHBvcnQgY29uc3QgQklUUzYgPSA2M1xuZXhwb3J0IGNvbnN0IEJJVFM3ID0gMTI3XG5leHBvcnQgY29uc3QgQklUUzggPSAyNTVcbmV4cG9ydCBjb25zdCBCSVRTOSA9IDUxMVxuZXhwb3J0IGNvbnN0IEJJVFMxMCA9IDEwMjNcbmV4cG9ydCBjb25zdCBCSVRTMTEgPSAyMDQ3XG5leHBvcnQgY29uc3QgQklUUzEyID0gNDA5NVxuZXhwb3J0IGNvbnN0IEJJVFMxMyA9IDgxOTFcbmV4cG9ydCBjb25zdCBCSVRTMTQgPSAxNjM4M1xuZXhwb3J0IGNvbnN0IEJJVFMxNSA9IDMyNzY3XG5leHBvcnQgY29uc3QgQklUUzE2ID0gNjU1MzVcbmV4cG9ydCBjb25zdCBCSVRTMTcgPSBCSVQxOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTggPSBCSVQxOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTkgPSBCSVQyMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjAgPSBCSVQyMSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjEgPSBCSVQyMiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjIgPSBCSVQyMyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjMgPSBCSVQyNCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjQgPSBCSVQyNSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjUgPSBCSVQyNiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjYgPSBCSVQyNyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjcgPSBCSVQyOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjggPSBCSVQyOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjkgPSBCSVQzMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMzAgPSBCSVQzMSAtIDFcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMSA9IDB4N0ZGRkZGRkZcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMiA9IDB4RkZGRkZGRkZcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/binary.js\n");

/***/ }),

/***/ "../node_modules/lib0/broadcastchannel.js":
/*!************************************************!*\
  !*** ../node_modules/lib0/broadcastchannel.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"publish\": () => (/* binding */ publish),\n/* harmony export */   \"subscribe\": () => (/* binding */ subscribe),\n/* harmony export */   \"unsubscribe\": () => (/* binding */ unsubscribe)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"../node_modules/lib0/map.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./set.js */ \"../node_modules/lib0/set.js\");\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ \"../node_modules/lib0/buffer.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./storage.js */ \"../node_modules/lib0/storage.js\");\n/* eslint-env browser */\n\n/**\n * Helpers for cross-tab communication using broadcastchannel with LocalStorage fallback.\n *\n * ```js\n * // In browser window A:\n * broadcastchannel.subscribe('my events', data => console.log(data))\n * broadcastchannel.publish('my events', 'Hello world!') // => A: 'Hello world!' fires synchronously in same tab\n *\n * // In browser window B:\n * broadcastchannel.publish('my events', 'hello from tab B') // => A: 'hello from tab B'\n * ```\n *\n * @module broadcastchannel\n */\n\n// @todo before next major: use Uint8Array instead as buffer object\n\n\n\n\n\n\n/**\n * @typedef {Object} Channel\n * @property {Set<function(any, any):any>} Channel.subs\n * @property {any} Channel.bc\n */\n\n/**\n * @type {Map<string, Channel>}\n */\nconst channels = new Map()\n\n/* c8 ignore start */\nclass LocalStoragePolyfill {\n  /**\n   * @param {string} room\n   */\n  constructor (room) {\n    this.room = room\n    /**\n     * @type {null|function({data:ArrayBuffer}):void}\n     */\n    this.onmessage = null\n    /**\n     * @param {any} e\n     */\n    this._onChange = e => e.key === room && this.onmessage !== null && this.onmessage({ data: _buffer_js__WEBPACK_IMPORTED_MODULE_0__.fromBase64(e.newValue || '') })\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__.onChange(this._onChange)\n  }\n\n  /**\n   * @param {ArrayBuffer} buf\n   */\n  postMessage (buf) {\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__.varStorage.setItem(this.room, _buffer_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayFromArrayBuffer(buf)))\n  }\n\n  close () {\n    _storage_js__WEBPACK_IMPORTED_MODULE_1__.offChange(this._onChange)\n  }\n}\n/* c8 ignore stop */\n\n// Use BroadcastChannel or Polyfill\n/* c8 ignore next */\nconst BC = typeof BroadcastChannel === 'undefined' ? LocalStoragePolyfill : BroadcastChannel\n\n/**\n * @param {string} room\n * @return {Channel}\n */\nconst getChannel = room =>\n  _map_js__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(channels, room, () => {\n    const subs = _set_js__WEBPACK_IMPORTED_MODULE_3__.create()\n    const bc = new BC(room)\n    /**\n     * @param {{data:ArrayBuffer}} e\n     */\n    /* c8 ignore next */\n    bc.onmessage = e => subs.forEach(sub => sub(e.data, 'broadcastchannel'))\n    return {\n      bc, subs\n    }\n  })\n\n/**\n * Subscribe to global `publish` events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nconst subscribe = (room, f) => {\n  getChannel(room).subs.add(f)\n  return f\n}\n\n/**\n * Unsubscribe from `publish` global events.\n *\n * @function\n * @param {string} room\n * @param {function(any, any):any} f\n */\nconst unsubscribe = (room, f) => {\n  const channel = getChannel(room)\n  const unsubscribed = channel.subs.delete(f)\n  if (unsubscribed && channel.subs.size === 0) {\n    channel.bc.close()\n    channels.delete(room)\n  }\n  return unsubscribed\n}\n\n/**\n * Publish data to all subscribers (including subscribers on this tab)\n *\n * @function\n * @param {string} room\n * @param {any} data\n * @param {any} [origin]\n */\nconst publish = (room, data, origin = null) => {\n  const c = getChannel(room)\n  c.bc.postMessage(data)\n  c.subs.forEach(sub => sub(data, origin))\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvYnJvYWRjYXN0Y2hhbm5lbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFK0I7QUFDQTtBQUNNO0FBQ0U7O0FBRXZDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsNkJBQTZCO0FBQzNDLGNBQWMsS0FBSztBQUNuQjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZSxpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0Esd0ZBQXdGLE1BQU0sa0RBQWlCLG9CQUFvQjtBQUNuSSxJQUFJLGlEQUFnQjtBQUNwQjs7QUFFQTtBQUNBLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0EsSUFBSSwyREFBMEIsWUFBWSxnREFBZSxDQUFDLHVFQUFzQztBQUNoRzs7QUFFQTtBQUNBLElBQUksa0RBQWlCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQSxFQUFFLG1EQUFrQjtBQUNwQixpQkFBaUIsMkNBQVU7QUFDM0I7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLHdCQUF3QjtBQUNuQztBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanM/ZGFkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIGZvciBjcm9zcy10YWIgY29tbXVuaWNhdGlvbiB1c2luZyBicm9hZGNhc3RjaGFubmVsIHdpdGggTG9jYWxTdG9yYWdlIGZhbGxiYWNrLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBBOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5zdWJzY3JpYmUoJ215IGV2ZW50cycsIGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpXG4gKiBicm9hZGNhc3RjaGFubmVsLnB1Ymxpc2goJ215IGV2ZW50cycsICdIZWxsbyB3b3JsZCEnKSAvLyA9PiBBOiAnSGVsbG8gd29ybGQhJyBmaXJlcyBzeW5jaHJvbm91c2x5IGluIHNhbWUgdGFiXG4gKlxuICogLy8gSW4gYnJvd3NlciB3aW5kb3cgQjpcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ2hlbGxvIGZyb20gdGFiIEInKSAvLyA9PiBBOiAnaGVsbG8gZnJvbSB0YWIgQidcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgYnJvYWRjYXN0Y2hhbm5lbFxuICovXG5cbi8vIEB0b2RvIGJlZm9yZSBuZXh0IG1ham9yOiB1c2UgVWludDhBcnJheSBpbnN0ZWFkIGFzIGJ1ZmZlciBvYmplY3RcblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJy4vYnVmZmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RvcmFnZSBmcm9tICcuL3N0b3JhZ2UuanMnXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2hhbm5lbFxuICogQHByb3BlcnR5IHtTZXQ8ZnVuY3Rpb24oYW55LCBhbnkpOmFueT59IENoYW5uZWwuc3Vic1xuICogQHByb3BlcnR5IHthbnl9IENoYW5uZWwuYmNcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLCBDaGFubmVsPn1cbiAqL1xuY29uc3QgY2hhbm5lbHMgPSBuZXcgTWFwKClcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jbGFzcyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHJvb20pIHtcbiAgICB0aGlzLnJvb20gPSByb29tXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGx8ZnVuY3Rpb24oe2RhdGE6QXJyYXlCdWZmZXJ9KTp2b2lkfVxuICAgICAqL1xuICAgIHRoaXMub25tZXNzYWdlID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7YW55fSBlXG4gICAgICovXG4gICAgdGhpcy5fb25DaGFuZ2UgPSBlID0+IGUua2V5ID09PSByb29tICYmIHRoaXMub25tZXNzYWdlICE9PSBudWxsICYmIHRoaXMub25tZXNzYWdlKHsgZGF0YTogYnVmZmVyLmZyb21CYXNlNjQoZS5uZXdWYWx1ZSB8fCAnJykgfSlcbiAgICBzdG9yYWdlLm9uQ2hhbmdlKHRoaXMuX29uQ2hhbmdlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZlxuICAgKi9cbiAgcG9zdE1lc3NhZ2UgKGJ1Zikge1xuICAgIHN0b3JhZ2UudmFyU3RvcmFnZS5zZXRJdGVtKHRoaXMucm9vbSwgYnVmZmVyLnRvQmFzZTY0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5RnJvbUFycmF5QnVmZmVyKGJ1ZikpKVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHN0b3JhZ2Uub2ZmQ2hhbmdlKHRoaXMuX29uQ2hhbmdlKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vLyBVc2UgQnJvYWRjYXN0Q2hhbm5lbCBvciBQb2x5ZmlsbFxuLyogYzggaWdub3JlIG5leHQgKi9cbmNvbnN0IEJDID0gdHlwZW9mIEJyb2FkY2FzdENoYW5uZWwgPT09ICd1bmRlZmluZWQnID8gTG9jYWxTdG9yYWdlUG9seWZpbGwgOiBCcm9hZGNhc3RDaGFubmVsXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEByZXR1cm4ge0NoYW5uZWx9XG4gKi9cbmNvbnN0IGdldENoYW5uZWwgPSByb29tID0+XG4gIG1hcC5zZXRJZlVuZGVmaW5lZChjaGFubmVscywgcm9vbSwgKCkgPT4ge1xuICAgIGNvbnN0IHN1YnMgPSBzZXQuY3JlYXRlKClcbiAgICBjb25zdCBiYyA9IG5ldyBCQyhyb29tKVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7e2RhdGE6QXJyYXlCdWZmZXJ9fSBlXG4gICAgICovXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBiYy5vbm1lc3NhZ2UgPSBlID0+IHN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGUuZGF0YSwgJ2Jyb2FkY2FzdGNoYW5uZWwnKSlcbiAgICByZXR1cm4ge1xuICAgICAgYmMsIHN1YnNcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIGdsb2JhbCBgcHVibGlzaGAgZXZlbnRzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJvb21cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LCBhbnkpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3Qgc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IHtcbiAgZ2V0Q2hhbm5lbChyb29tKS5zdWJzLmFkZChmKVxuICByZXR1cm4gZlxufVxuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gYHB1Ymxpc2hgIGdsb2JhbCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCB1bnN1YnNjcmliZSA9IChyb29tLCBmKSA9PiB7XG4gIGNvbnN0IGNoYW5uZWwgPSBnZXRDaGFubmVsKHJvb20pXG4gIGNvbnN0IHVuc3Vic2NyaWJlZCA9IGNoYW5uZWwuc3Vicy5kZWxldGUoZilcbiAgaWYgKHVuc3Vic2NyaWJlZCAmJiBjaGFubmVsLnN1YnMuc2l6ZSA9PT0gMCkge1xuICAgIGNoYW5uZWwuYmMuY2xvc2UoKVxuICAgIGNoYW5uZWxzLmRlbGV0ZShyb29tKVxuICB9XG4gIHJldHVybiB1bnN1YnNjcmliZWRcbn1cblxuLyoqXG4gKiBQdWJsaXNoIGRhdGEgdG8gYWxsIHN1YnNjcmliZXJzIChpbmNsdWRpbmcgc3Vic2NyaWJlcnMgb24gdGhpcyB0YWIpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqIEBwYXJhbSB7YW55fSBbb3JpZ2luXVxuICovXG5leHBvcnQgY29uc3QgcHVibGlzaCA9IChyb29tLCBkYXRhLCBvcmlnaW4gPSBudWxsKSA9PiB7XG4gIGNvbnN0IGMgPSBnZXRDaGFubmVsKHJvb20pXG4gIGMuYmMucG9zdE1lc3NhZ2UoZGF0YSlcbiAgYy5zdWJzLmZvckVhY2goc3ViID0+IHN1YihkYXRhLCBvcmlnaW4pKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/broadcastchannel.js\n");

/***/ }),

/***/ "../node_modules/lib0/buffer.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/buffer.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"copyUint8Array\": () => (/* binding */ copyUint8Array),\n/* harmony export */   \"createUint8ArrayFromArrayBuffer\": () => (/* binding */ createUint8ArrayFromArrayBuffer),\n/* harmony export */   \"createUint8ArrayFromLen\": () => (/* binding */ createUint8ArrayFromLen),\n/* harmony export */   \"createUint8ArrayViewFromArrayBuffer\": () => (/* binding */ createUint8ArrayViewFromArrayBuffer),\n/* harmony export */   \"decodeAny\": () => (/* binding */ decodeAny),\n/* harmony export */   \"encodeAny\": () => (/* binding */ encodeAny),\n/* harmony export */   \"fromBase64\": () => (/* binding */ fromBase64),\n/* harmony export */   \"toBase64\": () => (/* binding */ toBase64)\n/* harmony export */ });\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./string.js */ \"../node_modules/lib0/string.js\");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment.js */ \"../node_modules/lib0/environment.js\");\n/* harmony import */ var _encoding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./encoding.js */ \"../node_modules/lib0/encoding.js\");\n/* harmony import */ var _decoding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./decoding.js */ \"../node_modules/lib0/decoding.js\");\n/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\n\n\n\n\n\n/**\n * @param {number} len\n */\nconst createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nconst createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nconst createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* c8 ignore start */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* c8 ignore start */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* c8 ignore next */\nconst toBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node\n\n/* c8 ignore next */\nconst fromBase64 = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nconst copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nconst encodeAny = data => {\n  const encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_2__.createEncoder()\n  _encoding_js__WEBPACK_IMPORTED_MODULE_2__.writeAny(encoder, data)\n  return _encoding_js__WEBPACK_IMPORTED_MODULE_2__.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nconst decodeAny = buf => _decoding_js__WEBPACK_IMPORTED_MODULE_3__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_3__.createDecoder(buf))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvYnVmZmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0U7QUFDRTtBQUNBOztBQUV6QztBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QyxTQUFTLG9EQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDTyxpQkFBaUIsc0RBQWE7O0FBRXJDO0FBQ08sbUJBQW1CLHNEQUFhOztBQUV2QztBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDTztBQUNQLGtCQUFrQix1REFBc0I7QUFDeEMsRUFBRSxrREFBaUI7QUFDbkIsU0FBUyxzREFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNPLHlCQUF5QixpREFBZ0IsQ0FBQyx1REFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvYnVmZmVyLmpzPzRlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggYnVmZmVycyAoVWludDhBcnJheSkuXG4gKlxuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICcuL2RlY29kaW5nLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuID0gbGVuID0+IG5ldyBVaW50OEFycmF5KGxlbilcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyID0gKGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSA9PiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aClcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgVWludDhBcnJheShidWZmZXIpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvQmFzZTY0QnJvd3NlciA9IGJ5dGVzID0+IHtcbiAgbGV0IHMgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgIHMgKz0gc3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSlcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuIGJ0b2Eocylcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGZyb21CYXNlNjRCcm93c2VyID0gcyA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjb25zdCBhID0gYXRvYihzKVxuICBjb25zdCBieXRlcyA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKGEubGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGEuY2hhckNvZGVBdChpKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICovXG5jb25zdCBmcm9tQmFzZTY0Tm9kZSA9IHMgPT4ge1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzLCAnYmFzZTY0JylcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aClcbn1cblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB0b0Jhc2U2NCA9IGVudi5pc0Jyb3dzZXIgPyB0b0Jhc2U2NEJyb3dzZXIgOiB0b0Jhc2U2NE5vZGVcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBmcm9tQmFzZTY0ID0gZW52LmlzQnJvd3NlciA/IGZyb21CYXNlNjRCcm93c2VyIDogZnJvbUJhc2U2NE5vZGVcblxuLyoqXG4gKiBDb3B5IHRoZSBjb250ZW50IG9mIGFuIFVpbnQ4QXJyYXkgdmlldyB0byBhIG5ldyBBcnJheUJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5VWludDhBcnJheSA9IHVpbnQ4QXJyYXkgPT4ge1xuICBjb25zdCBuZXdCdWYgPSBjcmVhdGVVaW50OEFycmF5RnJvbUxlbih1aW50OEFycmF5LmJ5dGVMZW5ndGgpXG4gIG5ld0J1Zi5zZXQodWludDhBcnJheSlcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKipcbiAqIEVuY29kZSBhbnl0aGluZyBhcyBhIFVJbnQ4QXJyYXkuIEl0J3MgYSBwdW4gb24gdHlwZXNjcmlwdHMncyBgYW55YCB0eXBlLlxuICogU2VlIGVuY29kaW5nLndyaXRlQW55IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7YW55fSBkYXRhXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlQW55ID0gZGF0YSA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVBbnkoZW5jb2RlciwgZGF0YSlcbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIERlY29kZSBhbiBhbnktZW5jb2RlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlQW55ID0gYnVmID0+IGRlY29kaW5nLnJlYWRBbnkoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/buffer.js\n");

/***/ }),

/***/ "../node_modules/lib0/conditions.js":
/*!******************************************!*\
  !*** ../node_modules/lib0/conditions.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"undefinedToNull\": () => (/* binding */ undefinedToNull)\n/* harmony export */ });\n/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* c8 ignore next */\nconst undefinedToNull = v => v === undefined ? null : v\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsWUFBWTtBQUNaO0FBQ0E7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9jb25kaXRpb25zLmpzP2M1NjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBPZnRlbiB1c2VkIGNvbmRpdGlvbnMuXG4gKlxuICogQG1vZHVsZSBjb25kaXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfG51bGx8dW5kZWZpbmVkfSB2XG4gKiBAcmV0dXJuIHtUfG51bGx9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdW5kZWZpbmVkVG9OdWxsID0gdiA9PiB2ID09PSB1bmRlZmluZWQgPyBudWxsIDogdlxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/conditions.js\n");

/***/ }),

/***/ "../node_modules/lib0/decoding.js":
/*!****************************************!*\
  !*** ../node_modules/lib0/decoding.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Decoder\": () => (/* binding */ Decoder),\n/* harmony export */   \"IncUintOptRleDecoder\": () => (/* binding */ IncUintOptRleDecoder),\n/* harmony export */   \"IntDiffDecoder\": () => (/* binding */ IntDiffDecoder),\n/* harmony export */   \"IntDiffOptRleDecoder\": () => (/* binding */ IntDiffOptRleDecoder),\n/* harmony export */   \"RleDecoder\": () => (/* binding */ RleDecoder),\n/* harmony export */   \"RleIntDiffDecoder\": () => (/* binding */ RleIntDiffDecoder),\n/* harmony export */   \"StringDecoder\": () => (/* binding */ StringDecoder),\n/* harmony export */   \"UintOptRleDecoder\": () => (/* binding */ UintOptRleDecoder),\n/* harmony export */   \"_readVarStringNative\": () => (/* binding */ _readVarStringNative),\n/* harmony export */   \"_readVarStringPolyfill\": () => (/* binding */ _readVarStringPolyfill),\n/* harmony export */   \"clone\": () => (/* binding */ clone),\n/* harmony export */   \"createDecoder\": () => (/* binding */ createDecoder),\n/* harmony export */   \"hasContent\": () => (/* binding */ hasContent),\n/* harmony export */   \"peekUint16\": () => (/* binding */ peekUint16),\n/* harmony export */   \"peekUint32\": () => (/* binding */ peekUint32),\n/* harmony export */   \"peekUint8\": () => (/* binding */ peekUint8),\n/* harmony export */   \"peekVarInt\": () => (/* binding */ peekVarInt),\n/* harmony export */   \"peekVarString\": () => (/* binding */ peekVarString),\n/* harmony export */   \"peekVarUint\": () => (/* binding */ peekVarUint),\n/* harmony export */   \"readAny\": () => (/* binding */ readAny),\n/* harmony export */   \"readBigInt64\": () => (/* binding */ readBigInt64),\n/* harmony export */   \"readBigUint64\": () => (/* binding */ readBigUint64),\n/* harmony export */   \"readFloat32\": () => (/* binding */ readFloat32),\n/* harmony export */   \"readFloat64\": () => (/* binding */ readFloat64),\n/* harmony export */   \"readFromDataView\": () => (/* binding */ readFromDataView),\n/* harmony export */   \"readTailAsUint8Array\": () => (/* binding */ readTailAsUint8Array),\n/* harmony export */   \"readUint16\": () => (/* binding */ readUint16),\n/* harmony export */   \"readUint32\": () => (/* binding */ readUint32),\n/* harmony export */   \"readUint32BigEndian\": () => (/* binding */ readUint32BigEndian),\n/* harmony export */   \"readUint8\": () => (/* binding */ readUint8),\n/* harmony export */   \"readUint8Array\": () => (/* binding */ readUint8Array),\n/* harmony export */   \"readVarInt\": () => (/* binding */ readVarInt),\n/* harmony export */   \"readVarString\": () => (/* binding */ readVarString),\n/* harmony export */   \"readVarUint\": () => (/* binding */ readVarUint),\n/* harmony export */   \"readVarUint8Array\": () => (/* binding */ readVarUint8Array),\n/* harmony export */   \"skip8\": () => (/* binding */ skip8)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer.js */ \"../node_modules/lib0/buffer.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ \"../node_modules/lib0/binary.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./number.js */ \"../node_modules/lib0/number.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./string.js */ \"../node_modules/lib0/string.js\");\n/* harmony import */ var _error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error.js */ \"../node_modules/lib0/error.js\");\n/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\n\n\n\n\n\n\n\nconst errorUnexpectedEndOfArray = _error_js__WEBPACK_IMPORTED_MODULE_0__.create('Unexpected end of array')\nconst errorIntegerOutOfRange = _error_js__WEBPACK_IMPORTED_MODULE_0__.create('Integer out of Range')\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nclass Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nconst createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nconst hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nconst clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nconst readUint8Array = (decoder, len) => {\n  const view = _buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nconst readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nconst skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nconst readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nconst peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarUint = decoder => {\n  let num = 0\n  let mult = 1\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    const r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) * mult // shift $r << (7*#iterations) and add it to num\n    mult *= 128 // next iteration, shift 7 \"more\" to the left\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) {\n      return num\n    }\n    /* c8 ignore start */\n    if (num > _number_js__WEBPACK_IMPORTED_MODULE_3__.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nconst readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6\n  let mult = 64\n  const sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7) > 0 ? -1 : 1\n  if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  const len = decoder.arr.length\n  while (decoder.pos < len) {\n    r = decoder.arr[decoder.pos++]\n    // num = num | ((r & binary.BITS7) << len)\n    num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) * mult\n    mult *= 128\n    if (r < _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) {\n      return sign * num\n    }\n    /* c8 ignore start */\n    if (num > _number_js__WEBPACK_IMPORTED_MODULE_3__.MAX_SAFE_INTEGER) {\n      throw errorIntegerOutOfRange\n    }\n    /* c8 ignore stop */\n  }\n  throw errorUnexpectedEndOfArray\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nconst peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * We don't test this function anymore as we use native decoding/encoding by default now.\n * Better not modify this anymore..\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\n/* c8 ignore start */\nconst _readVarStringPolyfill = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n */\nconst _readVarStringNative = decoder =>\n  /** @type any */ _string_js__WEBPACK_IMPORTED_MODULE_4__.utf8TextDecoder.decode(readVarUint8Array(decoder))\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String\n *\n */\n/* c8 ignore next */\nconst readVarString = _string_js__WEBPACK_IMPORTED_MODULE_4__.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nconst peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nconst readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nconst readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nconst readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nclass RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nclass IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nclass RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_5__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nclass IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_5__.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nclass IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = _math_js__WEBPACK_IMPORTED_MODULE_5__.floor(diff / 2) // shift >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nclass StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZGVjb2RpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxQztBQUNBO0FBQ0o7QUFDSTtBQUNBO0FBQ0Y7O0FBRW5DLGtDQUFrQyw2Q0FBWTtBQUM5QywrQkFBK0IsNkNBQVk7O0FBRTNDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQLGVBQWUsMkVBQTBDO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBWTtBQUNqQztBQUNBLFlBQVksNENBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3REFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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L25vZGVfbW9kdWxlcy9saWIwL2RlY29kaW5nLmpzPzYxYmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGRlY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9kZWNvZGluZ10gd2l0aCBbbGliMC9lbmNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBkZWNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gJy4vbnVtYmVyLmpzJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnLi9lcnJvci5qcydcblxuY29uc3QgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheSA9IGVycm9yLmNyZWF0ZSgnVW5leHBlY3RlZCBlbmQgb2YgYXJyYXknKVxuY29uc3QgZXJyb3JJbnRlZ2VyT3V0T2ZSYW5nZSA9IGVycm9yLmNyZWF0ZSgnSW50ZWdlciBvdXQgb2YgUmFuZ2UnKVxuXG4vKipcbiAqIEEgRGVjb2RlciBoYW5kbGVzIHRoZSBkZWNvZGluZyBvZiBhbiBVaW50OEFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXkgQmluYXJ5IGRhdGEgdG8gZGVjb2RlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIC8qKlxuICAgICAqIERlY29kaW5nIHRhcmdldC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gdWludDhBcnJheVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgZGVjb2RpbmcgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqIEByZXR1cm4ge0RlY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEZWNvZGVyID0gdWludDhBcnJheSA9PiBuZXcgRGVjb2Rlcih1aW50OEFycmF5KVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzQ29udGVudCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MgIT09IGRlY29kZXIuYXJyLmxlbmd0aFxuXG4vKipcbiAqIENsb25lIGEgZGVjb2RlciBpbnN0YW5jZS5cbiAqIE9wdGlvbmFsbHkgc2V0IGEgbmV3IHBvc2l0aW9uIHBhcmFtZXRlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IFtuZXdQb3NdIERlZmF1bHRzIHRvIGN1cnJlbnQgcG9zaXRpb25cbiAqIEByZXR1cm4ge0RlY29kZXJ9IEEgY2xvbmUgb2YgYGRlY29kZXJgXG4gKi9cbmV4cG9ydCBjb25zdCBjbG9uZSA9IChkZWNvZGVyLCBuZXdQb3MgPSBkZWNvZGVyLnBvcykgPT4ge1xuICBjb25zdCBfZGVjb2RlciA9IGNyZWF0ZURlY29kZXIoZGVjb2Rlci5hcnIpXG4gIF9kZWNvZGVyLnBvcyA9IG5ld1Bvc1xuICByZXR1cm4gX2RlY29kZXJcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gVWludDhBcnJheSB2aWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzIGFuZCBhZHZhbmNlIHRoZSBwb3NpdGlvbiBieSBgbGVuYC5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXIgVGhlIGRlY29kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVGhlIGxlbmd0aCBvZiBieXRlcyB0byByZWFkXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQ4QXJyYXkgPSAoZGVjb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IHZpZXcgPSBidWZmZXIuY3JlYXRlVWludDhBcnJheVZpZXdGcm9tQXJyYXlCdWZmZXIoZGVjb2Rlci5hcnIuYnVmZmVyLCBkZWNvZGVyLnBvcyArIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQsIGxlbilcbiAgZGVjb2Rlci5wb3MgKz0gbGVuXG4gIHJldHVybiB2aWV3XG59XG5cbi8qKlxuICogUmVhZCB2YXJpYWJsZSBsZW5ndGggVWludDhBcnJheS5cbiAqXG4gKiBJbXBvcnRhbnQ6IFRoZSBVaW50OEFycmF5IHN0aWxsIHBvaW50cyB0byB0aGUgdW5kZXJseWluZyBBcnJheUJ1ZmZlci4gTWFrZSBzdXJlIHRvIGRpc2NhcmQgdGhlIHJlc3VsdCBhcyBzb29uIGFzIHBvc3NpYmxlIHRvIHByZXZlbnQgYW55IG1lbW9yeSBsZWFrcy5cbiAqICAgICAgICAgICAgVXNlIGBidWZmZXIuY29weVVpbnQ4QXJyYXlgIHRvIGNvcHkgdGhlIHJlc3VsdCBpbnRvIGEgbmV3IFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgcmVhZFZhclVpbnQoZGVjb2RlcikpXG5cbi8qKlxuICogUmVhZCB0aGUgcmVzdCBvZiB0aGUgY29udGVudCBhcyBhbiBBcnJheUJ1ZmZlclxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVGFpbEFzVWludDhBcnJheSA9IGRlY29kZXIgPT4gcmVhZFVpbnQ4QXJyYXkoZGVjb2RlciwgZGVjb2Rlci5hcnIubGVuZ3RoIC0gZGVjb2Rlci5wb3MpXG5cbi8qKlxuICogU2tpcCBvbmUgYnl0ZSwganVtcCB0byB0aGUgbmV4dCBwb3NpdGlvbi5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBuZXh0IHBvc2l0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBza2lwOCA9IGRlY29kZXIgPT4gZGVjb2Rlci5wb3MrK1xuXG4vKipcbiAqIFJlYWQgb25lIGJ5dGUgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50OCA9IGRlY29kZXIgPT4gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cblxuLyoqXG4gKiBSZWFkIDIgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQxNiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG4gIGRlY29kZXIucG9zICs9IDJcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgMTYpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBSZWFkIDQgYnl0ZXMgYXMgdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcmVhZFVpbnQzMkJpZ0VuZGlhbiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCB1aW50ID1cbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMl0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSA8PCAyNCkpID4+PiAwXG4gIGRlY29kZXIucG9zICs9IDRcbiAgcmV0dXJuIHVpbnRcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zXVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MTYgPSBkZWNvZGVyID0+XG4gIGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDFdIDw8IDgpXG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQzMiA9IGRlY29kZXIgPT4gKFxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDNdIDw8IDI0KVxuKSA+Pj4gMFxuXG4vKipcbiAqIFJlYWQgdW5zaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQgPSBkZWNvZGVyID0+IHtcbiAgbGV0IG51bSA9IDBcbiAgbGV0IG11bHQgPSAxXG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aFxuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICBjb25zdCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIGJpbmFyeS5CSVRTNykgKiBtdWx0IC8vIHNoaWZ0ICRyIDw8ICg3KiNpdGVyYXRpb25zKSBhbmQgYWRkIGl0IHRvIG51bVxuICAgIG11bHQgKj0gMTI4IC8vIG5leHQgaXRlcmF0aW9uLCBzaGlmdCA3IFwibW9yZVwiIHRvIHRoZSBsZWZ0XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gbnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59XG5cbi8qKlxuICogUmVhZCBzaWduZWQgaW50ZWdlciAoMzJiaXQpIHdpdGggdmFyaWFibGUgbGVuZ3RoLlxuICogMS84dGggb2YgdGhlIHN0b3JhZ2UgaXMgdXNlZCBhcyBlbmNvZGluZyBvdmVyaGVhZC5cbiAqICAqIG51bWJlcnMgPCAyXjcgaXMgc3RvcmVkIGluIG9uZSBieXRsZW5ndGhcbiAqICAqIG51bWJlcnMgPCAyXjE0IGlzIHN0b3JlZCBpbiB0d28gYnlsZW5ndGhcbiAqIEB0b2RvIFRoaXMgc2hvdWxkIHByb2JhYmx5IGNyZWF0ZSB0aGUgaW52ZXJzZSB+bnVtIGlmIG51bWJlciBpcyBuZWdhdGl2ZSAtIGJ1dCB0aGlzIHdvdWxkIGJlIGEgYnJlYWtpbmcgY2hhbmdlLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIubGVuZ3RoXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgbGV0IG51bSA9IHIgJiBiaW5hcnkuQklUUzZcbiAgbGV0IG11bHQgPSA2NFxuICBjb25zdCBzaWduID0gKHIgJiBiaW5hcnkuQklUNykgPiAwID8gLTEgOiAxXG4gIGlmICgociAmIGJpbmFyeS5CSVQ4KSA9PT0gMCkge1xuICAgIC8vIGRvbid0IGNvbnRpbnVlIHJlYWRpbmdcbiAgICByZXR1cm4gc2lnbiAqIG51bVxuICB9XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIuYXJyLmxlbmd0aFxuICB3aGlsZSAoZGVjb2Rlci5wb3MgPCBsZW4pIHtcbiAgICByID0gZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MrK11cbiAgICAvLyBudW0gPSBudW0gfCAoKHIgJiBiaW5hcnkuQklUUzcpIDw8IGxlbilcbiAgICBudW0gPSBudW0gKyAociAmIGJpbmFyeS5CSVRTNykgKiBtdWx0XG4gICAgbXVsdCAqPSAxMjhcbiAgICBpZiAociA8IGJpbmFyeS5CSVQ4KSB7XG4gICAgICByZXR1cm4gc2lnbiAqIG51bVxuICAgIH1cbiAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICBpZiAobnVtID4gbnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IGVycm9ySW50ZWdlck91dE9mUmFuZ2VcbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgfVxuICB0aHJvdyBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJVaW50IHdpdGhvdXQgaW5jcmVtZW50aW5nIHBvc2l0aW9uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFyVWludChkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFySW50ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHBvcyA9IGRlY29kZXIucG9zXG4gIGNvbnN0IHMgPSByZWFkVmFySW50KGRlY29kZXIpXG4gIGRlY29kZXIucG9zID0gcG9zXG4gIHJldHVybiBzXG59XG5cbi8qKlxuICogV2UgZG9uJ3QgdGVzdCB0aGlzIGZ1bmN0aW9uIGFueW1vcmUgYXMgd2UgdXNlIG5hdGl2ZSBkZWNvZGluZy9lbmNvZGluZyBieSBkZWZhdWx0IG5vdy5cbiAqIEJldHRlciBub3QgbW9kaWZ5IHRoaXMgYW55bW9yZS4uXG4gKlxuICogVHJhbnNmb3JtaW5nIHV0ZjggdG8gYSBzdHJpbmcgaXMgcHJldHR5IGV4cGVuc2l2ZS4gVGhlIGNvZGUgcGVyZm9ybXMgMTB4IGJldHRlclxuICogd2hlbiBTdHJpbmcuZnJvbUNvZGVQb2ludCBpcyBmZWQgd2l0aCBhbGwgY2hhcmFjdGVycyBhcyBhcmd1bWVudHMuXG4gKiBCdXQgbW9zdCBlbnZpcm9ubWVudHMgaGF2ZSBhIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyBwZXIgZnVuY3Rpb25zLlxuICogRm9yIGVmZmllbmN5IHJlYXNvbnMgd2UgYXBwbHkgYSBtYXhpbXVtIG9mIDEwMDAwIGNoYXJhY3RlcnMgYXQgb25jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVhZCBTdHJpbmcuXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IF9yZWFkVmFyU3RyaW5nUG9seWZpbGwgPSBkZWNvZGVyID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IHJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGlmIChyZW1haW5pbmdMZW4gPT09IDApIHtcbiAgICByZXR1cm4gJydcbiAgfSBlbHNlIHtcbiAgICBsZXQgZW5jb2RlZFN0cmluZyA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHJlYWRVaW50OChkZWNvZGVyKSkgLy8gcmVtZW1iZXIgdG8gZGVjcmVhc2UgcmVtYWluaW5nTGVuXG4gICAgaWYgKC0tcmVtYWluaW5nTGVuIDwgMTAwKSB7IC8vIGRvIG5vdCBjcmVhdGUgYSBVaW50OEFycmF5IGZvciBzbWFsbCBzdHJpbmdzXG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuLS0pIHtcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChyZW1haW5pbmdMZW4gPiAwKSB7XG4gICAgICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgICAgIC8vIHRoaXMgaXMgZGFuZ2Vyb3VzLCB3ZSBjcmVhdGUgYSBmcmVzaCBhcnJheSB2aWV3IGZyb20gdGhlIGV4aXN0aW5nIGJ1ZmZlclxuICAgICAgICBjb25zdCBieXRlcyA9IGRlY29kZXIuYXJyLnN1YmFycmF5KGRlY29kZXIucG9zLCBkZWNvZGVyLnBvcyArIG5leHRMZW4pXG4gICAgICAgIGRlY29kZXIucG9zICs9IG5leHRMZW5cbiAgICAgICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICAgICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICAgICAgcmVtYWluaW5nTGVuIC09IG5leHRMZW5cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCBfcmVhZFZhclN0cmluZ05hdGl2ZSA9IGRlY29kZXIgPT5cbiAgLyoqIEB0eXBlIGFueSAqLyAoc3RyaW5nLnV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKHJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgc3RyaW5nIG9mIHZhcmlhYmxlIGxlbmd0aFxuICogKiB2YXJVaW50IGlzIHVzZWQgdG8gc3RvcmUgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nXG4gKlxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJTdHJpbmcgPSBzdHJpbmcudXRmOFRleHREZWNvZGVyID8gX3JlYWRWYXJTdHJpbmdOYXRpdmUgOiBfcmVhZFZhclN0cmluZ1BvbHlmaWxsXG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJTdHJpbmcgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRnJvbURhdGFWaWV3ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQgKyBkZWNvZGVyLnBvcywgbGVuKVxuICBkZWNvZGVyLnBvcyArPSBsZW5cbiAgcmV0dXJuIGR2XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRmxvYXQzMiA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA0KS5nZXRGbG9hdDMyKDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0NjQgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkuZ2V0RmxvYXQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdJbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdJbnQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdVaW50NjQgPSBkZWNvZGVyID0+IC8qKiBAdHlwZSB7YW55fSAqLyAocmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KSkuZ2V0QmlnVWludDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihEZWNvZGVyKTphbnk+fVxuICovXG5jb25zdCByZWFkQW55TG9va3VwVGFibGUgPSBbXG4gIGRlY29kZXIgPT4gdW5kZWZpbmVkLCAvLyBDQVNFIDEyNzogdW5kZWZpbmVkXG4gIGRlY29kZXIgPT4gbnVsbCwgLy8gQ0FTRSAxMjY6IG51bGxcbiAgcmVhZFZhckludCwgLy8gQ0FTRSAxMjU6IGludGVnZXJcbiAgcmVhZEZsb2F0MzIsIC8vIENBU0UgMTI0OiBmbG9hdDMyXG4gIHJlYWRGbG9hdDY0LCAvLyBDQVNFIDEyMzogZmxvYXQ2NFxuICByZWFkQmlnSW50NjQsIC8vIENBU0UgMTIyOiBiaWdpbnRcbiAgZGVjb2RlciA9PiBmYWxzZSwgLy8gQ0FTRSAxMjE6IGJvb2xlYW4gKGZhbHNlKVxuICBkZWNvZGVyID0+IHRydWUsIC8vIENBU0UgMTIwOiBib29sZWFuICh0cnVlKVxuICByZWFkVmFyU3RyaW5nLCAvLyBDQVNFIDExOTogc3RyaW5nXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExODogb2JqZWN0PHN0cmluZyxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgb2JqW2tleV0gPSByZWFkQW55KGRlY29kZXIpXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE3OiBhcnJheTxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHJlYWRBbnkoZGVjb2RlcikpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfSxcbiAgcmVhZFZhclVpbnQ4QXJyYXkgLy8gQ0FTRSAxMTY6IFVpbnQ4QXJyYXlcbl1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbnkgPSBkZWNvZGVyID0+IHJlYWRBbnlMb29rdXBUYWJsZVsxMjcgLSByZWFkVWludDgoZGVjb2RlcildKGRlY29kZXIpXG5cbi8qKlxuICogVCBtdXN0IG5vdCBiZSBudWxsLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihEZWNvZGVyKTpUfSByZWFkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCByZWFkZXIpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIFRoZSByZWFkZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IHJlYWRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHRoaXMucmVhZGVyKHRoaXMpXG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxIC8vIHNlZSBlbmNvZGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVhc29uIHdoeSB0aGlzIGlzIGluY3JlbWVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ID0gLTEgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJsZUludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIHRoaXMucyA9IC10aGlzLnNcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucysrKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRpZmYgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgZmlyc3QgYml0IGlzIHNldCwgd2UgcmVhZCBtb3JlIGRhdGFcbiAgICAgIGNvbnN0IGhhc0NvdW50ID0gZGlmZiAmIDFcbiAgICAgIHRoaXMuZGlmZiA9IG1hdGguZmxvb3IoZGlmZiAvIDIpIC8vIHNoaWZ0ID4+IDFcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnMgKz0gdGhpcy5kaWZmXG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIodWludDhBcnJheSlcbiAgICB0aGlzLnN0ciA9IHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zcG9zID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuc3BvcyArIHRoaXMuZGVjb2Rlci5yZWFkKClcbiAgICBjb25zdCByZXMgPSB0aGlzLnN0ci5zbGljZSh0aGlzLnNwb3MsIGVuZClcbiAgICB0aGlzLnNwb3MgPSBlbmRcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/decoding.js\n");

/***/ }),

/***/ "../node_modules/lib0/dom.js":
/*!***********************************!*\
  !*** ../node_modules/lib0/dom.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CDATA_SECTION_NODE\": () => (/* binding */ CDATA_SECTION_NODE),\n/* harmony export */   \"COMMENT_NODE\": () => (/* binding */ COMMENT_NODE),\n/* harmony export */   \"DOCUMENT_FRAGMENT_NODE\": () => (/* binding */ DOCUMENT_FRAGMENT_NODE),\n/* harmony export */   \"DOCUMENT_NODE\": () => (/* binding */ DOCUMENT_NODE),\n/* harmony export */   \"DOCUMENT_TYPE_NODE\": () => (/* binding */ DOCUMENT_TYPE_NODE),\n/* harmony export */   \"ELEMENT_NODE\": () => (/* binding */ ELEMENT_NODE),\n/* harmony export */   \"TEXT_NODE\": () => (/* binding */ TEXT_NODE),\n/* harmony export */   \"addEventListener\": () => (/* binding */ addEventListener),\n/* harmony export */   \"addEventListeners\": () => (/* binding */ addEventListeners),\n/* harmony export */   \"append\": () => (/* binding */ append),\n/* harmony export */   \"appendChild\": () => (/* binding */ appendChild),\n/* harmony export */   \"canvas\": () => (/* binding */ canvas),\n/* harmony export */   \"checkNodeType\": () => (/* binding */ checkNodeType),\n/* harmony export */   \"createDocumentFragment\": () => (/* binding */ createDocumentFragment),\n/* harmony export */   \"createElement\": () => (/* binding */ createElement),\n/* harmony export */   \"createTextNode\": () => (/* binding */ createTextNode),\n/* harmony export */   \"doc\": () => (/* binding */ doc),\n/* harmony export */   \"domParser\": () => (/* binding */ domParser),\n/* harmony export */   \"element\": () => (/* binding */ element),\n/* harmony export */   \"emitCustomEvent\": () => (/* binding */ emitCustomEvent),\n/* harmony export */   \"fragment\": () => (/* binding */ fragment),\n/* harmony export */   \"getElementById\": () => (/* binding */ getElementById),\n/* harmony export */   \"insertBefore\": () => (/* binding */ insertBefore),\n/* harmony export */   \"isParentOf\": () => (/* binding */ isParentOf),\n/* harmony export */   \"mapToStyleString\": () => (/* binding */ mapToStyleString),\n/* harmony export */   \"pairToStyleString\": () => (/* binding */ pairToStyleString),\n/* harmony export */   \"pairsToStyleString\": () => (/* binding */ pairsToStyleString),\n/* harmony export */   \"parseElement\": () => (/* binding */ parseElement),\n/* harmony export */   \"parseFragment\": () => (/* binding */ parseFragment),\n/* harmony export */   \"querySelector\": () => (/* binding */ querySelector),\n/* harmony export */   \"querySelectorAll\": () => (/* binding */ querySelectorAll),\n/* harmony export */   \"remove\": () => (/* binding */ remove),\n/* harmony export */   \"removeEventListener\": () => (/* binding */ removeEventListener),\n/* harmony export */   \"removeEventListeners\": () => (/* binding */ removeEventListeners),\n/* harmony export */   \"replaceWith\": () => (/* binding */ replaceWith),\n/* harmony export */   \"setAttributes\": () => (/* binding */ setAttributes),\n/* harmony export */   \"setAttributesMap\": () => (/* binding */ setAttributesMap),\n/* harmony export */   \"text\": () => (/* binding */ text)\n/* harmony export */ });\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pair.js */ \"../node_modules/lib0/pair.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ \"../node_modules/lib0/map.js\");\n/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\n\n\n\n/* c8 ignore start */\n/**\n * @type {Document}\n */\nconst doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\nconst createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\nconst createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\nconst createTextNode = text => doc.createTextNode(text)\n\nconst domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\nconst emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\nconst setAttributes = (el, attrs) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\nconst setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\nconst fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\nconst append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\nconst remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nconst addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\nconst removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nconst addEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\nconst removeEventListeners = (node, listeners) => {\n  _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\nconst element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\nconst canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\nconst text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\nconst pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\nconst pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\nconst mapToStyleString = m => _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\nconst querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\nconst querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\nconst getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\nconst parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\nconst parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\nconst replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\nconst insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\nconst appendChild = (parent, child) => parent.appendChild(child)\n\nconst ELEMENT_NODE = doc.ELEMENT_NODE\nconst TEXT_NODE = doc.TEXT_NODE\nconst CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nconst COMMENT_NODE = doc.COMMENT_NODE\nconst DOCUMENT_NODE = doc.DOCUMENT_NODE\nconst DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nconst DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nconst checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nconst isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n/* c8 ignore stop */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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a0RBQWtELEtBQUs7O0FBRTlEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ087O0FBRVA7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakIsWUFBWTtBQUNaO0FBQ087O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVA7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CO0FBQ087O0FBRVA7QUFDQSxXQUFXLE1BQU07QUFDakIsV0FBVyxhQUFhO0FBQ3hCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9kb20uanM/MzcxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggdGhlIERPTS5cbiAqXG4gKiBAbW9kdWxlIGRvbVxuICovXG5cbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnLi9wYWlyLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHR5cGUge0RvY3VtZW50fVxuICovXG5leHBvcnQgY29uc3QgZG9jID0gLyoqIEB0eXBlIHtEb2N1bWVudH0gKi8gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHt9KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVsZW1lbnQgPSBuYW1lID0+IGRvYy5jcmVhdGVFbGVtZW50KG5hbWUpXG5cbi8qKlxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSAoKSA9PiBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUZXh0Tm9kZSA9IHRleHQgPT4gZG9jLmNyZWF0ZVRleHROb2RlKHRleHQpXG5cbmV4cG9ydCBjb25zdCBkb21QYXJzZXIgPSAvKiogQHR5cGUge0RPTVBhcnNlcn0gKi8gKHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IERPTVBhcnNlcigpIDogbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbmV4cG9ydCBjb25zdCBlbWl0Q3VzdG9tRXZlbnQgPSAoZWwsIG5hbWUsIG9wdHMpID0+IGVsLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIG9wdHMpKVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmd8Ym9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyaWJ1dGVzID0gKGVsLCBhdHRycykgPT4ge1xuICBwYWlyLmZvckVhY2goYXR0cnMsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSlcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCAnJylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpXG4gICAgfVxuICB9KVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsIHN0cmluZz59IGF0dHJzIEFycmF5IG9mIGtleS12YWx1ZSBwYWlyc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNldEF0dHJpYnV0ZXNNYXAgPSAoZWwsIGF0dHJzKSA9PiB7XG4gIGF0dHJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHsgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpIH0pXG4gIHJldHVybiBlbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT58SFRNTENvbGxlY3Rpb259IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5leHBvcnQgY29uc3QgZnJhZ21lbnQgPSBjaGlsZHJlbiA9PiB7XG4gIGNvbnN0IGZyYWdtZW50ID0gY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBhcHBlbmRDaGlsZChmcmFnbWVudCwgY2hpbGRyZW5baV0pXG4gIH1cbiAgcmV0dXJuIGZyYWdtZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IG5vZGVzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kID0gKHBhcmVudCwgbm9kZXMpID0+IHtcbiAgYXBwZW5kQ2hpbGQocGFyZW50LCBmcmFnbWVudChub2RlcykpXG4gIHJldHVybiBwYXJlbnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlID0gZWwgPT4gZWwucmVtb3ZlKClcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBmXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVyID0gKGVsLCBuYW1lLCBmKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGYpXG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsRXZlbnRMaXN0ZW5lcj4+fSBsaXN0ZW5lcnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBhZGRFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IGFkZEV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsRXZlbnRMaXN0ZW5lcj4+fSBsaXN0ZW5lcnNcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudExpc3RlbmVycyA9IChub2RlLCBsaXN0ZW5lcnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGxpc3RlbmVycywgKG5hbWUsIGYpID0+IHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgbmFtZSwgZikpXG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+fHBhaXIuUGFpcjxzdHJpbmcsYm9vbGVhbj4+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEBwYXJhbSB7QXJyYXk8Tm9kZT59IGNoaWxkcmVuXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgZWxlbWVudCA9IChuYW1lLCBhdHRycyA9IFtdLCBjaGlsZHJlbiA9IFtdKSA9PlxuICBhcHBlbmQoc2V0QXR0cmlidXRlcyhjcmVhdGVFbGVtZW50KG5hbWUpLCBhdHRycyksIGNoaWxkcmVuKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICovXG5leHBvcnQgY29uc3QgY2FudmFzID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgY29uc3QgYyA9IC8qKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9ICovIChjcmVhdGVFbGVtZW50KCdjYW52YXMnKSlcbiAgYy5oZWlnaHQgPSBoZWlnaHRcbiAgYy53aWR0aCA9IHdpZHRoXG4gIHJldHVybiBjXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRcbiAqIEByZXR1cm4ge1RleHR9XG4gKi9cbmV4cG9ydCBjb25zdCB0ZXh0ID0gY3JlYXRlVGV4dE5vZGVcblxuLyoqXG4gKiBAcGFyYW0ge3BhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPn0gcGFpclxuICovXG5leHBvcnQgY29uc3QgcGFpclRvU3R5bGVTdHJpbmcgPSBwYWlyID0+IGAke3BhaXIubGVmdH06JHtwYWlyLnJpZ2h0fTtgXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz4+fSBwYWlyc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcGFpcnNUb1N0eWxlU3RyaW5nID0gcGFpcnMgPT4gcGFpcnMubWFwKHBhaXJUb1N0eWxlU3RyaW5nKS5qb2luKCcnKVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxzdHJpbmc+fSBtXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBUb1N0eWxlU3RyaW5nID0gbSA9PiBtYXAubWFwKG0sICh2YWx1ZSwga2V5KSA9PiBgJHtrZXl9OiR7dmFsdWV9O2ApLmpvaW4oJycpXG5cbi8qKlxuICogQHRvZG8gc2hvdWxkIGFsd2F5cyBxdWVyeSBvbiBhIGRvbSBlbGVtZW50XG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudCB8IG51bGx9XG4gKi9cbmV4cG9ydCBjb25zdCBxdWVyeVNlbGVjdG9yID0gKGVsLCBxdWVyeSkgPT4gZWwucXVlcnlTZWxlY3RvcihxdWVyeSlcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fFNoYWRvd1Jvb3R9IGVsXG4gKiBAcGFyYW0ge3N0cmluZ30gcXVlcnlcbiAqIEByZXR1cm4ge05vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+fVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvckFsbCA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEVsZW1lbnRCeUlkID0gaWQgPT4gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGRvYy5nZXRFbGVtZW50QnlJZChpZCkpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5jb25zdCBfcGFyc2UgPSBodG1sID0+IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcoYDxodG1sPjxib2R5PiR7aHRtbH08L2JvZHk+PC9odG1sPmAsICd0ZXh0L2h0bWwnKS5ib2R5XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUZyYWdtZW50ID0gaHRtbCA9PiBmcmFnbWVudCgvKiogQHR5cGUge2FueX0gKi8gKF9wYXJzZShodG1sKS5jaGlsZE5vZGVzKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZUVsZW1lbnQgPSBodG1sID0+IC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqLyAoX3BhcnNlKGh0bWwpLmZpcnN0RWxlbWVudENoaWxkKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9sZEVsXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IG5ld0VsXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlV2l0aCA9IChvbGRFbCwgbmV3RWwpID0+IG9sZEVsLnJlcGxhY2VXaXRoKG5ld0VsKVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7Tm9kZXxudWxsfSByZWZcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgaW5zZXJ0QmVmb3JlID0gKHBhcmVudCwgZWwsIHJlZikgPT4gcGFyZW50Lmluc2VydEJlZm9yZShlbCwgcmVmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge05vZGV9IGNoaWxkXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgY29uc3QgYXBwZW5kQ2hpbGQgPSAocGFyZW50LCBjaGlsZCkgPT4gcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKVxuXG5leHBvcnQgY29uc3QgRUxFTUVOVF9OT0RFID0gZG9jLkVMRU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IFRFWFRfTk9ERSA9IGRvYy5URVhUX05PREVcbmV4cG9ydCBjb25zdCBDREFUQV9TRUNUSU9OX05PREUgPSBkb2MuQ0RBVEFfU0VDVElPTl9OT0RFXG5leHBvcnQgY29uc3QgQ09NTUVOVF9OT0RFID0gZG9jLkNPTU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX05PREUgPSBkb2MuRE9DVU1FTlRfTk9ERVxuZXhwb3J0IGNvbnN0IERPQ1VNRU5UX1RZUEVfTk9ERSA9IGRvYy5ET0NVTUVOVF9UWVBFX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREVcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gbm9kZVxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNoZWNrTm9kZVR5cGUgPSAobm9kZSwgdHlwZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gdHlwZVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjaGlsZFxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIGxldCBwID0gY2hpbGQucGFyZW50Tm9kZVxuICB3aGlsZSAocCAmJiBwICE9PSBwYXJlbnQpIHtcbiAgICBwID0gcC5wYXJlbnROb2RlXG4gIH1cbiAgcmV0dXJuIHAgPT09IHBhcmVudFxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/dom.js\n");

/***/ }),

/***/ "../node_modules/lib0/encoding.js":
/*!****************************************!*\
  !*** ../node_modules/lib0/encoding.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Encoder\": () => (/* binding */ Encoder),\n/* harmony export */   \"IncUintOptRleEncoder\": () => (/* binding */ IncUintOptRleEncoder),\n/* harmony export */   \"IntDiffEncoder\": () => (/* binding */ IntDiffEncoder),\n/* harmony export */   \"IntDiffOptRleEncoder\": () => (/* binding */ IntDiffOptRleEncoder),\n/* harmony export */   \"RleEncoder\": () => (/* binding */ RleEncoder),\n/* harmony export */   \"RleIntDiffEncoder\": () => (/* binding */ RleIntDiffEncoder),\n/* harmony export */   \"StringEncoder\": () => (/* binding */ StringEncoder),\n/* harmony export */   \"UintOptRleEncoder\": () => (/* binding */ UintOptRleEncoder),\n/* harmony export */   \"_writeVarStringNative\": () => (/* binding */ _writeVarStringNative),\n/* harmony export */   \"_writeVarStringPolyfill\": () => (/* binding */ _writeVarStringPolyfill),\n/* harmony export */   \"createEncoder\": () => (/* binding */ createEncoder),\n/* harmony export */   \"encode\": () => (/* binding */ encode),\n/* harmony export */   \"hasContent\": () => (/* binding */ hasContent),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"set\": () => (/* binding */ set),\n/* harmony export */   \"setUint16\": () => (/* binding */ setUint16),\n/* harmony export */   \"setUint32\": () => (/* binding */ setUint32),\n/* harmony export */   \"setUint8\": () => (/* binding */ setUint8),\n/* harmony export */   \"toUint8Array\": () => (/* binding */ toUint8Array),\n/* harmony export */   \"verifyLen\": () => (/* binding */ verifyLen),\n/* harmony export */   \"write\": () => (/* binding */ write),\n/* harmony export */   \"writeAny\": () => (/* binding */ writeAny),\n/* harmony export */   \"writeBigInt64\": () => (/* binding */ writeBigInt64),\n/* harmony export */   \"writeBigUint64\": () => (/* binding */ writeBigUint64),\n/* harmony export */   \"writeBinaryEncoder\": () => (/* binding */ writeBinaryEncoder),\n/* harmony export */   \"writeFloat32\": () => (/* binding */ writeFloat32),\n/* harmony export */   \"writeFloat64\": () => (/* binding */ writeFloat64),\n/* harmony export */   \"writeOnDataView\": () => (/* binding */ writeOnDataView),\n/* harmony export */   \"writeUint16\": () => (/* binding */ writeUint16),\n/* harmony export */   \"writeUint32\": () => (/* binding */ writeUint32),\n/* harmony export */   \"writeUint32BigEndian\": () => (/* binding */ writeUint32BigEndian),\n/* harmony export */   \"writeUint8\": () => (/* binding */ writeUint8),\n/* harmony export */   \"writeUint8Array\": () => (/* binding */ writeUint8Array),\n/* harmony export */   \"writeVarInt\": () => (/* binding */ writeVarInt),\n/* harmony export */   \"writeVarString\": () => (/* binding */ writeVarString),\n/* harmony export */   \"writeVarUint\": () => (/* binding */ writeVarUint),\n/* harmony export */   \"writeVarUint8Array\": () => (/* binding */ writeVarUint8Array)\n/* harmony export */ });\n/* harmony import */ var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./buffer.js */ \"../node_modules/lib0/buffer.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./number.js */ \"../node_modules/lib0/number.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./binary.js */ \"../node_modules/lib0/binary.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./string.js */ \"../node_modules/lib0/string.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./array.js */ \"../node_modules/lib0/array.js\");\n/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\n\n\n\n\n\n\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nclass Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nconst createEncoder = () => new Encoder()\n\n/**\n * @param {function(Encoder):void} f\n */\nconst encode = (f) => {\n  const encoder = createEncoder()\n  f(encoder)\n  return toUint8Array(encoder)\n}\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nconst length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Check whether encoder is empty.\n *\n * @function\n * @param {Encoder} encoder\n * @return {boolean}\n */\nconst hasContent = encoder => encoder.cpos > 0 || encoder.bufs.length > 0\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nconst toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nconst write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nconst set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint16 = (encoder, num) => {\n  write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  write(encoder, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nconst setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer. Max encodable integer is 2^53.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarUint = (encoder, num) => {\n  while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {\n    write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 128) // shift >>> 7\n  }\n  write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nconst writeVarInt = (encoder, num) => {\n  const isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num))\n  num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 64) // shift >>> 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (_binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num))\n    num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 128) // shift >>> 7\n  }\n}\n\n/**\n * A cache to store strings temporarily\n */\nconst _strBuffer = new Uint8Array(30000)\nconst _maxStrBSize = _strBuffer.length / 3\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringNative = (encoder, str) => {\n  if (str.length < _maxStrBSize) {\n    // We can encode the string into the existing buffer\n    /* c8 ignore next */\n    const written = _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0\n    writeVarUint(encoder, written)\n    for (let i = 0; i < written; i++) {\n      write(encoder, _strBuffer[i])\n    }\n  } else {\n    writeVarUint8Array(encoder, _string_js__WEBPACK_IMPORTED_MODULE_3__.encodeUtf8(str))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nconst _writeVarStringPolyfill = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\n/* c8 ignore next */\nconst writeVarString = (_string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder && /** @type {any} */ _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder.encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nconst writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_1__.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nconst writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nconst writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nconst writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nconst writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nconst writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (_number_js__WEBPACK_IMPORTED_MODULE_4__.isInteger(data) && _math_js__WEBPACK_IMPORTED_MODULE_1__.abs(data) <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (_array_js__WEBPACK_IMPORTED_MODULE_5__.isArray(data)) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nclass RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nclass IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nclass RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nclass UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nclass IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nclass IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nclass StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZW5jb2RpbmcuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUM7QUFDSjtBQUNJO0FBQ0E7QUFDQTtBQUNGOztBQUVuQztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFlBQVk7QUFDeEI7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyRUFBMEM7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IsMkVBQTBDO0FBQ2hFLGtDQUFrQyx5Q0FBUTtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL2VuY29kaW5nLmpzPzQ5MzMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFZmZpY2llbnQgc2NoZW1hLWxlc3MgYmluYXJ5IGVuY29kaW5nIHdpdGggc3VwcG9ydCBmb3IgdmFyaWFibGUgbGVuZ3RoIGVuY29kaW5nLlxuICpcbiAqIFVzZSBbbGliMC9lbmNvZGluZ10gd2l0aCBbbGliMC9kZWNvZGluZ10uIEV2ZXJ5IGVuY29kaW5nIGZ1bmN0aW9uIGhhcyBhIGNvcnJlc3BvbmRpbmcgZGVjb2RpbmcgZnVuY3Rpb24uXG4gKlxuICogRW5jb2RlcyBudW1iZXJzIGluIGxpdHRsZS1lbmRpYW4gb3JkZXIgKGxlYXN0IHRvIG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBvcmRlcilcbiAqIGFuZCBpcyBjb21wYXRpYmxlIHdpdGggR29sYW5nJ3MgYmluYXJ5IGVuY29kaW5nIChodHRwczovL2dvbGFuZy5vcmcvcGtnL2VuY29kaW5nL2JpbmFyeS8pXG4gKiB3aGljaCBpcyBhbHNvIHVzZWQgaW4gUHJvdG9jb2wgQnVmZmVycy5cbiAqXG4gKiBgYGBqc1xuICogLy8gZW5jb2Rpbmcgc3RlcFxuICogY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICogZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIDI1NilcbiAqIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsICdIZWxsbyB3b3JsZCEnKVxuICogY29uc3QgYnVmID0gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogLy8gZGVjb2Rpbmcgc3RlcFxuICogY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICogZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcikgLy8gPT4gMjU2XG4gKiBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpIC8vID0+ICdIZWxsbyB3b3JsZCEnXG4gKiBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpIC8vID0+IGZhbHNlIC0gYWxsIGRhdGEgaXMgcmVhZFxuICogYGBgXG4gKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG5cbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICcuL2J1ZmZlci5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgbnVtYmVyIGZyb20gJy4vbnVtYmVyLmpzJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJy4vYmluYXJ5LmpzJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJy4vc3RyaW5nLmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBBIEJpbmFyeUVuY29kZXIgaGFuZGxlcyB0aGUgZW5jb2RpbmcgdG8gYW4gVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIEVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5jcG9zID0gMFxuICAgIHRoaXMuY2J1ZiA9IG5ldyBVaW50OEFycmF5KDEwMClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VWludDhBcnJheT59XG4gICAgICovXG4gICAgdGhpcy5idWZzID0gW11cbiAgfVxufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHJldHVybiB7RW5jb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVuY29kZXIgPSAoKSA9PiBuZXcgRW5jb2RlcigpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyKTp2b2lkfSBmXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAoZikgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gY3JlYXRlRW5jb2RlcigpXG4gIGYoZW5jb2RlcilcbiAgcmV0dXJuIHRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50IGxlbmd0aCBvZiB0aGUgZW5jb2RlZCBkYXRhLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBlbmNvZGVyID0+IHtcbiAgbGV0IGxlbiA9IGVuY29kZXIuY3Bvc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGxlbiArPSBlbmNvZGVyLmJ1ZnNbaV0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGxlblxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgZW5jb2RlciBpcyBlbXB0eS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbnRlbnQgPSBlbmNvZGVyID0+IGVuY29kZXIuY3BvcyA+IDAgfHwgZW5jb2Rlci5idWZzLmxlbmd0aCA+IDBcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdG8gVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX0gVGhlIGNyZWF0ZWQgQXJyYXlCdWZmZXIuXG4gKi9cbmV4cG9ydCBjb25zdCB0b1VpbnQ4QXJyYXkgPSBlbmNvZGVyID0+IHtcbiAgY29uc3QgdWludDhhcnIgPSBuZXcgVWludDhBcnJheShsZW5ndGgoZW5jb2RlcikpXG4gIGxldCBjdXJQb3MgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGVuY29kZXIuYnVmc1tpXVxuICAgIHVpbnQ4YXJyLnNldChkLCBjdXJQb3MpXG4gICAgY3VyUG9zICs9IGQubGVuZ3RoXG4gIH1cbiAgdWludDhhcnIuc2V0KGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpXG4gIHJldHVybiB1aW50OGFyclxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIHdyaXRlIGBsZW5gIGJ5dGVzIHd0aWhvdXQgY2hlY2tpbmcuIElmXG4gKiBuZWNlc3NhcnksIGEgbmV3IEJ1ZmZlciB3aXRoIHRoZSByZXF1aXJlZCBsZW5ndGggaXMgYXR0YWNoZWQuXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGJ1ZmZlckxlbiAtIGVuY29kZXIuY3BvcyA8IGxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKGJ1ZmZlci5jcmVhdGVVaW50OEFycmF5Vmlld0Zyb21BcnJheUJ1ZmZlcihlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiwgbGVuKSAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIGJ5dGUgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGUgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGVuY29kZXIuY3BvcyA9PT0gYnVmZmVyTGVuKSB7XG4gICAgZW5jb2Rlci5idWZzLnB1c2goZW5jb2Rlci5jYnVmKVxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlckxlbiAqIDIpXG4gICAgZW5jb2Rlci5jcG9zID0gMFxuICB9XG4gIGVuY29kZXIuY2J1ZltlbmNvZGVyLmNwb3MrK10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhdCBhIHNwZWNpZmljIHBvc2l0aW9uLlxuICogUG9zaXRpb24gbXVzdCBhbHJlYWR5IGJlIHdyaXR0ZW4gKGkuZS4gZW5jb2Rlci5sZW5ndGggPiBwb3MpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb24gdG8gd2hpY2ggdG8gd3JpdGUgZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCBzZXQgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgbGV0IGJ1ZmZlciA9IG51bGxcbiAgLy8gaXRlcmF0ZSBhbGwgYnVmZmVycyBhbmQgYWRqdXN0IHBvc2l0aW9uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2Rlci5idWZzLmxlbmd0aCAmJiBidWZmZXIgPT09IG51bGw7IGkrKykge1xuICAgIGNvbnN0IGIgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICBpZiAocG9zIDwgYi5sZW5ndGgpIHtcbiAgICAgIGJ1ZmZlciA9IGIgLy8gZm91bmQgYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyAtPSBiLmxlbmd0aFxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyID09PSBudWxsKSB7XG4gICAgLy8gdXNlIGN1cnJlbnQgYnVmZmVyXG4gICAgYnVmZmVyID0gZW5jb2Rlci5jYnVmXG4gIH1cbiAgYnVmZmVyW3Bvc10gPSBudW1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OCA9IHdyaXRlXG5cbi8qKlxuICogV3JpdGUgb25lIGJ5dGUgYXMgYW4gdW5zaWduZWQgSW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDggPSBzZXRcblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDE2ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gIHdyaXRlKGVuY29kZXIsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDE2ID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIHNldChlbmNvZGVyLCBwb3MsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgc2V0KGVuY29kZXIsIHBvcyArIDEsIChudW0gPj4+IDgpICYgYmluYXJ5LkJJVFM4KVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB3cml0ZShlbmNvZGVyLCBudW0gJiBiaW5hcnkuQklUUzgpXG4gICAgbnVtID4+Pj0gOFxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQzMkJpZ0VuZGlhbiA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPj0gMDsgaS0tKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gKDggKiBpKSkgJiBiaW5hcnkuQklUUzgpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBsb2NhdGlvbiB3aGVyZSB0aGUgZGF0YSB3aWxsIGJlIHdyaXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgc2V0VWludDMyID0gKGVuY29kZXIsIHBvcywgbnVtKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgc2V0KGVuY29kZXIsIHBvcyArIGksIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCB1bnNpZ25lZCBpbnRlZ2VyLiBNYXggZW5jb2RhYmxlIGludGVnZXIgaXMgMl41My5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFyVWludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgd2hpbGUgKG51bSA+IGJpbmFyeS5CSVRTNykge1xuICAgIHdyaXRlKGVuY29kZXIsIGJpbmFyeS5CSVQ4IHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpXG4gICAgbnVtID0gbWF0aC5mbG9vcihudW0gLyAxMjgpIC8vIHNoaWZ0ID4+PiA3XG4gIH1cbiAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVFM3ICYgbnVtKVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIuXG4gKlxuICogV2UgdXNlIHRoZSA3dGggYml0IGluc3RlYWQgZm9yIHNpZ25hbGluZyB0aGF0IHRoaXMgaXMgYSBuZWdhdGl2ZSBudW1iZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhckludCA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8obnVtKVxuICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgIG51bSA9IC1udW1cbiAgfVxuICAvLyAgICAgICAgICAgICB8LSB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgICAgICAgICB8LSB3aGV0aGVyIGlzIG5lZ2F0aXZlICAgICB8LSBudW1iZXJcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+IGJpbmFyeS5CSVRTNiA/IGJpbmFyeS5CSVQ4IDogMCkgfCAoaXNOZWdhdGl2ZSA/IGJpbmFyeS5CSVQ3IDogMCkgfCAoYmluYXJ5LkJJVFM2ICYgbnVtKSlcbiAgbnVtID0gbWF0aC5mbG9vcihudW0gLyA2NCkgLy8gc2hpZnQgPj4+IDZcbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciB0aGUgY2FzZSBvZiBudW0gPT09IDAgc28gd2UgY2FuIHVzZSBhIGRpZmZlcmVudFxuICAvLyBwYXR0ZXJuIGhlcmUgdGhhbiBhYm92ZS5cbiAgd2hpbGUgKG51bSA+IDApIHtcbiAgICB3cml0ZShlbmNvZGVyLCAobnVtID4gYmluYXJ5LkJJVFM3ID8gYmluYXJ5LkJJVDggOiAwKSB8IChiaW5hcnkuQklUUzcgJiBudW0pKVxuICAgIG51bSA9IG1hdGguZmxvb3IobnVtIC8gMTI4KSAvLyBzaGlmdCA+Pj4gN1xuICB9XG59XG5cbi8qKlxuICogQSBjYWNoZSB0byBzdG9yZSBzdHJpbmdzIHRlbXBvcmFyaWx5XG4gKi9cbmNvbnN0IF9zdHJCdWZmZXIgPSBuZXcgVWludDhBcnJheSgzMDAwMClcbmNvbnN0IF9tYXhTdHJCU2l6ZSA9IF9zdHJCdWZmZXIubGVuZ3RoIC8gM1xuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IF93cml0ZVZhclN0cmluZ05hdGl2ZSA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgaWYgKHN0ci5sZW5ndGggPCBfbWF4U3RyQlNpemUpIHtcbiAgICAvLyBXZSBjYW4gZW5jb2RlIHRoZSBzdHJpbmcgaW50byB0aGUgZXhpc3RpbmcgYnVmZmVyXG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICBjb25zdCB3cml0dGVuID0gc3RyaW5nLnV0ZjhUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKHN0ciwgX3N0ckJ1ZmZlcikud3JpdHRlbiB8fCAwXG4gICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHdyaXR0ZW4pXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cml0dGVuOyBpKyspIHtcbiAgICAgIHdyaXRlKGVuY29kZXIsIF9zdHJCdWZmZXJbaV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdHJpbmcuZW5jb2RlVXRmOChzdHIpKVxuICB9XG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3QgX3dyaXRlVmFyU3RyaW5nUG9seWZpbGwgPSAoZW5jb2Rlciwgc3RyKSA9PiB7XG4gIGNvbnN0IGVuY29kZWRTdHJpbmcgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSlcbiAgY29uc3QgbGVuID0gZW5jb2RlZFN0cmluZy5sZW5ndGhcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSkpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJTdHJpbmcgPSAoc3RyaW5nLnV0ZjhUZXh0RW5jb2RlciAmJiAvKiogQHR5cGUge2FueX0gKi8gKHN0cmluZy51dGY4VGV4dEVuY29kZXIpLmVuY29kZUludG8pID8gX3dyaXRlVmFyU3RyaW5nTmF0aXZlIDogX3dyaXRlVmFyU3RyaW5nUG9seWZpbGxcblxuLyoqXG4gKiBXcml0ZSB0aGUgY29udGVudCBvZiBhbm90aGVyIEVuY29kZXIuXG4gKlxuICogQFRPRE86IGNhbiBiZSBpbXByb3ZlZCFcbiAqICAgICAgICAtIE5vdGU6IFNob3VsZCBjb25zaWRlciB0aGF0IHdoZW4gYXBwZW5kaW5nIGEgbG90IG9mIHNtYWxsIEVuY29kZXJzLCB3ZSBzaG91bGQgcmF0aGVyIGNsb25lIHRoYW4gcmVmZXJlbmNpbmcgdGhlIG9sZCBzdHJ1Y3R1cmUuXG4gKiAgICAgICAgICAgICAgICBFbmNvZGVycyBzdGFydCB3aXRoIGEgcmF0aGVyIGJpZyBpbml0aWFsIGJ1ZmZlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciBUaGUgZW5VaW50OEFyclxuICogQHBhcmFtIHtFbmNvZGVyfSBhcHBlbmQgVGhlIEJpbmFyeUVuY29kZXIgdG8gYmUgd3JpdHRlbi5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQmluYXJ5RW5jb2RlciA9IChlbmNvZGVyLCBhcHBlbmQpID0+IHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0b1VpbnQ4QXJyYXkoYXBwZW5kKSlcblxuLyoqXG4gKiBBcHBlbmQgZml4ZWQtbGVuZ3RoIFVpbnQ4QXJyYXkgdG8gdGhlIGVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBjb25zdCBjcG9zID0gZW5jb2Rlci5jcG9zXG4gIGNvbnN0IGxlZnRDb3B5TGVuID0gbWF0aC5taW4oYnVmZmVyTGVuIC0gY3BvcywgdWludDhBcnJheS5sZW5ndGgpXG4gIGNvbnN0IHJpZ2h0Q29weUxlbiA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gbGVmdENvcHlMZW5cbiAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KDAsIGxlZnRDb3B5TGVuKSwgY3BvcylcbiAgZW5jb2Rlci5jcG9zICs9IGxlZnRDb3B5TGVuXG4gIGlmIChyaWdodENvcHlMZW4gPiAwKSB7XG4gICAgLy8gU3RpbGwgc29tZXRoaW5nIHRvIHdyaXRlLCB3cml0ZSByaWdodCBoYWxmLi5cbiAgICAvLyBBcHBlbmQgbmV3IGJ1ZmZlclxuICAgIGVuY29kZXIuYnVmcy5wdXNoKGVuY29kZXIuY2J1ZilcbiAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgc2l6ZSBvZiByZW1haW5pbmcgYnVmZmVyXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuICogMiwgcmlnaHRDb3B5TGVuKSlcbiAgICAvLyBjb3B5IGFycmF5XG4gICAgZW5jb2Rlci5jYnVmLnNldCh1aW50OEFycmF5LnN1YmFycmF5KGxlZnRDb3B5TGVuKSlcbiAgICBlbmNvZGVyLmNwb3MgPSByaWdodENvcHlMZW5cbiAgfVxufVxuXG4vKipcbiAqIEFwcGVuZCBhbiBVaW50OEFycmF5IHRvIEVuY29kZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50OEFycmF5ID0gKGVuY29kZXIsIHVpbnQ4QXJyYXkpID0+IHtcbiAgd3JpdGVWYXJVaW50KGVuY29kZXIsIHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgd3JpdGVVaW50OEFycmF5KGVuY29kZXIsIHVpbnQ4QXJyYXkpXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIERhdGFWaWV3IG9mIHRoZSBuZXh0IGBsZW5gIGJ5dGVzLiBVc2UgaXQgdG8gd3JpdGUgZGF0YSBhZnRlclxuICogY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzXG4gKiAvLyB3cml0ZSBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuc2V0RmxvYXQzMigwLCAxLjEpXG4gKiAvLyByZWFkIGZsb2F0MzIgdXNpbmcgRGF0YVZpZXdcbiAqIGNvbnN0IGR2ID0gcmVhZEZyb21EYXRhVmlldyhlbmNvZGVyLCA0KVxuICogZHYuZ2V0RmxvYXQzMigwKSAvLyA9PiAxLjEwMDAwMDAyMzg0MTg1OCAobGVhdmluZyBpdCB0byB0aGUgcmVhZGVyIHRvIGZpbmQgb3V0IHdoeSB0aGlzIGlzIHRoZSBjb3JyZWN0IHJlc3VsdClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZU9uRGF0YVZpZXcgPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIHZlcmlmeUxlbihlbmNvZGVyLCBsZW4pXG4gIGNvbnN0IGR2aWV3ID0gbmV3IERhdGFWaWV3KGVuY29kZXIuY2J1Zi5idWZmZXIsIGVuY29kZXIuY3BvcywgbGVuKVxuICBlbmNvZGVyLmNwb3MgKz0gbGVuXG4gIHJldHVybiBkdmlld1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVGbG9hdDMyID0gKGVuY29kZXIsIG51bSkgPT4gd3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDQpLnNldEZsb2F0MzIoMCwgbnVtLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRmxvYXQ2NCA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KS5zZXRGbG9hdDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ0ludDY0ID0gKGVuY29kZXIsIG51bSkgPT4gLyoqIEB0eXBlIHthbnl9ICovICh3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkpLnNldEJpZ0ludDY0KDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge2JpZ2ludH0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpZ1VpbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdVaW50NjQoMCwgbnVtLCBmYWxzZSlcblxuY29uc3QgZmxvYXRUZXN0QmVkID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig0KSlcbi8qKlxuICogQ2hlY2sgaWYgYSBudW1iZXIgY2FuIGJlIGVuY29kZWQgYXMgYSAzMiBiaXQgZmxvYXQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNGbG9hdDMyID0gbnVtID0+IHtcbiAgZmxvYXRUZXN0QmVkLnNldEZsb2F0MzIoMCwgbnVtKVxuICByZXR1cm4gZmxvYXRUZXN0QmVkLmdldEZsb2F0MzIoMCkgPT09IG51bVxufVxuXG4vKipcbiAqIEVuY29kZSBkYXRhIHdpdGggZWZmaWNpZW50IGJpbmFyeSBmb3JtYXQuXG4gKlxuICogRGlmZmVyZW5jZXMgdG8gSlNPTjpcbiAqIOKAoiBUcmFuc2Zvcm1zIGRhdGEgdG8gYSBiaW5hcnkgZm9ybWF0IChub3QgdG8gYSBzdHJpbmcpXG4gKiDigKIgRW5jb2RlcyB1bmRlZmluZWQsIE5hTiwgYW5kIEFycmF5QnVmZmVyICh0aGVzZSBjYW4ndCBiZSByZXByZXNlbnRlZCBpbiBKU09OKVxuICog4oCiIE51bWJlcnMgYXJlIGVmZmljaWVudGx5IGVuY29kZWQgZWl0aGVyIGFzIGEgdmFyaWFibGUgbGVuZ3RoIGludGVnZXIsIGFzIGFcbiAqICAgMzIgYml0IGZsb2F0LCBhcyBhIDY0IGJpdCBmbG9hdCwgb3IgYXMgYSA2NCBiaXQgYmlnaW50LlxuICpcbiAqIEVuY29kaW5nIHRhYmxlOlxuICpcbiAqIHwgRGF0YSBUeXBlICAgICAgICAgICB8IFByZWZpeCAgIHwgRW5jb2RpbmcgTWV0aG9kICAgIHwgQ29tbWVudCB8XG4gKiB8IC0tLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0gfFxuICogfCB1bmRlZmluZWQgICAgICAgICAgIHwgMTI3ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBGdW5jdGlvbnMsIHN5bWJvbCwgYW5kIGV2ZXJ5dGhpbmcgdGhhdCBjYW5ub3QgYmUgaWRlbnRpZmllZCBpcyBlbmNvZGVkIGFzIHVuZGVmaW5lZCB8XG4gKiB8IG51bGwgICAgICAgICAgICAgICAgfCAxMjYgICAgICB8ICAgICAgICAgICAgICAgICAgICB8IHxcbiAqIHwgaW50ZWdlciAgICAgICAgICAgICB8IDEyNSAgICAgIHwgd3JpdGVWYXJJbnQgICAgICAgIHwgT25seSBlbmNvZGVzIDMyIGJpdCBzaWduZWQgaW50ZWdlcnMgfFxuICogfCBmbG9hdDMyICAgICAgICAgICAgIHwgMTI0ICAgICAgfCB3cml0ZUZsb2F0MzIgICAgICAgfCB8XG4gKiB8IGZsb2F0NjQgICAgICAgICAgICAgfCAxMjMgICAgICB8IHdyaXRlRmxvYXQ2NCAgICAgICB8IHxcbiAqIHwgYmlnaW50ICAgICAgICAgICAgICB8IDEyMiAgICAgIHwgd3JpdGVCaWdJbnQ2NCAgICAgIHwgfFxuICogfCBib29sZWFuIChmYWxzZSkgICAgIHwgMTIxICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCBUcnVlIGFuZCBmYWxzZSBhcmUgZGlmZmVyZW50IGRhdGEgdHlwZXMgc28gd2Ugc2F2ZSB0aGUgZm9sbG93aW5nIGJ5dGUgfFxuICogfCBib29sZWFuICh0cnVlKSAgICAgIHwgMTIwICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCAtIDBiMDExMTEwMDAgc28gdGhlIGxhc3QgYml0IGRldGVybWluZXMgd2hldGhlciB0cnVlIG9yIGZhbHNlIHxcbiAqIHwgc3RyaW5nICAgICAgICAgICAgICB8IDExOSAgICAgIHwgd3JpdGVWYXJTdHJpbmcgICAgIHwgfFxuICogfCBvYmplY3Q8c3RyaW5nLGFueT4gIHwgMTE4ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBrZXktdmFsdWUgcGFpcnMgfFxuICogfCBhcnJheTxhbnk+ICAgICAgICAgIHwgMTE3ICAgICAgfCBjdXN0b20gICAgICAgICAgICAgfCBXcml0ZXMge2xlbmd0aH0gdGhlbiB7bGVuZ3RofSBqc29uIHZhbHVlcyB8XG4gKiB8IFVpbnQ4QXJyYXkgICAgICAgICAgfCAxMTYgICAgICB8IHdyaXRlVmFyVWludDhBcnJheSB8IFdlIHVzZSBVaW50OEFycmF5IGZvciBhbnkga2luZCBvZiBiaW5hcnkgZGF0YSB8XG4gKlxuICogUmVhc29ucyBmb3IgdGhlIGRlY3JlYXNpbmcgcHJlZml4OlxuICogV2UgbmVlZCB0aGUgZmlyc3QgYml0IGZvciBleHRlbmRhYmlsaXR5IChsYXRlciB3ZSBtYXkgd2FudCB0byBlbmNvZGUgdGhlXG4gKiBwcmVmaXggd2l0aCB3cml0ZVZhclVpbnQpLiBUaGUgcmVtYWluaW5nIDcgYml0cyBhcmUgZGl2aWRlZCBhcyBmb2xsb3dzOlxuICogWzAtMzBdICAgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBjdXN0b20gcHVycG9zZXNcbiAqICAgICAgICAgIChkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbiB0aGF0IHVzZXMgdGhpcyBsaWJyYXJ5KVxuICogWzMxLTEyN10gdGhlIGVuZCBvZiB0aGUgZGF0YSByYW5nZSBpcyB1c2VkIGZvciBkYXRhIGVuY29kaW5nIGJ5XG4gKiAgICAgICAgICBsaWIwL2VuY29kaW5nLmpzXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxudWxsfG51bWJlcnxiaWdpbnR8Ym9vbGVhbnxzdHJpbmd8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58VWludDhBcnJheX0gZGF0YVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVBbnkgPSAoZW5jb2RlciwgZGF0YSkgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBkYXRhKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIC8vIFRZUEUgMTE5OiBTVFJJTkdcbiAgICAgIHdyaXRlKGVuY29kZXIsIDExOSlcbiAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRhdGEpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAobnVtYmVyLmlzSW50ZWdlcihkYXRhKSAmJiBtYXRoLmFicyhkYXRhKSA8PSBiaW5hcnkuQklUUzMxKSB7XG4gICAgICAgIC8vIFRZUEUgMTI1OiBJTlRFR0VSXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNSlcbiAgICAgICAgd3JpdGVWYXJJbnQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSBpZiAoaXNGbG9hdDMyKGRhdGEpKSB7XG4gICAgICAgIC8vIFRZUEUgMTI0OiBGTE9BVDMyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNClcbiAgICAgICAgd3JpdGVGbG9hdDMyKGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUWVBFIDEyMzogRkxPQVQ2NFxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjMpXG4gICAgICAgIHdyaXRlRmxvYXQ2NChlbmNvZGVyLCBkYXRhKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaWdpbnQnOlxuICAgICAgLy8gVFlQRSAxMjI6IEJpZ0ludFxuICAgICAgd3JpdGUoZW5jb2RlciwgMTIyKVxuICAgICAgd3JpdGVCaWdJbnQ2NChlbmNvZGVyLCBkYXRhKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVFlQRSAxMjY6IG51bGxcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTI2KVxuICAgICAgfSBlbHNlIGlmIChhcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIC8vIFRZUEUgMTE3OiBBcnJheVxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMTcpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVBbnkoZW5jb2RlciwgZGF0YVtpXSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAvLyBUWVBFIDExNjogQXJyYXlCdWZmZXJcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE2KVxuICAgICAgICB3cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRZUEUgMTE4OiBPYmplY3RcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE4KVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIsIGtleXMubGVuZ3RoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBrZXlzW2ldXG4gICAgICAgICAgd3JpdGVWYXJTdHJpbmcoZW5jb2Rlciwga2V5KVxuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFba2V5XSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIC8vIFRZUEUgMTIwLzEyMTogYm9vbGVhbiAodHJ1ZS9mYWxzZSlcbiAgICAgIHdyaXRlKGVuY29kZXIsIGRhdGEgPyAxMjAgOiAxMjEpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBUWVBFIDEyNzogdW5kZWZpbmVkXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMjcpXG4gIH1cbn1cblxuLyoqXG4gKiBOb3cgY29tZSBhIGZldyBzdGF0ZWZ1bCBlbmNvZGVyIHRoYXQgaGF2ZSB0aGVpciBvd24gY2xhc3Nlcy5cbiAqL1xuXG4vKipcbiAqIEJhc2ljIFJ1biBMZW5ndGggRW5jb2RlciAtIGEgYmFzaWMgY29tcHJlc3Npb24gaW1wbGVtZW50YXRpb24uXG4gKlxuICogRW5jb2RlcyBbMSwxLDEsN10gdG8gWzEsMyw3LDFdICgzIHRpbWVzIDEsIDEgdGltZSA3KS4gVGhpcyBlbmNvZGVyIG1pZ2h0IGRvIG1vcmUgaGFybSB0aGFuIGdvb2QgaWYgdGhlcmUgYXJlIGEgbG90IG9mIHZhbHVlcyB0aGF0IGFyZSBub3QgcmVwZWF0ZWQuXG4gKlxuICogSXQgd2FzIG9yaWdpbmFsbHkgdXNlZCBmb3IgaW1hZ2UgY29tcHJlc3Npb24uIENvb2wgLi4gYXJ0aWNsZSBodHRwOi8vY3NicnVjZS5jb20vY2JtL3RyYW5zYWN0b3IvcGRmcy90cmFuc192N19pMDYucGRmXG4gKlxuICogQG5vdGUgVCBtdXN0IG5vdCBiZSBudWxsIVxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEVuY29kZXIsIFQpOnZvaWR9IHdyaXRlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKHdyaXRlcikge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBUaGUgd3JpdGVyXG4gICAgICovXG4gICAgdGhpcy53ID0gd3JpdGVyXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtUfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5zID0gbnVsbFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgdGhpcy53KHRoaXMsIHYpXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzaWMgZGlmZiBkZWNvZGVyIHVzaW5nIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzMsIDExMDAsIDExMDEsIDEwNTAsIDBdIHRvIFszLCAxMDk3LCAxLCAtNTEsIC0xMDUwXSB1c2luZyB3cml0ZVZhckludC5cbiAqL1xuZXhwb3J0IGNsYXNzIEludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIHdyaXRlVmFySW50KHRoaXMsIHYgLSB0aGlzLnMpXG4gICAgdGhpcy5zID0gdlxuICB9XG59XG5cbi8qKlxuICogQSBjb21iaW5hdGlvbiBvZiBJbnREaWZmRW5jb2RlciBhbmQgUmxlRW5jb2Rlci5cbiAqXG4gKiBCYXNpY2FsbHkgZmlyc3Qgd3JpdGVzIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlbiBjb3VudHMgZHVwbGljYXRlIGRpZmZzIHVzaW5nIFJsZUVuY29kaW5nLlxuICpcbiAqIEVuY29kZXMgdGhlIHZhbHVlcyBbMSwxLDEsMiwzLDQsNSw2XSBhcyBbMSwxLDAsMiwxLDVdIChSTEUoWzEsMCwwLDEsMSwxLDEsMV0pIOKHkiBSbGVJbnREaWZmWzEsMSwwLDIsMSw1XSlcbiAqL1xuZXhwb3J0IGNsYXNzIFJsZUludERpZmZFbmNvZGVyIGV4dGVuZHMgRW5jb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdGFydCkge1xuICAgIHN1cGVyKClcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHN0YXRlXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSBzdGFydFxuICAgIHRoaXMuY291bnQgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMucyA9PT0gdiAmJiB0aGlzLmNvdW50ID4gMCkge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmNvdW50ID4gMCkge1xuICAgICAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAgICAgd3JpdGVWYXJVaW50KHRoaXMsIHRoaXMuY291bnQgLSAxKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAwLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgICAgfVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIC8vIHdyaXRlIGZpcnN0IHZhbHVlXG4gICAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludE9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hVaW50T3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBzaWduIHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IHNpZ24gdG8gbmVnYXRpdmUgdG8gaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBhIGxlbmd0aCBjb21pbmdcbiAgICB3cml0ZVZhckludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgPT09IDEgPyBlbmNvZGVyLnMgOiAtZW5jb2Rlci5zKVxuICAgIGlmIChlbmNvZGVyLmNvdW50ID4gMSkge1xuICAgICAgd3JpdGVWYXJVaW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2Rlci5jb3VudCAtIDIpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDEsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFJsZSBlbmNvZGVyIHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb20gdGhlIG1lbnRpb25lZCBwcm9ibGVtIG9mIHRoZSBiYXNpYyBSbGUgZW5jb2Rlci5cbiAqXG4gKiBJbnRlcm5hbGx5IHVzZXMgVmFySW50IGVuY29kZXIgdG8gd3JpdGUgdW5zaWduZWQgaW50ZWdlcnMuIElmIHRoZSBpbnB1dCBvY2N1cnMgbXVsdGlwbGUgdGltZXMsIHdlIHdyaXRlXG4gKiB3cml0ZSBpdCBhcyBhIG5lZ2F0aXZlIG51bWJlci4gVGhlIFVpbnRPcHRSbGVEZWNvZGVyIHRoZW4gdW5kZXJzdGFuZHMgdGhhdCBpdCBuZWVkcyB0byByZWFkIGEgY291bnQuXG4gKlxuICogRW5jb2RlcyBbMSwyLDMsMywzXSBhcyBbMSwyLC0zLDNdIChvbmNlIDEsIG9uY2UgMiwgdGhyZWUgdGltZXMgMylcbiAqL1xuZXhwb3J0IGNsYXNzIFVpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYpIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogSW5jcmVhc2luZyBVaW50IE9wdGltaXplZCBSTEUgRW5jb2RlclxuICpcbiAqIFRoZSBSTEUgZW5jb2RlciBjb3VudHMgdGhlIG51bWJlciBvZiBzYW1lIG9jY3VyZW5jZXMgb2YgdGhlIHNhbWUgdmFsdWUuXG4gKiBUaGUgSW5jVWludE9wdFJsZSBlbmNvZGVyIGNvdW50cyBpZiB0aGUgdmFsdWUgaW5jcmVhc2VzLlxuICogSS5lLiA3LCA4LCA5LCAxMCB3aWxsIGJlIGVuY29kZWQgYXMgWy03LCA0XS4gMSwgMywgNSB3aWxsIGJlIGVuY29kZWRcbiAqIGFzIFsxLCAzLCA1XS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuZW5jb2RlciA9IG5ldyBFbmNvZGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgKyB0aGlzLmNvdW50ID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SW50RGlmZk9wdFJsZUVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3QgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2RlciA9IGVuY29kZXIgPT4ge1xuICBpZiAoZW5jb2Rlci5jb3VudCA+IDApIHtcbiAgICAvLyAgICAgICAgICAzMSBiaXQgbWFraW5nIHVwIHRoZSBkaWZmIHwgd2V0aGVyIHRvIHdyaXRlIHRoZSBjb3VudGVyXG4gICAgLy8gY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgPDwgMSB8IChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgY29uc3QgZW5jb2RlZERpZmYgPSBlbmNvZGVyLmRpZmYgKiAyICsgKGVuY29kZXIuY291bnQgPT09IDEgPyAwIDogMSlcbiAgICAvLyBmbHVzaCBjb3VudGVyLCB1bmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgdmFsdWUgKGNvdW50ID0gMClcbiAgICAvLyBjYXNlIDE6IGp1c3QgYSBzaW5nbGUgdmFsdWUuIHNldCBmaXJzdCBiaXQgdG8gcG9zaXRpdmVcbiAgICAvLyBjYXNlIDI6IHdyaXRlIHNldmVyYWwgdmFsdWVzLiBzZXQgZmlyc3QgYml0IHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVkRGlmZilcbiAgICBpZiAoZW5jb2Rlci5jb3VudCA+IDEpIHtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgLSAyKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgdGhlIEludERpZmZFbmNvZGVyIGFuZCB0aGUgVWludE9wdFJsZUVuY29kZXIuXG4gKlxuICogVGhlIGNvdW50IGFwcHJvYWNoIGlzIHNpbWlsYXIgdG8gdGhlIFVpbnREaWZmT3B0UmxlRW5jb2RlciwgYnV0IGluc3RlYWQgb2YgdXNpbmcgdGhlIG5lZ2F0aXZlIGJpdGZsYWcsIGl0IGVuY29kZXNcbiAqIGluIHRoZSBMU0Igd2hldGhlciBhIGNvdW50IGlzIHRvIGJlIHJlYWQuIFRoZXJlZm9yZSB0aGlzIEVuY29kZXIgb25seSBzdXBwb3J0cyAzMSBiaXQgaW50ZWdlcnMhXG4gKlxuICogRW5jb2RlcyBbMSwgMiwgMywgMl0gYXMgWzMsIDEsIDYsIC0xXSAobW9yZSBzcGVjaWZpY2FsbHkgWygxIDw8IDEpIHwgMSwgKDMgPDwgMCkgfCAwLCAtMV0pXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy4gQ29udHJhcnkgdG8gbm9ybWFsIFVpbnRWYXIgZW5jb2RpbmcsIHRoZSBmaXJzdCBieXRlIGNvbnRhaW5zOlxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGUgbmV4dCB2YWx1ZSBpcyBhIGNvdW50IChMU0IpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgbmVnYXRpdmUgKE1TQiAtIDEpXG4gKiAqIDEgYml0IHRoYXQgZGVub3RlcyB3aGV0aGVyIHRvIGNvbnRpbnVlIHJlYWRpbmcgdGhlIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyIChNU0IpXG4gKlxuICogVGhlcmVmb3JlLCBvbmx5IGZpdmUgYml0cyByZW1haW4gdG8gZW5jb2RlIGRpZmYgcmFuZ2VzLlxuICpcbiAqIFVzZSB0aGlzIEVuY29kZXIgb25seSB3aGVuIGFwcHJvcHJpYXRlLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIHByb2JhYmx5IGEgYmFkIGlkZWEuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZcbiAgICovXG4gIHdyaXRlICh2KSB7XG4gICAgaWYgKHRoaXMuZGlmZiA9PT0gdiAtIHRoaXMucykge1xuICAgICAgdGhpcy5zID0gdlxuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIodGhpcylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICB0aGlzLmRpZmYgPSB2IC0gdGhpcy5zXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBPcHRpbWl6ZWQgU3RyaW5nIEVuY29kZXIuXG4gKlxuICogRW5jb2RpbmcgbWFueSBzbWFsbCBzdHJpbmdzIGluIGEgc2ltcGxlIEVuY29kZXIgaXMgbm90IHZlcnkgZWZmaWNpZW50LiBUaGUgZnVuY3Rpb24gY2FsbCB0byBkZWNvZGUgYSBzdHJpbmcgdGFrZXMgc29tZSB0aW1lIGFuZCBjcmVhdGVzIHJlZmVyZW5jZXMgdGhhdCBtdXN0IGJlIGV2ZW50dWFsbHkgZGVsZXRlZC5cbiAqIEluIHByYWN0aWNlLCB3aGVuIGRlY29kaW5nIHNldmVyYWwgbWlsbGlvbiBzbWFsbCBzdHJpbmdzLCB0aGUgR0Mgd2lsbCBraWNrIGluIG1vcmUgYW5kIG1vcmUgb2Z0ZW4gdG8gY29sbGVjdCBvcnBoYW5lZCBzdHJpbmcgb2JqZWN0cyAob3IgbWF5YmUgdGhlcmUgaXMgYW5vdGhlciByZWFzb24/KS5cbiAqXG4gKiBUaGlzIHN0cmluZyBlbmNvZGVyIHNvbHZlcyB0aGUgYWJvdmUgcHJvYmxlbS4gQWxsIHN0cmluZ3MgYXJlIGNvbmNhdGVuYXRlZCBhbmQgd3JpdHRlbiBhcyBhIHNpbmdsZSBzdHJpbmcgdXNpbmcgYSBzaW5nbGUgZW5jb2RpbmcgY2FsbC5cbiAqXG4gKiBUaGUgbGVuZ3RocyBhcmUgZW5jb2RlZCB1c2luZyBhIFVpbnRPcHRSbGVFbmNvZGVyLlxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnNhcnIgPSBbXVxuICAgIHRoaXMucyA9ICcnXG4gICAgdGhpcy5sZW5zRSA9IG5ldyBVaW50T3B0UmxlRW5jb2RlcigpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKi9cbiAgd3JpdGUgKHN0cmluZykge1xuICAgIHRoaXMucyArPSBzdHJpbmdcbiAgICBpZiAodGhpcy5zLmxlbmd0aCA+IDE5KSB7XG4gICAgICB0aGlzLnNhcnIucHVzaCh0aGlzLnMpXG4gICAgICB0aGlzLnMgPSAnJ1xuICAgIH1cbiAgICB0aGlzLmxlbnNFLndyaXRlKHN0cmluZy5sZW5ndGgpXG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgIHRoaXMucyA9ICcnXG4gICAgd3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgdGhpcy5zYXJyLmpvaW4oJycpKVxuICAgIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlbnNFLnRvVWludDhBcnJheSgpKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2RlcilcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/encoding.js\n");

/***/ }),

/***/ "../node_modules/lib0/environment.js":
/*!*******************************************!*\
  !*** ../node_modules/lib0/environment.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getConf\": () => (/* binding */ getConf),\n/* harmony export */   \"getParam\": () => (/* binding */ getParam),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"hasConf\": () => (/* binding */ hasConf),\n/* harmony export */   \"hasParam\": () => (/* binding */ hasParam),\n/* harmony export */   \"isBrowser\": () => (/* binding */ isBrowser),\n/* harmony export */   \"isMac\": () => (/* binding */ isMac),\n/* harmony export */   \"isNode\": () => (/* binding */ isNode),\n/* harmony export */   \"production\": () => (/* binding */ production),\n/* harmony export */   \"supportsColor\": () => (/* binding */ supportsColor)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"../node_modules/lib0/map.js\");\n/* harmony import */ var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./string.js */ \"../node_modules/lib0/string.js\");\n/* harmony import */ var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./conditions.js */ \"../node_modules/lib0/conditions.js\");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ \"../node_modules/lib0/storage.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./function.js */ \"../node_modules/lib0/function.js\");\n/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\n\n\n\n\n\n\n/* c8 ignore next */\n// @ts-ignore\nconst isNode = typeof process !== 'undefined' && process.release &&\n  /node|io\\.js/.test(process.release.name)\n/* c8 ignore next */\nconst isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !isNode\n/* c8 ignore next 3 */\nconst isMac = typeof navigator !== 'undefined'\n  ? /Mac/.test(navigator.platform)\n  : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* c8 ignore start */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n      const pargs = process.argv\n      let currParamName = null\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n      // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create(); // eslint-disable-next-line no-undef\n      (location.search || '?').slice(1).split('&').forEach((kv) => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n          params.set(`-${_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n    }\n  }\n  return params\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next */\nconst hasParam = (name) => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* c8 ignore next 2 */\nconst getParam = (name, defaultVal) =>\n  computeParams().get(name) || defaultVal\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 4 */\nconst getVariable = (name) =>\n  isNode\n    ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase()])\n    : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* c8 ignore next 2 */\nconst getConf = (name) =>\n  computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* c8 ignore next 2 */\nconst hasConf = (name) =>\n  hasParam('--' + name) || getVariable(name) !== null\n\n/* c8 ignore next */\nconst production = hasConf('production')\n\n/* c8 ignore next 2 */\nconst forceColor = isNode &&\n  _function_js__WEBPACK_IMPORTED_MODULE_4__.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])\n\n/* c8 ignore start */\nconst supportsColor = !hasParam('no-colors') &&\n  (!isNode || process.stdout.isTTY || forceColor) && (\n  !isNode || hasParam('color') || forceColor ||\n    getVariable('COLORTERM') !== null ||\n    (getVariable('TERM') || '').includes('color')\n)\n/* c8 ignore stop */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZW52aXJvbm1lbnQuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDTTtBQUNRO0FBQ047QUFDTDs7QUFFbEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSwyQ0FBVSxJQUFJO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBb0IsV0FBVztBQUN6RCx5QkFBeUIscURBQW9CLFdBQVc7QUFDeEQ7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGVBQWUsMkNBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDTztBQUNQO0FBQ0EsTUFBTSwyREFBMEI7QUFDaEMsTUFBTSwyREFBMEIsQ0FBQywyREFBMEI7O0FBRTNEO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsRUFBRSxpREFBUzs7QUFFWDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL2Vudmlyb25tZW50LmpzP2NkZDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSB0byB3b3JrIGFjY2VzcyB0aGUgZW52aXJvbm1lbnQgKHF1ZXJ5IHBhcmFtcywgZW52IHZhcmlhYmxlcykuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBjb25kaXRpb25zIGZyb20gJy4vY29uZGl0aW9ucy5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuaW1wb3J0ICogYXMgZiBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuLy8gQHRzLWlnbm9yZVxuZXhwb3J0IGNvbnN0IGlzTm9kZSA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLnJlbGVhc2UgJiZcbiAgL25vZGV8aW9cXC5qcy8udGVzdChwcm9jZXNzLnJlbGVhc2UubmFtZSlcbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhaXNOb2RlXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG5leHBvcnQgY29uc3QgaXNNYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICA6IGZhbHNlXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsc3RyaW5nPn1cbiAqL1xubGV0IHBhcmFtc1xuY29uc3QgYXJncyA9IFtdXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgY29tcHV0ZVBhcmFtcyA9ICgpID0+IHtcbiAgaWYgKHBhcmFtcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzTm9kZSkge1xuICAgICAgcGFyYW1zID0gbWFwLmNyZWF0ZSgpXG4gICAgICBjb25zdCBwYXJncyA9IHByb2Nlc3MuYXJndlxuICAgICAgbGV0IGN1cnJQYXJhbU5hbWUgPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmcgPSBwYXJnc1tpXVxuICAgICAgICBpZiAocGFyZ1swXSA9PT0gJy0nKSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgJycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJQYXJhbU5hbWUgPSBwYXJnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zZXQoY3VyclBhcmFtTmFtZSwgcGFyZylcbiAgICAgICAgICAgIGN1cnJQYXJhbU5hbWUgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChwYXJnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJQYXJhbU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCAnJylcbiAgICAgIH1cbiAgICAgIC8vIGluIFJlYWN0TmF0aXZlIGZvciBleGFtcGxlIHRoaXMgd291bGQgbm90IGJlIHRydWUgKHVubGVzcyBjb25uZWN0ZWQgdG8gdGhlIFJlbW90ZSBEZWJ1Z2dlcilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgICAobG9jYXRpb24uc2VhcmNoIHx8ICc/Jykuc2xpY2UoMSkuc3BsaXQoJyYnKS5mb3JFYWNoKChrdikgPT4ge1xuICAgICAgICBpZiAoa3YubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0ga3Yuc3BsaXQoJz0nKVxuICAgICAgICAgIHBhcmFtcy5zZXQoYC0tJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpXG4gICAgICAgICAgcGFyYW1zLnNldChgLSR7c3RyaW5nLmZyb21DYW1lbENhc2Uoa2V5LCAnLScpfWAsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBoYXNQYXJhbSA9IChuYW1lKSA9PiBjb21wdXRlUGFyYW1zKCkuaGFzKG5hbWUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZWZhdWx0VmFsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBnZXRQYXJhbSA9IChuYW1lLCBkZWZhdWx0VmFsKSA9PlxuICBjb21wdXRlUGFyYW1zKCkuZ2V0KG5hbWUpIHx8IGRlZmF1bHRWYWxcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDQgKi9cbmV4cG9ydCBjb25zdCBnZXRWYXJpYWJsZSA9IChuYW1lKSA9PlxuICBpc05vZGVcbiAgICA/IGNvbmRpdGlvbnMudW5kZWZpbmVkVG9OdWxsKHByb2Nlc3MuZW52W25hbWUudG9VcHBlckNhc2UoKV0pXG4gICAgOiBjb25kaXRpb25zLnVuZGVmaW5lZFRvTnVsbChzdG9yYWdlLnZhclN0b3JhZ2UuZ2V0SXRlbShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBnZXRDb25mID0gKG5hbWUpID0+XG4gIGNvbXB1dGVQYXJhbXMoKS5nZXQoJy0tJyArIG5hbWUpIHx8IGdldFZhcmlhYmxlKG5hbWUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBoYXNDb25mID0gKG5hbWUpID0+XG4gIGhhc1BhcmFtKCctLScgKyBuYW1lKSB8fCBnZXRWYXJpYWJsZShuYW1lKSAhPT0gbnVsbFxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHByb2R1Y3Rpb24gPSBoYXNDb25mKCdwcm9kdWN0aW9uJylcblxuLyogYzggaWdub3JlIG5leHQgMiAqL1xuY29uc3QgZm9yY2VDb2xvciA9IGlzTm9kZSAmJlxuICBmLmlzT25lT2YocHJvY2Vzcy5lbnYuRk9SQ0VfQ09MT1IsIFsndHJ1ZScsICcxJywgJzInXSlcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5leHBvcnQgY29uc3Qgc3VwcG9ydHNDb2xvciA9ICFoYXNQYXJhbSgnbm8tY29sb3JzJykgJiZcbiAgKCFpc05vZGUgfHwgcHJvY2Vzcy5zdGRvdXQuaXNUVFkgfHwgZm9yY2VDb2xvcikgJiYgKFxuICAhaXNOb2RlIHx8IGhhc1BhcmFtKCdjb2xvcicpIHx8IGZvcmNlQ29sb3IgfHxcbiAgICBnZXRWYXJpYWJsZSgnQ09MT1JURVJNJykgIT09IG51bGwgfHxcbiAgICAoZ2V0VmFyaWFibGUoJ1RFUk0nKSB8fCAnJykuaW5jbHVkZXMoJ2NvbG9yJylcbilcbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/environment.js\n");

/***/ }),

/***/ "../node_modules/lib0/error.js":
/*!*************************************!*\
  !*** ../node_modules/lib0/error.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"methodUnimplemented\": () => (/* binding */ methodUnimplemented),\n/* harmony export */   \"unexpectedCase\": () => (/* binding */ unexpectedCase)\n/* harmony export */ });\n/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* c8 ignore next */\nconst create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nconst methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* c8 ignore next 3 */\nconst unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZXJyb3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNPOztBQUVQO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaLFlBQVk7QUFDWjtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL2Vycm9yLmpzP2ZlNDUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFcnJvciBoZWxwZXJzLlxuICpcbiAqIEBtb2R1bGUgZXJyb3JcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtFcnJvcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSBzID0+IG5ldyBFcnJvcihzKVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbmV4cG9ydCBjb25zdCBtZXRob2RVbmltcGxlbWVudGVkID0gKCkgPT4ge1xuICB0aHJvdyBjcmVhdGUoJ01ldGhvZCB1bmltcGxlbWVudGVkJylcbn1cblxuLyoqXG4gKiBAdGhyb3dzIHtFcnJvcn1cbiAqIEByZXR1cm4ge25ldmVyfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG5leHBvcnQgY29uc3QgdW5leHBlY3RlZENhc2UgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnVW5leHBlY3RlZCBjYXNlJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/error.js\n");

/***/ }),

/***/ "../node_modules/lib0/eventloop.js":
/*!*****************************************!*\
  !*** ../node_modules/lib0/eventloop.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Animation\": () => (/* binding */ Animation),\n/* harmony export */   \"animationFrame\": () => (/* binding */ animationFrame),\n/* harmony export */   \"createDebouncer\": () => (/* binding */ createDebouncer),\n/* harmony export */   \"enqueue\": () => (/* binding */ enqueue),\n/* harmony export */   \"idleCallback\": () => (/* binding */ idleCallback),\n/* harmony export */   \"interval\": () => (/* binding */ interval),\n/* harmony export */   \"timeout\": () => (/* binding */ timeout)\n/* harmony export */ });\n/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nconst enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nconst interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* c8 ignore next */\nconst Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg))\n\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next */\nconst animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* c8 ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg))\n\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n/* c8 ignore next 2 */\n// @ts-ignore\nconst idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nconst createDebouncer = timeout => {\n  let timer = -1\n  return f => {\n    clearTimeout(timer)\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZXZlbnRsb29wLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxVQUFVO0FBQ3hCOztBQUVBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDTzs7QUFFUDtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLO0FBQzlCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9ldmVudGxvb3AuanM/NDA4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgcmVxdWVzdElkbGVDYWxsYmFjaywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWxJZGxlQ2FsbGJhY2ssIGNhbmNlbEFuaW1hdGlvbkZyYW1lICovXG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIEVjbWFTY3JpcHQncyBldmVudCBsb29wLlxuICpcbiAqIEBtb2R1bGUgZXZlbnRsb29wXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fVxuICovXG5sZXQgcXVldWUgPSBbXVxuXG5jb25zdCBfcnVuUXVldWUgPSAoKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICBxdWV1ZVtpXSgpXG4gIH1cbiAgcXVldWUgPSBbXVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBmXG4gKi9cbmV4cG9ydCBjb25zdCBlbnF1ZXVlID0gZiA9PiB7XG4gIHF1ZXVlLnB1c2goZilcbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSkge1xuICAgIHNldFRpbWVvdXQoX3J1blF1ZXVlLCAwKVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVGltZW91dE9iamVjdFxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gVGltZW91dE9iamVjdC5kZXN0cm95XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gY2xlYXJGdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVUaW1lb3V0Q2xhc3MgPSBjbGVhckZ1bmN0aW9uID0+IGNsYXNzIFRUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0SWRcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0aW1lb3V0SWQpIHtcbiAgICB0aGlzLl8gPSB0aW1lb3V0SWRcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGNsZWFyRnVuY3Rpb24odGhpcy5fKVxuICB9XG59XG5cbmNvbnN0IFRpbWVvdXQgPSBjcmVhdGVUaW1lb3V0Q2xhc3MoY2xlYXJUaW1lb3V0KVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7VGltZW91dE9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IHRpbWVvdXQgPSAodGltZW91dCwgY2FsbGJhY2spID0+IG5ldyBUaW1lb3V0KHNldFRpbWVvdXQoY2FsbGJhY2ssIHRpbWVvdXQpKVxuXG5jb25zdCBJbnRlcnZhbCA9IGNyZWF0ZVRpbWVvdXRDbGFzcyhjbGVhckludGVydmFsKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7VGltZW91dE9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGludGVydmFsID0gKHRpbWVvdXQsIGNhbGxiYWNrKSA9PiBuZXcgSW50ZXJ2YWwoc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIHRpbWVvdXQpKVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IEFuaW1hdGlvbiA9IGNyZWF0ZVRpbWVvdXRDbGFzcyhhcmcgPT4gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYXJnKSlcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlcik6dm9pZH0gY2JcbiAqIEByZXR1cm4ge1RpbWVvdXRPYmplY3R9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgYW5pbWF0aW9uRnJhbWUgPSBjYiA9PiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAndW5kZWZpbmVkJyA/IHRpbWVvdXQoMCwgY2IpIDogbmV3IEFuaW1hdGlvbihyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpKVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgSWRsZSA9IGNyZWF0ZVRpbWVvdXRDbGFzcyhhcmcgPT4gdHlwZW9mIGNhbmNlbElkbGVDYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FuY2VsSWRsZUNhbGxiYWNrKGFyZykpXG5cbi8qKlxuICogTm90ZTogdGhpcyBpcyBleHBlcmltZW50YWwgYW5kIGlzIHByb2JhYmx5IG9ubHkgdXNlZnVsIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gKiBAcmV0dXJuIHtUaW1lb3V0T2JqZWN0fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgaWRsZUNhbGxiYWNrID0gY2IgPT4gdHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICd1bmRlZmluZWQnID8gbmV3IElkbGUocmVxdWVzdElkbGVDYWxsYmFjayhjYikpIDogdGltZW91dCgxMDAwLCBjYilcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dCBUaW1lb3V0IG9mIHRoZSBkZWJvdW5jZSBhY3Rpb25cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKGZ1bmN0aW9uKCk6dm9pZCk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlYm91bmNlciA9IHRpbWVvdXQgPT4ge1xuICBsZXQgdGltZXIgPSAtMVxuICByZXR1cm4gZiA9PiB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgIGlmIChmKSB7XG4gICAgICB0aW1lciA9IC8qKiBAdHlwZSB7YW55fSAqLyAoc2V0VGltZW91dChmLCB0aW1lb3V0KSlcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/eventloop.js\n");

/***/ }),

/***/ "../node_modules/lib0/function.js":
/*!****************************************!*\
  !*** ../node_modules/lib0/function.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"apply\": () => (/* binding */ apply),\n/* harmony export */   \"callAll\": () => (/* binding */ callAll),\n/* harmony export */   \"equalityDeep\": () => (/* binding */ equalityDeep),\n/* harmony export */   \"equalityFlat\": () => (/* binding */ equalityFlat),\n/* harmony export */   \"equalityStrict\": () => (/* binding */ equalityStrict),\n/* harmony export */   \"id\": () => (/* binding */ id),\n/* harmony export */   \"is\": () => (/* binding */ is),\n/* harmony export */   \"isArray\": () => (/* binding */ isArray),\n/* harmony export */   \"isNumber\": () => (/* binding */ isNumber),\n/* harmony export */   \"isOneOf\": () => (/* binding */ isOneOf),\n/* harmony export */   \"isString\": () => (/* binding */ isString),\n/* harmony export */   \"isTemplate\": () => (/* binding */ isTemplate),\n/* harmony export */   \"nop\": () => (/* binding */ nop)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"../node_modules/lib0/array.js\");\n/* harmony import */ var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./object.js */ \"../node_modules/lib0/object.js\");\n/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\n\n\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nconst callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nconst nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nconst apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nconst id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nconst equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nconst equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((_array_js__WEBPACK_IMPORTED_MODULE_0__.isArray(a) && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b))))\n\n/* c8 ignore start */\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (_object_js__WEBPACK_IMPORTED_MODULE_1__.length(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n\n/**\n * @template V\n * @template {V} OPTS\n *\n * @param {V} value\n * @param {Array<OPTS>} options\n */\n// @ts-ignore\nconst isOneOf = (value, options) => options.includes(value)\n/* c8 ignore stop */\n\nconst isArray = _array_js__WEBPACK_IMPORTED_MODULE_0__.isArray\n\n/**\n * @param {any} s\n * @return {s is String}\n */\nconst isString = (s) => s && s.constructor === String\n\n/**\n * @param {any} n\n * @return {n is Number}\n */\nconst isNumber = n => n != null && n.constructor === Number\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {any} n\n * @param {TYPE} T\n * @return {n is InstanceType<TYPE>}\n */\nconst is = (n, T) => n && n.constructor === T\n\n/**\n * @template {abstract new (...args: any) => any} TYPE\n * @param {TYPE} T\n */\nconst isTemplate = (T) =>\n  /**\n   * @param {any} n\n   * @return {n is InstanceType<TYPE>}\n   **/\n  n => n && n.constructor === T\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUM7QUFDRTs7QUFFckM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxZQUFZO0FBQ3ZCO0FBQ087QUFDUDtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87O0FBRVA7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDTywwR0FBMEcsOENBQWEsT0FBTyxnREFBZSxlQUFlLFVBQVUsc0NBQXNDLGlEQUFnQjs7QUFFbk87O0FBRUE7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOENBQWEsUUFBUSw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsR0FBRztBQUNqQjtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ087QUFDUDs7QUFFTyxnQkFBZ0IsOENBQWE7O0FBRXBDO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0EsY0FBYyxvQ0FBb0M7QUFDbEQsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLGNBQWMsb0NBQW9DO0FBQ2xELFdBQVcsTUFBTTtBQUNqQjtBQUNPO0FBQ1A7QUFDQSxhQUFhLEtBQUs7QUFDbEIsY0FBYztBQUNkO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvZnVuY3Rpb24uanM/NzFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgYW5kIGZ1bmN0aW9uIGNhbGwgaGVscGVycy5cbiAqXG4gKiBAbW9kdWxlIGZ1bmN0aW9uXG4gKi9cblxuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICcuL29iamVjdC5qcydcblxuLyoqXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGluIGBmc2Agd2l0aCBhcmdzLiBPbmx5IHRocm93cyBhZnRlciBhbGwgZnVuY3Rpb25zIHdlcmUgY2FsbGVkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24+fSBmc1xuICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsQWxsID0gKGZzLCBhcmdzLCBpID0gMCkgPT4ge1xuICB0cnkge1xuICAgIGZvciAoOyBpIDwgZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZzW2ldKC4uLmFyZ3MpXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpIDwgZnMubGVuZ3RoKSB7XG4gICAgICBjYWxsQWxsKGZzLCBhcmdzLCBpICsgMSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG5vcCA9ICgpID0+IHt9XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpUfSBmXG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgYXBwbHkgPSBmID0+IGYoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKlxuICogQHBhcmFtIHtBfSBhXG4gKiBAcmV0dXJuIHtBfVxuICovXG5leHBvcnQgY29uc3QgaWQgPSBhID0+IGFcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7VH0gYVxuICogQHBhcmFtIHtUfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlTdHJpY3QgPSAoYSwgYikgPT4gYSA9PT0gYlxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKlxuICogQHBhcmFtIHtBcnJheTxUPnxvYmplY3R9IGFcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlGbGF0ID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT0gbnVsbCAmJiBiICE9IG51bGwgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYi5jb25zdHJ1Y3RvciAmJiAoKGFycmF5LmlzQXJyYXkoYSkgJiYgYXJyYXkuZXF1YWxGbGF0KGEsIC8qKiBAdHlwZSB7QXJyYXk8VD59ICovIChiKSkpIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSkpKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbGl0eURlZXAgPSAoYSwgYikgPT4ge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgIHJldHVybiBlcXVhbGl0eVN0cmljdChhLCBiKVxuICB9XG4gIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHN3aXRjaCAoYS5jb25zdHJ1Y3Rvcikge1xuICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICBhID0gbmV3IFVpbnQ4QXJyYXkoYSlcbiAgICAgIGIgPSBuZXcgVWludDhBcnJheShiKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgIGNhc2UgVWludDhBcnJheToge1xuICAgICAgaWYgKGEuYnl0ZUxlbmd0aCAhPT0gYi5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgU2V0OiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY2FzZSBNYXA6IHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGEua2V5cygpKSB7XG4gICAgICAgIGlmICghYi5oYXMoa2V5KSB8fCAhZXF1YWxpdHlEZWVwKGEuZ2V0KGtleSksIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgT2JqZWN0OlxuICAgICAgaWYgKG9iamVjdC5sZW5ndGgoYSkgIT09IG9iamVjdC5sZW5ndGgoYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBhKSB7XG4gICAgICAgIGlmICghb2JqZWN0Lmhhc1Byb3BlcnR5KGEsIGtleSkgfHwgIWVxdWFsaXR5RGVlcChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlIEFycmF5OlxuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIWVxdWFsaXR5RGVlcChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAdGVtcGxhdGUge1Z9IE9QVFNcbiAqXG4gKiBAcGFyYW0ge1Z9IHZhbHVlXG4gKiBAcGFyYW0ge0FycmF5PE9QVFM+fSBvcHRpb25zXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBpc09uZU9mID0gKHZhbHVlLCBvcHRpb25zKSA9PiBvcHRpb25zLmluY2x1ZGVzKHZhbHVlKVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuZXhwb3J0IGNvbnN0IGlzQXJyYXkgPSBhcnJheS5pc0FycmF5XG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge3MgaXMgU3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgaXNTdHJpbmcgPSAocykgPT4gcyAmJiBzLmNvbnN0cnVjdG9yID09PSBTdHJpbmdcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gblxuICogQHJldHVybiB7biBpcyBOdW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBpc051bWJlciA9IG4gPT4gbiAhPSBudWxsICYmIG4uY29uc3RydWN0b3IgPT09IE51bWJlclxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7YWJzdHJhY3QgbmV3ICguLi5hcmdzOiBhbnkpID0+IGFueX0gVFlQRVxuICogQHBhcmFtIHthbnl9IG5cbiAqIEBwYXJhbSB7VFlQRX0gVFxuICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gKi9cbmV4cG9ydCBjb25zdCBpcyA9IChuLCBUKSA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcblxuLyoqXG4gKiBAdGVtcGxhdGUge2Fic3RyYWN0IG5ldyAoLi4uYXJnczogYW55KSA9PiBhbnl9IFRZUEVcbiAqIEBwYXJhbSB7VFlQRX0gVFxuICovXG5leHBvcnQgY29uc3QgaXNUZW1wbGF0ZSA9IChUKSA9PlxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG5cbiAgICogQHJldHVybiB7biBpcyBJbnN0YW5jZVR5cGU8VFlQRT59XG4gICAqKi9cbiAgbiA9PiBuICYmIG4uY29uc3RydWN0b3IgPT09IFRcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/function.js\n");

/***/ }),

/***/ "../node_modules/lib0/iterator.js":
/*!****************************************!*\
  !*** ../node_modules/lib0/iterator.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createIterator\": () => (/* binding */ createIterator),\n/* harmony export */   \"iteratorFilter\": () => (/* binding */ iteratorFilter),\n/* harmony export */   \"iteratorMap\": () => (/* binding */ iteratorMap),\n/* harmony export */   \"mapIterator\": () => (/* binding */ mapIterator)\n/* harmony export */ });\n/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nconst mapIterator = (iterator, f) => ({\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nconst createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nconst iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nconst iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvaXRlcmF0b3IuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGVBQWU7QUFDMUIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsV0FBVyxxQkFBcUI7QUFDaEM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLGVBQWU7QUFDMUI7QUFDTztBQUNQLFVBQVUsY0FBYztBQUN4QixXQUFXO0FBQ1gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9pdGVyYXRvci5qcz81NWJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gY3JlYXRlIGFuZCBtYW5pcHVsYXRlIEl0ZXJhdG9ycy5cbiAqXG4gKiBAbW9kdWxlIGl0ZXJhdG9yXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVCxSXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpSfSBmXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFI+fVxuICovXG5leHBvcnQgY29uc3QgbWFwSXRlcmF0b3IgPSAoaXRlcmF0b3IsIGYpID0+ICh7XG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvLyBAdHMtaWdub3JlXG4gIG5leHQgKCkge1xuICAgIGNvbnN0IHIgPSBpdGVyYXRvci5uZXh0KClcbiAgICByZXR1cm4geyB2YWx1ZTogci5kb25lID8gdW5kZWZpbmVkIDogZihyLnZhbHVlKSwgZG9uZTogci5kb25lIH1cbiAgfVxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtmdW5jdGlvbigpOkl0ZXJhdG9yUmVzdWx0PFQ+fSBuZXh0XG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSXRlcmF0b3IgPSBuZXh0ID0+ICh7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgbmV4dFxufSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6Ym9vbGVhbn0gZmlsdGVyXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRvckZpbHRlciA9IChpdGVyYXRvciwgZmlsdGVyKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGxldCByZXNcbiAgZG8ge1xuICAgIHJlcyA9IGl0ZXJhdG9yLm5leHQoKVxuICB9IHdoaWxlICghcmVzLmRvbmUgJiYgIWZpbHRlcihyZXMudmFsdWUpKVxuICByZXR1cm4gcmVzXG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULE1cbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IGZtYXBcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yTWFwID0gKGl0ZXJhdG9yLCBmbWFwKSA9PiBjcmVhdGVJdGVyYXRvcigoKSA9PiB7XG4gIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGl0ZXJhdG9yLm5leHQoKVxuICByZXR1cm4geyBkb25lLCB2YWx1ZTogZG9uZSA/IHVuZGVmaW5lZCA6IGZtYXAodmFsdWUpIH1cbn0pXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/iterator.js\n");

/***/ }),

/***/ "../node_modules/lib0/json.js":
/*!************************************!*\
  !*** ../node_modules/lib0/json.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse),\n/* harmony export */   \"stringify\": () => (/* binding */ stringify)\n/* harmony export */ });\n/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nconst stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nconst parse = JSON.parse\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9qc29uLmpzP2I4MTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBKU09OIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBtb2R1bGUganNvblxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgb2JqZWN0IHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnlcblxuLyoqXG4gKiBQYXJzZSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvblxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/json.js\n");

/***/ }),

/***/ "../node_modules/lib0/logging.common.js":
/*!**********************************************!*\
  !*** ../node_modules/lib0/logging.common.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BLUE\": () => (/* binding */ BLUE),\n/* harmony export */   \"BOLD\": () => (/* binding */ BOLD),\n/* harmony export */   \"GREEN\": () => (/* binding */ GREEN),\n/* harmony export */   \"GREY\": () => (/* binding */ GREY),\n/* harmony export */   \"ORANGE\": () => (/* binding */ ORANGE),\n/* harmony export */   \"PURPLE\": () => (/* binding */ PURPLE),\n/* harmony export */   \"RED\": () => (/* binding */ RED),\n/* harmony export */   \"UNBOLD\": () => (/* binding */ UNBOLD),\n/* harmony export */   \"UNCOLOR\": () => (/* binding */ UNCOLOR),\n/* harmony export */   \"computeNoColorLoggingArgs\": () => (/* binding */ computeNoColorLoggingArgs),\n/* harmony export */   \"createModuleLogger\": () => (/* binding */ createModuleLogger)\n/* harmony export */ });\n/* harmony import */ var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbol.js */ \"../node_modules/lib0/symbol.js\");\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time.js */ \"../node_modules/lib0/time.js\");\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./environment.js */ \"../node_modules/lib0/environment.js\");\n/* harmony import */ var _function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./function.js */ \"../node_modules/lib0/function.js\");\n\n\n\n\n\nconst BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\nconst UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create()\n\n/* c8 ignore start */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNoColorLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (arg.constructor === String || arg.constructor === Number) {\n      strBuilder.push(arg)\n    } else if (arg.constructor === Object) {\n      logArgs.push(JSON.stringify(arg))\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n\n/* c8 ignore start */\n/**\n * @param {function(...any):void} _print\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = (_print, moduleName) => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_2__.getVariable('log')\n  const doLogging = debugRegexVar !== null &&\n    (debugRegexVar === '*' || debugRegexVar === 'true' ||\n      new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n  return !doLogging\n    ? _function_js__WEBPACK_IMPORTED_MODULE_3__.nop\n    : (...args) => {\n      const timeNow = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n      const timeDiff = timeNow - lastLoggingTime\n      lastLoggingTime = timeNow\n      _print(\n        color,\n        moduleName,\n        UNCOLOR,\n        ...args.map((arg) =>\n          (typeof arg === 'string' || typeof arg === 'symbol')\n            ? arg\n            : JSON.stringify(arg)\n        ),\n        color,\n        ' +' + timeDiff + 'ms'\n      )\n    }\n}\n/* c8 ignore stop */\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5jb21tb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFDO0FBQ0o7QUFDTTtBQUNGOztBQUU5QixhQUFhLDhDQUFhO0FBQzFCLGVBQWUsOENBQWE7QUFDNUIsYUFBYSw4Q0FBYTtBQUMxQixhQUFhLDhDQUFhO0FBQzFCLGNBQWMsOENBQWE7QUFDM0IsWUFBWSw4Q0FBYTtBQUN6QixlQUFlLDhDQUFhO0FBQzVCLGVBQWUsOENBQWE7QUFDNUIsZ0JBQWdCLDhDQUFhOztBQUVwQztBQUNBO0FBQ0EsV0FBVyxvQ0FBb0M7QUFDL0MsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixpREFBZ0I7O0FBRXRDO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBLHdCQUF3Qix3REFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDZDQUFRO0FBQ2Q7QUFDQSxzQkFBc0IsaURBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5jb21tb24uanM/ZmZjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzeW1ib2wgZnJvbSAnLi9zeW1ib2wuanMnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJy4vdGltZS5qcydcbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgZnVuYyBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG5leHBvcnQgY29uc3QgQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IFVOQk9MRCA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEJMVUUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBHUkVZID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFRU4gPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBSRUQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBQVVJQTEUgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBPUkFOR0UgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkNPTE9SID0gc3ltYm9sLmNyZWF0ZSgpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqIEByZXR1cm4ge0FycmF5PHN0cmluZ3xvYmplY3R8bnVtYmVyPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvbXB1dGVOb0NvbG9yTG9nZ2luZ0FyZ3MgPSBhcmdzID0+IHtcbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChKU09OLnN0cmluZ2lmeShhcmcpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuY29uc3QgbG9nZ2luZ0NvbG9ycyA9IFtHUkVFTiwgUFVSUExFLCBPUkFOR0UsIEJMVUVdXG5sZXQgbmV4dENvbG9yID0gMFxubGV0IGxhc3RMb2dnaW5nVGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9IF9wcmludFxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IChfcHJpbnQsIG1vZHVsZU5hbWUpID0+IHtcbiAgY29uc3QgY29sb3IgPSBsb2dnaW5nQ29sb3JzW25leHRDb2xvcl1cbiAgY29uc3QgZGVidWdSZWdleFZhciA9IGVudi5nZXRWYXJpYWJsZSgnbG9nJylcbiAgY29uc3QgZG9Mb2dnaW5nID0gZGVidWdSZWdleFZhciAhPT0gbnVsbCAmJlxuICAgIChkZWJ1Z1JlZ2V4VmFyID09PSAnKicgfHwgZGVidWdSZWdleFZhciA9PT0gJ3RydWUnIHx8XG4gICAgICBuZXcgUmVnRXhwKGRlYnVnUmVnZXhWYXIsICdnaScpLnRlc3QobW9kdWxlTmFtZSkpXG4gIG5leHRDb2xvciA9IChuZXh0Q29sb3IgKyAxKSAlIGxvZ2dpbmdDb2xvcnMubGVuZ3RoXG4gIG1vZHVsZU5hbWUgKz0gJzogJ1xuICByZXR1cm4gIWRvTG9nZ2luZ1xuICAgID8gZnVuYy5ub3BcbiAgICA6ICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCB0aW1lTm93ID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCB0aW1lRGlmZiA9IHRpbWVOb3cgLSBsYXN0TG9nZ2luZ1RpbWVcbiAgICAgIGxhc3RMb2dnaW5nVGltZSA9IHRpbWVOb3dcbiAgICAgIF9wcmludChcbiAgICAgICAgY29sb3IsXG4gICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgIFVOQ09MT1IsXG4gICAgICAgIC4uLmFyZ3MubWFwKChhcmcpID0+XG4gICAgICAgICAgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnKVxuICAgICAgICAgICAgPyBhcmdcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoYXJnKVxuICAgICAgICApLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgJyArJyArIHRpbWVEaWZmICsgJ21zJ1xuICAgICAgKVxuICAgIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/logging.common.js\n");

/***/ }),

/***/ "../node_modules/lib0/logging.js":
/*!***************************************!*\
  !*** ../node_modules/lib0/logging.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"BLUE\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BLUE),\n/* harmony export */   \"BOLD\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD),\n/* harmony export */   \"GREEN\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREEN),\n/* harmony export */   \"GREY\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREY),\n/* harmony export */   \"ORANGE\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE),\n/* harmony export */   \"PURPLE\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.PURPLE),\n/* harmony export */   \"RED\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED),\n/* harmony export */   \"UNBOLD\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNBOLD),\n/* harmony export */   \"UNCOLOR\": () => (/* reexport safe */ _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNCOLOR),\n/* harmony export */   \"VConsole\": () => (/* binding */ VConsole),\n/* harmony export */   \"createModuleLogger\": () => (/* binding */ createModuleLogger),\n/* harmony export */   \"createVConsole\": () => (/* binding */ createVConsole),\n/* harmony export */   \"group\": () => (/* binding */ group),\n/* harmony export */   \"groupCollapsed\": () => (/* binding */ groupCollapsed),\n/* harmony export */   \"groupEnd\": () => (/* binding */ groupEnd),\n/* harmony export */   \"print\": () => (/* binding */ print),\n/* harmony export */   \"printCanvas\": () => (/* binding */ printCanvas),\n/* harmony export */   \"printDom\": () => (/* binding */ printDom),\n/* harmony export */   \"printError\": () => (/* binding */ printError),\n/* harmony export */   \"printImg\": () => (/* binding */ printImg),\n/* harmony export */   \"printImgBase64\": () => (/* binding */ printImgBase64),\n/* harmony export */   \"vconsoles\": () => (/* binding */ vconsoles),\n/* harmony export */   \"warn\": () => (/* binding */ warn)\n/* harmony export */ });\n/* harmony import */ var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./environment.js */ \"../node_modules/lib0/environment.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./set.js */ \"../node_modules/lib0/set.js\");\n/* harmony import */ var _pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pair.js */ \"../node_modules/lib0/pair.js\");\n/* harmony import */ var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom.js */ \"../node_modules/lib0/dom.js\");\n/* harmony import */ var _json_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./json.js */ \"../node_modules/lib0/json.js\");\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map.js */ \"../node_modules/lib0/map.js\");\n/* harmony import */ var _eventloop_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./eventloop.js */ \"../node_modules/lib0/eventloop.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var _logging_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging.common.js */ \"../node_modules/lib0/logging.common.js\");\n/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'bold'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNBOLD]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'normal'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BLUE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'blue'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREEN]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'green'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREY]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'grey'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'red'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.PURPLE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'purple'),\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNCOLOR]: _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'black')\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\n/* c8 ignore start */\nconst computeBrowserLoggingArgs = (args) => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_2__.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n/* c8 ignore stop */\n\n/* c8 ignore start */\nconst computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_4__.supportsColor\n  ? computeBrowserLoggingArgs\n  : _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.computeNoColorLoggingArgs\n/* c8 ignore stop */\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.print(args))\n}\n\n/* c8 ignore start */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE)\n  vconsoles.forEach((vc) => vc.print(args))\n}\n/* c8 ignore stop */\n\n/**\n * @param {Error} err\n */\n/* c8 ignore start */\nconst printError = (err) => {\n  console.error(err)\n  vconsoles.forEach((vc) => vc.printError(err))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\n/* c8 ignore start */\nconst printImg = (url, height) => {\n  if (_environment_js__WEBPACK_IMPORTED_MODULE_4__.isBrowser) {\n    console.log(\n      '%c                      ',\n      `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`\n    )\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach((vc) => vc.printImg(url, height))\n}\n/* c8 ignore stop */\n\n/**\n * @param {string} base64\n * @param {number} height\n */\n/* c8 ignore next 2 */\nconst printImgBase64 = (base64, height) =>\n  printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nconst groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupCollapsed(args))\n}\n\nconst groupEnd = () => {\n  console.groupEnd()\n  /* c8 ignore next */\n  vconsoles.forEach((vc) => vc.groupEnd())\n}\n\n/**\n * @param {function():Node} createNode\n */\n/* c8 ignore next 2 */\nconst printDom = (createNode) =>\n  vconsoles.forEach((vc) => vc.printDom(createNode()))\n\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\n/* c8 ignore next 2 */\nconst printCanvas = (canvas, height) =>\n  printImg(canvas.toDataURL(), height)\n\nconst vconsoles = _set_js__WEBPACK_IMPORTED_MODULE_5__.create()\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\n/* c8 ignore start */\nconst _computeLineSpans = (args) => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))\n        ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg.toString())])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_6__.stringify(content) + ' '\n      }\n      spans.push(\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(/** @type {string} */ (content))])\n      )\n    }\n  }\n  return spans\n}\n/* c8 ignore stop */\n\nconst lineStyle =\n  'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* c8 ignore start */\nclass VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      const triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed),\n        _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:120%;')\n      ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')])\n      const triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', !collapsed),\n        _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:125%;')\n      ], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')])\n      const content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element(\n        'div',\n        [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create(\n          'style',\n          `${lineStyle};padding-left:${this.depth * 10}px`\n        )],\n        [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(\n          _computeLineSpans(args)\n        )\n      )\n      const nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [\n        _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed)\n      ])\n      const nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer])\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', (_event) => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_1__.create(\n            'style',\n            `${lineStyle};padding-left:${this.depth * 10}px`\n          )\n        ], _computeLineSpans(args))\n      ])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [\n        _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [\n          _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('src', url),\n          _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('height', `${_math_js__WEBPACK_IMPORTED_MODULE_8__.round(height * 1.5)}px`)\n        ])\n      ])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @param {Element} dom\n */\n/* c8 ignore next */\nconst createVConsole = (dom) => new VConsole(dom)\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nconst createModuleLogger = (moduleName) => _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.createModuleLogger(print, moduleName)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxhQUFhLG9DQUFvQztBQUNqRDtBQUNBO0FBQ0EsSUFBSSxrREFBaUI7QUFDckIsTUFBTSwyQ0FBVTtBQUNoQixRQUFRLDRDQUFXO0FBQ25CLFVBQVUsNENBQVc7QUFDckI7QUFDQSxlQUFlLFdBQVcsZUFBZSxnQkFBZ0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxnQkFBZ0IsbURBQVUsRUFBRSxvREFBVztBQUN2Qzs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLElBQUksa0RBQWlCO0FBQ3JCLE1BQU0sMkNBQVU7QUFDaEIsUUFBUSw0Q0FBVztBQUNuQixVQUFVLDRDQUFXO0FBQ3JCLFVBQVUsNENBQVcsY0FBYywyQ0FBVSxlQUFlO0FBQzVEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBLElBQUksa0RBQWlCO0FBQ3JCLE1BQU0sMkNBQVU7QUFDaEIsS0FBSztBQUNMOztBQUVBO0FBQ0EsSUFBSSxrREFBaUI7QUFDckI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTywyQ0FBMkMsa0VBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL2xvZ2dpbmcuanM/MDgyMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIElzb21vcnBoaWMgbG9nZ2luZyBtb2R1bGUgd2l0aCBzdXBwb3J0IGZvciBjb2xvcnMhXG4gKlxuICogQG1vZHVsZSBsb2dnaW5nXG4gKi9cblxuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJy4vcGFpci5qcydcbmltcG9ydCAqIGFzIGRvbSBmcm9tICcuL2RvbS5qcydcbmltcG9ydCAqIGFzIGpzb24gZnJvbSAnLi9qc29uLmpzJ1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgZXZlbnRsb29wIGZyb20gJy4vZXZlbnRsb29wLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBjb21tb24gZnJvbSAnLi9sb2dnaW5nLmNvbW1vbi5qcydcblxuZXhwb3J0IHsgQk9MRCwgVU5CT0xELCBCTFVFLCBHUkVZLCBHUkVFTiwgUkVELCBQVVJQTEUsIE9SQU5HRSwgVU5DT0xPUiB9IGZyb20gJy4vbG9nZ2luZy5jb21tb24uanMnXG5cbi8qKlxuICogQHR5cGUge09iamVjdDxTeW1ib2wscGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn1cbiAqL1xuY29uc3QgX2Jyb3dzZXJTdHlsZU1hcCA9IHtcbiAgW2NvbW1vbi5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ2JvbGQnKSxcbiAgW2NvbW1vbi5VTkJPTERdOiBwYWlyLmNyZWF0ZSgnZm9udC13ZWlnaHQnLCAnbm9ybWFsJyksXG4gIFtjb21tb24uQkxVRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibHVlJyksXG4gIFtjb21tb24uR1JFRU5dOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnZ3JlZW4nKSxcbiAgW2NvbW1vbi5HUkVZXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZXknKSxcbiAgW2NvbW1vbi5SRURdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAncmVkJyksXG4gIFtjb21tb24uUFVSUExFXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3B1cnBsZScpLFxuICBbY29tbW9uLk9SQU5HRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdvcmFuZ2UnKSwgLy8gbm90IHdlbGwgc3VwcG9ydGVkIGluIGNocm9tZSB3aGVuIGRlYnVnZ2luZyBub2RlIHdpdGggaW5zcGVjdG9yIC0gVE9ETzogZGVwcmVjYXRlXG4gIFtjb21tb24uVU5DT0xPUl06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdibGFjaycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8b2JqZWN0fG51bWJlcj59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJncyA9IChhcmdzKSA9PiB7XG4gIGNvbnN0IHN0ckJ1aWxkZXIgPSBbXVxuICBjb25zdCBzdHlsZXMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBtYXAuY3JlYXRlKClcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxzdHJpbmd8T2JqZWN0fG51bWJlcj59XG4gICAqL1xuICBsZXQgbG9nQXJncyA9IFtdXG4gIC8vIHRyeSB3aXRoIGZvcm1hdHRpbmcgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdW5zdXBwb3J0ZWRcbiAgbGV0IGkgPSAwXG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfYnJvd3NlclN0eWxlTWFwW2FyZ11cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9tLm1hcFRvU3R5bGVTdHJpbmcoY3VycmVudFN0eWxlKVxuICAgICAgICBpZiAoaSA+IDAgfHwgc3R5bGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaCgnJWMnICsgYXJnKVxuICAgICAgICAgIHN0eWxlcy5wdXNoKHN0eWxlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ckJ1aWxkZXIucHVzaChhcmcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChpID4gMCkge1xuICAgIC8vIGNyZWF0ZSBsb2dBcmdzIHdpdGggd2hhdCB3ZSBoYXZlIHNvIGZhclxuICAgIGxvZ0FyZ3MgPSBzdHlsZXNcbiAgICBsb2dBcmdzLnVuc2hpZnQoc3RyQnVpbGRlci5qb2luKCcnKSlcbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIGlmICghKGFyZyBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGxvZ0FyZ3MucHVzaChhcmcpXG4gICAgfVxuICB9XG4gIHJldHVybiBsb2dBcmdzXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVMb2dnaW5nQXJncyA9IGVudi5zdXBwb3J0c0NvbG9yXG4gID8gY29tcHV0ZUJyb3dzZXJMb2dnaW5nQXJnc1xuICA6IGNvbW1vbi5jb21wdXRlTm9Db2xvckxvZ2dpbmdBcmdzXG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgcHJpbnQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnQoYXJncykpXG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHdhcm4gPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLndhcm4oLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICBhcmdzLnVuc2hpZnQoY29tbW9uLk9SQU5HRSlcbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludChhcmdzKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50RXJyb3IgPSAoZXJyKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZXJyKVxuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLnByaW50RXJyb3IoZXJyKSlcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBpbWFnZSBsb2NhdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgdGhlIGltYWdlIGluIHBpeGVsXG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nID0gKHVybCwgaGVpZ2h0KSA9PiB7XG4gIGlmIChlbnYuaXNCcm93c2VyKSB7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAnJWMgICAgICAgICAgICAgICAgICAgICAgJyxcbiAgICAgIGBmb250LXNpemU6ICR7aGVpZ2h0fXB4OyBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47IGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7IGJhY2tncm91bmQtaW1hZ2U6IHVybCgke3VybH0pYFxuICAgIClcbiAgICAvLyBjb25zb2xlLmxvZygnJWMgICAgICAgICAgICAgICAgJywgYGZvbnQtc2l6ZTogJHtoZWlnaHR9eDsgYmFja2dyb3VuZDogdXJsKCR7dXJsfSkgbm8tcmVwZWF0O2ApXG4gIH1cbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludEltZyh1cmwsIGhlaWdodCkpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50SW1nQmFzZTY0ID0gKGJhc2U2NCwgaGVpZ2h0KSA9PlxuICBwcmludEltZyhgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YmFzZTY0fWAsIGhlaWdodClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IGdyb3VwID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5ncm91cCguLi5jb21wdXRlTG9nZ2luZ0FyZ3MoYXJncykpXG4gIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMuZ3JvdXAoYXJncykpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBncm91cENvbGxhcHNlZCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwQ29sbGFwc2VkKGFyZ3MpKVxufVxuXG5leHBvcnQgY29uc3QgZ3JvdXBFbmQgPSAoKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwRW5kKCkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOk5vZGV9IGNyZWF0ZU5vZGVcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50RG9tID0gKGNyZWF0ZU5vZGUpID0+XG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnREb20oY3JlYXRlTm9kZSgpKSlcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IHByaW50Q2FudmFzID0gKGNhbnZhcywgaGVpZ2h0KSA9PlxuICBwcmludEltZyhjYW52YXMudG9EYXRhVVJMKCksIGhlaWdodClcblxuZXhwb3J0IGNvbnN0IHZjb25zb2xlcyA9IHNldC5jcmVhdGUoKVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gKi9cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY29uc3QgX2NvbXB1dGVMaW5lU3BhbnMgPSAoYXJncykgPT4ge1xuICBjb25zdCBzcGFucyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG5ldyBNYXAoKVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0eWxlID0gX2Jyb3dzZXJTdHlsZU1hcFthcmddXG4gICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN1cnJlbnRTdHlsZS5zZXQoc3R5bGUubGVmdCwgc3R5bGUucmlnaHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHNwYW4gPSBkb20uZWxlbWVudCgnc3BhbicsIFtcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnc3R5bGUnLCBkb20ubWFwVG9TdHlsZVN0cmluZyhjdXJyZW50U3R5bGUpKVxuICAgICAgICBdLCBbZG9tLnRleHQoYXJnLnRvU3RyaW5nKCkpXSlcbiAgICAgICAgaWYgKHNwYW4uaW5uZXJIVE1MID09PSAnJykge1xuICAgICAgICAgIHNwYW4uaW5uZXJIVE1MID0gJyZuYnNwOydcbiAgICAgICAgfVxuICAgICAgICBzcGFucy5wdXNoKHNwYW4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBhcHBlbmQgdGhlIHJlc3RcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBhcmdzW2ldXG4gICAgaWYgKCEoY29udGVudCBpbnN0YW5jZW9mIFN5bWJvbCkpIHtcbiAgICAgIGlmIChjb250ZW50LmNvbnN0cnVjdG9yICE9PSBTdHJpbmcgJiYgY29udGVudC5jb25zdHJ1Y3RvciAhPT0gTnVtYmVyKSB7XG4gICAgICAgIGNvbnRlbnQgPSAnICcgKyBqc29uLnN0cmluZ2lmeShjb250ZW50KSArICcgJ1xuICAgICAgfVxuICAgICAgc3BhbnMucHVzaChcbiAgICAgICAgZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXSwgW2RvbS50ZXh0KC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoY29udGVudCkpXSlcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwYW5zXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG5jb25zdCBsaW5lU3R5bGUgPVxuICAnZm9udC1mYW1pbHk6bW9ub3NwYWNlO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMmUyZTI7cGFkZGluZzoycHg7J1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjbGFzcyBWQ29uc29sZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvbSkge1xuICAgIHRoaXMuZG9tID0gZG9tXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5kb21cbiAgICB0aGlzLmRlcHRoID0gMFxuICAgIHZjb25zb2xlcy5hZGQodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAgICogQHBhcmFtIHtib29sZWFufSBjb2xsYXBzZWRcbiAgICovXG4gIGdyb3VwIChhcmdzLCBjb2xsYXBzZWQgPSBmYWxzZSkge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGNvbnN0IHRyaWFuZ2xlRG93biA9IGRvbS5lbGVtZW50KCdzcGFuJywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKSxcbiAgICAgICAgcGFpci5jcmVhdGUoJ3N0eWxlJywgJ2NvbG9yOmdyZXk7Zm9udC1zaXplOjEyMCU7JylcbiAgICAgIF0sIFtkb20udGV4dCgn4pa8JyldKVxuICAgICAgY29uc3QgdHJpYW5nbGVSaWdodCA9IGRvbS5lbGVtZW50KCdzcGFuJywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgIWNvbGxhcHNlZCksXG4gICAgICAgIHBhaXIuY3JlYXRlKCdzdHlsZScsICdjb2xvcjpncmV5O2ZvbnQtc2l6ZToxMjUlOycpXG4gICAgICBdLCBbZG9tLnRleHQoJ+KWticpXSlcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb20uZWxlbWVudChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIFtwYWlyLmNyZWF0ZShcbiAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YFxuICAgICAgICApXSxcbiAgICAgICAgW3RyaWFuZ2xlRG93biwgdHJpYW5nbGVSaWdodCwgZG9tLnRleHQoJyAnKV0uY29uY2F0KFxuICAgICAgICAgIF9jb21wdXRlTGluZVNwYW5zKGFyZ3MpXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIGNvbnN0IG5leHRDb250YWluZXIgPSBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnaGlkZGVuJywgY29sbGFwc2VkKVxuICAgICAgXSlcbiAgICAgIGNvbnN0IG5leHRMaW5lID0gZG9tLmVsZW1lbnQoJ2RpdicsIFtdLCBbY29udGVudCwgbmV4dENvbnRhaW5lcl0pXG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW25leHRMaW5lXSlcbiAgICAgIHRoaXMuY2NvbnRhaW5lciA9IG5leHRDb250YWluZXJcbiAgICAgIHRoaXMuZGVwdGgrK1xuICAgICAgLy8gd2hlbiBoZWFkZXIgaXMgY2xpY2tlZCwgY29sbGFwc2UvdW5jb2xsYXBzZSBjb250YWluZXJcbiAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKGNvbnRlbnQsICdjbGljaycsIChfZXZlbnQpID0+IHtcbiAgICAgICAgbmV4dENvbnRhaW5lci50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICAgIHRyaWFuZ2xlRG93bi50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICAgIHRyaWFuZ2xlUmlnaHQudG9nZ2xlQXR0cmlidXRlKCdoaWRkZW4nKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKi9cbiAgZ3JvdXBDb2xsYXBzZWQgKGFyZ3MpIHtcbiAgICB0aGlzLmdyb3VwKGFyZ3MsIHRydWUpXG4gIH1cblxuICBncm91cEVuZCAoKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVwdGggPiAwKSB7XG4gICAgICAgIHRoaXMuZGVwdGgtLVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuY2NvbnRhaW5lciA9IHRoaXMuY2NvbnRhaW5lci5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKi9cbiAgcHJpbnQgKGFyZ3MpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW1xuICAgICAgICBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICAgIHBhaXIuY3JlYXRlKFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgIGAke2xpbmVTdHlsZX07cGFkZGluZy1sZWZ0OiR7dGhpcy5kZXB0aCAqIDEwfXB4YFxuICAgICAgICAgIClcbiAgICAgICAgXSwgX2NvbXB1dGVMaW5lU3BhbnMoYXJncykpXG4gICAgICBdKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqL1xuICBwcmludEVycm9yIChlcnIpIHtcbiAgICB0aGlzLnByaW50KFtjb21tb24uUkVELCBjb21tb24uQk9MRCwgZXJyLnRvU3RyaW5nKCldKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICAgKi9cbiAgcHJpbnRJbWcgKHVybCwgaGVpZ2h0KSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtcbiAgICAgICAgZG9tLmVsZW1lbnQoJ2ltZycsIFtcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnc3JjJywgdXJsKSxcbiAgICAgICAgICBwYWlyLmNyZWF0ZSgnaGVpZ2h0JywgYCR7bWF0aC5yb3VuZChoZWlnaHQgKiAxLjUpfXB4YClcbiAgICAgICAgXSlcbiAgICAgIF0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHByaW50RG9tIChub2RlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgZG9tLmFwcGVuZCh0aGlzLmNjb250YWluZXIsIFtub2RlXSlcbiAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgdmNvbnNvbGVzLmRlbGV0ZSh0aGlzKVxuICAgIH0pXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBkb21cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVWQ29uc29sZSA9IChkb20pID0+IG5ldyBWQ29uc29sZShkb20pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vZHVsZU5hbWVcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLmFueSk6dm9pZH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU1vZHVsZUxvZ2dlciA9IChtb2R1bGVOYW1lKSA9PiBjb21tb24uY3JlYXRlTW9kdWxlTG9nZ2VyKHByaW50LCBtb2R1bGVOYW1lKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/logging.js\n");

/***/ }),

/***/ "../node_modules/lib0/map.js":
/*!***********************************!*\
  !*** ../node_modules/lib0/map.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"all\": () => (/* binding */ all),\n/* harmony export */   \"any\": () => (/* binding */ any),\n/* harmony export */   \"copy\": () => (/* binding */ copy),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"setIfUndefined\": () => (/* binding */ setIfUndefined)\n/* harmony export */ });\n/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nconst create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nconst copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template V,K\n * @template {Map<K,V>} MAP\n * @param {MAP} map\n * @param {K} key\n * @param {function():V} createT\n * @return {V}\n */\nconst setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nconst map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nconst all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixXQUFXLEtBQUs7QUFDaEIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxjQUFjO0FBQ3pCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyx1QkFBdUI7QUFDbEMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9tYXAuanM/ZWM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBrZXktdmFsdWUgc3RvcmVzLlxuICpcbiAqIEBtb2R1bGUgbWFwXG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE1hcCBpbnN0YW5jZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge01hcDxhbnksIGFueT59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgTWFwKClcblxuLyoqXG4gKiBDb3B5IGEgTWFwIG9iamVjdCBpbnRvIGEgZnJlc2ggTWFwIG9iamVjdC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBYLFlcbiAqIEBwYXJhbSB7TWFwPFgsWT59IG1cbiAqIEByZXR1cm4ge01hcDxYLFk+fVxuICovXG5leHBvcnQgY29uc3QgY29weSA9IG0gPT4ge1xuICBjb25zdCByID0gY3JlYXRlKClcbiAgbS5mb3JFYWNoKCh2LCBrKSA9PiB7IHIuc2V0KGssIHYpIH0pXG4gIHJldHVybiByXG59XG5cbi8qKlxuICogR2V0IG1hcCBwcm9wZXJ0eS4gQ3JlYXRlIFQgaWYgcHJvcGVydHkgaXMgdW5kZWZpbmVkIGFuZCBzZXQgVCBvbiBtYXAuXG4gKlxuICogYGBganNcbiAqIGNvbnN0IGxpc3RlbmVycyA9IG1hcC5zZXRJZlVuZGVmaW5lZChldmVudHMsICdldmVudE5hbWUnLCBzZXQuY3JlYXRlKVxuICogbGlzdGVuZXJzLmFkZChsaXN0ZW5lcilcbiAqIGBgYFxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFYsS1xuICogQHRlbXBsYXRlIHtNYXA8SyxWPn0gTUFQXG4gKiBAcGFyYW0ge01BUH0gbWFwXG4gKiBAcGFyYW0ge0t9IGtleVxuICogQHBhcmFtIHtmdW5jdGlvbigpOlZ9IGNyZWF0ZVRcbiAqIEByZXR1cm4ge1Z9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpXG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpXG4gIH1cbiAgcmV0dXJuIHNldFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQXJyYXkgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIHRoZSBjb250ZW50IG9mIGFsbCBrZXktdmFsdWUgcGFpcnMgdXNpbmcgdGhlIGBmKHZhbHVlLCBrZXkpYCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIFJcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChtLCBmKSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICByZXMucHVzaChmKHZhbHVlLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFueSBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQHRvZG8gc2hvdWxkIHJlbmFtZSB0byBzb21lIC0gc2ltaWxhcmx5IHRvIEFycmF5LnNvbWVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbnkgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKGYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYWxsIGtleS12YWx1ZSBwYWlycyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IGBmKHZhbHVlLCBrZXkpYC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKCFmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/map.js\n");

/***/ }),

/***/ "../node_modules/lib0/math.js":
/*!************************************!*\
  !*** ../node_modules/lib0/math.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"abs\": () => (/* binding */ abs),\n/* harmony export */   \"add\": () => (/* binding */ add),\n/* harmony export */   \"ceil\": () => (/* binding */ ceil),\n/* harmony export */   \"exp10\": () => (/* binding */ exp10),\n/* harmony export */   \"floor\": () => (/* binding */ floor),\n/* harmony export */   \"imul\": () => (/* binding */ imul),\n/* harmony export */   \"isNaN\": () => (/* binding */ isNaN),\n/* harmony export */   \"isNegativeZero\": () => (/* binding */ isNegativeZero),\n/* harmony export */   \"log\": () => (/* binding */ log),\n/* harmony export */   \"log10\": () => (/* binding */ log10),\n/* harmony export */   \"log2\": () => (/* binding */ log2),\n/* harmony export */   \"max\": () => (/* binding */ max),\n/* harmony export */   \"min\": () => (/* binding */ min),\n/* harmony export */   \"pow\": () => (/* binding */ pow),\n/* harmony export */   \"round\": () => (/* binding */ round),\n/* harmony export */   \"sign\": () => (/* binding */ sign),\n/* harmony export */   \"sqrt\": () => (/* binding */ sqrt)\n/* harmony export */ });\n/**\n * Common Math expressions.\n *\n * @module math\n */\n\nconst floor = Math.floor\nconst ceil = Math.ceil\nconst abs = Math.abs\nconst imul = Math.imul\nconst round = Math.round\nconst log10 = Math.log10\nconst log2 = Math.log2\nconst log = Math.log\nconst sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nconst add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nconst min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nconst max = (a, b) => a > b ? a : b\n\nconst isNaN = Number.isNaN\n\nconst pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nconst exp10 = exp => Math.pow(10, exp)\n\nconst sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nconst isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWF0aC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVQO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNPOztBQUVBOztBQUVBO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNPOztBQUVBOztBQUVQO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL21hdGguanM/ZTQ4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvbW1vbiBNYXRoIGV4cHJlc3Npb25zLlxuICpcbiAqIEBtb2R1bGUgbWF0aFxuICovXG5cbmV4cG9ydCBjb25zdCBmbG9vciA9IE1hdGguZmxvb3JcbmV4cG9ydCBjb25zdCBjZWlsID0gTWF0aC5jZWlsXG5leHBvcnQgY29uc3QgYWJzID0gTWF0aC5hYnNcbmV4cG9ydCBjb25zdCBpbXVsID0gTWF0aC5pbXVsXG5leHBvcnQgY29uc3Qgcm91bmQgPSBNYXRoLnJvdW5kXG5leHBvcnQgY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwXG5leHBvcnQgY29uc3QgbG9nMiA9IE1hdGgubG9nMlxuZXhwb3J0IGNvbnN0IGxvZyA9IE1hdGgubG9nXG5leHBvcnQgY29uc3Qgc3FydCA9IE1hdGguc3FydFxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzdW0gb2YgYSBhbmQgYlxuICovXG5leHBvcnQgY29uc3QgYWRkID0gKGEsIGIpID0+IGEgKyBiXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHNtYWxsZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBtaW4gPSAoYSwgYikgPT4gYSA8IGIgPyBhIDogYlxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaWdnZXIgZWxlbWVudCBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBtYXggPSAoYSwgYikgPT4gYSA+IGIgPyBhIDogYlxuXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cblxuZXhwb3J0IGNvbnN0IHBvdyA9IE1hdGgucG93XG4vKipcbiAqIEJhc2UgMTAgZXhwb25lbnRpYWwgZnVuY3Rpb24uIFJldHVybnMgdGhlIHZhbHVlIG9mIDEwIHJhaXNlZCB0byB0aGUgcG93ZXIgb2YgcG93LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBleHBcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cDEwID0gZXhwID0+IE1hdGgucG93KDEwLCBleHApXG5cbmV4cG9ydCBjb25zdCBzaWduID0gTWF0aC5zaWduXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdldGhlciBuIGlzIG5lZ2F0aXZlLiBUaGlzIGZ1bmN0aW9uIGFsc28gZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiAtMCBhbmQgKzBcbiAqL1xuZXhwb3J0IGNvbnN0IGlzTmVnYXRpdmVaZXJvID0gbiA9PiBuICE9PSAwID8gbiA8IDAgOiAxIC8gbiA8IDBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/math.js\n");

/***/ }),

/***/ "../node_modules/lib0/metric.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/metric.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"atto\": () => (/* binding */ atto),\n/* harmony export */   \"centi\": () => (/* binding */ centi),\n/* harmony export */   \"deca\": () => (/* binding */ deca),\n/* harmony export */   \"deci\": () => (/* binding */ deci),\n/* harmony export */   \"exa\": () => (/* binding */ exa),\n/* harmony export */   \"femto\": () => (/* binding */ femto),\n/* harmony export */   \"giga\": () => (/* binding */ giga),\n/* harmony export */   \"hecto\": () => (/* binding */ hecto),\n/* harmony export */   \"kilo\": () => (/* binding */ kilo),\n/* harmony export */   \"mega\": () => (/* binding */ mega),\n/* harmony export */   \"micro\": () => (/* binding */ micro),\n/* harmony export */   \"milli\": () => (/* binding */ milli),\n/* harmony export */   \"nano\": () => (/* binding */ nano),\n/* harmony export */   \"peta\": () => (/* binding */ peta),\n/* harmony export */   \"pico\": () => (/* binding */ pico),\n/* harmony export */   \"prefix\": () => (/* binding */ prefix),\n/* harmony export */   \"tera\": () => (/* binding */ tera),\n/* harmony export */   \"yocto\": () => (/* binding */ yocto),\n/* harmony export */   \"yotta\": () => (/* binding */ yotta),\n/* harmony export */   \"zepto\": () => (/* binding */ zepto),\n/* harmony export */   \"zetta\": () => (/* binding */ zetta)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/**\n * Utility module to convert metric values.\n *\n * @module metric\n */\n\n\n\nconst yotta = 1e24\nconst zetta = 1e21\nconst exa = 1e18\nconst peta = 1e15\nconst tera = 1e12\nconst giga = 1e9\nconst mega = 1e6\nconst kilo = 1e3\nconst hecto = 1e2\nconst deca = 10\nconst deci = 0.1\nconst centi = 0.01\nconst milli = 1e-3\nconst micro = 1e-6\nconst nano = 1e-9\nconst pico = 1e-12\nconst femto = 1e-15\nconst atto = 1e-18\nconst zepto = 1e-21\nconst yocto = 1e-24\n\nconst prefixUp = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']\nconst prefixDown = ['', 'm', '', 'n', 'p', 'f', 'a', 'z', 'y']\n\n/**\n * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: 'k' }`\n *\n * @param {number} n\n * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds\n * @return {{n:number,prefix:string}}\n */\nconst prefix = (n, baseMultiplier = 0) => {\n  const nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n)\n  let mult = 0\n  while (nPow < mult * 3 && baseMultiplier > -8) {\n    baseMultiplier--\n    mult--\n  }\n  while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {\n    baseMultiplier++\n    mult++\n  }\n  const prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier]\n  return {\n    n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,\n    prefix\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWV0cmljLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQzs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUDtBQUNBOztBQUVBO0FBQ0EsNEVBQTRFLG1CQUFtQjtBQUMvRjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ087QUFDUCw2QkFBNkIsMkNBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sMkNBQVUsaUJBQWlCLDJDQUFVLGlCQUFpQiwyQ0FBVTtBQUN2RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWV0cmljLmpzPzM5MDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byBjb252ZXJ0IG1ldHJpYyB2YWx1ZXMuXG4gKlxuICogQG1vZHVsZSBtZXRyaWNcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcblxuZXhwb3J0IGNvbnN0IHlvdHRhID0gMWUyNFxuZXhwb3J0IGNvbnN0IHpldHRhID0gMWUyMVxuZXhwb3J0IGNvbnN0IGV4YSA9IDFlMThcbmV4cG9ydCBjb25zdCBwZXRhID0gMWUxNVxuZXhwb3J0IGNvbnN0IHRlcmEgPSAxZTEyXG5leHBvcnQgY29uc3QgZ2lnYSA9IDFlOVxuZXhwb3J0IGNvbnN0IG1lZ2EgPSAxZTZcbmV4cG9ydCBjb25zdCBraWxvID0gMWUzXG5leHBvcnQgY29uc3QgaGVjdG8gPSAxZTJcbmV4cG9ydCBjb25zdCBkZWNhID0gMTBcbmV4cG9ydCBjb25zdCBkZWNpID0gMC4xXG5leHBvcnQgY29uc3QgY2VudGkgPSAwLjAxXG5leHBvcnQgY29uc3QgbWlsbGkgPSAxZS0zXG5leHBvcnQgY29uc3QgbWljcm8gPSAxZS02XG5leHBvcnQgY29uc3QgbmFubyA9IDFlLTlcbmV4cG9ydCBjb25zdCBwaWNvID0gMWUtMTJcbmV4cG9ydCBjb25zdCBmZW10byA9IDFlLTE1XG5leHBvcnQgY29uc3QgYXR0byA9IDFlLTE4XG5leHBvcnQgY29uc3QgemVwdG8gPSAxZS0yMVxuZXhwb3J0IGNvbnN0IHlvY3RvID0gMWUtMjRcblxuY29uc3QgcHJlZml4VXAgPSBbJycsICdrJywgJ00nLCAnRycsICdUJywgJ1AnLCAnRScsICdaJywgJ1knXVxuY29uc3QgcHJlZml4RG93biA9IFsnJywgJ20nLCAnzrwnLCAnbicsICdwJywgJ2YnLCAnYScsICd6JywgJ3knXVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWV0cmljIHByZWZpeCBmb3IgYSBudW1iZXIuIEFzc3VtZXMgRS5nLiBgcHJlZml4KDEwMDApID0geyBuOiAxLCBwcmVmaXg6ICdrJyB9YFxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Jhc2VNdWx0aXBsaWVyXSBNdWx0aXBsaWVyIG9mIHRoZSBiYXNlICgxMF4oMypiYXNlTXVsdGlwbGllcikpLiBFLmcuIGBjb252ZXJ0KHRpbWUsIC0zKWAgaWYgdGltZSBpcyBhbHJlYWR5IGluIG1pbGxpIHNlY29uZHNcbiAqIEByZXR1cm4ge3tuOm51bWJlcixwcmVmaXg6c3RyaW5nfX1cbiAqL1xuZXhwb3J0IGNvbnN0IHByZWZpeCA9IChuLCBiYXNlTXVsdGlwbGllciA9IDApID0+IHtcbiAgY29uc3QgblBvdyA9IG4gPT09IDAgPyAwIDogbWF0aC5sb2cxMChuKVxuICBsZXQgbXVsdCA9IDBcbiAgd2hpbGUgKG5Qb3cgPCBtdWx0ICogMyAmJiBiYXNlTXVsdGlwbGllciA+IC04KSB7XG4gICAgYmFzZU11bHRpcGxpZXItLVxuICAgIG11bHQtLVxuICB9XG4gIHdoaWxlIChuUG93ID49IDMgKyBtdWx0ICogMyAmJiBiYXNlTXVsdGlwbGllciA8IDgpIHtcbiAgICBiYXNlTXVsdGlwbGllcisrXG4gICAgbXVsdCsrXG4gIH1cbiAgY29uc3QgcHJlZml4ID0gYmFzZU11bHRpcGxpZXIgPCAwID8gcHJlZml4RG93blstYmFzZU11bHRpcGxpZXJdIDogcHJlZml4VXBbYmFzZU11bHRpcGxpZXJdXG4gIHJldHVybiB7XG4gICAgbjogbWF0aC5yb3VuZCgobXVsdCA+IDAgPyBuIC8gbWF0aC5leHAxMChtdWx0ICogMykgOiBuICogbWF0aC5leHAxMChtdWx0ICogLTMpKSAqIDFlMTIpIC8gMWUxMixcbiAgICBwcmVmaXhcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/metric.js\n");

/***/ }),

/***/ "../node_modules/lib0/number.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/number.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HIGHEST_INT32\": () => (/* binding */ HIGHEST_INT32),\n/* harmony export */   \"HIGHEST_UINT32\": () => (/* binding */ HIGHEST_UINT32),\n/* harmony export */   \"LOWEST_INT32\": () => (/* binding */ LOWEST_INT32),\n/* harmony export */   \"MAX_SAFE_INTEGER\": () => (/* binding */ MAX_SAFE_INTEGER),\n/* harmony export */   \"MIN_SAFE_INTEGER\": () => (/* binding */ MIN_SAFE_INTEGER),\n/* harmony export */   \"isInteger\": () => (/* binding */ isInteger),\n/* harmony export */   \"isNaN\": () => (/* binding */ isNaN),\n/* harmony export */   \"parseInt\": () => (/* binding */ parseInt)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./binary.js */ \"../node_modules/lib0/binary.js\");\n/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\n\n\n\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nconst MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nconst LOWEST_INT32 = 1 << 31\nconst HIGHEST_INT32 = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS31\nconst HIGHEST_UINT32 = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS32\n\n/* c8 ignore next */\nconst isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num) === num)\nconst isNaN = Number.isNaN\nconst parseInt = Number.parseInt\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNJOztBQUU5QjtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLDhDQUFhO0FBQ25DLHVCQUF1Qiw4Q0FBYTs7QUFFM0M7QUFDTywwRkFBMEYsMkNBQVU7QUFDcEc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9udW1iZXIuanM/Mzg5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuZXhwb3J0IGNvbnN0IE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuXG5leHBvcnQgY29uc3QgTE9XRVNUX0lOVDMyID0gMSA8PCAzMVxuZXhwb3J0IGNvbnN0IEhJR0hFU1RfSU5UMzIgPSBiaW5hcnkuQklUUzMxXG5leHBvcnQgY29uc3QgSElHSEVTVF9VSU5UMzIgPSBiaW5hcnkuQklUUzMyXG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAobnVtID0+IHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIGlzRmluaXRlKG51bSkgJiYgbWF0aC5mbG9vcihudW0pID09PSBudW0pXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cbmV4cG9ydCBjb25zdCBwYXJzZUludCA9IE51bWJlci5wYXJzZUludFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/number.js\n");

/***/ }),

/***/ "../node_modules/lib0/object.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/object.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"assign\": () => (/* binding */ assign),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"equalFlat\": () => (/* binding */ equalFlat),\n/* harmony export */   \"every\": () => (/* binding */ every),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"hasProperty\": () => (/* binding */ hasProperty),\n/* harmony export */   \"isEmpty\": () => (/* binding */ isEmpty),\n/* harmony export */   \"keys\": () => (/* binding */ keys),\n/* harmony export */   \"length\": () => (/* binding */ length),\n/* harmony export */   \"map\": () => (/* binding */ map),\n/* harmony export */   \"some\": () => (/* binding */ some)\n/* harmony export */ });\n/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nconst create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nconst assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nconst keys = Object.keys\n\n/**\n * @template V\n * @param {{[k:string]:V}} obj\n * @param {function(V,string):any} f\n */\nconst forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @todo implement mapToArray & map\n *\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nconst map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nconst length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object|undefined} obj\n */\nconst isEmpty = obj => {\n  for (const _k in obj) {\n    return false\n  }\n  return true\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nconst every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nconst hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nconst equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvb2JqZWN0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNPOztBQUVQO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsV0FBVyx3QkFBd0I7QUFDbkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyx3QkFBd0I7QUFDbkMsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsOEJBQThCO0FBQ3pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGtCQUFrQjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsOEJBQThCO0FBQ3pDLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcz8wOGI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdvcmtpbmcgd2l0aCBFY21hU2NyaXB0IG9iamVjdHMuXG4gKlxuICogQG1vZHVsZSBvYmplY3RcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8qKlxuICogT2JqZWN0LmFzc2lnblxuICovXG5leHBvcnQgY29uc3QgYXNzaWduID0gT2JqZWN0LmFzc2lnblxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGtleXMgPSBPYmplY3Qua2V5c1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBWXG4gKiBAcGFyYW0ge3tbazpzdHJpbmddOlZ9fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixzdHJpbmcpOmFueX0gZlxuICovXG5leHBvcnQgY29uc3QgZm9yRWFjaCA9IChvYmosIGYpID0+IHtcbiAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgZihvYmpba2V5XSwga2V5KVxuICB9XG59XG5cbi8qKlxuICogQHRvZG8gaW1wbGVtZW50IG1hcFRvQXJyYXkgJiBtYXBcbiAqXG4gKiBAdGVtcGxhdGUgUlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChvYmosIGYpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdXG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIHJlc3VsdHMucHVzaChmKG9ialtrZXldLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXN1bHRzXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gb2JqID0+IGtleXMob2JqKS5sZW5ndGhcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSxzdHJpbmcpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKG9iaiwgZikgPT4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAoZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBvYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzRW1wdHkgPSBvYmogPT4ge1xuICBmb3IgKGNvbnN0IF9rIGluIG9iaikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQ2FsbHMgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzUHJvcGVydHkgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAobGVuZ3RoKGEpID09PSBsZW5ndGgoYikgJiYgZXZlcnkoYSwgKHZhbCwga2V5KSA9PiAodmFsICE9PSB1bmRlZmluZWQgfHwgaGFzUHJvcGVydHkoYiwga2V5KSkgJiYgYltrZXldID09PSB2YWwpKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/object.js\n");

/***/ }),

/***/ "../node_modules/lib0/observable.js":
/*!******************************************!*\
  !*** ../node_modules/lib0/observable.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Observable\": () => (/* binding */ Observable)\n/* harmony export */ });\n/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./map.js */ \"../node_modules/lib0/map.js\");\n/* harmony import */ var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./set.js */ \"../node_modules/lib0/set.js\");\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./array.js */ \"../node_modules/lib0/array.js\");\n/**\n * Observable class prototype.\n *\n * @module observable\n */\n\n\n\n\n\n/**\n * Handles named events.\n *\n * @template N\n */\nclass Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDQTtBQUNJOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxzQkFBc0IsMkNBQVU7QUFDaEM7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxJQUFJLG1EQUFrQix3QkFBd0IsMkNBQVU7QUFDeEQ7O0FBRUE7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQVUsK0JBQStCLDJDQUFVO0FBQzlEOztBQUVBO0FBQ0Esc0JBQXNCLDJDQUFVO0FBQ2hDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvb2JzZXJ2YWJsZS5qcz9lOGI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgTlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBTb21lIGRlc2MuXG4gICAgICogQHR5cGUge01hcDxOLCBhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbiAobmFtZSwgZikge1xuICAgIG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLl9vYnNlcnZlcnMsIG5hbWUsIHNldC5jcmVhdGUpLmFkZChmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvbmNlIChuYW1lLCBmKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtICB7Li4uYW55fSBhcmdzXG4gICAgICovXG4gICAgY29uc3QgX2YgPSAoLi4uYXJncykgPT4ge1xuICAgICAgdGhpcy5vZmYobmFtZSwgX2YpXG4gICAgICBmKC4uLmFyZ3MpXG4gICAgfVxuICAgIHRoaXMub24obmFtZSwgX2YpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtOfSBuYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAobmFtZSwgZikge1xuICAgIGNvbnN0IG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycy5nZXQobmFtZSlcbiAgICBpZiAob2JzZXJ2ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9ic2VydmVycy5kZWxldGUoZilcbiAgICAgIGlmIChvYnNlcnZlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9vYnNlcnZlcnMuZGVsZXRlKG5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgYSBuYW1lZCBldmVudC4gQWxsIHJlZ2lzdGVyZWQgZXZlbnQgbGlzdGVuZXJzIHRoYXQgbGlzdGVuIHRvIHRoZVxuICAgKiBzcGVjaWZpZWQgbmFtZSB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50LlxuICAgKlxuICAgKiBAdG9kbyBUaGlzIHNob3VsZCBjYXRjaCBleGNlcHRpb25zXG4gICAqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZSBUaGUgZXZlbnQgbmFtZS5cbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcmdzIFRoZSBhcmd1bWVudHMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAqL1xuICBlbWl0IChuYW1lLCBhcmdzKSB7XG4gICAgLy8gY29weSBhbGwgbGlzdGVuZXJzIHRvIGFuIGFycmF5IGZpcnN0IHRvIG1ha2Ugc3VyZSB0aGF0IG5vIGV2ZW50IGlzIGVtaXR0ZWQgdG8gbGlzdGVuZXJzIHRoYXQgYXJlIHN1YnNjcmliZWQgd2hpbGUgdGhlIGV2ZW50IGhhbmRsZXIgaXMgY2FsbGVkLlxuICAgIHJldHVybiBhcnJheS5mcm9tKCh0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpIHx8IG1hcC5jcmVhdGUoKSkudmFsdWVzKCkpLmZvckVhY2goZiA9PiBmKC4uLmFyZ3MpKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy5fb2JzZXJ2ZXJzID0gbWFwLmNyZWF0ZSgpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/observable.js\n");

/***/ }),

/***/ "../node_modules/lib0/pair.js":
/*!************************************!*\
  !*** ../node_modules/lib0/pair.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Pair\": () => (/* binding */ Pair),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"createReversed\": () => (/* binding */ createReversed),\n/* harmony export */   \"forEach\": () => (/* binding */ forEach),\n/* harmony export */   \"map\": () => (/* binding */ map)\n/* harmony export */ });\n/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nclass Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nconst create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nconst createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nconst forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nconst map = (arr, f) => arr.map(p => f(p.left, p.right))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL3BhaXIuanM/MTI2OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdvcmtpbmcgd2l0aCB2YWx1ZSBwYWlycy5cbiAqXG4gKiBAbW9kdWxlIHBhaXJcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqL1xuZXhwb3J0IGNsYXNzIFBhaXIge1xuICAvKipcbiAgICogQHBhcmFtIHtMfSBsZWZ0XG4gICAqIEBwYXJhbSB7Un0gcmlnaHRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCkge1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBMLFJcbiAqIEBwYXJhbSB7TH0gbGVmdFxuICogQHBhcmFtIHtSfSByaWdodFxuICogQHJldHVybiB7UGFpcjxMLFI+fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKGxlZnQsIHJpZ2h0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge1J9IHJpZ2h0XG4gKiBAcGFyYW0ge0x9IGxlZnRcbiAqIEByZXR1cm4ge1BhaXI8TCxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJldmVyc2VkID0gKHJpZ2h0LCBsZWZ0KSA9PiBuZXcgUGFpcihsZWZ0LCByaWdodClcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge0FycmF5PFBhaXI8TCxSPj59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihMLCBSKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAoYXJyLCBmKSA9PiBhcnIuZm9yRWFjaChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSLFhcbiAqIEBwYXJhbSB7QXJyYXk8UGFpcjxMLFI+Pn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEwsIFIpOlh9IGZcbiAqIEByZXR1cm4ge0FycmF5PFg+fVxuICovXG5leHBvcnQgY29uc3QgbWFwID0gKGFyciwgZikgPT4gYXJyLm1hcChwID0+IGYocC5sZWZ0LCBwLnJpZ2h0KSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/pair.js\n");

/***/ }),

/***/ "../node_modules/lib0/promise.js":
/*!***************************************!*\
  !*** ../node_modules/lib0/promise.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"all\": () => (/* binding */ all),\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"createEmpty\": () => (/* binding */ createEmpty),\n/* harmony export */   \"isPromise\": () => (/* binding */ isPromise),\n/* harmony export */   \"reject\": () => (/* binding */ reject),\n/* harmony export */   \"resolve\": () => (/* binding */ resolve),\n/* harmony export */   \"resolveWith\": () => (/* binding */ resolveWith),\n/* harmony export */   \"until\": () => (/* binding */ until),\n/* harmony export */   \"wait\": () => (/* binding */ wait)\n/* harmony export */ });\n/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ \"../node_modules/lib0/time.js\");\n/**\n * Utility helpers to work with promises.\n *\n * @module promise\n */\n\n\n\n/**\n * @template T\n * @callback PromiseResolve\n * @param {T|PromiseLike<T>} [result]\n */\n\n/**\n * @template T\n * @param {function(PromiseResolve<T>,function(Error):void):any} f\n * @return {Promise<T>}\n */\nconst create = f => /** @type {Promise<T>} */ (new Promise(f))\n\n/**\n * @param {function(function():void,function(Error):void):void} f\n * @return {Promise<void>}\n */\nconst createEmpty = f => new Promise(f)\n\n/**\n * `Promise.all` wait for all promises in the array to resolve and return the result\n * @template {unknown[] | []} PS\n *\n * @param {PS} ps\n * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}\n */\nconst all = Promise.all.bind(Promise)\n\n/**\n * @param {Error} [reason]\n * @return {Promise<never>}\n */\nconst reject = reason => Promise.reject(reason)\n\n/**\n * @template T\n * @param {T|void} res\n * @return {Promise<T|void>}\n */\nconst resolve = res => Promise.resolve(res)\n\n/**\n * @template T\n * @param {T} res\n * @return {Promise<T>}\n */\nconst resolveWith = res => Promise.resolve(res)\n\n/**\n * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]\n *\n * @param {number} timeout\n * @param {function():boolean} check\n * @param {number} [intervalResolution]\n * @return {Promise<void>}\n */\nconst until = (timeout, check, intervalResolution = 10) => create((resolve, reject) => {\n  const startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime()\n  const hasTimeout = timeout > 0\n  const untilInterval = () => {\n    if (check()) {\n      clearInterval(intervalHandle)\n      resolve()\n    } else if (hasTimeout) {\n      /* c8 ignore else */\n      if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {\n        clearInterval(intervalHandle)\n        reject(new Error('Timeout'))\n      }\n    }\n  }\n  const intervalHandle = setInterval(untilInterval, intervalResolution)\n})\n\n/**\n * @param {number} timeout\n * @return {Promise<undefined>}\n */\nconst wait = timeout => create((resolve, reject) => setTimeout(resolve, timeout))\n\n/**\n * Checks if an object is a promise using ducktyping.\n *\n * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this\n * library has some insane environment where global Promise objects are overwritten.\n *\n * @param {any} p\n * @return {boolean}\n */\nconst isPromise = p => p instanceof Promise || (p && p.then && p.catch && p.finally)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcHJvbWlzZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUM7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNEQUFzRDtBQUNqRSxZQUFZO0FBQ1o7QUFDTywrQkFBK0IsWUFBWTs7QUFFbEQ7QUFDQSxXQUFXLHFEQUFxRDtBQUNoRSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQSxXQUFXLElBQUk7QUFDZixZQUFZLFVBQVUsMkNBQTJDO0FBQ2pFO0FBQ087O0FBRVA7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsb0JBQW9CO0FBQy9CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQLG9CQUFvQixpREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsaURBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFlBQVk7QUFDWjtBQUNPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanM/YmI0OSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgaGVscGVycyB0byB3b3JrIHdpdGggcHJvbWlzZXMuXG4gKlxuICogQG1vZHVsZSBwcm9taXNlXG4gKi9cblxuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBQcm9taXNlUmVzb2x2ZVxuICogQHBhcmFtIHtUfFByb21pc2VMaWtlPFQ+fSBbcmVzdWx0XVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUHJvbWlzZVJlc29sdmU8VD4sZnVuY3Rpb24oRXJyb3IpOnZvaWQpOmFueX0gZlxuICogQHJldHVybiB7UHJvbWlzZTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGYgPT4gLyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqLyAobmV3IFByb21pc2UoZikpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbigpOnZvaWQsZnVuY3Rpb24oRXJyb3IpOnZvaWQpOnZvaWR9IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbXB0eSA9IGYgPT4gbmV3IFByb21pc2UoZilcblxuLyoqXG4gKiBgUHJvbWlzZS5hbGxgIHdhaXQgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgYXJyYXkgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdIHwgW119IFBTXG4gKlxuICogQHBhcmFtIHtQU30gcHNcbiAqIEByZXR1cm4ge1Byb21pc2U8eyAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgUFNdOiBBd2FpdGVkPFBTW1BdPiB9Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IFByb21pc2UuYWxsLmJpbmQoUHJvbWlzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXVxuICogQHJldHVybiB7UHJvbWlzZTxuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCByZWplY3QgPSByZWFzb24gPT4gUHJvbWlzZS5yZWplY3QocmVhc29uKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8dm9pZH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFR8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlID0gcmVzID0+IFByb21pc2UucmVzb2x2ZShyZXMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZVdpdGggPSByZXMgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcylcblxuLyoqXG4gKiBAdG9kbyBOZXh0IHZlcnNpb24sIHJlb3JkZXIgcGFyYW1ldGVyczogY2hlY2ssIFt0aW1lb3V0LCBbaW50ZXJ2YWxSZXNvbHV0aW9uXV1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbigpOmJvb2xlYW59IGNoZWNrXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsUmVzb2x1dGlvbl1cbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bnRpbCA9ICh0aW1lb3V0LCBjaGVjaywgaW50ZXJ2YWxSZXNvbHV0aW9uID0gMTApID0+IGNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBoYXNUaW1lb3V0ID0gdGltZW91dCA+IDBcbiAgY29uc3QgdW50aWxJbnRlcnZhbCA9ICgpID0+IHtcbiAgICBpZiAoY2hlY2soKSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgIHJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAoaGFzVGltZW91dCkge1xuICAgICAgLyogYzggaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aW1lLmdldFVuaXhUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbCh1bnRpbEludGVydmFsLCBpbnRlcnZhbFJlc29sdXRpb24pXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcmV0dXJuIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBjb25zdCB3YWl0ID0gdGltZW91dCA9PiBjcmVhdGUoKHJlc29sdmUsIHJlamVjdCkgPT4gc2V0VGltZW91dChyZXNvbHZlLCB0aW1lb3V0KSlcblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGEgcHJvbWlzZSB1c2luZyBkdWNrdHlwaW5nLlxuICpcbiAqIFByb21pc2VzIGFyZSBvZnRlbiBwb2x5ZmlsbGVkLCBzbyBpdCBtYWtlcyBzZW5zZSB0byBhZGQgc29tZSBhZGRpdGlvbmFsIGd1YXJhbnRlZXMgaWYgdGhlIHVzZXIgb2YgdGhpc1xuICogbGlicmFyeSBoYXMgc29tZSBpbnNhbmUgZW52aXJvbm1lbnQgd2hlcmUgZ2xvYmFsIFByb21pc2Ugb2JqZWN0cyBhcmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHthbnl9IHBcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1Byb21pc2UgPSBwID0+IHAgaW5zdGFuY2VvZiBQcm9taXNlIHx8IChwICYmIHAudGhlbiAmJiBwLmNhdGNoICYmIHAuZmluYWxseSlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/promise.js\n");

/***/ }),

/***/ "../node_modules/lib0/random.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/random.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"oneOf\": () => (/* binding */ oneOf),\n/* harmony export */   \"rand\": () => (/* binding */ rand),\n/* harmony export */   \"uint32\": () => (/* binding */ uint32),\n/* harmony export */   \"uint53\": () => (/* binding */ uint53),\n/* harmony export */   \"uuidv4\": () => (/* binding */ uuidv4)\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ \"../node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/webcrypto */ \"../node_modules/lib0/webcrypto.js\");\n\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\n\n\n\n\nconst rand = Math.random\n\nconst uint32 = () => (0,lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__.getRandomValues)(new Uint32Array(1))[0]\n\nconst uint53 = () => {\n  const arr = (0,lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__.getRandomValues)(new Uint32Array(8))\n  return (arr[0] & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS21) * (_binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32 + 1) + (arr[1] >>> 0)\n}\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nconst oneOf = arr => arr[_math_js__WEBPACK_IMPORTED_MODULE_2__.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nconst uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQztBQUNJO0FBQ1c7O0FBRXpDOztBQUVBLHFCQUFxQiwrREFBZTs7QUFFcEM7QUFDUCxjQUFjLCtEQUFlO0FBQzdCLG1CQUFtQiw4Q0FBYSxLQUFLLDhDQUFhO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ08seUJBQXlCLDJDQUFVOztBQUUxQztBQUNBO0FBQ08sa0VBQWtFLFFBQVE7QUFDakY7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9yYW5kb20uanM/NjhmMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgeyBnZXRSYW5kb21WYWx1ZXMgfSBmcm9tICdsaWIwL3dlYmNyeXB0bydcblxuZXhwb3J0IGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbVxuXG5leHBvcnQgY29uc3QgdWludDMyID0gKCkgPT4gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF1cblxuZXhwb3J0IGNvbnN0IHVpbnQ1MyA9ICgpID0+IHtcbiAgY29uc3QgYXJyID0gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSg4KSlcbiAgcmV0dXJuIChhcnJbMF0gJiBiaW5hcnkuQklUUzIxKSAqIChiaW5hcnkuQklUUzMyICsgMSkgKyAoYXJyWzFdID4+PiAwKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBvbmVPZiA9IGFyciA9PiBhcnJbbWF0aC5mbG9vcihyYW5kKCkgKiBhcnIubGVuZ3RoKV1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbilcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/random.js\n");

/***/ }),

/***/ "../node_modules/lib0/set.js":
/*!***********************************!*\
  !*** ../node_modules/lib0/set.js ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"first\": () => (/* binding */ first),\n/* harmony export */   \"from\": () => (/* binding */ from),\n/* harmony export */   \"toArray\": () => (/* binding */ toArray)\n/* harmony export */ });\n/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nconst create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nconst toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nconst first = set =>\n  set.values().next().value || undefined\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nconst from = entries => new Set(entries)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPOztBQUVQO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsWUFBWTtBQUNaO0FBQ08iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvc2V0LmpzP2Q0ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc2V0cy5cbiAqXG4gKiBAbW9kdWxlIHNldFxuICovXG5cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiBuZXcgU2V0KClcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtTZXQ8VD59IHNldFxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB0b0FycmF5ID0gc2V0ID0+IEFycmF5LmZyb20oc2V0KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtUfVxuICovXG5leHBvcnQgY29uc3QgZmlyc3QgPSBzZXQgPT5cbiAgc2V0LnZhbHVlcygpLm5leHQoKS52YWx1ZSB8fCB1bmRlZmluZWRcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtJdGVyYWJsZTxUPn0gZW50cmllc1xuICogQHJldHVybiB7U2V0PFQ+fVxuICovXG5leHBvcnQgY29uc3QgZnJvbSA9IGVudHJpZXMgPT4gbmV3IFNldChlbnRyaWVzKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/set.js\n");

/***/ }),

/***/ "../node_modules/lib0/storage.js":
/*!***************************************!*\
  !*** ../node_modules/lib0/storage.js ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"offChange\": () => (/* binding */ offChange),\n/* harmony export */   \"onChange\": () => (/* binding */ onChange),\n/* harmony export */   \"varStorage\": () => (/* binding */ varStorage)\n/* harmony export */ });\n/* eslint-env browser */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* c8 ignore start */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n/* c8 ignore stop */\n\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\n/* c8 ignore start */\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n/* c8 ignore stop */\n\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\n/* c8 ignore next */\nconst varStorage = _localStorage\n\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n\n/**\n * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\n/* c8 ignore next */\nconst offChange = eventHandler => usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3RvcmFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087O0FBRVA7QUFDQSx5REFBeUQsR0FBRztBQUM1RDtBQUNBLFdBQVcsV0FBVyxpREFBaUQsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDTyx1RkFBdUYsS0FBSzs7QUFFbkc7QUFDQSw0REFBNEQsR0FBRztBQUMvRDtBQUNBLFdBQVcsV0FBVyxpREFBaUQsU0FBUztBQUNoRjtBQUNBO0FBQ0E7QUFDTywyRkFBMkYsS0FBSyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9zdG9yYWdlLmpzP2ZmYjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogSXNvbW9ycGhpYyB2YXJpYWJsZSBzdG9yYWdlLlxuICpcbiAqIFVzZXMgTG9jYWxTdG9yYWdlIGluIHRoZSBicm93c2VyIGFuZCBmYWxscyBiYWNrIHRvIGluLW1lbW9yeSBzdG9yYWdlLlxuICpcbiAqIEBtb2R1bGUgc3RvcmFnZVxuICovXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuY2xhc3MgVmFyU3RvcmFnZVBvbHlmaWxsIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMubWFwID0gbmV3IE1hcCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge2FueX0gbmV3VmFsdWVcbiAgICovXG4gIHNldEl0ZW0gKGtleSwgbmV3VmFsdWUpIHtcbiAgICB0aGlzLm1hcC5zZXQoa2V5LCBuZXdWYWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICBnZXRJdGVtIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAdHlwZSB7YW55fVxuICovXG5sZXQgX2xvY2FsU3RvcmFnZSA9IG5ldyBWYXJTdG9yYWdlUG9seWZpbGwoKVxubGV0IHVzZVBvbHlmaWxsID0gdHJ1ZVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbnRyeSB7XG4gIC8vIGlmIHRoZSBzYW1lLW9yaWdpbiBydWxlIGlzIHZpb2xhdGVkLCBhY2Nlc3NpbmcgbG9jYWxTdG9yYWdlIG1pZ2h0IHRocm93biBhbiBlcnJvclxuICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfbG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlXG4gICAgdXNlUG9seWZpbGwgPSBmYWxzZVxuICB9XG59IGNhdGNoIChlKSB7IH1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogVGhpcyBpcyBiYXNpY2FsbHkgbG9jYWxTdG9yYWdlIGluIGJyb3dzZXIsIG9yIGEgcG9seWZpbGwgaW4gbm9kZWpzXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdmFyU3RvcmFnZSA9IF9sb2NhbFN0b3JhZ2VcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGV2ZW50ID0+IHsuLn0pYCB0aGF0IGRvZXMgbm90aGluZyBpZiB0aGUgcG9seWZpbGwgaXMgYmVpbmcgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHsga2V5OiBzdHJpbmcsIG5ld1ZhbHVlOiBzdHJpbmcsIG9sZFZhbHVlOiBzdHJpbmcgfSk6IHZvaWR9IGV2ZW50SGFuZGxlclxuICogQGZ1bmN0aW9uXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgb25DaGFuZ2UgPSBldmVudEhhbmRsZXIgPT4gdXNlUG9seWZpbGwgfHwgYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIC8qKiBAdHlwZSB7YW55fSAqLyAoZXZlbnRIYW5kbGVyKSlcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBgcmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGV2ZW50ID0+IHsuLn0pYCB0aGF0IGRvZXMgbm90aGluZyBpZiB0aGUgcG9seWZpbGwgaXMgYmVpbmcgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHsga2V5OiBzdHJpbmcsIG5ld1ZhbHVlOiBzdHJpbmcsIG9sZFZhbHVlOiBzdHJpbmcgfSk6IHZvaWR9IGV2ZW50SGFuZGxlclxuICogQGZ1bmN0aW9uXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3Qgb2ZmQ2hhbmdlID0gZXZlbnRIYW5kbGVyID0+IHVzZVBvbHlmaWxsIHx8IHJlbW92ZUV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAvKiogQHR5cGUge2FueX0gKi8gKGV2ZW50SGFuZGxlcikpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/storage.js\n");

/***/ }),

/***/ "../node_modules/lib0/string.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/string.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"_decodeUtf8Native\": () => (/* binding */ _decodeUtf8Native),\n/* harmony export */   \"_decodeUtf8Polyfill\": () => (/* binding */ _decodeUtf8Polyfill),\n/* harmony export */   \"_encodeUtf8Native\": () => (/* binding */ _encodeUtf8Native),\n/* harmony export */   \"_encodeUtf8Polyfill\": () => (/* binding */ _encodeUtf8Polyfill),\n/* harmony export */   \"decodeUtf8\": () => (/* binding */ decodeUtf8),\n/* harmony export */   \"encodeUtf8\": () => (/* binding */ encodeUtf8),\n/* harmony export */   \"fromCamelCase\": () => (/* binding */ fromCamelCase),\n/* harmony export */   \"fromCharCode\": () => (/* binding */ fromCharCode),\n/* harmony export */   \"fromCodePoint\": () => (/* binding */ fromCodePoint),\n/* harmony export */   \"repeat\": () => (/* binding */ repeat),\n/* harmony export */   \"splice\": () => (/* binding */ splice),\n/* harmony export */   \"trimLeft\": () => (/* binding */ trimLeft),\n/* harmony export */   \"utf8ByteLength\": () => (/* binding */ utf8ByteLength),\n/* harmony export */   \"utf8TextDecoder\": () => (/* binding */ utf8TextDecoder),\n/* harmony export */   \"utf8TextEncoder\": () => (/* binding */ utf8TextEncoder)\n/* harmony export */ });\n/* harmony import */ var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array.js */ \"../node_modules/lib0/array.js\");\n\n\n/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nconst fromCharCode = String.fromCharCode\nconst fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nconst fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nconst utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* c8 ignore next */\nconst utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nconst _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* c8 ignore next */\nconst encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* c8 ignore next */\nlet utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* c8 ignore start */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* c8 ignore next */\n  utf8TextDecoder = null\n}\n/* c8 ignore stop */\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nconst _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* c8 ignore next */\nconst decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nconst splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n\n/**\n * @param {string} source\n * @param {number} n\n */\nconst repeat = (source, n) => _array_js__WEBPACK_IMPORTED_MODULE_0__.unfold(n, () => source).join('')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDQTs7QUFFUDtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDTzs7QUFFUDs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ08sMkZBQTJGLFVBQVUsRUFBRSxtQkFBbUI7O0FBRWpJO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDTyxtQ0FBbUMsYUFBYTs7QUFFdkQ7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDTzs7QUFFUDtBQUNBLFdBQVcsWUFBWTtBQUN2QixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPLDZGQUE2Riw4QkFBOEI7O0FBRWxJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWTtBQUNaO0FBQ08sNENBQTRDLGFBQWE7O0FBRWhFO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVk7QUFDWjtBQUNBO0FBQ087O0FBRVA7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTzs7QUFFUDtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDTyw4QkFBOEIsNkNBQVkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3RyaW5nLmpzP2Y0ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggc3RyaW5ncy5cbiAqXG4gKiBAbW9kdWxlIHN0cmluZ1xuICovXG5cbmV4cG9ydCBjb25zdCBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlXG5leHBvcnQgY29uc3QgZnJvbUNvZGVQb2ludCA9IFN0cmluZy5mcm9tQ29kZVBvaW50XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgdG9Mb3dlckNhc2UgPSBzID0+IHMudG9Mb3dlckNhc2UoKVxuXG5jb25zdCB0cmltTGVmdFJlZ2V4ID0gL15cXHMqL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdHJpbUxlZnQgPSBzID0+IHMucmVwbGFjZSh0cmltTGVmdFJlZ2V4LCAnJylcblxuY29uc3QgZnJvbUNhbWVsQ2FzZVJlZ2V4ID0gLyhbQS1aXSkvZ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VwYXJhdG9yXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tQ2FtZWxDYXNlID0gKHMsIHNlcGFyYXRvcikgPT4gdHJpbUxlZnQocy5yZXBsYWNlKGZyb21DYW1lbENhc2VSZWdleCwgbWF0Y2ggPT4gYCR7c2VwYXJhdG9yfSR7dG9Mb3dlckNhc2UobWF0Y2gpfWApKVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHV0ZjhCeXRlTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCB1dGY4Qnl0ZUxlbmd0aCA9IHN0ciA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkubGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4UG9seWZpbGwgPSBzdHIgPT4ge1xuICBjb25zdCBlbmNvZGVkU3RyaW5nID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpXG4gIGNvbnN0IGxlbiA9IGVuY29kZWRTdHJpbmcubGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoZW5jb2RlZFN0cmluZy5jb2RlUG9pbnRBdChpKSlcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdXRmOFRleHRFbmNvZGVyID0gLyoqIEB0eXBlIHtUZXh0RW5jb2Rlcn0gKi8gKHR5cGVvZiBUZXh0RW5jb2RlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgVGV4dEVuY29kZXIoKSA6IG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVVdGY4TmF0aXZlID0gc3RyID0+IHV0ZjhUZXh0RW5jb2Rlci5lbmNvZGUoc3RyKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZW5jb2RlVXRmOCA9IHV0ZjhUZXh0RW5jb2RlciA/IF9lbmNvZGVVdGY4TmF0aXZlIDogX2VuY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOFBvbHlmaWxsID0gYnVmID0+IHtcbiAgbGV0IHJlbWFpbmluZ0xlbiA9IGJ1Zi5sZW5ndGhcbiAgbGV0IGVuY29kZWRTdHJpbmcgPSAnJ1xuICBsZXQgYnVmUG9zID0gMFxuICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgIGNvbnN0IG5leHRMZW4gPSByZW1haW5pbmdMZW4gPCAxMDAwMCA/IHJlbWFpbmluZ0xlbiA6IDEwMDAwXG4gICAgY29uc3QgYnl0ZXMgPSBidWYuc3ViYXJyYXkoYnVmUG9zLCBidWZQb3MgKyBuZXh0TGVuKVxuICAgIGJ1ZlBvcyArPSBuZXh0TGVuXG4gICAgLy8gU3RhcnRpbmcgd2l0aCBFUzUuMSB3ZSBjYW4gc3VwcGx5IGEgZ2VuZXJpYyBhcnJheS1saWtlIG9iamVjdCBhcyBhcmd1bWVudHNcbiAgICBlbmNvZGVkU3RyaW5nICs9IFN0cmluZy5mcm9tQ29kZVBvaW50LmFwcGx5KG51bGwsIC8qKiBAdHlwZSB7YW55fSAqLyAoYnl0ZXMpKVxuICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gIH1cbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoZW5jb2RlZFN0cmluZykpXG59XG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgbGV0IHV0ZjhUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgZmF0YWw6IHRydWUsIGlnbm9yZUJPTTogdHJ1ZSB9KVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmlmICh1dGY4VGV4dERlY29kZXIgJiYgdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEpIHtcbiAgLy8gU2FmYXJpIGRvZXNuJ3QgaGFuZGxlIEJPTSBjb3JyZWN0bHkuXG4gIC8vIFRoaXMgZml4ZXMgYSBidWcgaW4gU2FmYXJpIDEzLjAuNSB3aGVyZSBpdCBwcm9kdWNlcyBhIEJPTSB0aGUgZmlyc3QgdGltZSBpdCBpcyBjYWxsZWQuXG4gIC8vIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxIG9uIHRoZSBmaXJzdCBjYWxsIGFuZFxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgc2Vjb25kIGNhbGxcbiAgLy8gQW5vdGhlciBpc3N1ZSBpcyB0aGF0IGZyb20gdGhlbiBvbiBubyBCT00gY2hhcnMgYXJlIHJlY29nbml6ZWQgYW55bW9yZVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB1dGY4VGV4dERlY29kZXIgPSBudWxsXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCBfZGVjb2RlVXRmOE5hdGl2ZSA9IGJ1ZiA9PiAvKiogQHR5cGUge1RleHREZWNvZGVyfSAqLyAodXRmOFRleHREZWNvZGVyKS5kZWNvZGUoYnVmKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgZGVjb2RlVXRmOCA9IHV0ZjhUZXh0RGVjb2RlciA/IF9kZWNvZGVVdGY4TmF0aXZlIDogX2RlY29kZVV0ZjhQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgVGhlIGluaXRpYWwgc3RyaW5nXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggU3RhcnRpbmcgcG9zaXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSByZW1vdmUgTnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5zZXJ0IE5ldyBjb250ZW50IHRvIGluc2VydFxuICovXG5leHBvcnQgY29uc3Qgc3BsaWNlID0gKHN0ciwgaW5kZXgsIHJlbW92ZSwgaW5zZXJ0ID0gJycpID0+IHN0ci5zbGljZSgwLCBpbmRleCkgKyBpbnNlcnQgKyBzdHIuc2xpY2UoaW5kZXggKyByZW1vdmUpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZVxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlcGVhdCA9IChzb3VyY2UsIG4pID0+IGFycmF5LnVuZm9sZChuLCAoKSA9PiBzb3VyY2UpLmpvaW4oJycpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/string.js\n");

/***/ }),

/***/ "../node_modules/lib0/symbol.js":
/*!**************************************!*\
  !*** ../node_modules/lib0/symbol.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"create\": () => (/* binding */ create),\n/* harmony export */   \"isSymbol\": () => (/* binding */ isSymbol)\n/* harmony export */ });\n/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nconst create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nconst isSymbol = s => typeof s === 'symbol'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvc3ltYm9sLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTzs7QUFFUDtBQUNBLFdBQVcsS0FBSztBQUNoQixZQUFZO0FBQ1o7QUFDTyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC9zeW1ib2wuanM/Yjc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBFY21hU2NyaXB0IFN5bWJvbHMuXG4gKlxuICogQG1vZHVsZSBzeW1ib2xcbiAqL1xuXG4vKipcbiAqIFJldHVybiBmcmVzaCBzeW1ib2wuXG4gKlxuICogQHJldHVybiB7U3ltYm9sfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gU3ltYm9sXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IHNcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBpc1N5bWJvbCA9IHMgPT4gdHlwZW9mIHMgPT09ICdzeW1ib2wnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/lib0/symbol.js\n");

/***/ }),

/***/ "../node_modules/lib0/time.js":
/*!************************************!*\
  !*** ../node_modules/lib0/time.js ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getDate\": () => (/* binding */ getDate),\n/* harmony export */   \"getUnixTime\": () => (/* binding */ getUnixTime),\n/* harmony export */   \"humanizeDuration\": () => (/* binding */ humanizeDuration)\n/* harmony export */ });\n/* harmony import */ var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./metric.js */ \"../node_modules/lib0/metric.js\");\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math.js */ \"../node_modules/lib0/math.js\");\n/**\n * Utility module to work with time.\n *\n * @module time\n */\n\n\n\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nconst getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nconst getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nconst humanizeDuration = d => {\n  if (d < 60000) {\n    const p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1)\n    return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60\n  const hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24\n  const days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* c8 ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvdGltZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFDO0FBQ0o7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDTztBQUNQO0FBQ0EsY0FBYyw4Q0FBYTtBQUMzQixXQUFXLDJDQUFVO0FBQ3JCO0FBQ0EsTUFBTSwyQ0FBVTtBQUNoQjtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixnQkFBZ0IsMkNBQVU7QUFDMUIsZUFBZSwyQ0FBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2xpYjAvdGltZS5qcz9jOGFiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRpbWUuXG4gKlxuICogQG1vZHVsZSB0aW1lXG4gKi9cblxuaW1wb3J0ICogYXMgbWV0cmljIGZyb20gJy4vbWV0cmljLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtEYXRlfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RGF0ZSA9ICgpID0+IG5ldyBEYXRlKClcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB1bml4IHRpbWUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VW5peFRpbWUgPSBEYXRlLm5vd1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aW1lIChpbiBtcykgdG8gYSBodW1hbiByZWFkYWJsZSBmb3JtYXQuIEUuZy4gMTEwMCA9PiAxLjFzLiA2MHMgPT4gMW1pbi4gLjAwMSA9PiAxMM68cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZCBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAqIEByZXR1cm4ge3N0cmluZ30gaHVtYW5pemVkIGFwcHJveGltYXRpb24gb2YgdGltZVxuICovXG5leHBvcnQgY29uc3QgaHVtYW5pemVEdXJhdGlvbiA9IGQgPT4ge1xuICBpZiAoZCA8IDYwMDAwKSB7XG4gICAgY29uc3QgcCA9IG1ldHJpYy5wcmVmaXgoZCwgLTEpXG4gICAgcmV0dXJuIG1hdGgucm91bmQocC5uICogMTAwKSAvIDEwMCArIHAucHJlZml4ICsgJ3MnXG4gIH1cbiAgZCA9IG1hdGguZmxvb3IoZCAvIDEwMDApXG4gIGNvbnN0IHNlY29uZHMgPSBkICUgNjBcbiAgY29uc3QgbWludXRlcyA9IG1hdGguZmxvb3IoZCAvIDYwKSAlIDYwXG4gIGNvbnN0IGhvdXJzID0gbWF0aC5mbG9vcihkIC8gMzYwMCkgJSAyNFxuICBjb25zdCBkYXlzID0gbWF0aC5mbG9vcihkIC8gODY0MDApXG4gIGlmIChkYXlzID4gMCkge1xuICAgIHJldHVybiBkYXlzICsgJ2QnICsgKChob3VycyA+IDAgfHwgbWludXRlcyA+IDMwKSA/ICcgJyArIChtaW51dGVzID4gMzAgPyBob3VycyArIDEgOiBob3VycykgKyAnaCcgOiAnJylcbiAgfVxuICBpZiAoaG91cnMgPiAwKSB7XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gaG91cnMgKyAnaCcgKyAoKG1pbnV0ZXMgPiAwIHx8IHNlY29uZHMgPiAzMCkgPyAnICcgKyAoc2Vjb25kcyA+IDMwID8gbWludXRlcyArIDEgOiBtaW51dGVzKSArICdtaW4nIDogJycpXG4gIH1cbiAgcmV0dXJuIG1pbnV0ZXMgKyAnbWluJyArIChzZWNvbmRzID4gMCA/ICcgJyArIHNlY29uZHMgKyAncycgOiAnJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/lib0/time.js\n");

/***/ }),

/***/ "../node_modules/lib0/webcrypto.js":
/*!*****************************************!*\
  !*** ../node_modules/lib0/webcrypto.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getRandomValues\": () => (/* binding */ getRandomValues),\n/* harmony export */   \"subtle\": () => (/* binding */ subtle)\n/* harmony export */ });\n/* eslint-env browser */\n\nconst subtle = crypto.subtle\nconst getRandomValues = crypto.getRandomValues.bind(crypto)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2xpYjAvd2ViY3J5cHRvLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7O0FBRU87QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbGliMC93ZWJjcnlwdG8uanM/NjkxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuZXhwb3J0IGNvbnN0IHN1YnRsZSA9IGNyeXB0by5zdWJ0bGVcbmV4cG9ydCBjb25zdCBnZXRSYW5kb21WYWx1ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/lib0/webcrypto.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/contrib/backo2.js":
/*!********************************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/contrib/backo2.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Backoff\": () => (/* binding */ Backoff)\n/* harmony export */ });\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nfunction Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL2NvbnRyaWIvYmFja28yLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL2JhY2tvMi5qcz83ZjYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gICAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHRoaXMubXMgPSBtaW47XG59O1xuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG59O1xuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uIChqaXR0ZXIpIHtcbiAgICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/contrib/backo2.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Manager\": () => (/* reexport safe */ _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager),\n/* harmony export */   \"Socket\": () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket),\n/* harmony export */   \"connect\": () => (/* binding */ lookup),\n/* harmony export */   \"default\": () => (/* binding */ lookup),\n/* harmony export */   \"io\": () => (/* binding */ lookup),\n/* harmony export */   \"protocol\": () => (/* reexport safe */ socket_io_parser__WEBPACK_IMPORTED_MODULE_3__.protocol)\n/* harmony export */ });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ \"../node_modules/socket.io-client/build/esm/url.js\");\n/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./manager.js */ \"../node_modules/socket.io-client/build/esm/manager.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket.js */ \"../node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-parser */ \"../node_modules/socket.io-parser/build/esm/index.js\");\n\n\n\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = (0,_url_js__WEBPACK_IMPORTED_MODULE_0__.url)(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager,\n    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\n\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDUTtBQUNGO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRDQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdEQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnRiIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vaW5kZXguanM/MzRiYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cmwgfSBmcm9tIFwiLi91cmwuanNcIjtcbmltcG9ydCB7IE1hbmFnZXIgfSBmcm9tIFwiLi9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBjb25zdCBwYXJzZWQgPSB1cmwodXJpLCBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gICAgY29uc3QgaWQgPSBwYXJzZWQuaWQ7XG4gICAgY29uc3QgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgIGNvbnN0IHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF1bXCJuc3BzXCJdO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8XG4gICAgICAgIG9wdHNbXCJmb3JjZSBuZXcgY29ubmVjdGlvblwiXSB8fFxuICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHxcbiAgICAgICAgc2FtZU5hbWVzcGFjZTtcbiAgICBsZXQgaW87XG4gICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgaW8gPSBuZXcgTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIGNhY2hlW2lkXSA9IG5ldyBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaW8gPSBjYWNoZVtpZF07XG4gICAgfVxuICAgIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeUtleTtcbiAgICB9XG4gICAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG4vLyBzbyB0aGF0IFwibG9va3VwXCIgY2FuIGJlIHVzZWQgYm90aCBhcyBhIGZ1bmN0aW9uIChlLmcuIGBpbyguLi4pYCkgYW5kIGFzIGFcbi8vIG5hbWVzcGFjZSAoZS5nLiBgaW8uY29ubmVjdCguLi4pYCksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKGxvb2t1cCwge1xuICAgIE1hbmFnZXIsXG4gICAgU29ja2V0LFxuICAgIGlvOiBsb29rdXAsXG4gICAgY29ubmVjdDogbG9va3VwLFxufSk7XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBwcm90b2NvbCB9IGZyb20gXCJzb2NrZXQuaW8tcGFyc2VyXCI7XG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBNYW5hZ2VyLCBTb2NrZXQsIGxvb2t1cCBhcyBpbywgbG9va3VwIGFzIGNvbm5lY3QsIGxvb2t1cCBhcyBkZWZhdWx0LCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/index.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/manager.js":
/*!*************************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/manager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Manager\": () => (/* binding */ Manager)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ \"../node_modules/engine.io-client/build/esm/index.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./socket.js */ \"../node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-parser */ \"../node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./on.js */ \"../node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/backo2.js */ \"../node_modules/socket.io-client/build/esm/contrib/backo2.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n\n\n\n\n\n\nclass Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.installTimerFunctions)(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__.Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        // emit `error`\n        const errorSub = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", (err) => {\n            self.cleanup();\n            self._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                self.maybeReconnectOnOpen();\n            }\n        });\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            if (timeout === 0) {\n                openSubDestroy(); // prevents a race condition with the 'open' event\n            }\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                socket.close();\n                // @ts-ignore\n                socket.emit(\"error\", new Error(\"timeout\"));\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push((0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"ping\", this.onping.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"data\", this.ondata.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", this.onerror.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"close\", this.onclose.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(function subDestroy() {\n                clearTimeout(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL21hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFzRjtBQUNqRDtBQUNNO0FBQ2Q7QUFDaUI7QUFDVTtBQUNqRCxzQkFBc0IsaUVBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1RUFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix1REFBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDZDQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQU07QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwQ0FBRTtBQUNqQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EseUJBQXlCLDBDQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBRSwwQ0FBMEMsMENBQUUsMENBQTBDLDBDQUFFLDRDQUE0QywwQ0FBRSw0Q0FBNEMsMENBQUU7QUFDN007QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQVE7QUFDaEI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsOENBQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vbWFuYWdlci5qcz9hYTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvY2tldCBhcyBFbmdpbmUsIGluc3RhbGxUaW1lckZ1bmN0aW9ucywgbmV4dFRpY2ssIH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbmltcG9ydCB7IFNvY2tldCB9IGZyb20gXCIuL3NvY2tldC5qc1wiO1xuaW1wb3J0ICogYXMgcGFyc2VyIGZyb20gXCJzb2NrZXQuaW8tcGFyc2VyXCI7XG5pbXBvcnQgeyBvbiB9IGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgeyBCYWNrb2ZmIH0gZnJvbSBcIi4vY29udHJpYi9iYWNrbzIuanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIsIH0gZnJvbSBcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIjtcbmV4cG9ydCBjbGFzcyBNYW5hZ2VyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3BzID0ge307XG4gICAgICAgIHRoaXMuc3VicyA9IFtdO1xuICAgICAgICBpZiAodXJpICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB1cmkpIHtcbiAgICAgICAgICAgIG9wdHMgPSB1cmk7XG4gICAgICAgICAgICB1cmkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCBcIi9zb2NrZXQuaW9cIjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgICAgICAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKChfYSA9IG9wdHMucmFuZG9taXphdGlvbkZhY3RvcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC41KTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgICAgICAgICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgICAgICAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICAgICAgICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLnVyaSA9IHVyaTtcbiAgICAgICAgY29uc3QgX3BhcnNlciA9IG9wdHMucGFyc2VyIHx8IHBhcnNlcjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbmV3IF9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLmRlY29kZXIgPSBuZXcgX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2F1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvQ29ubmVjdClcbiAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb24odikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb25BdHRlbXB0cyh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1pbih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJhbmRvbWl6YXRpb25GYWN0b3Iodikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEppdHRlcih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1heCh2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRpbWVvdXQodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAgICAgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbWF5YmVSZWNvbm5lY3RPbk9wZW4oKSB7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9yZWNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBvcHRpb25hbCwgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb3Blbihmbikge1xuICAgICAgICBpZiAofnRoaXMuX3JlYWR5U3RhdGUuaW5kZXhPZihcIm9wZW5cIikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgRW5naW5lKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIC8vIGVtaXQgYG9wZW5gXG4gICAgICAgIGNvbnN0IG9wZW5TdWJEZXN0cm95ID0gb24oc29ja2V0LCBcIm9wZW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbm9wZW4oKTtcbiAgICAgICAgICAgIGZuICYmIGZuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBlbWl0IGBlcnJvcmBcbiAgICAgICAgY29uc3QgZXJyb3JTdWIgPSBvbihzb2NrZXQsIFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgICAgICAgICBzZWxmLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9wZW5TdWJEZXN0cm95KCk7IC8vIHByZXZlbnRzIGEgcmFjZSBjb25kaXRpb24gd2l0aCB0aGUgJ29wZW4nIGV2ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGltZXJcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wZW5TdWJEZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHNvY2tldC5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKGZ1bmN0aW9uIHN1YkRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWJEZXN0cm95KTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIG9wZW4oKVxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNvbm5lY3QoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbihmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbm9wZW4oKSB7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBzdWJzXG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAvLyBtYXJrIGFzIG9wZW5cbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm9wZW5cIik7XG4gICAgICAgIC8vIGFkZCBuZXcgc3Vic1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCBcInBpbmdcIiwgdGhpcy5vbnBpbmcuYmluZCh0aGlzKSksIG9uKHNvY2tldCwgXCJkYXRhXCIsIHRoaXMub25kYXRhLmJpbmQodGhpcykpLCBvbihzb2NrZXQsIFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpLCBvbihzb2NrZXQsIFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLCBvbih0aGlzLmRlY29kZXIsIFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25waW5nKCkge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJwYXJzZSBlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kZWNvZGVkKHBhY2tldCkge1xuICAgICAgICAvLyB0aGUgbmV4dFRpY2sgY2FsbCBwcmV2ZW50cyBhbiBleGNlcHRpb24gaW4gYSB1c2VyLXByb3ZpZGVkIGV2ZW50IGxpc3RlbmVyIGZyb20gdHJpZ2dlcmluZyBhIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGEgXCJwYXJzZSBlcnJvclwiXG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldChuc3AsIG9wdHMpIHtcbiAgICAgICAgbGV0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYXV0b0Nvbm5lY3QgJiYgIXNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc29ja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVzdHJveShzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgbnNwcyA9IE9iamVjdC5rZXlzKHRoaXMubnNwcyk7XG4gICAgICAgIGZvciAoY29uc3QgbnNwIG9mIG5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICAgICAgaWYgKHNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhY2tldChwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWJEZXN0cm95KSA9PiBzdWJEZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnN1YnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgICAgIGlmICh0aGlzLmVuZ2luZSlcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBjbG9zZSgpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5fcmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9mYWlsZWRcIik7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0X2F0dGVtcHRcIiwgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc2VsZi5vcGVuKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RfZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5hdXRvVW5yZWYpIHtcbiAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdWJzLnB1c2goZnVuY3Rpb24gc3ViRGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ucmVjb25uZWN0KCkge1xuICAgICAgICBjb25zdCBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0XCIsIGF0dGVtcHQpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/manager.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/on.js":
/*!********************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/on.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"on\": () => (/* binding */ on)\n/* harmony export */ });\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL29uLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL29uLmpzP2IxNGEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gICAgb2JqLm9uKGV2LCBmbik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHN1YkRlc3Ryb3koKSB7XG4gICAgICAgIG9iai5vZmYoZXYsIGZuKTtcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/on.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/socket.js":
/*!************************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/socket.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Socket\": () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-parser */ \"../node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./on.js */ \"../node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n\n\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__.Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"open\", this.onopen.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"packet\", this.onpacket.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"error\", this.onerror.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n        }\n        else if (this.connected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        this.acks[id] = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, [null, ...args]);\n        };\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        // the timeout flag is optional\n        const withErr = this.flags.timeout !== undefined || this._opts.ackTimeout !== undefined;\n        return new Promise((resolve, reject) => {\n            args.push((arg1, arg2) => {\n                if (withErr) {\n                    return arg1 ? reject(arg1) : resolve(arg2);\n                }\n                else {\n                    return resolve(arg1);\n                }\n            });\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowlegement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (\"function\" === typeof ack) {\n            ack.apply(this, packet.data);\n            delete this.acks[packet.id];\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL3NvY2tldC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThDO0FBQ2pCO0FBQzJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsZUFBZTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DLElBQUk7QUFDSjtBQUNPLHFCQUFxQixpRUFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsWUFBWTtBQUNaO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsbUJBQW1CO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsUUFBUTtBQUNSO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUFFO0FBQ2QsWUFBWSwwQ0FBRTtBQUNkLFlBQVksMENBQUU7QUFDZCxZQUFZLDBDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUNBQW1DO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhEQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxpQkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFrQjtBQUNwQztBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnRUFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWdCO0FBQ2pDLGlCQUFpQixxRUFBdUI7QUFDeEM7QUFDQTtBQUNBLGlCQUFpQiw0REFBYztBQUMvQixpQkFBaUIsbUVBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUIsbUVBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUIsc0VBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDREQUFjO0FBQ3BDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxjQUFjO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sbUVBQXFCLEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE1BQU07QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vc29ja2V0LmpzPzA0MWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFja2V0VHlwZSB9IGZyb20gXCJzb2NrZXQuaW8tcGFyc2VyXCI7XG5pbXBvcnQgeyBvbiB9IGZyb20gXCIuL29uLmpzXCI7XG5pbXBvcnQgeyBFbWl0dGVyLCB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG4vKipcbiAqIEludGVybmFsIGV2ZW50cy5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICovXG5jb25zdCBSRVNFUlZFRF9FVkVOVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBjb25uZWN0OiAxLFxuICAgIGNvbm5lY3RfZXJyb3I6IDEsXG4gICAgZGlzY29ubmVjdDogMSxcbiAgICBkaXNjb25uZWN0aW5nOiAxLFxuICAgIC8vIEV2ZW50RW1pdHRlciByZXNlcnZlZCBldmVudHM6IGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2V2ZW50X25ld2xpc3RlbmVyXG4gICAgbmV3TGlzdGVuZXI6IDEsXG4gICAgcmVtb3ZlTGlzdGVuZXI6IDEsXG59KTtcbi8qKlxuICogQSBTb2NrZXQgaXMgdGhlIGZ1bmRhbWVudGFsIGNsYXNzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBzZXJ2ZXIuXG4gKlxuICogQSBTb2NrZXQgYmVsb25ncyB0byBhIGNlcnRhaW4gTmFtZXNwYWNlIChieSBkZWZhdWx0IC8pIGFuZCB1c2VzIGFuIHVuZGVybHlpbmcge0BsaW5rIE1hbmFnZXJ9IHRvIGNvbW11bmljYXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBzb2NrZXQgPSBpbygpO1xuICpcbiAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICogICBjb25zb2xlLmxvZyhcImNvbm5lY3RlZFwiKTtcbiAqIH0pO1xuICpcbiAqIC8vIHNlbmQgYW4gZXZlbnQgdG8gdGhlIHNlcnZlclxuICogc29ja2V0LmVtaXQoXCJmb29cIiwgXCJiYXJcIik7XG4gKlxuICogc29ja2V0Lm9uKFwiZm9vYmFyXCIsICgpID0+IHtcbiAqICAgLy8gYW4gZXZlbnQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICogfSk7XG4gKlxuICogLy8gdXBvbiBkaXNjb25uZWN0aW9uXG4gKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAqICAgY29uc29sZS5sb2coYGRpc2Nvbm5lY3RlZCBkdWUgdG8gJHtyZWFzb259YCk7XG4gKiB9KTtcbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldCBleHRlbmRzIEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGlvLCBuc3AsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgY29ubmVjdGVkIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHNvY2tldC5vbihcImNvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uZWN0ZWQpOyAvLyB0cnVlXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsICgpID0+IHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuY29ubmVjdGVkKTsgLy8gZmFsc2VcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgY29ubmVjdGlvbiBzdGF0ZSB3YXMgcmVjb3ZlcmVkIGFmdGVyIGEgdGVtcG9yYXJ5IGRpc2Nvbm5lY3Rpb24uIEluIHRoYXQgY2FzZSwgYW55IG1pc3NlZCBwYWNrZXRzIHdpbGxcbiAgICAgICAgICogYmUgdHJhbnNtaXR0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVjb3ZlcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgZm9yIHBhY2tldHMgcmVjZWl2ZWQgYmVmb3JlIHRoZSBDT05ORUNUIHBhY2tldFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWZmZXIgZm9yIHBhY2tldHMgdGhhdCB3aWxsIGJlIHNlbnQgb25jZSB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcXVldWUgb2YgcGFja2V0cyB0byBiZSBzZW50IHdpdGggcmV0cnkgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQYWNrZXRzIGFyZSBzZW50IG9uZSBieSBvbmUsIGVhY2ggd2FpdGluZyBmb3IgdGhlIHNlcnZlciBhY2tub3dsZWRnZW1lbnQsIGluIG9yZGVyIHRvIGd1YXJhbnRlZSB0aGUgZGVsaXZlcnkgb3JkZXIuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXF1ZW5jZSB0byBnZW5lcmF0ZSB0aGUgSUQgb2YgdGhlIHtAbGluayBRdWV1ZWRQYWNrZXR9LlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcXVldWVTZXEgPSAwO1xuICAgICAgICB0aGlzLmlkcyA9IDA7XG4gICAgICAgIHRoaXMuYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHRoaXMuaW8gPSBpbztcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuYXV0aCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gb3B0cy5hdXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuaW8uX2F1dG9Db25uZWN0KVxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgZGlzY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kaXNjb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGlzY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWJFdmVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlvID0gdGhpcy5pbztcbiAgICAgICAgdGhpcy5zdWJzID0gW1xuICAgICAgICAgICAgb24oaW8sIFwib3BlblwiLCB0aGlzLm9ub3Blbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIG9uKGlvLCBcInBhY2tldFwiLCB0aGlzLm9ucGFja2V0LmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb24oaW8sIFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb24oaW8sIFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBTb2NrZXQgd2lsbCB0cnkgdG8gcmVjb25uZWN0IHdoZW4gaXRzIE1hbmFnZXIgY29ubmVjdHMgb3IgcmVjb25uZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHNvY2tldC5hY3RpdmUpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAgICAgKiAgIGlmIChyZWFzb24gPT09IFwiaW8gc2VydmVyIGRpc2Nvbm5lY3RcIikge1xuICAgICAqICAgICAvLyB0aGUgZGlzY29ubmVjdGlvbiB3YXMgaW5pdGlhdGVkIGJ5IHRoZSBzZXJ2ZXIsIHlvdSBuZWVkIHRvIG1hbnVhbGx5IHJlY29ubmVjdFxuICAgICAqICAgICBjb25zb2xlLmxvZyhzb2NrZXQuYWN0aXZlKTsgLy8gZmFsc2VcbiAgICAgKiAgIH1cbiAgICAgKiAgIC8vIGVsc2UgdGhlIHNvY2tldCB3aWxsIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIHJlY29ubmVjdFxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmFjdGl2ZSk7IC8vIHRydWVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnN1YnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbyh7XG4gICAgICogICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuc3ViRXZlbnRzKCk7XG4gICAgICAgIGlmICghdGhpcy5pb1tcIl9yZWNvbm5lY3RpbmdcIl0pXG4gICAgICAgICAgICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmlvLl9yZWFkeVN0YXRlKVxuICAgICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgY29ubmVjdCgpfS5cbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICBhcmdzLnVuc2hpZnQoXCJtZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBgZW1pdGAuXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogVWludDhBcnJheS5mcm9tKFs2XSkgfSk7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIiwgKHZhbCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChSRVNFUlZFRF9FVkVOVFMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGV2LnRvU3RyaW5nKCkgKyAnXCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGV2KTtcbiAgICAgICAgaWYgKHRoaXMuX29wdHMucmV0cmllcyAmJiAhdGhpcy5mbGFncy5mcm9tUXVldWUgJiYgIXRoaXMuZmxhZ3Mudm9sYXRpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZFRvUXVldWUoYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBQYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm9wdGlvbnMgPSB7fTtcbiAgICAgICAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSB0aGlzLmZsYWdzLmNvbXByZXNzICE9PSBmYWxzZTtcbiAgICAgICAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5pZHMrKztcbiAgICAgICAgICAgIGNvbnN0IGFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spO1xuICAgICAgICAgICAgcGFja2V0LmlkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNUcmFuc3BvcnRXcml0YWJsZSA9IHRoaXMuaW8uZW5naW5lICYmXG4gICAgICAgICAgICB0aGlzLmlvLmVuZ2luZS50cmFuc3BvcnQgJiZcbiAgICAgICAgICAgIHRoaXMuaW8uZW5naW5lLnRyYW5zcG9ydC53cml0YWJsZTtcbiAgICAgICAgY29uc3QgZGlzY2FyZFBhY2tldCA9IHRoaXMuZmxhZ3Mudm9sYXRpbGUgJiYgKCFpc1RyYW5zcG9ydFdyaXRhYmxlIHx8ICF0aGlzLmNvbm5lY3RlZCk7XG4gICAgICAgIGlmIChkaXNjYXJkUGFja2V0KSB7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSAoX2EgPSB0aGlzLmZsYWdzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX29wdHMuYWNrVGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tzW2lkXSA9IGFjaztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHRpbWVyID0gdGhpcy5pby5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWNrc1tpZF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbmRCdWZmZXJbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNrLmNhbGwodGhpcywgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5hY2tzW2lkXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmlvLmNsZWFyVGltZW91dEZuKHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbbnVsbCwgLi4uYXJnc10pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBhbmQgd2FpdHMgZm9yIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyB3aXRob3V0IHRpbWVvdXRcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC5lbWl0V2l0aEFjayhcImhlbGxvXCIsIFwid29ybGRcIik7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGEgc3BlY2lmaWMgdGltZW91dFxuICAgICAqIHRyeSB7XG4gICAgICogICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNvY2tldC50aW1lb3V0KDEwMDApLmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKiB9IGNhdGNoIChlcnIpIHtcbiAgICAgKiAgIC8vIHRoZSBzZXJ2ZXIgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogfVxuICAgICAqXG4gICAgICogQHJldHVybiBhIFByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgYWNrbm93bGVkZ2VzIHRoZSBldmVudFxuICAgICAqL1xuICAgIGVtaXRXaXRoQWNrKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIC8vIHRoZSB0aW1lb3V0IGZsYWcgaXMgb3B0aW9uYWxcbiAgICAgICAgY29uc3Qgd2l0aEVyciA9IHRoaXMuZmxhZ3MudGltZW91dCAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuX29wdHMuYWNrVGltZW91dCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgYXJncy5wdXNoKChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpdGhFcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyZzEgPyByZWplY3QoYXJnMSkgOiByZXNvbHZlKGFyZzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoYXJnMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYWNrZXQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9RdWV1ZShhcmdzKSB7XG4gICAgICAgIGxldCBhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX3F1ZXVlU2VxKyssXG4gICAgICAgICAgICB0cnlDb3VudDogMCxcbiAgICAgICAgICAgIHBlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIGZsYWdzOiBPYmplY3QuYXNzaWduKHsgZnJvbVF1ZXVlOiB0cnVlIH0sIHRoaXMuZmxhZ3MpLFxuICAgICAgICB9O1xuICAgICAgICBhcmdzLnB1c2goKGVyciwgLi4ucmVzcG9uc2VBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFja2V0ICE9PSB0aGlzLl9xdWV1ZVswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwYWNrZXQgaGFzIGFscmVhZHkgYmVlbiBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNFcnJvciA9IGVyciAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQudHJ5Q291bnQgPiB0aGlzLl9vcHRzLnJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWNrKG51bGwsIC4uLnJlc3BvbnNlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFja2V0LnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhY2tldCk7XG4gICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgZmlyc3QgcGFja2V0IG9mIHRoZSBxdWV1ZSwgYW5kIHdhaXQgZm9yIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIGZvcmNlIC0gd2hldGhlciB0byByZXNlbmQgYSBwYWNrZXQgdGhhdCBoYXMgbm90IGJlZW4gYWNrbm93bGVkZ2VkIHlldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhaW5RdWV1ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcXVldWVbMF07XG4gICAgICAgIGlmIChwYWNrZXQucGVuZGluZyAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYWNrZXQucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHBhY2tldC50cnlDb3VudCsrO1xuICAgICAgICB0aGlzLmZsYWdzID0gcGFja2V0LmZsYWdzO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgcGFja2V0LmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICAgICAgICB0aGlzLmlvLl9wYWNrZXQocGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25vcGVuKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXV0aCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb25uZWN0UGFja2V0KGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29ubmVjdFBhY2tldCh0aGlzLmF1dGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgQ09OTkVDVCBwYWNrZXQgdG8gaW5pdGlhdGUgdGhlIFNvY2tldC5JTyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kQ29ubmVjdFBhY2tldChkYXRhKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgIHR5cGU6IFBhY2tldFR5cGUuQ09OTkVDVCxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX3BpZFxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IHBpZDogdGhpcy5fcGlkLCBvZmZzZXQ6IHRoaXMuX2xhc3RPZmZzZXQgfSwgZGF0YSlcbiAgICAgICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgb3IgbWFuYWdlciBgZXJyb3JgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVyclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25lcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdFwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9ucGFja2V0KHBhY2tldCkge1xuICAgICAgICBjb25zdCBzYW1lTmFtZXNwYWNlID0gcGFja2V0Lm5zcCA9PT0gdGhpcy5uc3A7XG4gICAgICAgIGlmICghc2FtZU5hbWVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldC5kYXRhICYmIHBhY2tldC5kYXRhLnNpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY29ubmVjdChwYWNrZXQuZGF0YS5zaWQsIHBhY2tldC5kYXRhLnBpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgbmV3IEVycm9yKFwiSXQgc2VlbXMgeW91IGFyZSB0cnlpbmcgdG8gcmVhY2ggYSBTb2NrZXQuSU8gc2VydmVyIGluIHYyLnggd2l0aCBhIHYzLnggY2xpZW50LCBidXQgdGhleSBhcmUgbm90IGNvbXBhdGlibGUgKG1vcmUgaW5mb3JtYXRpb24gaGVyZTogaHR0cHM6Ly9zb2NrZXQuaW8vZG9jcy92My9taWdyYXRpbmctZnJvbS0yLXgtdG8tMy0wLylcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SOlxuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihwYWNrZXQuZGF0YS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgZXJyLmRhdGEgPSBwYWNrZXQuZGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25ldmVudChwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICAgICAgICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goT2JqZWN0LmZyZWV6ZShhcmdzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW1pdEV2ZW50KGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgaWYgKHRoaXMuX3BpZCAmJiBhcmdzLmxlbmd0aCAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0T2Zmc2V0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFjayhpZCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHNlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChzZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFBhY2tldFR5cGUuQUNLLFxuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWNrKSB7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNvbm5lY3QoaWQsIHBpZCkge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMucmVjb3ZlcmVkID0gcGlkICYmIHRoaXMuX3BpZCA9PT0gcGlkO1xuICAgICAgICB0aGlzLl9waWQgPSBwaWQ7IC8vIGRlZmluZWQgb25seSBpZiBjb25uZWN0aW9uIHN0YXRlIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuX2RyYWluUXVldWUodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGVtaXRCdWZmZXJlZCgpIHtcbiAgICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyLmZvckVhY2goKGFyZ3MpID0+IHRoaXMuZW1pdEV2ZW50KGFyZ3MpKTtcbiAgICAgICAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChwYWNrZXQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMocGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMub25jbG9zZShcImlvIHNlcnZlciBkaXNjb25uZWN0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICAgICAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gICAgICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMpIHtcbiAgICAgICAgICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgICAgICAgICAgdGhpcy5zdWJzLmZvckVhY2goKHN1YkRlc3Ryb3kpID0+IHN1YkRlc3Ryb3koKSk7XG4gICAgICAgICAgICB0aGlzLnN1YnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pb1tcIl9kZXN0cm95XCJdKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LiBJbiB0aGF0IGNhc2UsIHRoZSBzb2NrZXQgd2lsbCBub3QgdHJ5IHRvIHJlY29ubmVjdC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgaXMgdGhlIGxhc3QgYWN0aXZlIFNvY2tldCBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIE1hbmFnZXJ9LCB0aGUgbG93LWxldmVsIGNvbm5lY3Rpb24gd2lsbCBiZSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAgICAgKiAgIC8vIGNvbnNvbGUubG9nKHJlYXNvbik7IHByaW50cyBcImlvIGNsaWVudCBkaXNjb25uZWN0XCJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogUGFja2V0VHlwZS5ESVNDT05ORUNUIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBkaXNjb25uZWN0KCl9LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LmNvbXByZXNzKGZhbHNlKS5lbWl0KFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MuY29tcHJlc3MgPSBjb21wcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IG1lc3NhZ2Ugd2lsbCBiZSBkcm9wcGVkIHdoZW4gdGhpcyBzb2NrZXQgaXMgbm90XG4gICAgICogcmVhZHkgdG8gc2VuZCBtZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnZvbGF0aWxlLmVtaXQoXCJoZWxsb1wiKTsgLy8gdGhlIHNlcnZlciBtYXkgb3IgbWF5IG5vdCByZWNlaXZlIGl0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzZWxmXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICB0aGlzLmZsYWdzLnZvbGF0aWxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCB3aXRob3V0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXI6XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC50aW1lb3V0KDUwMDApLmVtaXQoXCJteS1ldmVudFwiLCAoZXJyKSA9PiB7XG4gICAgICogICBpZiAoZXJyKSB7XG4gICAgICogICAgIC8vIHRoZSBzZXJ2ZXIgZGlkIG5vdCBhY2tub3dsZWRnZSB0aGUgZXZlbnQgaW4gdGhlIGdpdmVuIGRlbGF5XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBzZWxmXG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5vbkFueSgoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBnb3QgJHtldmVudH1gKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQucHJlcGVuZEFueSgoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBnb3QgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHByZXBlbmRBbnkobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHNvY2tldC5vbkFueShjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogc29ja2V0Lm9mZkFueShjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIG9yIHJlbW92ZSBhbGwgbGlzdGVuZXJzXG4gICAgICogc29ja2V0Lm9mZkFueSgpO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb2ZmQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBOb3RlOiBhY2tub3dsZWRnZW1lbnRzIHNlbnQgdG8gdGhlIHNlcnZlciBhcmUgbm90IGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQub25BbnlPdXRnb2luZygoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvbkFueU91dGdvaW5nKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLiBUaGUgZXZlbnQgbmFtZSBpcyBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZVxuICAgICAqIGNhbGxiYWNrLiBUaGUgbGlzdGVuZXIgaXMgYWRkZWQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdGVuZXJzIGFycmF5LlxuICAgICAqXG4gICAgICogTm90ZTogYWNrbm93bGVkZ2VtZW50cyBzZW50IHRvIHRoZSBzZXJ2ZXIgYXJlIG5vdCBpbmNsdWRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnByZXBlbmRBbnlPdXRnb2luZygoZXZlbnQsIC4uLmFyZ3MpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGBzZW50IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3QgY2F0Y2hBbGxMaXN0ZW5lciA9IChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBzb2NrZXQub25BbnlPdXRnb2luZyhjYXRjaEFsbExpc3RlbmVyKTtcbiAgICAgKlxuICAgICAqIC8vIHJlbW92ZSBhIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICogc29ja2V0Lm9mZkFueU91dGdvaW5nKGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogLy8gb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBzb2NrZXQub2ZmQW55T3V0Z29pbmcoKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbbGlzdGVuZXJdIC0gdGhlIGNhdGNoLWFsbCBsaXN0ZW5lciAob3B0aW9uYWwpXG4gICAgICovXG4gICAgb2ZmQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQgdGhhdCBpcyBzcGVjaWZpZWQuIFRoaXMgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkLFxuICAgICAqIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBsaXN0ZW5lcnNBbnlPdXRnb2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhlIGxpc3RlbmVycyBmb3IgZWFjaCBwYWNrZXQgc2VudFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzICYmIHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/socket.js\n");

/***/ }),

/***/ "../node_modules/socket.io-client/build/esm/url.js":
/*!*********************************************************!*\
  !*** ../node_modules/socket.io-client/build/esm/url.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"url\": () => (/* binding */ url)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ \"../node_modules/engine.io-client/build/esm/index.js\");\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.parse)(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvYnVpbGQvZXNtL3VybC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdURBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9idWlsZC9lc20vdXJsLmpzPzZmMWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcGFyc2UgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB1cmkgLSB1cmxcbiAqIEBwYXJhbSBwYXRoIC0gdGhlIHJlcXVlc3QgcGF0aCBvZiB0aGUgY29ubmVjdGlvblxuICogQHBhcmFtIGxvYyAtIEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXJsKHVyaSwgcGF0aCA9IFwiXCIsIGxvYykge1xuICAgIGxldCBvYmogPSB1cmk7XG4gICAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgICBsb2MgPSBsb2MgfHwgKHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBsb2NhdGlvbik7XG4gICAgaWYgKG51bGwgPT0gdXJpKVxuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2MuaG9zdDtcbiAgICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIHVyaSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoXCIvXCIgPT09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGlmIChcIi9cIiA9PT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5ob3N0ICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxvYykge1xuICAgICAgICAgICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHVyaSA9IFwiaHR0cHM6Ly9cIiArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBwYXJzZVxuICAgICAgICBvYmogPSBwYXJzZSh1cmkpO1xuICAgIH1cbiAgICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgICBpZiAoIW9iai5wb3J0KSB7XG4gICAgICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgICAgICAgb2JqLnBvcnQgPSBcIjgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICBvYmoucG9ydCA9IFwiNDQzXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCBcIi9cIjtcbiAgICBjb25zdCBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZihcIjpcIikgIT09IC0xO1xuICAgIGNvbnN0IGhvc3QgPSBpcHY2ID8gXCJbXCIgKyBvYmouaG9zdCArIFwiXVwiIDogb2JqLmhvc3Q7XG4gICAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICAgIG9iai5pZCA9IG9iai5wcm90b2NvbCArIFwiOi8vXCIgKyBob3N0ICsgXCI6XCIgKyBvYmoucG9ydCArIHBhdGg7XG4gICAgLy8gZGVmaW5lIGhyZWZcbiAgICBvYmouaHJlZiA9XG4gICAgICAgIG9iai5wcm90b2NvbCArXG4gICAgICAgICAgICBcIjovL1wiICtcbiAgICAgICAgICAgIGhvc3QgK1xuICAgICAgICAgICAgKGxvYyAmJiBsb2MucG9ydCA9PT0gb2JqLnBvcnQgPyBcIlwiIDogXCI6XCIgKyBvYmoucG9ydCk7XG4gICAgcmV0dXJuIG9iajtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/socket.io-client/build/esm/url.js\n");

/***/ }),

/***/ "../node_modules/socket.io-parser/build/esm/binary.js":
/*!************************************************************!*\
  !*** ../node_modules/socket.io-parser/build/esm/binary.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"deconstructPacket\": () => (/* binding */ deconstructPacket),\n/* harmony export */   \"reconstructPacket\": () => (/* binding */ reconstructPacket)\n/* harmony export */ });\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-binary.js */ \"../node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_0__.isBinary)(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvZXNtL2JpbmFyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFRO0FBQ2hCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9idWlsZC9lc20vYmluYXJ5LmpzPzliNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNCaW5hcnkgfSBmcm9tIFwiLi9pcy1iaW5hcnkuanNcIjtcbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgfCBCbG9iIHwgRmlsZSBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQHB1YmxpY1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICBjb25zdCBwYWNrID0gcGFja2V0O1xuICAgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgIHJldHVybiB7IHBhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVycyB9O1xufVxuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmIChpc0JpbmFyeShkYXRhKSkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWNvbnN0cnVjdFBhY2tldChwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gICAgZGVsZXRlIHBhY2tldC5hdHRhY2htZW50czsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICAgIHJldHVybiBwYWNrZXQ7XG59XG5mdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIgPT09IHRydWUpIHtcbiAgICAgICAgY29uc3QgaXNJbmRleFZhbGlkID0gdHlwZW9mIGRhdGEubnVtID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBkYXRhLm51bSA+PSAwICYmXG4gICAgICAgICAgICBkYXRhLm51bSA8IGJ1ZmZlcnMubGVuZ3RoO1xuICAgICAgICBpZiAoaXNJbmRleFZhbGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBhdHRhY2htZW50c1wiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/socket.io-parser/build/esm/binary.js\n");

/***/ }),

/***/ "../node_modules/socket.io-parser/build/esm/index.js":
/*!***********************************************************!*\
  !*** ../node_modules/socket.io-parser/build/esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Decoder\": () => (/* binding */ Decoder),\n/* harmony export */   \"Encoder\": () => (/* binding */ Encoder),\n/* harmony export */   \"PacketType\": () => (/* binding */ PacketType),\n/* harmony export */   \"protocol\": () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @socket.io/component-emitter */ \"../node_modules/@socket.io/component-emitter/index.mjs\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ \"../node_modules/socket.io-parser/build/esm/binary.js\");\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-binary.js */ \"../node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n\n\n/**\n * Protocol version.\n *\n * @public\n */\nconst protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.hasBinary)(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.deconstructPacket)(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__.Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.isBinary)(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return typeof payload === \"object\";\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || typeof payload === \"object\";\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"string\" || typeof payload[0] === \"number\"));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.reconstructPacket)(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDWTtBQUNkO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdEQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2REFBaUI7QUFDaEQ7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNPLHNCQUFzQixpRUFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVEQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2REFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvZXNtL2luZGV4LmpzP2MzMGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBkZWNvbnN0cnVjdFBhY2tldCwgcmVjb25zdHJ1Y3RQYWNrZXQgfSBmcm9tIFwiLi9iaW5hcnkuanNcIjtcbmltcG9ydCB7IGlzQmluYXJ5LCBoYXNCaW5hcnkgfSBmcm9tIFwiLi9pcy1iaW5hcnkuanNcIjtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBwcm90b2NvbCA9IDU7XG5leHBvcnQgdmFyIFBhY2tldFR5cGU7XG4oZnVuY3Rpb24gKFBhY2tldFR5cGUpIHtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUXCJdID0gMF0gPSBcIkNPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJESVNDT05ORUNUXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJFVkVOVFwiXSA9IDJdID0gXCJFVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkFDS1wiXSA9IDNdID0gXCJBQ0tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUX0VSUk9SXCJdID0gNF0gPSBcIkNPTk5FQ1RfRVJST1JcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJCSU5BUllfRVZFTlRcIl0gPSA1XSA9IFwiQklOQVJZX0VWRU5UXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0FDS1wiXSA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShQYWNrZXRUeXBlIHx8IChQYWNrZXRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogRW5jb2RlciBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVwbGFjZXIgLSBjdXN0b20gcmVwbGFjZXIgdG8gcGFzcyBkb3duIHRvIEpTT04ucGFyc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXBsYWNlcikge1xuICAgICAgICB0aGlzLnJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICAgICAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAgICAgKi9cbiAgICBlbmNvZGUob2JqKSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5FVkVOVCB8fCBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5BQ0spIHtcbiAgICAgICAgICAgIGlmIChoYXNCaW5hcnkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUFzQmluYXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gUGFja2V0VHlwZS5CSU5BUllfRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUGFja2V0VHlwZS5CSU5BUllfQUNLLFxuICAgICAgICAgICAgICAgICAgICBuc3A6IG9iai5uc3AsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5lbmNvZGVBc1N0cmluZyhvYmopXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gICAgICAgIC8vIGZpcnN0IGlzIHR5cGVcbiAgICAgICAgbGV0IHN0ciA9IFwiXCIgKyBvYmoudHlwZTtcbiAgICAgICAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfRVZFTlQgfHxcbiAgICAgICAgICAgIG9iai50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyBcIi1cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gICAgICAgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICAgICAgICBpZiAob2JqLm5zcCAmJiBcIi9cIiAhPT0gb2JqLm5zcCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5uc3AgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGpzb24gZGF0YVxuICAgICAgICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgICAgICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhLCB0aGlzLnJlcGxhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAgICAgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gICAgICovXG4gICAgZW5jb2RlQXNCaW5hcnkob2JqKSB7XG4gICAgICAgIGNvbnN0IGRlY29uc3RydWN0aW9uID0gZGVjb25zdHJ1Y3RQYWNrZXQob2JqKTtcbiAgICAgICAgY29uc3QgcGFjayA9IHRoaXMuZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG4gICAgICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICAgIH1cbn1cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICovXG5leHBvcnQgY2xhc3MgRGVjb2RlciBleHRlbmRzIEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIERlY29kZXIgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHJldml2ZXIgLSBjdXN0b20gcmV2aXZlciB0byBwYXNzIGRvd24gdG8gSlNPTi5zdHJpbmdpZnlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXZpdmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gZW5jb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAgICAgKi9cbiAgICBhZGQob2JqKSB7XG4gICAgICAgIGxldCBwYWNrZXQ7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IHBsYWludGV4dCBkYXRhIHdoZW4gcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWNrZXQgPSB0aGlzLmRlY29kZVN0cmluZyhvYmopO1xuICAgICAgICAgICAgY29uc3QgaXNCaW5hcnlFdmVudCA9IHBhY2tldC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDtcbiAgICAgICAgICAgIGlmIChpc0JpbmFyeUV2ZW50IHx8IHBhY2tldC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgICAgICBwYWNrZXQudHlwZSA9IGlzQmluYXJ5RXZlbnQgPyBQYWNrZXRUeXBlLkVWRU5UIDogUGFja2V0VHlwZS5BQ0s7XG4gICAgICAgICAgICAgICAgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuICAgICAgICAgICAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldC5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgICAgICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0JpbmFyeShvYmopIHx8IG9iai5iYXNlNjQpIHtcbiAgICAgICAgICAgIC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIiArIG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gICAgICovXG4gICAgZGVjb2RlU3RyaW5nKHN0cikge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIC8vIGxvb2sgdXAgdHlwZVxuICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyKHN0ci5jaGFyQXQoMCkpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoUGFja2V0VHlwZVtwLnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gcGFja2V0IHR5cGUgXCIgKyBwLnR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgICAgICAgaWYgKHAudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfRVZFTlQgfHxcbiAgICAgICAgICAgIHAudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPT0gXCItXCIgJiYgaSAhPSBzdHIubGVuZ3RoKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IGJ1ZiA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgICAgICAgICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9PSBcIi1cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgYXR0YWNobWVudHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgICAgICAgaWYgKFwiL1wiID09PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoXCIsXCIgPT09IGMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAubnNwID0gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwLm5zcCA9IFwiL1wiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgaWRcbiAgICAgICAgY29uc3QgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICAgICAgICBpZiAoXCJcIiAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBzdHIubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuaWQgPSBOdW1iZXIoc3RyLnN1YnN0cmluZyhzdGFydCwgaSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICAgICAgICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy50cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICAgICAgICAgIGlmIChEZWNvZGVyLmlzUGF5bG9hZFZhbGlkKHAudHlwZSwgcGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB0cnlQYXJzZShzdHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0ciwgdGhpcy5yZXZpdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBpc1BheWxvYWRWYWxpZCh0eXBlLCBwYXlsb2FkKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGF5bG9hZCA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5FVkVOVDpcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmXG4gICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcGF5bG9hZFswXSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcGF5bG9hZFswXSA9PT0gXCJudW1iZXJcIikpO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5CSU5BUllfQUNLOlxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQmluYXJ5UmVjb25zdHJ1Y3RvciB7XG4gICAgY29uc3RydWN0b3IocGFja2V0KSB7XG4gICAgICAgIHRoaXMucGFja2V0ID0gcGFja2V0O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAgICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICAgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gICAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICovXG4gICAgdGFrZUJpbmFyeURhdGEoYmluRGF0YSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/socket.io-parser/build/esm/index.js\n");

/***/ }),

/***/ "../node_modules/socket.io-parser/build/esm/is-binary.js":
/*!***************************************************************!*\
  !*** ../node_modules/socket.io-parser/build/esm/is-binary.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hasBinary\": () => (/* binding */ hasBinary),\n/* harmony export */   \"isBinary\": () => (/* binding */ isBinary)\n/* harmony export */ });\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvYnVpbGQvZXNtL2lzLWJpbmFyeS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2VzbS9pcy1iaW5hcnkuanM/OGNmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGlzVmlldyA9IChvYmopID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbiAgICAgICAgOiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3Qgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUZpbGUgPSB0eXBlb2YgRmlsZSA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHRvU3RyaW5nLmNhbGwoRmlsZSkgPT09IFwiW29iamVjdCBGaWxlQ29uc3RydWN0b3JdXCIpO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgQnVmZmVyLCBhbiBBcnJheUJ1ZmZlciwgYSBCbG9iIG9yIGEgRmlsZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gICAgcmV0dXJuICgod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0JpbmFyeShvYmosIHRvSlNPTikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNCaW5hcnkob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iai50b0pTT04gJiZcbiAgICAgICAgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/socket.io-parser/build/esm/is-binary.js\n");

/***/ }),

/***/ "../node_modules/y-protocols/awareness.js":
/*!************************************************!*\
  !*** ../node_modules/y-protocols/awareness.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Awareness\": () => (/* binding */ Awareness),\n/* harmony export */   \"applyAwarenessUpdate\": () => (/* binding */ applyAwarenessUpdate),\n/* harmony export */   \"encodeAwarenessUpdate\": () => (/* binding */ encodeAwarenessUpdate),\n/* harmony export */   \"modifyAwarenessUpdate\": () => (/* binding */ modifyAwarenessUpdate),\n/* harmony export */   \"outdatedTimeout\": () => (/* binding */ outdatedTimeout),\n/* harmony export */   \"removeAwarenessStates\": () => (/* binding */ removeAwarenessStates)\n/* harmony export */ });\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ \"../node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ \"../node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/time */ \"../node_modules/lib0/time.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/math */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable */ \"../node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/function */ \"../node_modules/lib0/function.js\");\n/**\n * @module awareness-protocol\n */\n\n\n\n\n\n\n\n // eslint-disable-line\n\nconst outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nclass Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = lib0_time__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, lib0_math__WEBPACK_IMPORTED_MODULE_2__.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!lib0_function__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nconst removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nconst encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(state))\n  }\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nconst modifyAwarenessUpdate = (update, modify) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder()\n  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const modifiedState = modify(state)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clientID)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, clock)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nconst applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)\n  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_1__.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)\n    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!lib0_function__WEBPACK_IMPORTED_MODULE_3__.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRXlDO0FBQ0E7QUFDUjtBQUNBO0FBQ1c7QUFDVjtBQUNWOztBQUVqQjs7QUFFUDtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQThEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNPLHdCQUF3Qix1REFBVTtBQUN6QztBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUMsa0JBQWtCLGtEQUFnQjtBQUNsQyxxRkFBcUYscUJBQXFCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsNENBQVU7QUFDakI7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBZ0I7QUFDbkMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxXQUFXLHVEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBDQUEwQztBQUN2RTtBQUNBLDJCQUEyQix5QkFBeUI7QUFDcEQ7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLGVBQWU7QUFDMUIsV0FBVyxLQUFLO0FBQ2hCO0FBQ087QUFDUDtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQSx1QkFBdUIsa0RBQWdCO0FBQ3ZDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxlQUFlO0FBQzFCLFlBQVk7QUFDWjtBQUNPO0FBQ1A7QUFDQSxrQkFBa0Isd0RBQXNCO0FBQ3hDLEVBQUUsdURBQXFCO0FBQ3ZCLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDLElBQUksdURBQXFCO0FBQ3pCLElBQUksdURBQXFCO0FBQ3pCLElBQUkseURBQXVCO0FBQzNCO0FBQ0EsU0FBUyx1REFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsbUJBQW1CO0FBQzlCLFlBQVk7QUFDWjtBQUNPO0FBQ1Asa0JBQWtCLHdEQUFzQjtBQUN4QyxrQkFBa0Isd0RBQXNCO0FBQ3hDLGNBQWMsc0RBQW9CO0FBQ2xDLEVBQUUsdURBQXFCO0FBQ3ZCLGtCQUFrQixTQUFTO0FBQzNCLHFCQUFxQixzREFBb0I7QUFDekMsa0JBQWtCLHNEQUFvQjtBQUN0Qyw2QkFBNkIsd0RBQXNCO0FBQ25EO0FBQ0EsSUFBSSx1REFBcUI7QUFDekIsSUFBSSx1REFBcUI7QUFDekIsSUFBSSx5REFBdUI7QUFDM0I7QUFDQSxTQUFTLHVEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixXQUFXLFlBQVk7QUFDdkIsV0FBVyxLQUFLO0FBQ2hCO0FBQ087QUFDUCxrQkFBa0Isd0RBQXNCO0FBQ3hDLG9CQUFvQixrREFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFvQjtBQUNsQyxrQkFBa0IsU0FBUztBQUMzQixxQkFBcUIsc0RBQW9CO0FBQ3pDLGdCQUFnQixzREFBb0I7QUFDcEMsNkJBQTZCLHdEQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUixhQUFhLHVEQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy95LXByb3RvY29scy9hd2FyZW5lc3MuanM/MTQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCBjb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdXG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpXG4gICAgICB9XG4gICAgfSwgbWF0aC5mbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKVxuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEXG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDFcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIH0pXG4gICAgY29uc3QgYWRkZWQgPSBbXVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpXG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbFxuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvbnRlbnQgb2YgYW4gYXdhcmVuZXNzIHVwZGF0ZSBiZWZvcmUgcmUtZW5jb2RpbmcgaXQgdG8gYW4gYXdhcmVuZXNzIHVwZGF0ZS5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgY2VudHJhbCBzZXJ2ZXIgdGhhdCB3YW50cyB0byBlbnN1cmUgdGhhdCBjbGllbnRzXG4gKiBjYW50IGhpamFjayBzb21lYm9keSBlbHNlcyBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gbW9kaWZ5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5QXdhcmVuZXNzVXBkYXRlID0gKHVwZGF0ZSwgbW9kaWZ5KSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBtb2RpZmllZFN0YXRlID0gbW9kaWZ5KHN0YXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkobW9kaWZpZWRTdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgYWRkZWQgPSBbXVxuICBjb25zdCB1cGRhdGVkID0gW11cbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrXG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pXG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZi5lcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/y-protocols/awareness.js\n");

/***/ }),

/***/ "../node_modules/y-socket.io/dist/index.mjs":
/*!**************************************************!*\
  !*** ../node_modules/y-socket.io/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SocketIOProvider\": () => (/* binding */ d)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"../node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/broadcastchannel */ \"../node_modules/lib0/broadcastchannel.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"../node_modules/y-protocols/awareness.js\");\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/observable */ \"../node_modules/lib0/observable.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! socket.io-client */ \"../node_modules/socket.io-client/build/esm/index.js\");\n// src/client/provider.ts\n\n\n\n\n\nvar d = class extends lib0_observable__WEBPACK_IMPORTED_MODULE_2__.Observable {\n  constructor(e, t, o = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc(), {\n    autoConnect: c = !0,\n    awareness: i = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.Awareness(o),\n    resyncInterval: h = -1,\n    disableBc: l = !1,\n    auth: p = {}\n  }) {\n    super();\n    this.bcconnected = !1;\n    this._synced = !1;\n    this.resyncInterval = null;\n    this.initSyncListeners = () => {\n      this.socket.on(\"sync-step-1\", (e, t) => {\n        t(yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateAsUpdate(this.doc, new Uint8Array(e))), this.synced = !0;\n      }), this.socket.on(\"sync-update\", this.onSocketSyncUpdate);\n    };\n    this.initAwarenessListeners = () => {\n      this.socket.on(\"awareness-update\", (e) => {\n        y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.applyAwarenessUpdate(this.awareness, new Uint8Array(e), this);\n      });\n    };\n    this.initSystemListeners = () => {\n      typeof window != \"undefined\" ? window.addEventListener(\"beforeunload\", this.beforeUnloadHandler) : typeof process != \"undefined\" && process.on(\"exit\", this.beforeUnloadHandler);\n    };\n    this.onSocketConnection = (e = -1) => {\n      this.emit(\"status\", [{ status: \"connected\" }]), this.socket.emit(\"sync-step-1\", yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateVector(this.doc), (t) => {\n        yjs__WEBPACK_IMPORTED_MODULE_3__.applyUpdate(this.doc, new Uint8Array(t), this);\n      }), this.awareness.getLocalState() !== null && this.socket.emit(\"awareness-update\", y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID])), e > 0 && (this.resyncInterval = setInterval(() => {\n        this.socket.disconnected || this.socket.emit(\"sync-step-1\", yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateVector(this.doc), (t) => {\n          yjs__WEBPACK_IMPORTED_MODULE_3__.applyUpdate(this.doc, new Uint8Array(t), this);\n        });\n      }, e));\n    };\n    this.onSocketDisconnection = (e) => {\n      this.emit(\"connection-close\", [e, this]), this.synced = !1, y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.removeAwarenessStates(this.awareness, Array.from(this.awareness.getStates().keys()).filter((t) => t !== this.doc.clientID), this), this.emit(\"status\", [{ status: \"disconnected\" }]);\n    };\n    this.onSocketConnectionError = (e) => {\n      this.emit(\"connection-error\", [e, this]);\n    };\n    this.onUpdateDoc = (e, t) => {\n      t !== this && (this.socket.emit(\"sync-update\", e), this.bcconnected && lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, {\n        type: \"sync-update\",\n        data: e\n      }, this));\n    };\n    this.onSocketSyncUpdate = (e) => {\n      yjs__WEBPACK_IMPORTED_MODULE_3__.applyUpdate(this.doc, new Uint8Array(e), this);\n    };\n    this.awarenessUpdate = ({ added: e, updated: t, removed: o }, c) => {\n      let i = e.concat(t).concat(o);\n      this.socket.emit(\"awareness-update\", y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, i)), this.bcconnected && lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, {\n        type: \"awareness-update\",\n        data: y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, i)\n      }, this);\n    };\n    this.beforeUnloadHandler = () => {\n      y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.removeAwarenessStates(this.awareness, [this.doc.clientID], \"window unload\");\n    };\n    this.connectBc = () => {\n      this.bcconnected || (lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.subscribe(this._broadcastChannel, this.onBroadcastChannelMessage), this.bcconnected = !0), lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, { type: \"sync-step-1\", data: yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateVector(this.doc) }, this), lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, { type: \"sync-step-2\", data: yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateAsUpdate(this.doc) }, this), lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, { type: \"query-awareness\", data: null }, this), lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, { type: \"awareness-update\", data: y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID]) }, this);\n    };\n    this.disconnectBc = () => {\n      lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, {\n        type: \"awareness-update\",\n        data: y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, [this.doc.clientID], /* @__PURE__ */ new Map())\n      }, this), this.bcconnected && (lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.unsubscribe(this._broadcastChannel, this.onBroadcastChannelMessage), this.bcconnected = !1);\n    };\n    this.onBroadcastChannelMessage = (e, t) => {\n      if (t !== this && e.type.length > 0)\n        switch (e.type) {\n          case \"sync-step-1\":\n            lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, {\n              type: \"sync-step-2\",\n              data: yjs__WEBPACK_IMPORTED_MODULE_3__.encodeStateAsUpdate(this.doc, e.data)\n            }, this);\n            break;\n          case \"sync-step-2\":\n            yjs__WEBPACK_IMPORTED_MODULE_3__.applyUpdate(this.doc, new Uint8Array(e.data), this);\n            break;\n          case \"sync-update\":\n            yjs__WEBPACK_IMPORTED_MODULE_3__.applyUpdate(this.doc, new Uint8Array(e.data), this);\n            break;\n          case \"query-awareness\":\n            lib0_broadcastchannel__WEBPACK_IMPORTED_MODULE_4__.publish(this._broadcastChannel, {\n              type: \"awareness-update\",\n              data: y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.encodeAwarenessUpdate(this.awareness, Array.from(this.awareness.getStates().keys()))\n            }, this);\n            break;\n          case \"awareness-update\":\n            y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__.applyAwarenessUpdate(this.awareness, new Uint8Array(e.data), this);\n            break;\n          default:\n            break;\n        }\n    };\n    for (; e[e.length - 1] === \"/\"; )\n      e = e.slice(0, e.length - 1);\n    this._url = e, this.roomName = t, this.doc = o, this.awareness = i, this._broadcastChannel = `${e}/${t}`, this.disableBc = l, this.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_1__.io)(`${this.url}/yjs|${t}`, {\n      autoConnect: !1,\n      transports: [\"websocket\"],\n      forceNew: !0,\n      auth: p\n    }), this.doc.on(\"update\", this.onUpdateDoc), this.socket.on(\"connect\", () => this.onSocketConnection(h)), this.socket.on(\"disconnect\", (r) => this.onSocketDisconnection(r)), this.socket.on(\"connect_error\", (r) => this.onSocketConnectionError(r)), this.initSyncListeners(), this.initAwarenessListeners(), this.initSystemListeners(), i.on(\"update\", this.awarenessUpdate), c && this.connect();\n  }\n  get broadcastChannel() {\n    return this._broadcastChannel;\n  }\n  get url() {\n    return this._url;\n  }\n  get synced() {\n    return this._synced;\n  }\n  set synced(e) {\n    this._synced !== e && (this._synced = e, this.emit(\"synced\", [e]), this.emit(\"sync\", [e]));\n  }\n  connect() {\n    this.socket.connected || (this.emit(\"status\", [{ status: \"connecting\" }]), this.socket.connect(), this.disableBc || this.connectBc(), this.synced = !1);\n  }\n  disconnect() {\n    this.socket.connected && (this.disconnectBc(), this.socket.disconnect());\n  }\n  destroy() {\n    this.resyncInterval != null && clearInterval(this.resyncInterval), this.disconnect(), typeof window != \"undefined\" ? window.removeEventListener(\"beforeunload\", this.beforeUnloadHandler) : typeof process != \"undefined\" && process.off(\"exit\", this.beforeUnloadHandler), this.awareness.off(\"update\", this.awarenessUpdate), this.doc.off(\"update\", this.onUpdateDoc), super.destroy();\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3ktc29ja2V0LmlvL2Rpc3QvaW5kZXgubWpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3lCO0FBQ2tCO0FBQ0E7QUFDTztBQUNQO0FBQzNDLHNCQUFzQix1REFBQztBQUN2Qiw0QkFBNEIsb0NBQUs7QUFDakM7QUFDQSx1QkFBdUIsNERBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQXFCO0FBQy9CLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVFQUFzQjtBQUM5QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUIsb0NBQW9DLGtEQUFtQjtBQUN6RyxRQUFRLDRDQUFhO0FBQ3JCLE9BQU8sbUZBQW1GLHdFQUF1QjtBQUNqSCxvRUFBb0Usa0RBQW1CO0FBQ3ZGLFVBQVUsNENBQWE7QUFDdkIsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0Esa0VBQWtFLHdFQUF1QixxSUFBcUksd0JBQXdCO0FBQ3RQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsMERBQVM7QUFDdEY7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTSw0Q0FBYTtBQUNuQjtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQSwyQ0FBMkMsd0VBQXVCLDBDQUEwQywwREFBUztBQUNySDtBQUNBLGNBQWMsd0VBQXVCO0FBQ3JDLE9BQU87QUFDUDtBQUNBO0FBQ0EsTUFBTSx3RUFBdUI7QUFDN0I7QUFDQTtBQUNBLDJCQUEyQiw0REFBVyxrRkFBa0YsMERBQVMsMkJBQTJCLDJCQUEyQixrREFBbUIsWUFBWSxTQUFTLDBEQUFTLDJCQUEyQiwyQkFBMkIsb0RBQXFCLFlBQVksU0FBUywwREFBUywyQkFBMkIscUNBQXFDLFNBQVMsMERBQVMsMkJBQTJCLGdDQUFnQyx3RUFBdUIsdUNBQXVDO0FBQzVoQjtBQUNBO0FBQ0EsTUFBTSwwREFBUztBQUNmO0FBQ0EsY0FBYyx3RUFBdUI7QUFDckMsT0FBTyw4QkFBOEIsOERBQWE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQVM7QUFDckI7QUFDQSxvQkFBb0Isb0RBQXFCO0FBQ3pDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSw0Q0FBYTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSw0Q0FBYTtBQUN6QjtBQUNBO0FBQ0EsWUFBWSwwREFBUztBQUNyQjtBQUNBLG9CQUFvQix3RUFBdUI7QUFDM0MsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLHVFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQSxvR0FBb0csRUFBRSxHQUFHLEVBQUUscUNBQXFDLG9EQUFDLElBQUksU0FBUyxPQUFPLEVBQUU7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzQkFBc0I7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3ktc29ja2V0LmlvL2Rpc3QvaW5kZXgubWpzP2M4MmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2NsaWVudC9wcm92aWRlci50c1xuaW1wb3J0ICogYXMgcyBmcm9tIFwieWpzXCI7XG5pbXBvcnQgKiBhcyBhIGZyb20gXCJsaWIwL2Jyb2FkY2FzdGNoYW5uZWxcIjtcbmltcG9ydCAqIGFzIG4gZnJvbSBcInktcHJvdG9jb2xzL2F3YXJlbmVzc1wiO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSBhcyB5IH0gZnJvbSBcImxpYjAvb2JzZXJ2YWJsZVwiO1xuaW1wb3J0IHsgaW8gYXMgYiB9IGZyb20gXCJzb2NrZXQuaW8tY2xpZW50XCI7XG52YXIgZCA9IGNsYXNzIGV4dGVuZHMgeSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIG8gPSBuZXcgcy5Eb2MoKSwge1xuICAgIGF1dG9Db25uZWN0OiBjID0gITAsXG4gICAgYXdhcmVuZXNzOiBpID0gbmV3IG4uQXdhcmVuZXNzKG8pLFxuICAgIHJlc3luY0ludGVydmFsOiBoID0gLTEsXG4gICAgZGlzYWJsZUJjOiBsID0gITEsXG4gICAgYXV0aDogcCA9IHt9XG4gIH0pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSAhMTtcbiAgICB0aGlzLl9zeW5jZWQgPSAhMTtcbiAgICB0aGlzLnJlc3luY0ludGVydmFsID0gbnVsbDtcbiAgICB0aGlzLmluaXRTeW5jTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgdGhpcy5zb2NrZXQub24oXCJzeW5jLXN0ZXAtMVwiLCAoZSwgdCkgPT4ge1xuICAgICAgICB0KHMuZW5jb2RlU3RhdGVBc1VwZGF0ZSh0aGlzLmRvYywgbmV3IFVpbnQ4QXJyYXkoZSkpKSwgdGhpcy5zeW5jZWQgPSAhMDtcbiAgICAgIH0pLCB0aGlzLnNvY2tldC5vbihcInN5bmMtdXBkYXRlXCIsIHRoaXMub25Tb2NrZXRTeW5jVXBkYXRlKTtcbiAgICB9O1xuICAgIHRoaXMuaW5pdEF3YXJlbmVzc0xpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHRoaXMuc29ja2V0Lm9uKFwiYXdhcmVuZXNzLXVwZGF0ZVwiLCAoZSkgPT4ge1xuICAgICAgICBuLmFwcGx5QXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBuZXcgVWludDhBcnJheShlKSwgdGhpcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMuaW5pdFN5c3RlbUxpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgIHR5cGVvZiB3aW5kb3cgIT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuYmVmb3JlVW5sb2FkSGFuZGxlcikgOiB0eXBlb2YgcHJvY2VzcyAhPSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3Mub24oXCJleGl0XCIsIHRoaXMuYmVmb3JlVW5sb2FkSGFuZGxlcik7XG4gICAgfTtcbiAgICB0aGlzLm9uU29ja2V0Q29ubmVjdGlvbiA9IChlID0gLTEpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbeyBzdGF0dXM6IFwiY29ubmVjdGVkXCIgfV0pLCB0aGlzLnNvY2tldC5lbWl0KFwic3luYy1zdGVwLTFcIiwgcy5lbmNvZGVTdGF0ZVZlY3Rvcih0aGlzLmRvYyksICh0KSA9PiB7XG4gICAgICAgIHMuYXBwbHlVcGRhdGUodGhpcy5kb2MsIG5ldyBVaW50OEFycmF5KHQpLCB0aGlzKTtcbiAgICAgIH0pLCB0aGlzLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT09IG51bGwgJiYgdGhpcy5zb2NrZXQuZW1pdChcImF3YXJlbmVzcy11cGRhdGVcIiwgbi5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0pKSwgZSA+IDAgJiYgKHRoaXMucmVzeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIHRoaXMuc29ja2V0LmRpc2Nvbm5lY3RlZCB8fCB0aGlzLnNvY2tldC5lbWl0KFwic3luYy1zdGVwLTFcIiwgcy5lbmNvZGVTdGF0ZVZlY3Rvcih0aGlzLmRvYyksICh0KSA9PiB7XG4gICAgICAgICAgcy5hcHBseVVwZGF0ZSh0aGlzLmRvYywgbmV3IFVpbnQ4QXJyYXkodCksIHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGUpKTtcbiAgICB9O1xuICAgIHRoaXMub25Tb2NrZXREaXNjb25uZWN0aW9uID0gKGUpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb24tY2xvc2VcIiwgW2UsIHRoaXNdKSwgdGhpcy5zeW5jZWQgPSAhMSwgbi5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIEFycmF5LmZyb20odGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKS5maWx0ZXIoKHQpID0+IHQgIT09IHRoaXMuZG9jLmNsaWVudElEKSwgdGhpcyksIHRoaXMuZW1pdChcInN0YXR1c1wiLCBbeyBzdGF0dXM6IFwiZGlzY29ubmVjdGVkXCIgfV0pO1xuICAgIH07XG4gICAgdGhpcy5vblNvY2tldENvbm5lY3Rpb25FcnJvciA9IChlKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uLWVycm9yXCIsIFtlLCB0aGlzXSk7XG4gICAgfTtcbiAgICB0aGlzLm9uVXBkYXRlRG9jID0gKGUsIHQpID0+IHtcbiAgICAgIHQgIT09IHRoaXMgJiYgKHRoaXMuc29ja2V0LmVtaXQoXCJzeW5jLXVwZGF0ZVwiLCBlKSwgdGhpcy5iY2Nvbm5lY3RlZCAmJiBhLnB1Ymxpc2godGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwge1xuICAgICAgICB0eXBlOiBcInN5bmMtdXBkYXRlXCIsXG4gICAgICAgIGRhdGE6IGVcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9O1xuICAgIHRoaXMub25Tb2NrZXRTeW5jVXBkYXRlID0gKGUpID0+IHtcbiAgICAgIHMuYXBwbHlVcGRhdGUodGhpcy5kb2MsIG5ldyBVaW50OEFycmF5KGUpLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuYXdhcmVuZXNzVXBkYXRlID0gKHsgYWRkZWQ6IGUsIHVwZGF0ZWQ6IHQsIHJlbW92ZWQ6IG8gfSwgYykgPT4ge1xuICAgICAgbGV0IGkgPSBlLmNvbmNhdCh0KS5jb25jYXQobyk7XG4gICAgICB0aGlzLnNvY2tldC5lbWl0KFwiYXdhcmVuZXNzLXVwZGF0ZVwiLCBuLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgaSkpLCB0aGlzLmJjY29ubmVjdGVkICYmIGEucHVibGlzaCh0aGlzLl9icm9hZGNhc3RDaGFubmVsLCB7XG4gICAgICAgIHR5cGU6IFwiYXdhcmVuZXNzLXVwZGF0ZVwiLFxuICAgICAgICBkYXRhOiBuLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgaSlcbiAgICAgIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5iZWZvcmVVbmxvYWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgbi5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sIFwid2luZG93IHVubG9hZFwiKTtcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdEJjID0gKCkgPT4ge1xuICAgICAgdGhpcy5iY2Nvbm5lY3RlZCB8fCAoYS5zdWJzY3JpYmUodGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwgdGhpcy5vbkJyb2FkY2FzdENoYW5uZWxNZXNzYWdlKSwgdGhpcy5iY2Nvbm5lY3RlZCA9ICEwKSwgYS5wdWJsaXNoKHRoaXMuX2Jyb2FkY2FzdENoYW5uZWwsIHsgdHlwZTogXCJzeW5jLXN0ZXAtMVwiLCBkYXRhOiBzLmVuY29kZVN0YXRlVmVjdG9yKHRoaXMuZG9jKSB9LCB0aGlzKSwgYS5wdWJsaXNoKHRoaXMuX2Jyb2FkY2FzdENoYW5uZWwsIHsgdHlwZTogXCJzeW5jLXN0ZXAtMlwiLCBkYXRhOiBzLmVuY29kZVN0YXRlQXNVcGRhdGUodGhpcy5kb2MpIH0sIHRoaXMpLCBhLnB1Ymxpc2godGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwgeyB0eXBlOiBcInF1ZXJ5LWF3YXJlbmVzc1wiLCBkYXRhOiBudWxsIH0sIHRoaXMpLCBhLnB1Ymxpc2godGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwgeyB0eXBlOiBcImF3YXJlbmVzcy11cGRhdGVcIiwgZGF0YTogbi5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0pIH0sIHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5kaXNjb25uZWN0QmMgPSAoKSA9PiB7XG4gICAgICBhLnB1Ymxpc2godGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwge1xuICAgICAgICB0eXBlOiBcImF3YXJlbmVzcy11cGRhdGVcIixcbiAgICAgICAgZGF0YTogbi5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIFt0aGlzLmRvYy5jbGllbnRJRF0sIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpXG4gICAgICB9LCB0aGlzKSwgdGhpcy5iY2Nvbm5lY3RlZCAmJiAoYS51bnN1YnNjcmliZSh0aGlzLl9icm9hZGNhc3RDaGFubmVsLCB0aGlzLm9uQnJvYWRjYXN0Q2hhbm5lbE1lc3NhZ2UpLCB0aGlzLmJjY29ubmVjdGVkID0gITEpO1xuICAgIH07XG4gICAgdGhpcy5vbkJyb2FkY2FzdENoYW5uZWxNZXNzYWdlID0gKGUsIHQpID0+IHtcbiAgICAgIGlmICh0ICE9PSB0aGlzICYmIGUudHlwZS5sZW5ndGggPiAwKVxuICAgICAgICBzd2l0Y2ggKGUudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJzeW5jLXN0ZXAtMVwiOlxuICAgICAgICAgICAgYS5wdWJsaXNoKHRoaXMuX2Jyb2FkY2FzdENoYW5uZWwsIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJzeW5jLXN0ZXAtMlwiLFxuICAgICAgICAgICAgICBkYXRhOiBzLmVuY29kZVN0YXRlQXNVcGRhdGUodGhpcy5kb2MsIGUuZGF0YSlcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInN5bmMtc3RlcC0yXCI6XG4gICAgICAgICAgICBzLmFwcGx5VXBkYXRlKHRoaXMuZG9jLCBuZXcgVWludDhBcnJheShlLmRhdGEpLCB0aGlzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzeW5jLXVwZGF0ZVwiOlxuICAgICAgICAgICAgcy5hcHBseVVwZGF0ZSh0aGlzLmRvYywgbmV3IFVpbnQ4QXJyYXkoZS5kYXRhKSwgdGhpcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicXVlcnktYXdhcmVuZXNzXCI6XG4gICAgICAgICAgICBhLnB1Ymxpc2godGhpcy5fYnJvYWRjYXN0Q2hhbm5lbCwge1xuICAgICAgICAgICAgICB0eXBlOiBcImF3YXJlbmVzcy11cGRhdGVcIixcbiAgICAgICAgICAgICAgZGF0YTogbi5lbmNvZGVBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIEFycmF5LmZyb20odGhpcy5hd2FyZW5lc3MuZ2V0U3RhdGVzKCkua2V5cygpKSlcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImF3YXJlbmVzcy11cGRhdGVcIjpcbiAgICAgICAgICAgIG4uYXBwbHlBd2FyZW5lc3NVcGRhdGUodGhpcy5hd2FyZW5lc3MsIG5ldyBVaW50OEFycmF5KGUuZGF0YSksIHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKDsgZVtlLmxlbmd0aCAtIDFdID09PSBcIi9cIjsgKVxuICAgICAgZSA9IGUuc2xpY2UoMCwgZS5sZW5ndGggLSAxKTtcbiAgICB0aGlzLl91cmwgPSBlLCB0aGlzLnJvb21OYW1lID0gdCwgdGhpcy5kb2MgPSBvLCB0aGlzLmF3YXJlbmVzcyA9IGksIHRoaXMuX2Jyb2FkY2FzdENoYW5uZWwgPSBgJHtlfS8ke3R9YCwgdGhpcy5kaXNhYmxlQmMgPSBsLCB0aGlzLnNvY2tldCA9IGIoYCR7dGhpcy51cmx9L3lqc3wke3R9YCwge1xuICAgICAgYXV0b0Nvbm5lY3Q6ICExLFxuICAgICAgdHJhbnNwb3J0czogW1wid2Vic29ja2V0XCJdLFxuICAgICAgZm9yY2VOZXc6ICEwLFxuICAgICAgYXV0aDogcFxuICAgIH0pLCB0aGlzLmRvYy5vbihcInVwZGF0ZVwiLCB0aGlzLm9uVXBkYXRlRG9jKSwgdGhpcy5zb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHRoaXMub25Tb2NrZXRDb25uZWN0aW9uKGgpKSwgdGhpcy5zb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyKSA9PiB0aGlzLm9uU29ja2V0RGlzY29ubmVjdGlvbihyKSksIHRoaXMuc29ja2V0Lm9uKFwiY29ubmVjdF9lcnJvclwiLCAocikgPT4gdGhpcy5vblNvY2tldENvbm5lY3Rpb25FcnJvcihyKSksIHRoaXMuaW5pdFN5bmNMaXN0ZW5lcnMoKSwgdGhpcy5pbml0QXdhcmVuZXNzTGlzdGVuZXJzKCksIHRoaXMuaW5pdFN5c3RlbUxpc3RlbmVycygpLCBpLm9uKFwidXBkYXRlXCIsIHRoaXMuYXdhcmVuZXNzVXBkYXRlKSwgYyAmJiB0aGlzLmNvbm5lY3QoKTtcbiAgfVxuICBnZXQgYnJvYWRjYXN0Q2hhbm5lbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnJvYWRjYXN0Q2hhbm5lbDtcbiAgfVxuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cbiAgZ2V0IHN5bmNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3luY2VkO1xuICB9XG4gIHNldCBzeW5jZWQoZSkge1xuICAgIHRoaXMuX3N5bmNlZCAhPT0gZSAmJiAodGhpcy5fc3luY2VkID0gZSwgdGhpcy5lbWl0KFwic3luY2VkXCIsIFtlXSksIHRoaXMuZW1pdChcInN5bmNcIiwgW2VdKSk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLnNvY2tldC5jb25uZWN0ZWQgfHwgKHRoaXMuZW1pdChcInN0YXR1c1wiLCBbeyBzdGF0dXM6IFwiY29ubmVjdGluZ1wiIH1dKSwgdGhpcy5zb2NrZXQuY29ubmVjdCgpLCB0aGlzLmRpc2FibGVCYyB8fCB0aGlzLmNvbm5lY3RCYygpLCB0aGlzLnN5bmNlZCA9ICExKTtcbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuc29ja2V0LmNvbm5lY3RlZCAmJiAodGhpcy5kaXNjb25uZWN0QmMoKSwgdGhpcy5zb2NrZXQuZGlzY29ubmVjdCgpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVzeW5jSW50ZXJ2YWwgIT0gbnVsbCAmJiBjbGVhckludGVydmFsKHRoaXMucmVzeW5jSW50ZXJ2YWwpLCB0aGlzLmRpc2Nvbm5lY3QoKSwgdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgdGhpcy5iZWZvcmVVbmxvYWRIYW5kbGVyKSA6IHR5cGVvZiBwcm9jZXNzICE9IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5vZmYoXCJleGl0XCIsIHRoaXMuYmVmb3JlVW5sb2FkSGFuZGxlciksIHRoaXMuYXdhcmVuZXNzLm9mZihcInVwZGF0ZVwiLCB0aGlzLmF3YXJlbmVzc1VwZGF0ZSksIHRoaXMuZG9jLm9mZihcInVwZGF0ZVwiLCB0aGlzLm9uVXBkYXRlRG9jKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgZCBhcyBTb2NrZXRJT1Byb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/y-socket.io/dist/index.mjs\n");

/***/ }),

/***/ "../node_modules/yjs/dist/yjs.mjs":
/*!****************************************!*\
  !*** ../node_modules/yjs/dist/yjs.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbsolutePosition\": () => (/* binding */ AbsolutePosition),\n/* harmony export */   \"AbstractConnector\": () => (/* binding */ AbstractConnector),\n/* harmony export */   \"AbstractStruct\": () => (/* binding */ AbstractStruct),\n/* harmony export */   \"AbstractType\": () => (/* binding */ AbstractType),\n/* harmony export */   \"Array\": () => (/* binding */ YArray),\n/* harmony export */   \"ContentAny\": () => (/* binding */ ContentAny),\n/* harmony export */   \"ContentBinary\": () => (/* binding */ ContentBinary),\n/* harmony export */   \"ContentDeleted\": () => (/* binding */ ContentDeleted),\n/* harmony export */   \"ContentEmbed\": () => (/* binding */ ContentEmbed),\n/* harmony export */   \"ContentFormat\": () => (/* binding */ ContentFormat),\n/* harmony export */   \"ContentJSON\": () => (/* binding */ ContentJSON),\n/* harmony export */   \"ContentString\": () => (/* binding */ ContentString),\n/* harmony export */   \"ContentType\": () => (/* binding */ ContentType),\n/* harmony export */   \"Doc\": () => (/* binding */ Doc),\n/* harmony export */   \"GC\": () => (/* binding */ GC),\n/* harmony export */   \"ID\": () => (/* binding */ ID),\n/* harmony export */   \"Item\": () => (/* binding */ Item),\n/* harmony export */   \"Map\": () => (/* binding */ YMap),\n/* harmony export */   \"PermanentUserData\": () => (/* binding */ PermanentUserData),\n/* harmony export */   \"RelativePosition\": () => (/* binding */ RelativePosition),\n/* harmony export */   \"Snapshot\": () => (/* binding */ Snapshot),\n/* harmony export */   \"Text\": () => (/* binding */ YText),\n/* harmony export */   \"Transaction\": () => (/* binding */ Transaction),\n/* harmony export */   \"UndoManager\": () => (/* binding */ UndoManager),\n/* harmony export */   \"UpdateEncoderV1\": () => (/* binding */ UpdateEncoderV1),\n/* harmony export */   \"XmlElement\": () => (/* binding */ YXmlElement),\n/* harmony export */   \"XmlFragment\": () => (/* binding */ YXmlFragment),\n/* harmony export */   \"XmlHook\": () => (/* binding */ YXmlHook),\n/* harmony export */   \"XmlText\": () => (/* binding */ YXmlText),\n/* harmony export */   \"YArrayEvent\": () => (/* binding */ YArrayEvent),\n/* harmony export */   \"YEvent\": () => (/* binding */ YEvent),\n/* harmony export */   \"YMapEvent\": () => (/* binding */ YMapEvent),\n/* harmony export */   \"YTextEvent\": () => (/* binding */ YTextEvent),\n/* harmony export */   \"YXmlEvent\": () => (/* binding */ YXmlEvent),\n/* harmony export */   \"applyUpdate\": () => (/* binding */ applyUpdate),\n/* harmony export */   \"applyUpdateV2\": () => (/* binding */ applyUpdateV2),\n/* harmony export */   \"cleanupYTextFormatting\": () => (/* binding */ cleanupYTextFormatting),\n/* harmony export */   \"compareIDs\": () => (/* binding */ compareIDs),\n/* harmony export */   \"compareRelativePositions\": () => (/* binding */ compareRelativePositions),\n/* harmony export */   \"convertUpdateFormatV1ToV2\": () => (/* binding */ convertUpdateFormatV1ToV2),\n/* harmony export */   \"convertUpdateFormatV2ToV1\": () => (/* binding */ convertUpdateFormatV2ToV1),\n/* harmony export */   \"createAbsolutePositionFromRelativePosition\": () => (/* binding */ createAbsolutePositionFromRelativePosition),\n/* harmony export */   \"createDeleteSet\": () => (/* binding */ createDeleteSet),\n/* harmony export */   \"createDeleteSetFromStructStore\": () => (/* binding */ createDeleteSetFromStructStore),\n/* harmony export */   \"createDocFromSnapshot\": () => (/* binding */ createDocFromSnapshot),\n/* harmony export */   \"createID\": () => (/* binding */ createID),\n/* harmony export */   \"createRelativePositionFromJSON\": () => (/* binding */ createRelativePositionFromJSON),\n/* harmony export */   \"createRelativePositionFromTypeIndex\": () => (/* binding */ createRelativePositionFromTypeIndex),\n/* harmony export */   \"createSnapshot\": () => (/* binding */ createSnapshot),\n/* harmony export */   \"decodeRelativePosition\": () => (/* binding */ decodeRelativePosition),\n/* harmony export */   \"decodeSnapshot\": () => (/* binding */ decodeSnapshot),\n/* harmony export */   \"decodeSnapshotV2\": () => (/* binding */ decodeSnapshotV2),\n/* harmony export */   \"decodeStateVector\": () => (/* binding */ decodeStateVector),\n/* harmony export */   \"decodeUpdate\": () => (/* binding */ decodeUpdate),\n/* harmony export */   \"decodeUpdateV2\": () => (/* binding */ decodeUpdateV2),\n/* harmony export */   \"diffUpdate\": () => (/* binding */ diffUpdate),\n/* harmony export */   \"diffUpdateV2\": () => (/* binding */ diffUpdateV2),\n/* harmony export */   \"emptySnapshot\": () => (/* binding */ emptySnapshot),\n/* harmony export */   \"encodeRelativePosition\": () => (/* binding */ encodeRelativePosition),\n/* harmony export */   \"encodeSnapshot\": () => (/* binding */ encodeSnapshot),\n/* harmony export */   \"encodeSnapshotV2\": () => (/* binding */ encodeSnapshotV2),\n/* harmony export */   \"encodeStateAsUpdate\": () => (/* binding */ encodeStateAsUpdate),\n/* harmony export */   \"encodeStateAsUpdateV2\": () => (/* binding */ encodeStateAsUpdateV2),\n/* harmony export */   \"encodeStateVector\": () => (/* binding */ encodeStateVector),\n/* harmony export */   \"encodeStateVectorFromUpdate\": () => (/* binding */ encodeStateVectorFromUpdate),\n/* harmony export */   \"encodeStateVectorFromUpdateV2\": () => (/* binding */ encodeStateVectorFromUpdateV2),\n/* harmony export */   \"equalSnapshots\": () => (/* binding */ equalSnapshots),\n/* harmony export */   \"findIndexSS\": () => (/* binding */ findIndexSS),\n/* harmony export */   \"findRootTypeKey\": () => (/* binding */ findRootTypeKey),\n/* harmony export */   \"getItem\": () => (/* binding */ getItem),\n/* harmony export */   \"getState\": () => (/* binding */ getState),\n/* harmony export */   \"getTypeChildren\": () => (/* binding */ getTypeChildren),\n/* harmony export */   \"isDeleted\": () => (/* binding */ isDeleted),\n/* harmony export */   \"isParentOf\": () => (/* binding */ isParentOf),\n/* harmony export */   \"iterateDeletedStructs\": () => (/* binding */ iterateDeletedStructs),\n/* harmony export */   \"logType\": () => (/* binding */ logType),\n/* harmony export */   \"logUpdate\": () => (/* binding */ logUpdate),\n/* harmony export */   \"logUpdateV2\": () => (/* binding */ logUpdateV2),\n/* harmony export */   \"mergeUpdates\": () => (/* binding */ mergeUpdates),\n/* harmony export */   \"mergeUpdatesV2\": () => (/* binding */ mergeUpdatesV2),\n/* harmony export */   \"obfuscateUpdate\": () => (/* binding */ obfuscateUpdate),\n/* harmony export */   \"obfuscateUpdateV2\": () => (/* binding */ obfuscateUpdateV2),\n/* harmony export */   \"parseUpdateMeta\": () => (/* binding */ parseUpdateMeta),\n/* harmony export */   \"parseUpdateMetaV2\": () => (/* binding */ parseUpdateMetaV2),\n/* harmony export */   \"readUpdate\": () => (/* binding */ readUpdate),\n/* harmony export */   \"readUpdateV2\": () => (/* binding */ readUpdateV2),\n/* harmony export */   \"relativePositionToJSON\": () => (/* binding */ relativePositionToJSON),\n/* harmony export */   \"snapshot\": () => (/* binding */ snapshot),\n/* harmony export */   \"transact\": () => (/* binding */ transact),\n/* harmony export */   \"tryGc\": () => (/* binding */ tryGc),\n/* harmony export */   \"typeListToArraySnapshot\": () => (/* binding */ typeListToArraySnapshot),\n/* harmony export */   \"typeMapGetSnapshot\": () => (/* binding */ typeMapGetSnapshot)\n/* harmony export */ });\n/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/observable */ \"../node_modules/lib0/observable.js\");\n/* harmony import */ var lib0_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/array */ \"../node_modules/lib0/array.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/math */ \"../node_modules/lib0/math.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/map */ \"../node_modules/lib0/map.js\");\n/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/encoding */ \"../node_modules/lib0/encoding.js\");\n/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/decoding */ \"../node_modules/lib0/decoding.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/random */ \"../node_modules/lib0/random.js\");\n/* harmony import */ var lib0_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/promise */ \"../node_modules/lib0/promise.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/buffer */ \"../node_modules/lib0/buffer.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/error */ \"../node_modules/lib0/error.js\");\n/* harmony import */ var lib0_binary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lib0/binary */ \"../node_modules/lib0/binary.js\");\n/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/function */ \"../node_modules/lib0/function.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/set */ \"../node_modules/lib0/set.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/logging */ \"../node_modules/lib0/logging.js\");\n/* harmony import */ var lib0_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/logging */ \"../node_modules/lib0/logging.common.js\");\n/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/time */ \"../node_modules/lib0/time.js\");\n/* harmony import */ var lib0_string__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lib0/string */ \"../node_modules/lib0/string.js\");\n/* harmony import */ var lib0_iterator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lib0/iterator */ \"../node_modules/lib0/iterator.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lib0/object */ \"../node_modules/lib0/object.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * This is an abstract interface that all Connectors should implement to keep them interchangeable.\n *\n * @note This interface is experimental and it is not advised to actually inherit this class.\n *       It just serves as typing information.\n *\n * @extends {Observable<any>}\n */\nclass AbstractConnector extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {Doc} ydoc\n   * @param {any} awareness\n   */\n  constructor (ydoc, awareness) {\n    super();\n    this.doc = ydoc;\n    this.awareness = awareness;\n  }\n}\n\nclass DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock;\n    /**\n     * @type {number}\n     */\n    this.len = len;\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nclass DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map();\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid));\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i];\n      iterateStructs(transaction, structs, del.clock, del.len, f);\n    }\n  });\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nconst findIndexDS = (dis, clock) => {\n  let left = 0;\n  let right = dis.length - 1;\n  while (left <= right) {\n    const midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n    const mid = dis[midindex];\n    const midclock = mid.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n  }\n  return null\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client);\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n};\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock);\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j;\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1];\n      const right = dels[i];\n      if (left.clock + left.len >= right.clock) {\n        left.len = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(left.len, right.clock + right.len - left.clock);\n      } else {\n        if (j < i) {\n          dels[j] = right;\n        }\n        j++;\n      }\n    }\n    dels.length = j;\n  });\n};\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nconst mergeDeleteSets = dss => {\n  const merged = new DeleteSet();\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice();\n        for (let i = dssI + 1; i < dss.length; i++) {\n          lib0_array__WEBPACK_IMPORTED_MODULE_2__.appendTo(dels, dss[i].clients.get(client) || []);\n        }\n        merged.clients.set(client, dels);\n      }\n    });\n  }\n  sortAndMergeDeleteSet(merged);\n  return merged\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nconst addToDeleteSet = (ds, client, clock, length) => {\n  lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, () => /** @type {Array<DeleteItem>} */ ([])).push(new DeleteItem(clock, length));\n};\n\nconst createDeleteSet = () => new DeleteSet();\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nconst createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet();\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = [];\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i];\n      if (struct.deleted) {\n        const clock = struct.id.clock;\n        let len = struct.length;\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n            len += next.length;\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len));\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems);\n    }\n  });\n  return ds\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nconst writeDeleteSet = (encoder, ds) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, ds.clients.size);\n\n  // Ensure that the delete set is written in a deterministic order\n  lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(ds.clients.entries())\n    .sort((a, b) => b[0] - a[0])\n    .forEach(([client, dsitems]) => {\n      encoder.resetDsCurVal();\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client);\n      const len = dsitems.length;\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, len);\n      for (let i = 0; i < len; i++) {\n        const item = dsitems[i];\n        encoder.writeDsClock(item.clock);\n        encoder.writeDsLen(item.len);\n      }\n    });\n};\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nconst readDeleteSet = decoder => {\n  const ds = new DeleteSet();\n  const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    if (numberOfDeletes > 0) {\n      const dsField = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, () => /** @type {Array<DeleteItem>} */ ([]));\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n      }\n    }\n  }\n  return ds\n};\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nconst readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet();\n  const numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal();\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const structs = store.clients.get(client) || [];\n    const state = getState(store, client);\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock();\n      const clockEnd = clock + decoder.readDsLen();\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n        }\n        let index = findIndexSS(structs, clock);\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index];\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n          index++; // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++];\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n              }\n              struct.delete(transaction);\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(ds.restEncoder, 0); // encode 0 structs\n    writeDeleteSet(ds, unappliedDS);\n    return ds.toUint8Array()\n  }\n  return null\n};\n\n/**\n * @module Y\n */\n\nconst generateNewClientId = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uint32;\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nclass Doc extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {DocOpts} opts configuration\n   */\n  constructor ({ guid = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {\n    super();\n    this.gc = gc;\n    this.gcFilter = gcFilter;\n    this.clientID = generateNewClientId();\n    this.guid = guid;\n    this.collectionid = collectionid;\n    /**\n     * @type {Map<string, AbstractType<YEvent<any>>>}\n     */\n    this.share = new Map();\n    this.store = new StructStore();\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null;\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = [];\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set();\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null;\n    this.shouldLoad = shouldLoad;\n    this.autoLoad = autoLoad;\n    this.meta = meta;\n    /**\n     * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.\n     * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.\n     *\n     * @type {boolean}\n     */\n    this.isLoaded = false;\n    /**\n     * This is set to true when the connection provider has successfully synced with a backend.\n     * Note that when using peer-to-peer providers this event may not provide very useful.\n     * Also note that not all providers implement this feature. Provider authors are encouraged to fire\n     * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is\n     * lost (with false as a parameter).\n     */\n    this.isSynced = false;\n    /**\n     * Promise that resolves once the document has been loaded from a presistence provider.\n     */\n    this.whenLoaded = lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(resolve => {\n      this.on('load', () => {\n        this.isLoaded = true;\n        resolve(this);\n      });\n    });\n    const provideSyncedPromise = () => lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(resolve => {\n      /**\n       * @param {boolean} isSynced\n       */\n      const eventHandler = (isSynced) => {\n        if (isSynced === undefined || isSynced === true) {\n          this.off('sync', eventHandler);\n          resolve();\n        }\n      };\n      this.on('sync', eventHandler);\n    });\n    this.on('sync', isSynced => {\n      if (isSynced === false && this.isSynced) {\n        this.whenSynced = provideSyncedPromise();\n      }\n      this.isSynced = isSynced === undefined || isSynced === true;\n      if (!this.isLoaded) {\n        this.emit('load', []);\n      }\n    });\n    /**\n     * Promise that resolves once the document has been synced with a backend.\n     * This promise is recreated when the connection is lost.\n     * Note the documentation about the `isSynced` property.\n     */\n    this.whenSynced = provideSyncedPromise();\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item;\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this);\n      }, null, true);\n    }\n    this.shouldLoad = true;\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @template T\n   * @param {function(Transaction):T} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   * @return T\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    return transact(this, f, origin)\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor();\n      t._integrate(this, null);\n      return t\n    });\n    const Constr = type.constructor;\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor();\n        t._map = type._map;\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t;\n          }\n        });\n        t._start = type._start;\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t;\n        }\n        t._length = type._length;\n        this.share.set(name, t);\n        t._integrate(this, null);\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YMap<T>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {};\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON();\n    });\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).forEach(subdoc => subdoc.destroy());\n    const item = this._item;\n    if (item !== null) {\n      this._item = null;\n      const content = /** @type {ContentDoc} */ (item.content);\n      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });\n      content.doc._item = item;\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        const doc = content.doc;\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(doc);\n        }\n        transaction.subdocsRemoved.add(this);\n      }, null, true);\n    }\n    this.emit('destroyed', [true]);\n    this.emit('destroy', [this]);\n    super.destroy();\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f);\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f);\n  }\n}\n\nclass DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n}\n\nclass UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return lib0_buffer__WEBPACK_IMPORTED_MODULE_8__.copyUint8Array(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder)\n  }\n}\n\nclass DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0;\n    this.restDecoder = decoder;\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) + 1;\n    this.dsCurrVal += diff;\n    return diff\n  }\n}\n\nclass UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder);\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = [];\n    lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder); // read feature flag - currently unused\n    this.keyClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.clientDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.leftClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.rightClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.infoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.stringDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.StringDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.parentInfoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);\n    this.typeRefDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n    this.lenDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read();\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read();\n      this.keys.push(key);\n      return key\n    }\n  }\n}\n\nclass DSEncoderV1 {\n  constructor () {\n    this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n  }\n\n  toUint8Array () {\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, clock);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n  }\n}\n\nclass UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(this.restEncoder, info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, JSON.stringify(embed));\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, key);\n  }\n}\n\nclass DSEncoderV2 {\n  constructor () {\n    this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder(); // encodes all the rest / non-optimized\n    this.dsCurrVal = 0;\n  }\n\n  toUint8Array () {\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0;\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal;\n    this.dsCurrVal = clock;\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, diff);\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len - 1);\n    this.dsCurrVal += len;\n  }\n}\n\nclass UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super();\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map();\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0;\n    this.keyClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.clientEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.leftClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.rightClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();\n    this.infoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.stringEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();\n    this.parentInfoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);\n    this.typeRefEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n    this.lenEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();\n  }\n\n  toUint8Array () {\n    const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.infoEncoder));\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.parentInfoEncoder));\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n    // @note The rest encoder is appended! (note the missing var)\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder));\n    return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client);\n    this.leftClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client);\n    this.rightClockEncoder.write(id.clock);\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info);\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s);\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0);\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info);\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len);\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, embed);\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key);\n    if (clock === undefined) {\n      /**\n       * @todo uncomment to introduce this feature finally\n       *\n       * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.\n       * Furthermore, I forgot to set the keyclock. So everything was working fine.\n       *\n       * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).\n       *\n       * I don't know yet how to reintroduce this feature..\n       *\n       * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.\n       *\n       */\n      // this.keyMap.set(key, this.keyClock)\n      this.keyClockEncoder.write(this.keyClock++);\n      this.stringEncoder.write(key);\n    } else {\n      this.keyClockEncoder.write(clock);\n    }\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(clock, structs[0].id.clock); // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock);\n  // write # encoded structs\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n  encoder.writeClient(client);\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n  const firstStruct = structs[startNewStructs];\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock);\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0);\n  }\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nconst writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map();\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock);\n    }\n  });\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0);\n    }\n  });\n  // write # states that were updated\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sm.size);\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock);\n  });\n};\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nconst readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs);\n    const client = decoder.readClient();\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs });\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      switch (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen();\n          refs[i] = new GC(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n          refs[i] = new Skip(createID(client, clock), len);\n          clock += len;\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          );\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct;\n          clock += struct.length;\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n};\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = [];\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(clientsStructRefs.keys()).sort((a, b) => a - b);\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop();\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  };\n  let curStructsTarget = getNextStructTarget();\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore();\n  const missingSV = new Map();\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client);\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock);\n    }\n  };\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];\n  // caching the state because it is used very often\n  const state = new Map();\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client;\n      const unapplicableItems = clientsStructRefs.get(client);\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--;\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));\n        clientsStructRefs.delete(client);\n        unapplicableItems.i = 0;\n        unapplicableItems.refs = [];\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item]);\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client);\n    }\n    stack.length = 0;\n  };\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n      const offset = localClock - stackHead.id.clock;\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead);\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS();\n      } else {\n        const missing = stackHead.getMissing(transaction, store);\n        if (missing !== null) {\n          stack.push(stackHead);\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing));\n            addStackToRestSS();\n          } else {\n            stackHead = structRefs.refs[structRefs.i++];\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset);\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop());\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n    } else {\n      curStructsTarget = getNextStructTarget();\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2();\n    writeClientsStructs(encoder, restStructs, new Map());\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n};\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nconst writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nconst readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    // force that transaction.local is set to non-local\n    transaction.local = false;\n    let retry = false;\n    const doc = transaction.doc;\n    const store = doc.store;\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc);\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true;\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(store.pendingDs));\n      lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest;\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nconst applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update);\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n};\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nconst applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nconst writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector);\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector);\n  writeStateAsUpdate(encoder, doc, targetStateVector);\n  const updates = [encoder.toUint8Array()];\n  // also add the pending updates (if there are any)\n  if (doc.store.pendingDs) {\n    updates.push(doc.store.pendingDs);\n  }\n  if (doc.store.pendingStructs) {\n    updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));\n  }\n  if (updates.length > 1) {\n    if (encoder.constructor === UpdateEncoderV1) {\n      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)))\n    } else if (encoder.constructor === UpdateEncoderV2) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n};\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst readStateVector = decoder => {\n  const ss = new Map();\n  const ssLength = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < ssLength; i++) {\n    const client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    ss.set(client, clock);\n  }\n  return ss\n};\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nconst decodeStateVector = decodedState => readStateVector(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(decodedState)));\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nconst writeStateVector = (encoder, sv) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sv.size);\n  lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);\n  });\n  return encoder\n};\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nconst writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store));\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc);\n  } else {\n    writeDocumentStateVector(encoder, doc);\n  }\n  return encoder.toUint8Array()\n};\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nconst encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1());\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nclass EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = [];\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nconst createEventHandler = () => new EventHandler();\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nconst addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f);\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nconst removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l;\n  const len = l.length;\n  eventHandler.l = l.filter(g => f !== g);\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.');\n  }\n};\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nconst callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll(eventHandler.l, [arg0, arg1]);\n\nclass ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client;\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock;\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock);\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nconst createID = (client, clock) => new ID(client, clock);\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nconst writeID = (encoder, id) => {\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.client);\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.clock);\n};\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nconst readID = decoder =>\n  createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder));\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nconst findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n};\n\n/**\n * Check if `parent` is a parent of `child`.\n *\n * @param {AbstractType<any>} parent\n * @param {Item|null} child\n * @return {Boolean} Whether `parent` is a parent of `child`.\n *\n * @private\n * @function\n */\nconst isParentOf = (parent, child) => {\n  while (child !== null) {\n    if (child.parent === parent) {\n      return true\n    }\n    child = /** @type {AbstractType<any>} */ (child.parent)._item;\n  }\n  return false\n};\n\n/**\n * Convenient helper to log type information.\n *\n * Do not use in productive systems as the output can be immense!\n *\n * @param {AbstractType<any>} type\n */\nconst logType = type => {\n  const res = [];\n  let n = type._start;\n  while (n) {\n    res.push(n);\n    n = n.right;\n  }\n  console.log('Children: ', res);\n  console.log('Children content: ', res.filter(m => !m.deleted).map(m => m.content));\n};\n\nclass PermanentUserData {\n  /**\n   * @param {Doc} doc\n   * @param {YMap<any>} [storeType]\n   */\n  constructor (doc, storeType = doc.getMap('users')) {\n    /**\n     * @type {Map<string,DeleteSet>}\n     */\n    const dss = new Map();\n    this.yusers = storeType;\n    this.doc = doc;\n    /**\n     * Maps from clientid to userDescription\n     *\n     * @type {Map<number,string>}\n     */\n    this.clients = new Map();\n    this.dss = dss;\n    /**\n     * @param {YMap<any>} user\n     * @param {string} userDescription\n     */\n    const initUser = (user, userDescription) => {\n      /**\n       * @type {YArray<Uint8Array>}\n       */\n      const ds = user.get('ds');\n      const ids = user.get('ids');\n      const addClientId = /** @param {number} clientid */ clientid => this.clients.set(clientid, userDescription);\n      ds.observe(/** @param {YArrayEvent<any>} event */ event => {\n        event.changes.added.forEach(item => {\n          item.content.getContent().forEach(encodedDs => {\n            if (encodedDs instanceof Uint8Array) {\n              this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)))]));\n            }\n          });\n        });\n      });\n      this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs => readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs))))));\n      ids.observe(/** @param {YArrayEvent<any>} event */ event =>\n        event.changes.added.forEach(item => item.content.getContent().forEach(addClientId))\n      );\n      ids.forEach(addClientId);\n    };\n    // observe users\n    storeType.observe(event => {\n      event.keysChanged.forEach(userDescription =>\n        initUser(storeType.get(userDescription), userDescription)\n      );\n    });\n    // add intial data\n    storeType.forEach(initUser);\n  }\n\n  /**\n   * @param {Doc} doc\n   * @param {number} clientid\n   * @param {string} userDescription\n   * @param {Object} conf\n   * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n   */\n  setUserMapping (doc, clientid, userDescription, { filter = () => true } = {}) {\n    const users = this.yusers;\n    let user = users.get(userDescription);\n    if (!user) {\n      user = new YMap();\n      user.set('ids', new YArray());\n      user.set('ds', new YArray());\n      users.set(userDescription, user);\n    }\n    user.get('ids').push([clientid]);\n    users.observe(_event => {\n      setTimeout(() => {\n        const userOverwrite = users.get(userDescription);\n        if (userOverwrite !== user) {\n          // user was overwritten, port all data over to the next user object\n          // @todo Experiment with Y.Sets here\n          user = userOverwrite;\n          // @todo iterate over old type\n          this.clients.forEach((_userDescription, clientid) => {\n            if (userDescription === _userDescription) {\n              user.get('ids').push([clientid]);\n            }\n          });\n          const encoder = new DSEncoderV1();\n          const ds = this.dss.get(userDescription);\n          if (ds) {\n            writeDeleteSet(encoder, ds);\n            user.get('ds').push([encoder.toUint8Array()]);\n          }\n        }\n      }, 0);\n    });\n    doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction => {\n      setTimeout(() => {\n        const yds = user.get('ds');\n        const ds = transaction.deleteSet;\n        if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n          const encoder = new DSEncoderV1();\n          writeDeleteSet(encoder, ds);\n          yds.push([encoder.toUint8Array()]);\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {number} clientid\n   * @return {any}\n   */\n  getUserByClientId (clientid) {\n    return this.clients.get(clientid) || null\n  }\n\n  /**\n   * @param {ID} id\n   * @return {string | null}\n   */\n  getUserByDeletedId (id) {\n    for (const [userDescription, ds] of this.dss.entries()) {\n      if (isDeleted(ds, id)) {\n        return userDescription\n      }\n    }\n    return null\n  }\n}\n\n/**\n * A relative position is based on the Yjs model and is not affected by document changes.\n * E.g. If you place a relative position before a certain character, it will always point to this character.\n * If you place a relative position at the end of a type, it will always point to the end of the type.\n *\n * A numeric position is often unsuited for user selections, because it does not change when content is inserted\n * before or after.\n *\n * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.\n *\n * One of the properties must be defined.\n *\n * @example\n *   // Current cursor position is at position 10\n *   const relativePosition = createRelativePositionFromIndex(yText, 10)\n *   // modify yText\n *   yText.insert(0, 'abc')\n *   yText.delete(3, 10)\n *   // Compute the cursor position\n *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)\n *   absolutePosition.type === yText // => true\n *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3\n *\n */\nclass RelativePosition {\n  /**\n   * @param {ID|null} type\n   * @param {string|null} tname\n   * @param {ID|null} item\n   * @param {number} assoc\n   */\n  constructor (type, tname, item, assoc = 0) {\n    /**\n     * @type {ID|null}\n     */\n    this.type = type;\n    /**\n     * @type {string|null}\n     */\n    this.tname = tname;\n    /**\n     * @type {ID | null}\n     */\n    this.item = item;\n    /**\n     * A relative position is associated to a specific character. By default\n     * assoc >= 0, the relative position is associated to the character\n     * after the meant position.\n     * I.e. position 1 in 'ab' is associated to character 'b'.\n     *\n     * If assoc < 0, then the relative position is associated to the caharacter\n     * before the meant position.\n     *\n     * @type {number}\n     */\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {RelativePosition} rpos\n * @return {any}\n */\nconst relativePositionToJSON = rpos => {\n  const json = {};\n  if (rpos.type) {\n    json.type = rpos.type;\n  }\n  if (rpos.tname) {\n    json.tname = rpos.tname;\n  }\n  if (rpos.item) {\n    json.item = rpos.item;\n  }\n  if (rpos.assoc != null) {\n    json.assoc = rpos.assoc;\n  }\n  return json\n};\n\n/**\n * @param {any} json\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromJSON = json => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n\nclass AbsolutePosition {\n  /**\n   * @param {AbstractType<any>} type\n   * @param {number} index\n   * @param {number} [assoc]\n   */\n  constructor (type, index, assoc = 0) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n    /**\n     * @type {number}\n     */\n    this.index = index;\n    this.assoc = assoc;\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @param {number} [assoc]\n *\n * @function\n */\nconst createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n\n/**\n * @param {AbstractType<any>} type\n * @param {ID|null} item\n * @param {number} [assoc]\n *\n * @function\n */\nconst createRelativePosition = (type, item, assoc) => {\n  let typeid = null;\n  let tname = null;\n  if (type._item === null) {\n    tname = findRootTypeKey(type);\n  } else {\n    typeid = createID(type._item.id.client, type._item.id.clock);\n  }\n  return new RelativePosition(typeid, tname, item, assoc)\n};\n\n/**\n * Create a relativePosition based on a absolute position.\n *\n * @param {AbstractType<any>} type The base type (e.g. YText or YArray).\n * @param {number} index The absolute position.\n * @param {number} [assoc]\n * @return {RelativePosition}\n *\n * @function\n */\nconst createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n  let t = type._start;\n  if (assoc < 0) {\n    // associated to the left character or the beginning of a type, increment index if possible.\n    if (index === 0) {\n      return createRelativePosition(type, null, assoc)\n    }\n    index--;\n  }\n  while (t !== null) {\n    if (!t.deleted && t.countable) {\n      if (t.length > index) {\n        // case 1: found position somewhere in the linked list\n        return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)\n      }\n      index -= t.length;\n    }\n    if (t.right === null && assoc < 0) {\n      // left-associated position, return last available id\n      return createRelativePosition(type, t.lastId, assoc)\n    }\n    t = t.right;\n  }\n  return createRelativePosition(type, null, assoc)\n};\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {RelativePosition} rpos\n *\n * @function\n */\nconst writeRelativePosition = (encoder, rpos) => {\n  const { type, tname, item, assoc } = rpos;\n  if (item !== null) {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0);\n    writeID(encoder, item);\n  } else if (tname !== null) {\n    // case 2: found position at the end of the list and type is stored in y.share\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 1);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, tname);\n  } else if (type !== null) {\n    // case 3: found position at the end of the list and type is attached to an item\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 2);\n    writeID(encoder, type);\n  } else {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n  }\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarInt(encoder, assoc);\n  return encoder\n};\n\n/**\n * @param {RelativePosition} rpos\n * @return {Uint8Array}\n */\nconst encodeRelativePosition = rpos => {\n  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n  writeRelativePosition(encoder, rpos);\n  return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder)\n};\n\n/**\n * @param {decoding.Decoder} decoder\n * @return {RelativePosition}\n *\n * @function\n */\nconst readRelativePosition = decoder => {\n  let type = null;\n  let tname = null;\n  let itemID = null;\n  switch (lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)) {\n    case 0:\n      // case 1: found position somewhere in the linked list\n      itemID = readID(decoder);\n      break\n    case 1:\n      // case 2: found position at the end of the list and type is stored in y.share\n      tname = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder);\n      break\n    case 2: {\n      // case 3: found position at the end of the list and type is attached to an item\n      type = readID(decoder);\n    }\n  }\n  const assoc = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.hasContent(decoder) ? lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarInt(decoder) : 0;\n  return new RelativePosition(type, tname, itemID, assoc)\n};\n\n/**\n * @param {Uint8Array} uint8Array\n * @return {RelativePosition}\n */\nconst decodeRelativePosition = uint8Array => readRelativePosition(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(uint8Array));\n\n/**\n * @param {RelativePosition} rpos\n * @param {Doc} doc\n * @return {AbsolutePosition|null}\n *\n * @function\n */\nconst createAbsolutePositionFromRelativePosition = (rpos, doc) => {\n  const store = doc.store;\n  const rightID = rpos.item;\n  const typeID = rpos.type;\n  const tname = rpos.tname;\n  const assoc = rpos.assoc;\n  let type = null;\n  let index = 0;\n  if (rightID !== null) {\n    if (getState(store, rightID.client) <= rightID.clock) {\n      return null\n    }\n    const res = followRedone(store, rightID);\n    const right = res.item;\n    if (!(right instanceof Item)) {\n      return null\n    }\n    type = /** @type {AbstractType<any>} */ (right.parent);\n    if (type._item === null || !type._item.deleted) {\n      index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc >= 0 ? 0 : 1)); // adjust position based on left association if necessary\n      let n = right.left;\n      while (n !== null) {\n        if (!n.deleted && n.countable) {\n          index += n.length;\n        }\n        n = n.left;\n      }\n    }\n  } else {\n    if (tname !== null) {\n      type = doc.get(tname);\n    } else if (typeID !== null) {\n      if (getState(store, typeID.client) <= typeID.clock) {\n        // type does not exist yet\n        return null\n      }\n      const { item } = followRedone(store, typeID);\n      if (item instanceof Item && item.content instanceof ContentType) {\n        type = item.content.type;\n      } else {\n        // struct is garbage collected\n        return null\n      }\n    } else {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n    if (assoc >= 0) {\n      index = type._length;\n    } else {\n      index = 0;\n    }\n  }\n  return createAbsolutePosition(type, index, rpos.assoc)\n};\n\n/**\n * @param {RelativePosition|null} a\n * @param {RelativePosition|null} b\n * @return {boolean}\n *\n * @function\n */\nconst compareRelativePositions = (a, b) => a === b || (\n  a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc\n);\n\nclass Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds;\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv;\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nconst equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients;\n  const ds2 = snap2.ds.clients;\n  const sv1 = snap1.sv;\n  const sv2 = snap2.sv;\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || [];\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i];\n      const dsitem2 = dsitems2[i];\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n};\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nconst encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds);\n  writeStateVector(encoder, snapshot.sv);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nconst encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1());\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nconst decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n};\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nconst decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)));\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nconst createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n\nconst emptySnapshot = createSnapshot(createDeleteSet(), new Map());\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nconst snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nconst isVisible = (item, snapshot) => snapshot === undefined\n  ? !item.deleted\n  : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nconst splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create);\n  const store = transaction.doc.store;\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n    });\n    iterateDeletedStructs(transaction, snapshot.ds, item => {});\n    meta.add(snapshot);\n  }\n};\n\n/**\n * @example\n *  const ydoc = new Y.Doc({ gc: false })\n *  ydoc.getText().insert(0, 'world!')\n *  const snapshot = Y.snapshot(ydoc)\n *  ydoc.getText().insert(0, 'hello ')\n *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)\n *  assert(restored.getText().toString() === 'world!')\n *\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nconst createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('Garbage-collection must be disabled in `originDoc`!')\n  }\n  const { sv, ds } = snapshot;\n\n  const encoder = new UpdateEncoderV2();\n  originDoc.transact(transaction => {\n    let size = 0;\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++;\n      }\n    });\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, size);\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock));\n      }\n      const structs = originDoc.store.clients.get(client) || [];\n      const lastStructIndex = findIndexSS(structs, clock - 1);\n      // write # encoded structs\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n      encoder.writeClient(client);\n      // first clock written is 0\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0);\n      }\n    }\n    writeDeleteSet(encoder, ds);\n  });\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');\n  return newDoc\n};\n\nclass StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map();\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null;\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null;\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nconst getStateVector = store => {\n  const sm = new Map();\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1];\n    sm.set(client, struct.id.clock + struct.length);\n  });\n  return sm\n};\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nconst getState = (store, client) => {\n  const structs = store.clients.get(client);\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1];\n  return lastStruct.id.clock + lastStruct.length\n};\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nconst addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client);\n  if (structs === undefined) {\n    structs = [];\n    store.clients.set(struct.id.client, structs);\n  } else {\n    const lastStruct = structs[structs.length - 1];\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n  }\n  structs.push(struct);\n};\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nconst findIndexSS = (structs, clock) => {\n  let left = 0;\n  let right = structs.length - 1;\n  let mid = structs[right];\n  let midclock = mid.id.clock;\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex];\n    midclock = mid.id.clock;\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1;\n    } else {\n      right = midindex - 1;\n    }\n    midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nconst find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  return structs[findIndexSS(structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nconst getItem = /** @type {function(StructStore,ID):Item} */ (find);\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nconst findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock);\n  const struct = structs[index];\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n    return index + 1\n  }\n  return index\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client));\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n};\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nconst getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client);\n  const index = findIndexSS(structs, id.clock);\n  const struct = structs[index];\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));\n  }\n  return struct\n};\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nconst replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client));\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n};\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nconst iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len;\n  let index = findIndexCleanStart(transaction, structs, clockStart);\n  let struct;\n  do {\n    struct = structs[index++];\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd);\n    }\n    f(struct);\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n};\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nclass Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet();\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store);\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map();\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}\n     */\n    this.changed = new Map();\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}\n     */\n    this.changedParentTypes = new Map();\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = [];\n    /**\n     * @type {any}\n     */\n    this.origin = origin;\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map();\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local;\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set();\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set();\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nconst writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !lib0_map__WEBPACK_IMPORTED_MODULE_3__.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet);\n  writeStructsFromTransaction(encoder, transaction);\n  writeDeleteSet(encoder, transaction.deleteSet);\n  return true\n};\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent<any>>} type\n * @param {string|null} parentSub\n */\nconst addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item;\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.changed, type, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create).add(parentSub);\n  }\n};\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1];\n  const right = structs[pos];\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1);\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si];\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false);\n        }\n      }\n    }\n  }\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di];\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = lib0_math__WEBPACK_IMPORTED_MODULE_1__.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si);\n      }\n    }\n  });\n};\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter);\n  tryMergeDeleteSet(ds, store);\n};\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i];\n    const doc = transaction.doc;\n    const store = doc.store;\n    const ds = transaction.deleteSet;\n    const mergeStructs = transaction._mergeStructs;\n    try {\n      sortAndMergeDeleteSet(ds);\n      transaction.afterState = getStateVector(transaction.doc.store);\n      doc.emit('beforeObserverCalls', [transaction, doc]);\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = [];\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs);\n          }\n        })\n      );\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                );\n              events\n                .forEach(event => {\n                  event.currentTarget = type;\n                });\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length);\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          })\n        );\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]));\n      });\n      (0,lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll)(fs, []);\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter);\n      }\n      tryMergeDeleteSet(ds, store);\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0;\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(findIndexSS(structs, beforeClock), 1);\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i);\n          }\n        }\n      });\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id;\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client));\n        const replacedStructPos = findIndexSS(structs, clock);\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1);\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos);\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(lib0_logging__WEBPACK_IMPORTED_MODULE_14__.ORANGE, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.BOLD, '[yjs] ', lib0_logging__WEBPACK_IMPORTED_MODULE_14__.UNBOLD, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.RED, 'Changed the client-id because another client seems to be using it.');\n        doc.clientID = generateNewClientId();\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc]);\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2();\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);\n        }\n      }\n      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n        subdocsAdded.forEach(subdoc => {\n          subdoc.clientID = doc.clientID;\n          if (subdoc.collectionid == null) {\n            subdoc.collectionid = doc.collectionid;\n          }\n          doc.subdocs.add(subdoc);\n        });\n        subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc));\n        doc.emit('subdocs', [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction]);\n        subdocsRemoved.forEach(subdoc => subdoc.destroy());\n      }\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = [];\n        doc.emit('afterAllTransactions', [doc, transactionCleanups]);\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1);\n      }\n    }\n  }\n};\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @template T\n * @param {Doc} doc\n * @param {function(Transaction):T} f\n * @param {any} [origin=true]\n * @return {T}\n *\n * @function\n */\nconst transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups;\n  let initialCall = false;\n  /**\n   * @type {any}\n   */\n  let result = null;\n  if (doc._transaction === null) {\n    initialCall = true;\n    doc._transaction = new Transaction(doc, origin, local);\n    transactionCleanups.push(doc._transaction);\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc]);\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc]);\n  }\n  try {\n    result = f(doc._transaction);\n  } finally {\n    if (initialCall) {\n      const finishCleanup = doc._transaction === transactionCleanups[0];\n      doc._transaction = null;\n      if (finishCleanup) {\n        // The first transaction ended, now process observer calls.\n        // Observer call may create new transactions for which we need to call the observers and do cleanup.\n        // We don't want to nest these calls, so we execute these calls one after\n        // another.\n        // Also we need to ensure that all cleanups are called, even if the\n        // observes throw errors.\n        // This file is full of hacky try {} finally {} blocks to ensure that an\n        // event can throw errors and also that the cleanup is called.\n        cleanupTransactions(transactionCleanups, 0);\n      }\n    }\n  }\n  return result\n};\n\nclass StackItem {\n  /**\n   * @param {DeleteSet} deletions\n   * @param {DeleteSet} insertions\n   */\n  constructor (deletions, insertions) {\n    this.insertions = insertions;\n    this.deletions = deletions;\n    /**\n     * Use this to save and restore metadata like selection range\n     */\n    this.meta = new Map();\n  }\n}\n/**\n * @param {Transaction} tr\n * @param {UndoManager} um\n * @param {StackItem} stackItem\n */\nconst clearUndoManagerStackItem = (tr, um, stackItem) => {\n  iterateDeletedStructs(tr, stackItem.deletions, item => {\n    if (item instanceof Item && um.scope.some(type => isParentOf(type, item))) {\n      keepItem(item, false);\n    }\n  });\n};\n\n/**\n * @param {UndoManager} undoManager\n * @param {Array<StackItem>} stack\n * @param {string} eventType\n * @return {StackItem?}\n */\nconst popStackItem = (undoManager, stack, eventType) => {\n  /**\n   * Whether a change happened\n   * @type {StackItem?}\n   */\n  let result = null;\n  /**\n   * Keep a reference to the transaction so we can fire the event with the changedParentTypes\n   * @type {any}\n   */\n  let _tr = null;\n  const doc = undoManager.doc;\n  const scope = undoManager.scope;\n  transact(doc, transaction => {\n    while (stack.length > 0 && result === null) {\n      const store = doc.store;\n      const stackItem = /** @type {StackItem} */ (stack.pop());\n      /**\n       * @type {Set<Item>}\n       */\n      const itemsToRedo = new Set();\n      /**\n       * @type {Array<Item>}\n       */\n      const itemsToDelete = [];\n      let performedChange = false;\n      iterateDeletedStructs(transaction, stackItem.insertions, struct => {\n        if (struct instanceof Item) {\n          if (struct.redone !== null) {\n            let { item, diff } = followRedone(store, struct.id);\n            if (diff > 0) {\n              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n            }\n            struct = item;\n          }\n          if (!struct.deleted && scope.some(type => isParentOf(type, /** @type {Item} */ (struct)))) {\n            itemsToDelete.push(struct);\n          }\n        }\n      });\n      iterateDeletedStructs(transaction, stackItem.deletions, struct => {\n        if (\n          struct instanceof Item &&\n          scope.some(type => isParentOf(type, struct)) &&\n          // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)\n        ) {\n          itemsToRedo.add(struct);\n        }\n      });\n      itemsToRedo.forEach(struct => {\n        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n      });\n      // We want to delete in reverse order so that children are deleted before\n      // parents, so we have more information available when items are filtered.\n      for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n        const item = itemsToDelete[i];\n        if (undoManager.deleteFilter(item)) {\n          item.delete(transaction);\n          performedChange = true;\n        }\n      }\n      result = performedChange ? stackItem : null;\n    }\n    transaction.changed.forEach((subProps, type) => {\n      // destroy search marker if necessary\n      if (subProps.has(null) && type._searchMarker) {\n        type._searchMarker.length = 0;\n      }\n    });\n    _tr = transaction;\n  }, undoManager);\n  if (result != null) {\n    const changedParentTypes = _tr.changedParentTypes;\n    undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);\n  }\n  return result\n};\n\n/**\n * @typedef {Object} UndoManagerOptions\n * @property {number} [UndoManagerOptions.captureTimeout=500]\n * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.\n * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes\n * it is necessary to filter what an Undo/Redo operation can delete. If this\n * filter returns false, the type/item won't be deleted even it is in the\n * undo/redo scope.\n * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]\n * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).\n * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.\n */\n\n/**\n * Fires 'stack-item-added' event when a stack item was added to either the undo- or\n * the redo-stack. You may store additional stack information via the\n * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).\n * Fires 'stack-item-popped' event when a stack item was popped from either the\n * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.\n *\n * @extends {Observable<'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'>}\n */\nclass UndoManager extends lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable {\n  /**\n   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types\n   * @param {UndoManagerOptions} options\n   */\n  constructor (typeScope, {\n    captureTimeout = 500,\n    captureTransaction = _tr => true,\n    deleteFilter = () => true,\n    trackedOrigins = new Set([null]),\n    ignoreRemoteMapChanges = false,\n    doc = /** @type {Doc} */ (lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(typeScope) ? typeScope[0].doc : typeScope.doc)\n  } = {}) {\n    super();\n    /**\n     * @type {Array<AbstractType<any>>}\n     */\n    this.scope = [];\n    this.addToScope(typeScope);\n    this.deleteFilter = deleteFilter;\n    trackedOrigins.add(this);\n    this.trackedOrigins = trackedOrigins;\n    this.captureTransaction = captureTransaction;\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.undoStack = [];\n    /**\n     * @type {Array<StackItem>}\n     */\n    this.redoStack = [];\n    /**\n     * Whether the client is currently undoing (calling UndoManager.undo)\n     *\n     * @type {boolean}\n     */\n    this.undoing = false;\n    this.redoing = false;\n    this.doc = doc;\n    this.lastChange = 0;\n    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n    this.captureTimeout = captureTimeout;\n    /**\n     * @param {Transaction} transaction\n     */\n    this.afterTransactionHandler = transaction => {\n      // Only track certain transactions\n      if (\n        !this.captureTransaction(transaction) ||\n        !this.scope.some(type => transaction.changedParentTypes.has(type)) ||\n        (!this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))\n      ) {\n        return\n      }\n      const undoing = this.undoing;\n      const redoing = this.redoing;\n      const stack = undoing ? this.redoStack : this.undoStack;\n      if (undoing) {\n        this.stopCapturing(); // next undo should not be appended to last stack item\n      } else if (!redoing) {\n        // neither undoing nor redoing: delete redoStack\n        this.clear(false, true);\n      }\n      const insertions = new DeleteSet();\n      transaction.afterState.forEach((endClock, client) => {\n        const startClock = transaction.beforeState.get(client) || 0;\n        const len = endClock - startClock;\n        if (len > 0) {\n          addToDeleteSet(insertions, client, startClock, len);\n        }\n      });\n      const now = lib0_time__WEBPACK_IMPORTED_MODULE_15__.getUnixTime();\n      let didAdd = false;\n      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n        // append change to last stack op\n        const lastOp = stack[stack.length - 1];\n        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n      } else {\n        // create a new stack op\n        stack.push(new StackItem(transaction.deleteSet, insertions));\n        didAdd = true;\n      }\n      if (!undoing && !redoing) {\n        this.lastChange = now;\n      }\n      // make sure that deleted structs are not gc'd\n      iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item => {\n        if (item instanceof Item && this.scope.some(type => isParentOf(type, item))) {\n          keepItem(item, true);\n        }\n      });\n      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this];\n      if (didAdd) {\n        this.emit('stack-item-added', changeEvent);\n      } else {\n        this.emit('stack-item-updated', changeEvent);\n      }\n    };\n    this.doc.on('afterTransaction', this.afterTransactionHandler);\n    this.doc.on('destroy', () => {\n      this.destroy();\n    });\n  }\n\n  /**\n   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes\n   */\n  addToScope (ytypes) {\n    ytypes = lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(ytypes) ? ytypes : [ytypes];\n    ytypes.forEach(ytype => {\n      if (this.scope.every(yt => yt !== ytype)) {\n        this.scope.push(ytype);\n      }\n    });\n  }\n\n  /**\n   * @param {any} origin\n   */\n  addTrackedOrigin (origin) {\n    this.trackedOrigins.add(origin);\n  }\n\n  /**\n   * @param {any} origin\n   */\n  removeTrackedOrigin (origin) {\n    this.trackedOrigins.delete(origin);\n  }\n\n  clear (clearUndoStack = true, clearRedoStack = true) {\n    if ((clearUndoStack && this.canUndo()) || (clearRedoStack && this.canRedo())) {\n      this.doc.transact(tr => {\n        if (clearUndoStack) {\n          this.undoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));\n          this.undoStack = [];\n        }\n        if (clearRedoStack) {\n          this.redoStack.forEach(item => clearUndoManagerStackItem(tr, this, item));\n          this.redoStack = [];\n        }\n        this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);\n      });\n    }\n  }\n\n  /**\n   * UndoManager merges Undo-StackItem if they are created within time-gap\n   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n   * StackItem won't be merged.\n   *\n   *\n   * @example\n   *     // without stopCapturing\n   *     ytext.insert(0, 'a')\n   *     ytext.insert(1, 'b')\n   *     um.undo()\n   *     ytext.toString() // => '' (note that 'ab' was removed)\n   *     // with stopCapturing\n   *     ytext.insert(0, 'a')\n   *     um.stopCapturing()\n   *     ytext.insert(0, 'b')\n   *     um.undo()\n   *     ytext.toString() // => 'a' (note that only 'b' was removed)\n   *\n   */\n  stopCapturing () {\n    this.lastChange = 0;\n  }\n\n  /**\n   * Undo last changes on type.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  undo () {\n    this.undoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.undoStack, 'undo');\n    } finally {\n      this.undoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Redo last undo operation.\n   *\n   * @return {StackItem?} Returns StackItem if a change was applied\n   */\n  redo () {\n    this.redoing = true;\n    let res;\n    try {\n      res = popStackItem(this, this.redoStack, 'redo');\n    } finally {\n      this.redoing = false;\n    }\n    return res\n  }\n\n  /**\n   * Are undo steps available?\n   *\n   * @return {boolean} `true` if undo is possible\n   */\n  canUndo () {\n    return this.undoStack.length > 0\n  }\n\n  /**\n   * Are redo steps available?\n   *\n   * @return {boolean} `true` if redo is possible\n   */\n  canRedo () {\n    return this.redoStack.length > 0\n  }\n\n  destroy () {\n    this.trackedOrigins.delete(this);\n    this.doc.off('afterTransaction', this.afterTransactionHandler);\n    super.destroy();\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    const client = decoder.readClient();\n    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo();\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);\n        yield new Skip(createID(client, clock), len);\n        clock += len;\n      } else if ((lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        );\n        yield struct;\n        clock += struct.length;\n      } else {\n        const len = decoder.readLen();\n        yield new GC(createID(client, clock), len);\n        clock += len;\n      }\n    }\n  }\n}\n\nclass LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder);\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null;\n    this.done = false;\n    this.filterSkips = filterSkips;\n    this.next();\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null;\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst logUpdate = update => logUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('Structs: ', structs);\n  const ds = readDeleteSet(updateDecoder);\n  lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('DeleteSet: ', ds);\n};\n\n/**\n * @param {Uint8Array} update\n *\n */\nconst decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nconst decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = [];\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr);\n  }\n  return {\n    structs,\n    ds: readDeleteSet(updateDecoder)\n  }\n};\n\nclass LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0;\n    this.startClock = 0;\n    this.written = 0;\n    this.encoder = encoder;\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = [];\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nconst mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder();\n  const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let size = 0;\n    let currClient = curr.id.client;\n    let stopCounting = curr.id.clock !== 0; // must start at 0\n    let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        if (currClock !== 0) {\n          size++;\n          // We found a new client\n          // write what we have to the encoder\n          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n        }\n        currClient = curr.id.client;\n        currClock = 0;\n        stopCounting = curr.id.clock !== 0;\n      }\n      // we ignore skips\n      if (curr.constructor === Skip) {\n        stopCounting = true;\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length;\n      }\n    }\n    // write what we have\n    if (currClock !== 0) {\n      size++;\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);\n      lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);\n    }\n    // prepend the size of the state vector\n    const enc = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(enc, size);\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder(enc, encoder.restEncoder);\n    encoder.restEncoder = enc;\n    return encoder.toUint8Array()\n  } else {\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);\n    return encoder.toUint8Array()\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nconst encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map();\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map();\n  const updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);\n  let curr = updateDecoder.curr;\n  if (curr !== null) {\n    let currClient = curr.id.client;\n    let currClock = curr.id.clock;\n    // write the beginning to `from`\n    from.set(currClient, currClock);\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock);\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock);\n        // update currClient\n        currClient = curr.id.client;\n      }\n      currClock = curr.id.clock + curr.length;\n    }\n    // write the end to `to`\n    to.set(currClient, currClock);\n  }\n  return { from, to }\n};\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nconst parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1);\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id;\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id;\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left);\n    const { client, clock } = leftItem.id;\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n};\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nconst mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  if (updates.length === 1) {\n    return updates[0]\n  }\n  const updateDecoders = updates.map(update => new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)));\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true));\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null;\n\n  const updateEncoder = new YEncoder();\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first  sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null);\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n          if (clockDiff === 0) {\n            // @todo remove references to skip since the structDecoders must filter Skips.\n            return dec1.curr.constructor === dec2.curr.constructor\n              ? 0\n              : dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    );\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0];\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr);\n      let iterated = false;\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next();\n        iterated = true;\n      }\n      if (\n        curr === null || // current decoder is empty\n        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n        (iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates\n      ) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: curr, offset: 0 };\n        currDecoder.next();\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n            currWrite = { struct, offset: 0 };\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff;\n            } else {\n              curr = sliceStruct(curr, diff);\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n            currWrite = { struct: curr, offset: 0 };\n            currDecoder.next();\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };\n      currDecoder.next();\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = { struct: next, offset: 0 };\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n    currWrite = null;\n  }\n  finishLazyStructWriting(lazyStructEncoder);\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder));\n  const ds = mergeDeleteSets(dss);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nconst diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv);\n  const encoder = new YEncoder();\n  const lazyStructWriter = new LazyStructWriter(encoder);\n  const decoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const reader = new LazyStructReader(decoder, false);\n  while (reader.curr) {\n    const curr = reader.curr;\n    const currClient = curr.id.client;\n    const svClock = state.get(currClient) || 0;\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next();\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(svClock - curr.id.clock, 0));\n      reader.next();\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n        reader.next();\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next();\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter);\n  // write ds\n  const ds = readDeleteSet(decoder);\n  writeDeleteSet(encoder, ds);\n  return encoder.toUint8Array()\n};\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nconst diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(lazyWriter.encoder.restEncoder) });\n    lazyWriter.encoder.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();\n    lazyWriter.written = 0;\n  }\n};\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter);\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client;\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client);\n    // write startClock\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n  }\n  struct.write(lazyWriter.encoder, offset);\n  lazyWriter.written++;\n};\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter);\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder;\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i];\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, partStructs.written);\n    // write the rest of the fragment\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(restEncoder, partStructs.restEncoder);\n  }\n};\n\n/**\n * @param {Uint8Array} update\n * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder\n * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder\n */\nconst convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n  const updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));\n  const lazyDecoder = new LazyStructReader(updateDecoder, false);\n  const updateEncoder = new YEncoder();\n  const lazyWriter = new LazyStructWriter(updateEncoder);\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n  }\n  finishLazyStructWriting(lazyWriter);\n  const ds = readDeleteSet(updateDecoder);\n  writeDeleteSet(updateEncoder, ds);\n  return updateEncoder.toUint8Array()\n};\n\n/**\n * @typedef {Object} ObfuscatorOptions\n * @property {boolean} [ObfuscatorOptions.formatting=true]\n * @property {boolean} [ObfuscatorOptions.subdocs=true]\n * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName\n */\n\n/**\n * @param {ObfuscatorOptions} obfuscator\n */\nconst createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n  let i = 0;\n  const mapKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const nodeNameCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const formattingKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  const formattingValueCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range\n  /**\n   * @param {Item|GC|Skip} block\n   * @return {Item|GC|Skip}\n   */\n  return block => {\n    switch (block.constructor) {\n      case GC:\n      case Skip:\n        return block\n      case Item: {\n        const item = /** @type {Item} */ (block);\n        const content = item.content;\n        switch (content.constructor) {\n          case ContentDeleted:\n            break\n          case ContentType: {\n            if (yxml) {\n              const type = /** @type {ContentType} */ (content).type;\n              if (type instanceof YXmlElement) {\n                type.nodeName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.nodeName, () => 'node-' + i);\n              }\n              if (type instanceof YXmlHook) {\n                type.hookName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.hookName, () => 'hook-' + i);\n              }\n            }\n            break\n          }\n          case ContentAny: {\n            const c = /** @type {ContentAny} */ (content);\n            c.arr = c.arr.map(() => i);\n            break\n          }\n          case ContentBinary: {\n            const c = /** @type {ContentBinary} */ (content);\n            c.content = new Uint8Array([i]);\n            break\n          }\n          case ContentDoc: {\n            const c = /** @type {ContentDoc} */ (content);\n            if (subdocs) {\n              c.opts = {};\n              c.doc.guid = i + '';\n            }\n            break\n          }\n          case ContentEmbed: {\n            const c = /** @type {ContentEmbed} */ (content);\n            c.embed = {};\n            break\n          }\n          case ContentFormat: {\n            const c = /** @type {ContentFormat} */ (content);\n            if (formatting) {\n              c.key = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingKeyCache, c.key, () => i + '');\n              c.value = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingValueCache, c.value, () => ({ i }));\n            }\n            break\n          }\n          case ContentJSON: {\n            const c = /** @type {ContentJSON} */ (content);\n            c.arr = c.arr.map(() => i);\n            break\n          }\n          case ContentString: {\n            const c = /** @type {ContentString} */ (content);\n            c.str = lib0_string__WEBPACK_IMPORTED_MODULE_16__.repeat((i % 10) + '', c.str.length);\n            break\n          }\n          default:\n            // unknown content type\n            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n        }\n        if (item.parentSub) {\n          item.parentSub = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(mapKeyCache, item.parentSub, () => i + '');\n        }\n        i++;\n        return block\n      }\n      default:\n        // unknown block-type\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n  }\n};\n\n/**\n * This function obfuscates the content of a Yjs update. This is useful to share\n * buggy Yjs documents while significantly limiting the possibility that a\n * developer can on the user. Note that it might still be possible to deduce\n * some information by analyzing the \"structure\" of the document or by analyzing\n * the typing behavior using the CRDT-related metadata that is still kept fully\n * intact.\n *\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nconst obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\n\n/**\n * @param {Uint8Array} update\n * @param {ObfuscatorOptions} [opts]\n */\nconst obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\n\n/**\n * @param {Uint8Array} update\n */\nconst convertUpdateFormatV1ToV2 = update => convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV1, UpdateEncoderV2);\n\n/**\n * @param {Uint8Array} update\n */\nconst convertUpdateFormatV2ToV1 = update => convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV2, UpdateEncoderV1);\n\n/**\n * @template {AbstractType<any>} T\n * YEvent describes the changes on a YType.\n */\nclass YEvent {\n  /**\n   * @param {T} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {T}\n     */\n    this.target = target;\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target;\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction;\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null;\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null;\n    /**\n     * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null;\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map();\n      const target = this.target;\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key));\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action;\n          let oldValue;\n          if (this.adds(item)) {\n            let prev = item.left;\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left;\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete';\n                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update';\n                oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());\n              } else {\n                action = 'add';\n                oldValue = undefined;\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete';\n              oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(/** @type {Item} */ item.content.getContent());\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue });\n        }\n      });\n      this._keys = keys;\n    }\n    return this._keys\n  }\n\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * This is a computed property. Note that this can only be safely computed during the\n   * event call. Computing this property after other changes happened might result in\n   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n   *\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes;\n    if (changes === null) {\n      const target = this.target;\n      const added = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n      const deleted = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = [];\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      };\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target));\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null;\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp);\n          }\n        };\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp();\n                lastOp = { delete: 0 };\n              }\n              lastOp.delete += item.length;\n              deleted.add(item);\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp();\n                lastOp = { insert: [] };\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent());\n              added.add(item);\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp();\n                lastOp = { retain: 0 };\n              }\n              lastOp.retain += item.length;\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp();\n        }\n      }\n      this._changes = changes;\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = [];\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub);\n    } else {\n      // parent is array-ish\n      let i = 0;\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start;\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++;\n        }\n        c = c.right;\n      }\n      path.unshift(i);\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent);\n  }\n  return path\n};\n\nconst maxSearchMarker = 80;\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0;\n\nclass ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true;\n    this.p = p;\n    this.index = index;\n    this.timestamp = globalSearchMarkerTimestamp++;\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++; };\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false;\n  marker.p = p;\n  p.marker = true;\n  marker.index = index;\n  marker.timestamp = globalSearchMarkerTimestamp++;\n};\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n    overwriteMarker(marker, p, index);\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index);\n    searchMarker.push(pm);\n    return pm\n  }\n};\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nconst findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - a.index) < lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - b.index) ? a : b);\n  let p = yarray._start;\n  let pindex = 0;\n  if (marker !== null) {\n    p = marker.p;\n    pindex = marker.index;\n    refreshMarkerTimestamp(marker); // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length;\n    }\n    p = p.right;\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left;\n    if (!p.deleted && p.countable) {\n      pindex -= p.length;\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex);\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n};\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nconst updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i];\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p;\n      p.marker = false;\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left;\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length;\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1);\n        continue\n      }\n      m.p = p;\n      p.marker = true;\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(index, m.index + len);\n    }\n  }\n};\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nconst getTypeChildren = t => {\n  let s = t._start;\n  const arr = [];\n  while (s) {\n    arr.push(s);\n    s = s.right;\n  }\n  return arr\n};\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nconst callTypeObservers = (type, transaction, event) => {\n  const changedType = type;\n  const changedParentTypes = transaction.changedParentTypes;\n  while (true) {\n    // @ts-ignore\n    lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(changedParentTypes, type, () => []).push(event);\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent);\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction);\n};\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nclass AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null;\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map();\n    /**\n     * @type {Item|null}\n     */\n    this._start = null;\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null;\n    this._length = 0;\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler();\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent<any>>,Transaction>}\n     */\n    this._dEH = createEventHandler();\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null;\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y;\n    this._item = item;\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n   */\n  _write (_encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, _parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0;\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f);\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f);\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start;\n  }\n  if (end < 0) {\n    end = type._length + end;\n  }\n  let len = end - start;\n  const cs = [];\n  let n = type._start;\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      if (c.length <= start) {\n        start -= c.length;\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i]);\n          len--;\n        }\n        start = 0;\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArray = type => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nconst typeListToArraySnapshot = (type, snapshot) => {\n  const cs = [];\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i]);\n      }\n    }\n    n = n.right;\n  }\n  return cs\n};\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nconst typeListForEach = (type, f) => {\n  let index = 0;\n  let n = type._start;\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent();\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type);\n      }\n    }\n    n = n.right;\n  }\n};\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nconst typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = [];\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type));\n  });\n  return result\n};\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nconst typeListCreateIterator = type => {\n  let n = type._start;\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null;\n  let currentContentIndex = 0;\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right;\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent();\n        currentContentIndex = 0;\n        n = n.right; // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++];\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null;\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n};\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nconst typeListGet = (type, index) => {\n  const marker = findMarker(type, index);\n  let n = type._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length;\n    }\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const store = doc.store;\n  const right = referenceItem === null ? parent._start : referenceItem.right;\n  /**\n   * @type {Array<Object|Array<any>|number|null>}\n   */\n  let jsonContent = [];\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n      left.integrate(transaction, 0);\n      jsonContent = [];\n    }\n  };\n  content.forEach(c => {\n    if (c === null) {\n      jsonContent.push(c);\n    } else {\n      switch (c.constructor) {\n        case Number:\n        case Object:\n        case Boolean:\n        case Array:\n        case String:\n          jsonContent.push(c);\n          break\n        default:\n          packJsonContent();\n          switch (c.constructor) {\n            case Uint8Array:\n            case ArrayBuffer:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));\n              left.integrate(transaction, 0);\n              break\n            case Doc:\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));\n              left.integrate(transaction, 0);\n              break\n            default:\n              if (c instanceof AbstractType) {\n                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                left.integrate(transaction, 0);\n              } else {\n                throw new Error('Unexpected content type in insert operation')\n              }\n          }\n      }\n    }\n  });\n  packJsonContent();\n};\n\nconst lengthExceeded = lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Length exceeded!');\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index > parent._length) {\n    throw lengthExceeded\n  }\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev; // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0;\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        break\n      }\n      index -= n.length;\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * Pushing content is special as we generally want to push after the last item. So we don't have to update\n * the serach marker.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nconst typeListPushGenerics = (transaction, parent, content) => {\n  // Use the marker with the highest index and iterate to the right.\n  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });\n  let n = marker.p;\n  if (n) {\n    while (n.right) {\n      n = n.right;\n    }\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nconst typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index;\n  const startLength = length;\n  const marker = findMarker(parent, index);\n  let n = parent._start;\n  if (marker !== null) {\n    n = marker.p;\n    index -= marker.index;\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n      }\n      index -= n.length;\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));\n      }\n      n.delete(transaction);\n      length -= n.length;\n    }\n    n = n.right;\n  }\n  if (length > 0) {\n    throw lengthExceeded\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nconst typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key);\n  if (c !== undefined) {\n    c.delete(transaction);\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nconst typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null;\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  let content;\n  if (value == null) {\n    content = new ContentAny([value]);\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value]);\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value));\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value));\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value);\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGet = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nconst typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {};\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1];\n    }\n  });\n  return res\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nconst typeMapHas = (parent, key) => {\n  const val = parent._map.get(key);\n  return val !== undefined && !val.deleted\n};\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nconst typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null;\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left;\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n};\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nconst createMapIterator = map => lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorFilter(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted);\n\n/**\n * @module YArray\n */\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n * @extends YEvent<YArray<T>>\n */\nclass YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction);\n    this._transaction = transaction;\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nclass YArray extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    /**\n     * @type {YArray<T>}\n     */\n    const a = new YArray();\n    a.push(items);\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    /**\n     * @type {YArray<T>}\n     */\n    const arr = new YArray();\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? /** @type {typeof el} */ (el.clone()) : el\n    ));\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, /** @type {any} */ (content));\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   *\n   * @todo Use the following implementation in all types.\n   */\n  push (content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListPushGenerics(transaction, this, /** @type {any} */ (content));\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).push(...content);\n    }\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length);\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */\nconst readYArray = _decoder => new YArray();\n\n/**\n * @template T\n * @extends YEvent<YMap<T>>\n * Event that describes the changes on a YMap.\n */\nclass YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction);\n    this.keysChanged = subs;\n  }\n}\n\n/**\n * @template MapType\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<MapType>>\n * @implements {Iterable<MapType>}\n */\nclass YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super();\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null;\n\n    if (entries === undefined) {\n      this._prelimContent = new Map();\n    } else {\n      this._prelimContent = new Map(entries);\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value);\n    });\n    this._prelimContent = null;\n  }\n\n  /**\n   * @return {YMap<MapType>}\n   */\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<MapType>}\n   */\n  clone () {\n    /**\n     * @type {YMap<MapType>}\n     */\n    const map = new YMap();\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ (value.clone()) : value);\n    });\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,MapType>}\n     */\n    const map = {};\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1];\n        map[key] = v instanceof AbstractType ? v.toJSON() : v;\n      }\n    });\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this);\n      }\n    });\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key);\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   * @template {MapType} VAL\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {VAL} value The value of the element to add\n   * @return {VAL}\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, /** @type {any} */ (value));\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value);\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {MapType|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * Removes all elements from this YMap.\n   */\n  clear () {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        this.forEach(function (_value, key, map) {\n          typeMapDelete(transaction, map, key);\n        });\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).clear();\n    }\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n *\n * @private\n * @function\n */\nconst readYMap = _decoder => new YMap();\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && lib0_object__WEBPACK_IMPORTED_MODULE_18__.equalFlat(a, b));\n\nclass ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left;\n    this.right = right;\n    this.index = index;\n    this.currentAttributes = currentAttributes;\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n    }\n    switch (this.right.content.constructor) {\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));\n        }\n        break\n      default:\n        if (!this.right.deleted) {\n          this.index += this.right.length;\n        }\n        break\n    }\n    this.left = this.right;\n    this.right = this.right.right;\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));\n        }\n        break\n      default:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n          }\n          pos.index += pos.right.length;\n          count -= pos.right.length;\n        }\n        break\n    }\n    pos.left = pos.right;\n    pos.right = pos.right.right;\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map();\n  const marker = findMarker(parent, index);\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n    return findNextPosition(transaction, pos, index)\n  }\n};\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);\n    }\n    currPos.forward();\n  }\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  negatedAttributes.forEach((val, key) => {\n    const left = currPos.left;\n    const right = currPos.right;\n    const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n    nextFormat.integrate(transaction, 0);\n    currPos.right = nextFormat;\n    currPos.forward();\n  });\n};\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format;\n  if (value === null) {\n    currentAttributes.delete(key);\n  } else {\n    currentAttributes.set(key, value);\n  }\n};\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {\n      break\n    }\n    currPos.forward();\n  }\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  const negatedAttributes = new Map();\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key];\n    const currentVal = currPos.currentAttributes.get(key) || null;\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal);\n      const { left, right } = currPos;\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n  }\n  return negatedAttributes\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object|AbstractType<any>} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((_val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null;\n    }\n  });\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text));\n  let { left, right, index } = currPos;\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n  right.integrate(transaction, 0);\n  currPos.right = right;\n  currPos.index = index;\n  currPos.forward();\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc;\n  const ownClientId = doc.clientID;\n  minimizeAttributeChanges(currPos, attributes);\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there\n  // eslint-disable-next-line no-labels\n  iterationLoop: while (\n    currPos.right !== null &&\n    (length > 0 ||\n      (\n        negatedAttributes.size > 0 &&\n        (currPos.right.deleted || currPos.right.content.constructor === ContentFormat)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);\n          const attr = attributes[key];\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key);\n            } else {\n              if (length === 0) {\n                // no need to further extend negatedAttributes\n                // eslint-disable-next-line no-labels\n                break iterationLoop\n              }\n              negatedAttributes.set(key, value);\n            }\n            currPos.right.delete(transaction);\n          } else {\n            currPos.currentAttributes.set(key, value);\n          }\n          break\n        }\n        default:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          break\n      }\n    }\n    currPos.forward();\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = '';\n    for (; length > 0; length--) {\n      newlines += '\\n';\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n    currPos.right.integrate(transaction, 0);\n    currPos.forward();\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n};\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} currAttributes\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n  /**\n   * @type {Item|null}\n   */\n  let end = start;\n  /**\n   * @type {Map<string,ContentFormat>}\n   */\n  const endFormats = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n  while (end && (!end.countable || end.deleted)) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      const cf = /** @type {ContentFormat} */ (end.content);\n      endFormats.set(cf.key, cf);\n    }\n    end = end.right;\n  }\n  let cleanups = 0;\n  let reachedCurr = false;\n  while (start !== end) {\n    if (curr === start) {\n      reachedCurr = true;\n    }\n    if (!start.deleted) {\n      const content = start.content;\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content);\n          const startAttrValue = startAttributes.get(key) || null;\n          if (endFormats.get(key) !== content || startAttrValue === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction);\n            cleanups++;\n            if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {\n              if (startAttrValue === null) {\n                currAttributes.delete(key);\n              } else {\n                currAttributes.set(key, startAttrValue);\n              }\n            }\n          }\n          if (!reachedCurr && !start.deleted) {\n            updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ (content));\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right);\n  }\n  return cleanups\n};\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || !item.right.countable)) {\n    item = item.right;\n  }\n  const attrs = new Set();\n  // iterate back until a content item is found\n  while (item && (item.deleted || !item.countable)) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key;\n      if (attrs.has(key)) {\n        item.delete(transaction);\n      } else {\n        attrs.add(key);\n      }\n    }\n    item = item.left;\n  }\n};\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nconst cleanupYTextFormatting = type => {\n  let res = 0;\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start);\n    let end = type._start;\n    let startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();\n    const currentAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(startAttributes);\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));\n            break\n          default:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n            startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currentAttributes);\n            start = end;\n            break\n        }\n      }\n      end = end.right;\n    }\n  });\n  return res\n};\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length;\n  const startAttrs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currPos.currentAttributes);\n  const start = currPos.right;\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentType:\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));\n          }\n          length -= currPos.right.length;\n          currPos.right.delete(transaction);\n          break\n      }\n    }\n    currPos.forward();\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);\n  }\n  return currPos\n};\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * @extends YEvent<YText>\n * Event that describes the changes on a YText type.\n */\nclass YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.keysChanged.add(sub);\n      }\n    });\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      };\n      this._changes = changes;\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc);\n      /**\n       * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = [];\n      transact(y, transaction => {\n        const currentAttributes = new Map(); // saves all current attributes for insert\n        const oldAttributes = new Map();\n        let item = this.target._start;\n        /**\n         * @type {string?}\n         */\n        let action = null;\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}; // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = '';\n        let retain = 0;\n        let deleteLen = 0;\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op = null;\n            switch (action) {\n              case 'delete':\n                if (deleteLen > 0) {\n                  op = { delete: deleteLen };\n                }\n                deleteLen = 0;\n                break\n              case 'insert':\n                if (typeof insert === 'object' || insert.length > 0) {\n                  op = { insert };\n                  if (currentAttributes.size > 0) {\n                    op.attributes = {};\n                    currentAttributes.forEach((value, key) => {\n                      if (value !== null) {\n                        op.attributes[key] = value;\n                      }\n                    });\n                  }\n                }\n                insert = '';\n                break\n              case 'retain':\n                if (retain > 0) {\n                  op = { retain };\n                  if (!lib0_object__WEBPACK_IMPORTED_MODULE_18__.isEmpty(attributes)) {\n                    op.attributes = lib0_object__WEBPACK_IMPORTED_MODULE_18__.assign({}, attributes);\n                  }\n                }\n                retain = 0;\n                break\n            }\n            if (op) delta.push(op);\n            action = null;\n          }\n        };\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentType:\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp();\n                  action = 'insert';\n                  insert = item.content.getContent()[0];\n                  addOp();\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += 1;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += 1;\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp();\n                    action = 'insert';\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str;\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp();\n                  action = 'delete';\n                }\n                deleteLen += item.length;\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp();\n                  action = 'retain';\n                }\n                retain += item.length;\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content);\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (value !== null) {\n                    item.delete(transaction);\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value);\n                const curVal = currentAttributes.get(key) || null;\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp();\n                  }\n                  attributes[key] = curVal;\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value);\n                const attr = attributes[key];\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp();\n                    }\n                    if (value === null) {\n                      delete attributes[key];\n                    } else {\n                      attributes[key] = value;\n                    }\n                  } else if (attr !== null) { // this will be cleaned up automatically by the contextless cleanup function\n                    item.delete(transaction);\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp();\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));\n              }\n              break\n            }\n          }\n          item = item.right;\n        }\n        addOp();\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1];\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop();\n          } else {\n            break\n          }\n        }\n      });\n      this._delta = delta;\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nclass YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super();\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : [];\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = [];\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f());\n    } catch (e) {\n      console.error(e);\n    }\n    this._pending = null;\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs);\n    const event = new YTextEvent(this, transaction, parentSubs);\n    const doc = transaction.doc;\n    callTypeObservers(this, transaction, event);\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false;\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0;\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true;\n          }\n        });\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this);\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item);\n            }\n          });\n        }\n      });\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = '';\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start;\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str;\n      }\n      n = n.right;\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  opts\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map());\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i];\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert;\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {});\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {});\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete);\n          }\n        }\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta));\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = [];\n    const currentAttributes = new Map();\n    const doc = /** @type {Doc} */ (this.doc);\n    let str = '';\n    let n = this._start;\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {};\n        let addAttributes = false;\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true;\n          attributes[key] = value;\n        });\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str };\n        if (addAttributes) {\n          op.attributes = attributes;\n        }\n        ops.push(op);\n        str = '';\n      }\n    }\n    const computeDelta = () => {\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange');\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {\n                  packStr();\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });\n                }\n              } else if (cur !== undefined) {\n                packStr();\n                currentAttributes.delete('ychange');\n              }\n              str += /** @type {ContentString} */ (n.content).str;\n              break\n            }\n            case ContentType:\n            case ContentEmbed: {\n              packStr();\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: n.content.getContent()[0]\n              };\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({});\n                op.attributes = attrs;\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value;\n                });\n              }\n              ops.push(op);\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr();\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));\n              }\n              break\n          }\n        }\n        n = n.right;\n      }\n      packStr();\n    };\n    if (snapshot || prevSnapshot) {\n      // snapshots are merged again after the transaction, so we need to keep the\n      // transaction alive until we are done\n      transact(doc, transaction => {\n        if (snapshot) {\n          splitSnapshotAffectedStructs(transaction, snapshot);\n        }\n        if (prevSnapshot) {\n          splitSnapshotAffectedStructs(transaction, prevSnapshot);\n        }\n        computeDelta();\n      }, 'cleanup');\n    } else {\n      computeDelta();\n    }\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (!attributes) {\n          attributes = {};\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v; });\n        }\n        insertText(transaction, this, pos, text, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes));\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        insertText(transaction, this, pos, embed, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes));\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length));\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc;\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index);\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes));\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName));\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue));\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes () {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nconst readYText = _decoder => new YText();\n\n/**\n * @module YXml\n */\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nclass YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f;\n    this._root = root;\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start);\n    this._firstCall = true;\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode;\n    let type = n && n.content && /** @type {any} */ (n.content).type;\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type;\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start;\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right;\n              break\n            } else if (n.parent === this._root) {\n              n = null;\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item;\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false;\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n;\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nclass YXmlFragment extends AbstractType {\n  constructor () {\n    super();\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = [];\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first;\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item);\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent));\n    this._prelimContent = null;\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment();\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query);\n    const next = iterator.next();\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase();\n    // @ts-ignore\n    return lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment();\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this);\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n    });\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref;\n        typeListInsertGenericsAfter(transaction, this, refItem, content);\n      });\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent);\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1;\n      if (index === 0 && ref !== null) {\n        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content);\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length);\n      });\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length);\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content);\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content);\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Executes a provided function on once on overy child element.\n   *\n   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f);\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nconst readYXmlFragment = _decoder => new YXmlFragment();\n\n/**\n * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes\n */\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n *\n * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]\n */\nclass YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super();\n    this.nodeName = nodeName;\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map();\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value);\n    });\n    this._prelimAttrs = null;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement<KV>}\n   */\n  clone () {\n    /**\n     * @type {YXmlElement<KV>}\n     */\n    const el = new YXmlElement(this.nodeName);\n    const attrs = this.getAttributes();\n    lib0_object__WEBPACK_IMPORTED_MODULE_18__.forEach(attrs, (value, key) => {\n      if (typeof value === 'string') {\n        el.setAttribute(key, value);\n      }\n    });\n    // @ts-ignore\n    el.insert(0, this.toArray().map(item => item instanceof AbstractType ? item.clone() : item));\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes();\n    const stringBuilder = [];\n    const keys = [];\n    for (const key in attrs) {\n      keys.push(key);\n    }\n    keys.sort();\n    const keysLen = keys.length;\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i];\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase();\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {string} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName);\n      });\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName);\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that is to be set.\n   * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue);\n      });\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue);\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @template {keyof KV & string} KEY\n   *\n   * @param {KEY} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {KV[KEY]|undefined} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns whether an attribute exists\n   *\n   * @param {string} attributeName The attribute name to check for existence.\n   * @return {boolean} whether the attribute exists.\n   *\n   * @public\n   */\n  hasAttribute (attributeName) {\n    return /** @type {any} */ (typeMapHas(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes () {\n    return /** @type {any} */ (typeMapGetAll(this))\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName);\n    const attrs = this.getAttributes();\n    for (const key in attrs) {\n      const value = attrs[key];\n      if (typeof value === 'string') {\n        dom.setAttribute(key, value);\n      }\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding));\n    });\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID);\n    encoder.writeKey(this.nodeName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nconst readYXmlElement = decoder => new YXmlElement(decoder.readKey());\n\n/**\n * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nclass YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction);\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false;\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set();\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true;\n      } else {\n        this.attributesChanged.add(sub);\n      }\n    });\n  }\n}\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nclass YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super();\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName;\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName);\n    this.forEach((value, key) => {\n      el.set(key, value);\n    });\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName];\n    let dom;\n    if (hook !== undefined) {\n      dom = hook.createDom(this);\n    } else {\n      dom = document.createElement(this.hookName);\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName);\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID);\n    encoder.writeKey(this.hookName);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nconst readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey());\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nclass YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null;\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText();\n    text.applyDelta(this.toDelta());\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString());\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this);\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = [];\n      for (const nodeName in delta.attributes) {\n        const attrs = [];\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] });\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n        nestedNodes.push({ nodeName, attrs });\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n      // now convert to dom string\n      let str = '';\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i];\n        str += `<${node.nodeName}`;\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j];\n          str += ` ${attr.key}=\"${attr.value}\"`;\n        }\n        str += '>';\n      }\n      str += delta.insert;\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`;\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nconst readYXmlText = decoder => new YXmlText();\n\nclass AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id;\n    this.length = length;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n}\n\nconst structGCRefNumber = 0;\n\n/**\n * @private\n */\nclass GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.length -= offset;\n    }\n    addStruct(transaction.doc.store, this);\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber);\n    encoder.writeLen(this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\nclass ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nconst readContentBinary = decoder => new ContentBinary(decoder.readBuf());\n\nclass ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset);\n    this.len = offset;\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n    item.markDeleted();\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nconst readContentDeleted = decoder => new ContentDeleted(decoder.readLen());\n\n/**\n * @param {string} guid\n * @param {Object<string, any>} opts\n */\nconst createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });\n\n/**\n * @private\n */\nclass ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc;\n    /**\n     * @type {any}\n     */\n    const opts = {};\n    this.opts = opts;\n    if (!doc.gc) {\n      opts.gc = false;\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true;\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta;\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item;\n    transaction.subdocsAdded.add(this.doc);\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc);\n    } else {\n      transaction.subdocsRemoved.add(this.doc);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid);\n    encoder.writeAny(this.opts);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nconst readContentDoc = decoder => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\n\n/**\n * @private\n */\nclass ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nconst readContentEmbed = decoder => new ContentEmbed(decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key;\n    this.value = value;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null;\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key);\n    encoder.writeJSON(this.value);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nconst readContentFormat = decoder => new ContentFormat(decoder.readKey(), decoder.readJSON());\n\n/**\n * @private\n */\nclass ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nconst readContentJSON = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString();\n    if (c === 'undefined') {\n      cs.push(undefined);\n    } else {\n      cs.push(JSON.parse(c));\n    }\n  }\n  return new ContentJSON(cs)\n};\n\nclass ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset));\n    this.arr = this.arr.slice(0, offset);\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr);\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length;\n    encoder.writeLen(len - offset);\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i];\n      encoder.writeAny(c);\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nconst readContentAny = decoder => {\n  const len = decoder.readLen();\n  const cs = [];\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny());\n  }\n  return new ContentAny(cs)\n};\n\n/**\n * @private\n */\nclass ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset));\n    this.str = this.str.slice(0, offset);\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1);\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character ( / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + '';\n      // replace right as well\n      right.str = '' + right.str.slice(1);\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nconst readContentString = decoder => new ContentString(decoder.readString());\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nconst typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n];\n\nconst YArrayRefID = 0;\nconst YMapRefID = 1;\nconst YTextRefID = 2;\nconst YXmlElementRefID = 3;\nconst YXmlFragmentRefID = 4;\nconst YXmlHookRefID = 5;\nconst YXmlTextRefID = 6;\n\n/**\n * @private\n */\nclass ContentType {\n  /**\n   * @param {AbstractType<any>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type;\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start;\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // This will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item);\n      }\n      item = item.right;\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction);\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item);\n      }\n    });\n    transaction.changed.delete(this.type);\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start;\n    while (item !== null) {\n      item.gc(store, true);\n      item = item.right;\n    }\n    this.type._start = null;\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.left;\n      }\n    });\n    this.type._map = new Map();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder);\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nconst readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nconst followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id;\n  let diff = 0;\n  let item;\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff);\n    }\n    item = getItem(store, nextID);\n    diff = nextID.clock - item.id.clock;\n    nextID = item.redone;\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n};\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nconst keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep;\n    item = /** @type {AbstractType<any>} */ (item.parent)._item;\n  }\n};\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nconst splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id;\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  );\n  if (leftItem.deleted) {\n    rightItem.markDeleted();\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true;\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem;\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem;\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem);\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);\n  }\n  leftItem.length = diff;\n  return rightItem\n};\n\n/**\n * @param {Array<StackItem>} stack\n * @param {ID} id\n */\nconst isDeletedByUndoStack = (stack, id) => lib0_array__WEBPACK_IMPORTED_MODULE_2__.some(stack, /** @param {StackItem} s */ s => isDeleted(s.deletions, id));\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n * @param {DeleteSet} itemsToDelete\n * @param {boolean} ignoreRemoteMapChanges\n * @param {import('../utils/UndoManager.js').UndoManager} um\n *\n * @return {Item|null}\n *\n * @private\n */\nconst redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n  const doc = transaction.doc;\n  const store = doc.store;\n  const ownClientID = doc.clientID;\n  const redone = item.redone;\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item;\n  /**\n   * @type {Item|null}\n   */\n  let left = null;\n  /**\n   * @type {Item|null}\n   */\n  let right;\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true) {\n    // try to undo parent if it will be undone anyway\n    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n      return null\n    }\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone);\n    }\n  }\n  const parentType = parentItem === null ? /** @type {AbstractType<any>} */ (item.parent) : /** @type {ContentType} */ (parentItem.content).type;\n\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left;\n    right = item;\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left;\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace;\n        break\n      }\n      left = left.left;\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right;\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace;\n        break\n      }\n      right = right.right;\n    }\n  } else {\n    right = null;\n    if (item.right && !ignoreRemoteMapChanges) {\n      left = item;\n      // Iterate right while right is in itemsToDelete\n      // If it is intended to delete right while item is redone, we can expect that item should replace right.\n      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n        left = left.right;\n        // follow redone\n        while (left.redone) left = getItemCleanStart(transaction, left.redone);\n      }\n      if (left && left.right !== null) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    } else {\n      left = parentType._map.get(item.parentSub) || null;\n    }\n  }\n  const nextClock = getState(store, ownClientID);\n  const nextId = createID(ownClientID, nextClock);\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentType,\n    item.parentSub,\n    item.content.copy()\n  );\n  item.redone = nextId;\n  keepItem(redoneItem, true);\n  redoneItem.integrate(transaction, 0);\n  return redoneItem\n};\n\n/**\n * Abstract class that represents any content.\n */\nclass Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength());\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin;\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left;\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right;\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin;\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent;\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub;\n    /**\n     * If this type's effect is redone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null;\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content;\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2 : 0;\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0) !== isMarked) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4;\n    }\n  }\n\n  get marker () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1;\n    }\n  }\n\n  get countable () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n    }\n  }\n\n  markDeleted () {\n    this.info |= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin);\n      this.origin = this.left.lastId;\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin);\n      this.rightOrigin = this.right.id;\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null;\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent;\n        this.parentSub = this.left.parentSub;\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent;\n        this.parentSub = this.right.parentSub;\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent);\n      if (parentItem.constructor === GC) {\n        this.parent = null;\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type;\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset;\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n      this.origin = this.left.lastId;\n      this.content = this.content.splice(offset);\n      this.length -= offset;\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left;\n\n        /**\n         * @type {Item|null}\n         */\n        let o;\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right;\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (o !== null && o.left !== null) {\n            o = o.left;\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start;\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set();\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set();\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o);\n          conflictingItems.add(o);\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o;\n              conflictingItems.clear();\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o;\n              conflictingItems.clear();\n            }\n          } else {\n            break\n          }\n          o = o.right;\n        }\n        this.left = left;\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right;\n        this.right = right;\n        this.left.right = this;\n      } else {\n        let r;\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null;\n          while (r !== null && r.left !== null) {\n            r = r.left;\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this;\n        }\n        this.right = r;\n      }\n      if (this.right !== null) {\n        this.right.left = this;\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this);\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction);\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length;\n      }\n      addStruct(transaction.doc.store, this);\n      this.content.integrate(transaction, this);\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub);\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction);\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0);\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right;\n    while (n !== null && n.deleted) {\n      n = n.right;\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left;\n    while (n !== null && n.deleted) {\n      n = n.left;\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      const searchMarker = /** @type {AbstractType<any>} */ (this.parent)._searchMarker;\n      if (searchMarker) {\n        searchMarker.forEach(marker => {\n          if (marker.p === right) {\n            // right is going to be \"forgotten\" so we need to update the marker\n            marker.p = this;\n            // adjust marker index\n            if (!this.deleted && this.countable) {\n              marker.index -= this.length;\n            }\n          }\n        });\n      }\n      if (right.keep) {\n        this.keep = true;\n      }\n      this.right = right.right;\n      if (this.right !== null) {\n        this.right.left = this;\n      }\n      this.length += right.length;\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length;\n      }\n      this.markDeleted();\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n      addChangedTypeToTransaction(transaction, parent, this.parentSub);\n      this.content.delete(transaction);\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase()\n    }\n    this.content.gc(store);\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length));\n    } else {\n      this.content = new ContentDeleted(this.length);\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n    const rightOrigin = this.rightOrigin;\n    const parentSub = this.parentSub;\n    const info = (this.content.getRef() & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5) |\n      (origin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6); // parentSub is non-null\n    encoder.writeInfo(info);\n    if (origin !== null) {\n      encoder.writeLeftID(origin);\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin);\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent);\n      if (parent._item !== undefined) {\n        const parentItem = parent._item;\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent);\n          encoder.writeParentInfo(true); // write parentYKey\n          encoder.writeString(ykey);\n        } else {\n          encoder.writeParentInfo(false); // write parent id\n          encoder.writeLeftID(parentItem.id);\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true); // write parentYKey\n        encoder.writeString(parent);\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false); // write parent id\n        encoder.writeLeftID(parent);\n      } else {\n        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub);\n      }\n    }\n    this.content.write(encoder, offset);\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nconst readItemContent = (decoder, info) => contentRefs[info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5](decoder);\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nconst contentRefs = [\n  () => { lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase(); }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase(); } // 10 - Skip is not ItemContent\n];\n\nconst structSkipRefNumber = 10;\n\n/**\n * @private\n */\nclass Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length;\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber);\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, this.length - offset);\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n\n/** eslint-env browser */\n\nconst glo = /** @type {any} */ (typeof globalThis !== 'undefined'\n  ? globalThis\n  : typeof window !== 'undefined'\n    ? window\n    // @ts-ignore\n    : typeof global !== 'undefined' ? global : {});\n\nconst importIdentifier = '__ $YJS$ __';\n\nif (glo[importIdentifier] === true) {\n  /**\n   * Dear reader of this message. Please take this seriously.\n   *\n   * If you see this message, make sure that you only import one version of Yjs. In many cases,\n   * your package manager installs two versions of Yjs that are used by different packages within your project.\n   * Another reason for this message is that some parts of your project use the commonjs version of Yjs\n   * and others use the EcmaScript version of Yjs.\n   *\n   * This often leads to issues that are hard to debug. We often need to perform constructor checks,\n   * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to\n   * do the constructor checks anymore - which might break the CRDT algorithm.\n   *\n   * https://github.com/yjs/yjs/issues/438\n   */\n  console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');\n}\nglo[importIdentifier] = true;\n\n\n//# sourceMappingURL=yjs.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3lqcy9kaXN0L3lqcy5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ1Q7QUFDRjtBQUNGO0FBQ1U7QUFDQTtBQUNKO0FBQ0U7QUFDRjtBQUNGO0FBQ0U7QUFDSDtBQUNLO0FBQ1I7QUFDUTtBQUNOO0FBQ0k7QUFDSTtBQUNKOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQ0FBZ0MsdURBQVU7QUFDMUM7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxLQUFLO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsV0FBVztBQUN0QixXQUFXLHdCQUF3QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQyxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNENBQVU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdkM7QUFDQSxRQUFRO0FBQ1Isd0NBQXdDO0FBQ3hDO0FBQ0EsUUFBUTtBQUNSLFFBQVEsc0RBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLFFBQVE7QUFDbkI7QUFDQSw4REFBOEQsK0NBQVk7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVSxzREFBb0IsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNEQUFvQixNQUFNO0FBQ3BDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNEQUFvQjtBQUN4Qjs7QUFFQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hELGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQXFCO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4aEQ7QUFDOWhEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy95anMvZGlzdC95anMubWpzP2I3YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5JztcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJztcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCc7XG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJztcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnO1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJztcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJztcbmltcG9ydCAqIGFzIGJ1ZmZlciBmcm9tICdsaWIwL2J1ZmZlcic7XG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJztcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICdsaWIwL2JpbmFyeSc7XG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24nO1xuaW1wb3J0IHsgY2FsbEFsbCB9IGZyb20gJ2xpYjAvZnVuY3Rpb24nO1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0JztcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJztcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lJztcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICdsaWIwL3N0cmluZyc7XG5pbXBvcnQgKiBhcyBpdGVyYXRvciBmcm9tICdsaWIwL2l0ZXJhdG9yJztcbmltcG9ydCAqIGFzIG9iamVjdCBmcm9tICdsaWIwL29iamVjdCc7XG5cbi8qKlxuICogVGhpcyBpcyBhbiBhYnN0cmFjdCBpbnRlcmZhY2UgdGhhdCBhbGwgQ29ubmVjdG9ycyBzaG91bGQgaW1wbGVtZW50IHRvIGtlZXAgdGhlbSBpbnRlcmNoYW5nZWFibGUuXG4gKlxuICogQG5vdGUgVGhpcyBpbnRlcmZhY2UgaXMgZXhwZXJpbWVudGFsIGFuZCBpdCBpcyBub3QgYWR2aXNlZCB0byBhY3R1YWxseSBpbmhlcml0IHRoaXMgY2xhc3MuXG4gKiAgICAgICBJdCBqdXN0IHNlcnZlcyBhcyB0eXBpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8YW55Pn1cbiAqL1xuY2xhc3MgQWJzdHJhY3RDb25uZWN0b3IgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gICAqIEBwYXJhbSB7YW55fSBhd2FyZW5lc3NcbiAgICovXG4gIGNvbnN0cnVjdG9yICh5ZG9jLCBhd2FyZW5lc3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9jID0geWRvYztcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzcztcbiAgfVxufVxuXG5jbGFzcyBEZWxldGVJdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xvY2ssIGxlbikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IGNsb2NrO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSBsZW47XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBubyBsb25nZXIgbWFpbnRhaW4gYSBEZWxldGVTdG9yZS4gRGVsZXRlU2V0IGlzIGEgdGVtcG9yYXJ5IG9iamVjdCB0aGF0IGlzIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKiAtIFdoZW4gY3JlYXRlZCBpbiBhIHRyYW5zYWN0aW9uLCBpdCBtdXN0IG9ubHkgYmUgYWNjZXNzZWQgYWZ0ZXIgc29ydGluZywgYW5kIG1lcmdpbmdcbiAqICAgLSBUaGlzIERlbGV0ZVNldCBpcyBzZW5kIHRvIG90aGVyIGNsaWVudHNcbiAqIC0gV2UgZG8gbm90IGNyZWF0ZSBhIERlbGV0ZVNldCB3aGVuIHdlIHNlbmQgYSBzeW5jIG1lc3NhZ2UuIFRoZSBEZWxldGVTZXQgbWVzc2FnZSBpcyBjcmVhdGVkIGRpcmVjdGx5IGZyb20gU3RydWN0U3RvcmVcbiAqIC0gV2UgcmVhZCBhIERlbGV0ZVNldCBhcyBwYXJ0IG9mIGEgc3luYy91cGRhdGUgbWVzc2FnZS4gSW4gdGhpcyBjYXNlIHRoZSBEZWxldGVTZXQgaXMgYWxyZWFkeSBzb3J0ZWQgYW5kIG1lcmdlZC5cbiAqL1xuY2xhc3MgRGVsZXRlU2V0IHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PERlbGV0ZUl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHN0cnVjdHMgdGhhdCB0aGUgRGVsZXRlU2V0IGdjJ3MuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtmdW5jdGlvbihHQ3xJdGVtKTp2b2lkfSBmXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGl0ZXJhdGVEZWxldGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgZHMsIGYpID0+XG4gIGRzLmNsaWVudHMuZm9yRWFjaCgoZGVsZXRlcywgY2xpZW50aWQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnRpZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsID0gZGVsZXRlc1tpXTtcbiAgICAgIGl0ZXJhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBkZWwuY2xvY2ssIGRlbC5sZW4sIGYpO1xuICAgIH1cbiAgfSk7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVJdGVtPn0gZGlzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZEluZGV4RFMgPSAoZGlzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGRpcy5sZW5ndGggLSAxO1xuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIGNvbnN0IG1pZGluZGV4ID0gbWF0aC5mbG9vcigobGVmdCArIHJpZ2h0KSAvIDIpO1xuICAgIGNvbnN0IG1pZCA9IGRpc1ttaWRpbmRleF07XG4gICAgY29uc3QgbWlkY2xvY2sgPSBtaWQuY2xvY2s7XG4gICAgaWYgKG1pZGNsb2NrIDw9IGNsb2NrKSB7XG4gICAgICBpZiAoY2xvY2sgPCBtaWRjbG9jayArIG1pZC5sZW4pIHtcbiAgICAgICAgcmV0dXJuIG1pZGluZGV4XG4gICAgICB9XG4gICAgICBsZWZ0ID0gbWlkaW5kZXggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByaWdodCA9IG1pZGluZGV4IC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzRGVsZXRlZCA9IChkcywgaWQpID0+IHtcbiAgY29uc3QgZGlzID0gZHMuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIGRpcyAhPT0gdW5kZWZpbmVkICYmIGZpbmRJbmRleERTKGRpcywgaWQuY2xvY2spICE9PSBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgc29ydEFuZE1lcmdlRGVsZXRlU2V0ID0gZHMgPT4ge1xuICBkcy5jbGllbnRzLmZvckVhY2goZGVscyA9PiB7XG4gICAgZGVscy5zb3J0KChhLCBiKSA9PiBhLmNsb2NrIC0gYi5jbG9jayk7XG4gICAgLy8gbWVyZ2UgaXRlbXMgd2l0aG91dCBmaWx0ZXJpbmcgb3Igc3BsaWNpbmcgdGhlIGFycmF5XG4gICAgLy8gaSBpcyB0aGUgY3VycmVudCBwb2ludGVyXG4gICAgLy8gaiByZWZlcnMgdG8gdGhlIGN1cnJlbnQgaW5zZXJ0IHBvc2l0aW9uIGZvciB0aGUgcG9pbnRlZCBpdGVtXG4gICAgLy8gdHJ5IHRvIG1lcmdlIGRlbHNbaV0gaW50byBkZWxzW2otMV0gb3Igc2V0IGRlbHNbal09ZGVsc1tpXVxuICAgIGxldCBpLCBqO1xuICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGVmdCA9IGRlbHNbaiAtIDFdO1xuICAgICAgY29uc3QgcmlnaHQgPSBkZWxzW2ldO1xuICAgICAgaWYgKGxlZnQuY2xvY2sgKyBsZWZ0LmxlbiA+PSByaWdodC5jbG9jaykge1xuICAgICAgICBsZWZ0LmxlbiA9IG1hdGgubWF4KGxlZnQubGVuLCByaWdodC5jbG9jayArIHJpZ2h0LmxlbiAtIGxlZnQuY2xvY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGogPCBpKSB7XG4gICAgICAgICAgZGVsc1tqXSA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICB9XG4gICAgZGVscy5sZW5ndGggPSBqO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVTZXQ+fSBkc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gQSBmcmVzaCBEZWxldGVTZXRcbiAqL1xuY29uc3QgbWVyZ2VEZWxldGVTZXRzID0gZHNzID0+IHtcbiAgY29uc3QgbWVyZ2VkID0gbmV3IERlbGV0ZVNldCgpO1xuICBmb3IgKGxldCBkc3NJID0gMDsgZHNzSSA8IGRzcy5sZW5ndGg7IGRzc0krKykge1xuICAgIGRzc1tkc3NJXS5jbGllbnRzLmZvckVhY2goKGRlbHNMZWZ0LCBjbGllbnQpID0+IHtcbiAgICAgIGlmICghbWVyZ2VkLmNsaWVudHMuaGFzKGNsaWVudCkpIHtcbiAgICAgICAgLy8gV3JpdGUgYWxsIG1pc3Npbmcga2V5cyBmcm9tIGN1cnJlbnQgZHMgYW5kIGFsbCBmb2xsb3dpbmcuXG4gICAgICAgIC8vIElmIG1lcmdlZCBhbHJlYWR5IGNvbnRhaW5zIGBjbGllbnRgIGN1cnJlbnQgZHMgaGFzIGFscmVhZHkgYmVlbiBhZGRlZC5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGRlbHMgPSBkZWxzTGVmdC5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gZHNzSSArIDE7IGkgPCBkc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5hcHBlbmRUbyhkZWxzLCBkc3NbaV0uY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkLmNsaWVudHMuc2V0KGNsaWVudCwgZGVscyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KG1lcmdlZCk7XG4gIHJldHVybiBtZXJnZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZFRvRGVsZXRlU2V0ID0gKGRzLCBjbGllbnQsIGNsb2NrLCBsZW5ndGgpID0+IHtcbiAgbWFwLnNldElmVW5kZWZpbmVkKGRzLmNsaWVudHMsIGNsaWVudCwgKCkgPT4gLyoqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn0gKi8gKFtdKSkucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuZ3RoKSk7XG59O1xuXG5jb25zdCBjcmVhdGVEZWxldGVTZXQgPSAoKSA9PiBuZXcgRGVsZXRlU2V0KCk7XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gTWVyZ2VkIGFuZCBzb3J0ZWQgRGVsZXRlU2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVEZWxldGVTZXRGcm9tU3RydWN0U3RvcmUgPSBzcyA9PiB7XG4gIGNvbnN0IGRzID0gY3JlYXRlRGVsZXRlU2V0KCk7XG4gIHNzLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzaXRlbXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaV07XG4gICAgICBpZiAoc3RydWN0LmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBzdHJ1Y3QuaWQuY2xvY2s7XG4gICAgICAgIGxldCBsZW4gPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgICBpZiAoaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IG5leHQgPSBzdHJ1Y3RzW2kgKyAxXTsgaSArIDEgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBuZXh0LmRlbGV0ZWQ7IG5leHQgPSBzdHJ1Y3RzWysraSArIDFdKSB7XG4gICAgICAgICAgICBsZW4gKz0gbmV4dC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRzaXRlbXMucHVzaChuZXcgRGVsZXRlSXRlbShjbG9jaywgbGVuKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkc2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRzLmNsaWVudHMuc2V0KGNsaWVudCwgZHNpdGVtcyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZURlbGV0ZVNldCA9IChlbmNvZGVyLCBkcykgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgZHMuY2xpZW50cy5zaXplKTtcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgZGVsZXRlIHNldCBpcyB3cml0dGVuIGluIGEgZGV0ZXJtaW5pc3RpYyBvcmRlclxuICBhcnJheS5mcm9tKGRzLmNsaWVudHMuZW50cmllcygpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSlcbiAgICAuZm9yRWFjaCgoW2NsaWVudCwgZHNpdGVtc10pID0+IHtcbiAgICAgIGVuY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsaWVudCk7XG4gICAgICBjb25zdCBsZW4gPSBkc2l0ZW1zLmxlbmd0aDtcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsZW4pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gZHNpdGVtc1tpXTtcbiAgICAgICAgZW5jb2Rlci53cml0ZURzQ2xvY2soaXRlbS5jbG9jayk7XG4gICAgICAgIGVuY29kZXIud3JpdGVEc0xlbihpdGVtLmxlbik7XG4gICAgICB9XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7RGVsZXRlU2V0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZERlbGV0ZVNldCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBkcyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgY29uc3QgbnVtQ2xpZW50cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IG51bWJlck9mRGVsZXRlcyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGlmIChudW1iZXJPZkRlbGV0ZXMgPiAwKSB7XG4gICAgICBjb25zdCBkc0ZpZWxkID0gbWFwLnNldElmVW5kZWZpbmVkKGRzLmNsaWVudHMsIGNsaWVudCwgKCkgPT4gLyoqIEB0eXBlIHtBcnJheTxEZWxldGVJdGVtPn0gKi8gKFtdKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICAgIGRzRmllbGQucHVzaChuZXcgRGVsZXRlSXRlbShkZWNvZGVyLnJlYWREc0Nsb2NrKCksIGRlY29kZXIucmVhZERzTGVuKCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRzXG59O1xuXG4vKipcbiAqIEB0b2RvIFlEZWNvZGVyIGFsc28gY29udGFpbnMgcmVmZXJlbmNlcyB0byBTdHJpbmcgYW5kIG90aGVyIERlY29kZXJzLiBXb3VsZCBtYWtlIHNlbnNlIHRvIGV4Y2hhbmdlIFlEZWNvZGVyLnRvVWludDhBcnJheSBmb3IgWURlY29kZXIuRHNUb1VpbnQ4QXJyYXkoKS4uXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7VWludDhBcnJheXxudWxsfSBSZXR1cm5zIGEgdjIgdXBkYXRlIGNvbnRhaW5pbmcgYWxsIGRlbGV0ZXMgdGhhdCBjb3VsZG4ndCBiZSBhcHBsaWVkIHlldDsgb3IgbnVsbCBpZiBhbGwgZGVsZXRlcyB3ZXJlIGFwcGxpZWQgc3VjY2Vzc2Z1bGx5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZEFuZEFwcGx5RGVsZXRlU2V0ID0gKGRlY29kZXIsIHRyYW5zYWN0aW9uLCBzdG9yZSkgPT4ge1xuICBjb25zdCB1bmFwcGxpZWREUyA9IG5ldyBEZWxldGVTZXQoKTtcbiAgY29uc3QgbnVtQ2xpZW50cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNsaWVudHM7IGkrKykge1xuICAgIGRlY29kZXIucmVzZXREc0N1clZhbCgpO1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IG51bWJlck9mRGVsZXRlcyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IHN0cnVjdHMgPSBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdO1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoc3RvcmUsIGNsaWVudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRlbGV0ZXM7IGkrKykge1xuICAgICAgY29uc3QgY2xvY2sgPSBkZWNvZGVyLnJlYWREc0Nsb2NrKCk7XG4gICAgICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrICsgZGVjb2Rlci5yZWFkRHNMZW4oKTtcbiAgICAgIGlmIChjbG9jayA8IHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgYWRkVG9EZWxldGVTZXQodW5hcHBsaWVkRFMsIGNsaWVudCwgc3RhdGUsIGNsb2NrRW5kIC0gc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGNhbiBpZ25vcmUgdGhlIGNhc2Ugb2YgR0MgYW5kIERlbGV0ZSBzdHJ1Y3RzLCBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byBza2lwIHRoZW1cbiAgICAgICAgICogQHR5cGUge0l0ZW19XG4gICAgICAgICAqL1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGxldCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XTtcbiAgICAgICAgLy8gc3BsaXQgdGhlIGZpcnN0IGl0ZW0gaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQgJiYgc3RydWN0LmlkLmNsb2NrIDwgY2xvY2spIHtcbiAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9jayAtIHN0cnVjdC5pZC5jbG9jaykpO1xuICAgICAgICAgIGluZGV4Kys7IC8vIGluY3JlYXNlIHdlIG5vdyB3YW50IHRvIHVzZSB0aGUgbmV4dCBzdHJ1Y3RcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4KytdO1xuICAgICAgICAgIGlmIChzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9ja0VuZCkge1xuICAgICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCkge1xuICAgICAgICAgICAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXgsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9ja0VuZCAtIHN0cnVjdC5pZC5jbG9jaykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0cnVjdC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkVG9EZWxldGVTZXQodW5hcHBsaWVkRFMsIGNsaWVudCwgY2xvY2ssIGNsb2NrRW5kIC0gY2xvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodW5hcHBsaWVkRFMuY2xpZW50cy5zaXplID4gMCkge1xuICAgIGNvbnN0IGRzID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChkcy5yZXN0RW5jb2RlciwgMCk7IC8vIGVuY29kZSAwIHN0cnVjdHNcbiAgICB3cml0ZURlbGV0ZVNldChkcywgdW5hcHBsaWVkRFMpO1xuICAgIHJldHVybiBkcy50b1VpbnQ4QXJyYXkoKVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBtb2R1bGUgWVxuICovXG5cbmNvbnN0IGdlbmVyYXRlTmV3Q2xpZW50SWQgPSByYW5kb20udWludDMyO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IERvY09wdHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuZ2M9dHJ1ZV0gRGlzYWJsZSBnYXJiYWdlIGNvbGxlY3Rpb24gKGRlZmF1bHQ6IGdjPXRydWUpXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IFtEb2NPcHRzLmdjRmlsdGVyXSBXaWxsIGJlIGNhbGxlZCBiZWZvcmUgYW4gSXRlbSBpcyBnYXJiYWdlIGNvbGxlY3RlZC4gUmV0dXJuIGZhbHNlIHRvIGtlZXAgdGhlIEl0ZW0uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0RvY09wdHMuZ3VpZF0gRGVmaW5lIGEgZ2xvYmFsbHkgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZG9jdW1lbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nIHwgbnVsbH0gW0RvY09wdHMuY29sbGVjdGlvbmlkXSBBc3NvY2lhdGUgdGhpcyBkb2N1bWVudCB3aXRoIGEgY29sbGVjdGlvbi4gVGhpcyBvbmx5IHBsYXlzIGEgcm9sZSBpZiB5b3VyIHByb3ZpZGVyIGhhcyBhIGNvbmNlcHQgb2YgY29sbGVjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7YW55fSBbRG9jT3B0cy5tZXRhXSBBbnkga2luZCBvZiBtZXRhIGluZm9ybWF0aW9uIHlvdSB3YW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgZG9jdW1lbnQuIElmIHRoaXMgaXMgYSBzdWJkb2N1bWVudCwgcmVtb3RlIHBlZXJzIHdpbGwgc3RvcmUgdGhlIG1ldGEgaW5mb3JtYXRpb24gYXMgd2VsbC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuYXV0b0xvYWRdIElmIGEgc3ViZG9jdW1lbnQsIGF1dG9tYXRpY2FsbHkgbG9hZCBkb2N1bWVudC4gSWYgdGhpcyBpcyBhIHN1YmRvY3VtZW50LCByZW1vdGUgcGVlcnMgd2lsbCBsb2FkIHRoZSBkb2N1bWVudCBhcyB3ZWxsIGF1dG9tYXRpY2FsbHkuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtEb2NPcHRzLnNob3VsZExvYWRdIFdoZXRoZXIgdGhlIGRvY3VtZW50IHNob3VsZCBiZSBzeW5jZWQgYnkgdGhlIHByb3ZpZGVyIG5vdy4gVGhpcyBpcyB0b2dnbGVkIHRvIHRydWUgd2hlbiB5b3UgY2FsbCB5ZG9jLmxvYWQoKVxuICovXG5cbi8qKlxuICogQSBZanMgaW5zdGFuY2UgaGFuZGxlcyB0aGUgc3RhdGUgb2Ygc2hhcmVkIGRhdGEuXG4gKiBAZXh0ZW5kcyBPYnNlcnZhYmxlPHN0cmluZz5cbiAqL1xuY2xhc3MgRG9jIGV4dGVuZHMgT2JzZXJ2YWJsZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY09wdHN9IG9wdHMgY29uZmlndXJhdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHsgZ3VpZCA9IHJhbmRvbS51dWlkdjQoKSwgY29sbGVjdGlvbmlkID0gbnVsbCwgZ2MgPSB0cnVlLCBnY0ZpbHRlciA9ICgpID0+IHRydWUsIG1ldGEgPSBudWxsLCBhdXRvTG9hZCA9IGZhbHNlLCBzaG91bGRMb2FkID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2MgPSBnYztcbiAgICB0aGlzLmdjRmlsdGVyID0gZ2NGaWx0ZXI7XG4gICAgdGhpcy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICB0aGlzLmd1aWQgPSBndWlkO1xuICAgIHRoaXMuY29sbGVjdGlvbmlkID0gY29sbGVjdGlvbmlkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBBYnN0cmFjdFR5cGU8WUV2ZW50PGFueT4+Pn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXJlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RydWN0U3RvcmUoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7VHJhbnNhY3Rpb24gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8VHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3RyYW5zYWN0aW9uQ2xlYW51cHMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgZG9jdW1lbnQgaXMgYSBzdWJkb2N1bWVudCAtIGEgZG9jdW1lbnQgaW50ZWdyYXRlZCBpbnRvIGFub3RoZXIgZG9jdW1lbnQgLSB0aGVuIF9pdGVtIGlzIGRlZmluZWQuXG4gICAgICogQHR5cGUge0l0ZW0/fVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIHRoaXMuc2hvdWxkTG9hZCA9IHNob3VsZExvYWQ7XG4gICAgdGhpcy5hdXRvTG9hZCA9IGF1dG9Mb2FkO1xuICAgIHRoaXMubWV0YSA9IG1ldGE7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBzZXQgdG8gdHJ1ZSB3aGVuIHRoZSBwZXJzaXN0ZW5jZSBwcm92aWRlciBsb2FkZWQgdGhlIGRvY3VtZW50IGZyb20gdGhlIGRhdGFiYXNlIG9yIHdoZW4gdGhlIGBzeW5jYCBldmVudCBmaXJlcy5cbiAgICAgKiBOb3RlIHRoYXQgbm90IGFsbCBwcm92aWRlcnMgaW1wbGVtZW50IHRoaXMgZmVhdHVyZS4gUHJvdmlkZXIgYXV0aG9ycyBhcmUgZW5jb3VyYWdlZCB0byBmaXJlIHRoZSBgbG9hZGAgZXZlbnQgd2hlbiB0aGUgZG9jIGNvbnRlbnQgaXMgbG9hZGVkIGZyb20gdGhlIGRhdGFiYXNlLlxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2V0IHRvIHRydWUgd2hlbiB0aGUgY29ubmVjdGlvbiBwcm92aWRlciBoYXMgc3VjY2Vzc2Z1bGx5IHN5bmNlZCB3aXRoIGEgYmFja2VuZC5cbiAgICAgKiBOb3RlIHRoYXQgd2hlbiB1c2luZyBwZWVyLXRvLXBlZXIgcHJvdmlkZXJzIHRoaXMgZXZlbnQgbWF5IG5vdCBwcm92aWRlIHZlcnkgdXNlZnVsLlxuICAgICAqIEFsc28gbm90ZSB0aGF0IG5vdCBhbGwgcHJvdmlkZXJzIGltcGxlbWVudCB0aGlzIGZlYXR1cmUuIFByb3ZpZGVyIGF1dGhvcnMgYXJlIGVuY291cmFnZWQgdG8gZmlyZVxuICAgICAqIHRoZSBgc3luY2AgZXZlbnQgd2hlbiB0aGUgZG9jIGhhcyBiZWVuIHN5bmNlZCAod2l0aCBgdHJ1ZWAgYXMgYSBwYXJhbWV0ZXIpIG9yIGlmIGNvbm5lY3Rpb24gaXNcbiAgICAgKiBsb3N0ICh3aXRoIGZhbHNlIGFzIGEgcGFyYW1ldGVyKS5cbiAgICAgKi9cbiAgICB0aGlzLmlzU3luY2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIGxvYWRlZCBmcm9tIGEgcHJlc2lzdGVuY2UgcHJvdmlkZXIuXG4gICAgICovXG4gICAgdGhpcy53aGVuTG9hZGVkID0gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICB0aGlzLm9uKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVTeW5jZWRQcm9taXNlID0gKCkgPT4gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTeW5jZWRcbiAgICAgICAqL1xuICAgICAgY29uc3QgZXZlbnRIYW5kbGVyID0gKGlzU3luY2VkKSA9PiB7XG4gICAgICAgIGlmIChpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5vZmYoJ3N5bmMnLCBldmVudEhhbmRsZXIpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMub24oJ3N5bmMnLCBldmVudEhhbmRsZXIpO1xuICAgIH0pO1xuICAgIHRoaXMub24oJ3N5bmMnLCBpc1N5bmNlZCA9PiB7XG4gICAgICBpZiAoaXNTeW5jZWQgPT09IGZhbHNlICYmIHRoaXMuaXNTeW5jZWQpIHtcbiAgICAgICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNTeW5jZWQgPSBpc1N5bmNlZCA9PT0gdW5kZWZpbmVkIHx8IGlzU3luY2VkID09PSB0cnVlO1xuICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9hZCcsIFtdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gc3luY2VkIHdpdGggYSBiYWNrZW5kLlxuICAgICAqIFRoaXMgcHJvbWlzZSBpcyByZWNyZWF0ZWQgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBsb3N0LlxuICAgICAqIE5vdGUgdGhlIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlIGBpc1N5bmNlZGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgdGhpcy53aGVuU3luY2VkID0gcHJvdmlkZVN5bmNlZFByb21pc2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCBkb2N1bWVudCB0aGF0IHlvdSByZXF1ZXN0IHRvIGxvYWQgZGF0YSBpbnRvIHRoaXMgc3ViZG9jdW1lbnQgKGlmIGl0IGlzIGEgc3ViZG9jdW1lbnQpLlxuICAgKlxuICAgKiBgbG9hZCgpYCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgdG8gcmVxdWVzdCBhbnkgcHJvdmlkZXIgdG8gbG9hZCB0aGUgbW9zdCBjdXJyZW50IGRhdGEuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gY2FsbCBgbG9hZCgpYCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtO1xuICAgIGlmIChpdGVtICE9PSBudWxsICYmICF0aGlzLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0KC8qKiBAdHlwZSB7YW55fSAqLyAoaXRlbS5wYXJlbnQpLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLnNob3VsZExvYWQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0U3ViZG9jcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ViZG9jc1xuICB9XG5cbiAgZ2V0U3ViZG9jR3VpZHMgKCkge1xuICAgIHJldHVybiBuZXcgU2V0KGFycmF5LmZyb20odGhpcy5zdWJkb2NzKS5tYXAoZG9jID0+IGRvYy5ndWlkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2VzIHRoYXQgaGFwcGVuIGluc2lkZSBvZiBhIHRyYW5zYWN0aW9uIGFyZSBidW5kbGVkLiBUaGlzIG1lYW5zIHRoYXRcbiAgICogdGhlIG9ic2VydmVyIGZpcmVzIF9hZnRlcl8gdGhlIHRyYW5zYWN0aW9uIGlzIGZpbmlzaGVkIGFuZCB0aGF0IGFsbCBjaGFuZ2VzXG4gICAqIHRoYXQgaGFwcGVuZWQgaW5zaWRlIG9mIHRoZSB0cmFuc2FjdGlvbiBhcmUgc2VudCBhcyBvbmUgbWVzc2FnZSB0byB0aGVcbiAgICogb3RoZXIgcGVlcnMuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOlR9IGYgVGhlIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGV4ZWN1dGVkIGFzIGEgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHthbnl9IFtvcmlnaW5dIE9yaWdpbiBvZiB3aG8gc3RhcnRlZCB0aGUgdHJhbnNhY3Rpb24uIFdpbGwgYmUgc3RvcmVkIG9uIHRyYW5zYWN0aW9uLm9yaWdpblxuICAgKiBAcmV0dXJuIFRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdHJhbnNhY3QgKGYsIG9yaWdpbiA9IG51bGwpIHtcbiAgICByZXR1cm4gdHJhbnNhY3QodGhpcywgZiwgb3JpZ2luKVxuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBhIHNoYXJlZCBkYXRhIHR5cGUuXG4gICAqXG4gICAqIE11bHRpcGxlIGNhbGxzIG9mIGB5LmdldChuYW1lLCBUeXBlQ29uc3RydWN0b3IpYCB5aWVsZCB0aGUgc2FtZSByZXN1bHRcbiAgICogYW5kIGRvIG5vdCBvdmVyd3JpdGUgZWFjaCBvdGhlci4gSS5lLlxuICAgKiBgeS5kZWZpbmUobmFtZSwgWS5BcnJheSkgPT09IHkuZGVmaW5lKG5hbWUsIFkuQXJyYXkpYFxuICAgKlxuICAgKiBBZnRlciB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIHRoZSB0eXBlIGlzIGFsc28gYXZhaWxhYmxlIG9uIGB5LnNoYXJlLmdldChuYW1lKWAuXG4gICAqXG4gICAqICpCZXN0IFByYWN0aWNlczoqXG4gICAqIERlZmluZSBhbGwgdHlwZXMgcmlnaHQgYWZ0ZXIgdGhlIFlqcyBpbnN0YW5jZSBpcyBjcmVhdGVkIGFuZCBzdG9yZSB0aGVtIGluIGEgc2VwYXJhdGUgb2JqZWN0LlxuICAgKiBBbHNvIHVzZSB0aGUgdHlwZWQgbWV0aG9kcyBgZ2V0VGV4dChuYW1lKWAsIGBnZXRBcnJheShuYW1lKWAsIC4uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgY29uc3QgeSA9IG5ldyBZKC4uKVxuICAgKiAgIGNvbnN0IGFwcFN0YXRlID0ge1xuICAgKiAgICAgZG9jdW1lbnQ6IHkuZ2V0VGV4dCgnZG9jdW1lbnQnKVxuICAgKiAgICAgY29tbWVudHM6IHkuZ2V0QXJyYXkoJ2NvbW1lbnRzJylcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFR5cGVDb25zdHJ1Y3RvciBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHR5cGUgZGVmaW5pdGlvbi4gRS5nLiBZLlRleHQsIFkuQXJyYXksIFkuTWFwLCAuLi5cbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT59IFRoZSBjcmVhdGVkIHR5cGUuIENvbnN0cnVjdGVkIHdpdGggVHlwZUNvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldCAobmFtZSwgVHlwZUNvbnN0cnVjdG9yID0gQWJzdHJhY3RUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0aGlzLnNoYXJlLCBuYW1lLCAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ID0gbmV3IFR5cGVDb25zdHJ1Y3RvcigpO1xuICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgcmV0dXJuIHRcbiAgICB9KTtcbiAgICBjb25zdCBDb25zdHIgPSB0eXBlLmNvbnN0cnVjdG9yO1xuICAgIGlmIChUeXBlQ29uc3RydWN0b3IgIT09IEFic3RyYWN0VHlwZSAmJiBDb25zdHIgIT09IFR5cGVDb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKENvbnN0ciA9PT0gQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdCA9IG5ldyBUeXBlQ29uc3RydWN0b3IoKTtcbiAgICAgICAgdC5fbWFwID0gdHlwZS5fbWFwO1xuICAgICAgICB0eXBlLl9tYXAuZm9yRWFjaCgvKiogQHBhcmFtIHtJdGVtP30gbiAqLyBuID0+IHtcbiAgICAgICAgICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ubGVmdCkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbi5wYXJlbnQgPSB0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHQuX3N0YXJ0ID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIGZvciAobGV0IG4gPSB0Ll9zdGFydDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IHQ7XG4gICAgICAgIH1cbiAgICAgICAgdC5fbGVuZ3RoID0gdHlwZS5fbGVuZ3RoO1xuICAgICAgICB0aGlzLnNoYXJlLnNldChuYW1lLCB0KTtcbiAgICAgICAgdC5faW50ZWdyYXRlKHRoaXMsIG51bGwpO1xuICAgICAgICByZXR1cm4gdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUeXBlIHdpdGggdGhlIG5hbWUgJHtuYW1lfSBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQgd2l0aCBhIGRpZmZlcmVudCBjb25zdHJ1Y3RvcmApXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEFycmF5IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlBcnJheSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRUZXh0IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlUZXh0KVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WU1hcDxUPn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0TWFwIChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlNYXApXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldFhtbEZyYWdtZW50IChuYW1lID0gJycpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlYbWxGcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZW50aXJlIGRvY3VtZW50IGludG8gYSBqcyBvYmplY3QsIHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgZWFjaCB5anMgdHlwZVxuICAgKiBEb2Vzbid0IGxvZyB0eXBlcyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCAodXNpbmcgeWRvYy5nZXRUeXBlKC4uKSkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgYW5kIHJhdGhlciBjYWxsIHRvSlNPTiBkaXJlY3RseSBvbiB0aGUgc2hhcmVkIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkb2MgPSB7fTtcblxuICAgIHRoaXMuc2hhcmUuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZG9jW2tleV0gPSB2YWx1ZS50b0pTT04oKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGBkZXN0cm95YCBldmVudCBhbmQgdW5yZWdpc3RlciBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBhcnJheS5mcm9tKHRoaXMuc3ViZG9jcykuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSk7XG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW07XG4gICAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgICAgY29uc3QgY29udGVudCA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGl0ZW0uY29udGVudCk7XG4gICAgICBjb250ZW50LmRvYyA9IG5ldyBEb2MoeyBndWlkOiB0aGlzLmd1aWQsIC4uLmNvbnRlbnQub3B0cywgc2hvdWxkTG9hZDogZmFsc2UgfSk7XG4gICAgICBjb250ZW50LmRvYy5faXRlbSA9IGl0ZW07XG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudC5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gY29udGVudC5kb2M7XG4gICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmFkZChkb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NSZW1vdmVkLmFkZCh0aGlzKTtcbiAgICAgIH0sIG51bGwsIHRydWUpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3llZCcsIFt0cnVlXSk7XG4gICAgdGhpcy5lbWl0KCdkZXN0cm95JywgW3RoaXNdKTtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLmFueSk6YW55fSBmXG4gICAqL1xuICBvbiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub24oZXZlbnROYW1lLCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZcbiAgICovXG4gIG9mZiAoZXZlbnROYW1lLCBmKSB7XG4gICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgZik7XG4gIH1cbn1cblxuY2xhc3MgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIHRoaXMucmVzdERlY29kZXIgPSBkZWNvZGVyO1xuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRGVjb2RlclYxIGV4dGVuZHMgRFNEZWNvZGVyVjEge1xuICAvKipcbiAgICogQHJldHVybiB7SUR9XG4gICAqL1xuICByZWFkTGVmdElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZFJpZ2h0SUQgKCkge1xuICAgIHJldHVybiBjcmVhdGVJRChkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSwgZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCB0aGUgbmV4dCBjbGllbnQgaWQuXG4gICAqIFVzZSB0aGlzIGluIGZhdm9yIG9mIHJlYWRJRCB3aGVuZXZlciBwb3NzaWJsZSB0byByZWR1Y2UgdGhlIG51bWJlciBvZiBvYmplY3RzIGNyZWF0ZWQuXG4gICAqL1xuICByZWFkQ2xpZW50ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVWludDgodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkU3RyaW5nICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGlzS2V5XG4gICAqL1xuICByZWFkUGFyZW50SW5mbyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpID09PSAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgcmVhZExlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEFueSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRBbnkodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgcmVhZEJ1ZiAoKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5jb3B5VWludDhBcnJheShkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBMZWdhY3kgaW1wbGVtZW50YXRpb24gdXNlcyBKU09OIHBhcnNlLiBXZSB1c2UgYW55LWRlY29kaW5nIGluIHYyLlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICByZWFkSlNPTiAoKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICByZWFkS2V5ICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFZhclN0cmluZyh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG59XG5cbmNsYXNzIERTRGVjb2RlclYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlcjtcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkRHNDbG9jayAoKSB7XG4gICAgdGhpcy5kc0N1cnJWYWwgKz0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2Rlcik7XG4gICAgcmV0dXJuIHRoaXMuZHNDdXJyVmFsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzTGVuICgpIHtcbiAgICBjb25zdCBkaWZmID0gZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlcikgKyAxO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRpZmY7XG4gICAgcmV0dXJuIGRpZmZcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVEZWNvZGVyVjIgZXh0ZW5kcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgc3VwZXIoZGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBjYWNoZWQga2V5cy4gSWYgdGhlIGtleXNbaWRdIGRvZXMgbm90IGV4aXN0LCB3ZSByZWFkIGEgbmV3IGtleVxuICAgICAqIGZyb20gc3RyaW5nRW5jb2RlciBhbmQgcHVzaCBpdCB0byBrZXlzLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlcik7IC8vIHJlYWQgZmVhdHVyZSBmbGFnIC0gY3VycmVudGx5IHVudXNlZFxuICAgIHRoaXMua2V5Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLmNsaWVudERlY29kZXIgPSBuZXcgZGVjb2RpbmcuVWludE9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpO1xuICAgIHRoaXMubGVmdENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5yaWdodENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5pbmZvRGVjb2RlciA9IG5ldyBkZWNvZGluZy5SbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRGVjb2RlciA9IG5ldyBkZWNvZGluZy5TdHJpbmdEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgICB0aGlzLnBhcmVudEluZm9EZWNvZGVyID0gbmV3IGRlY29kaW5nLlJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIGRlY29kaW5nLnJlYWRVaW50OCk7XG4gICAgdGhpcy50eXBlUmVmRGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSk7XG4gICAgdGhpcy5sZW5EZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5sZWZ0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMucmlnaHRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuaW5mb0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmZvRGVjb2Rlci5yZWFkKCkgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlUmVmRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5EZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgY29uc3Qga2V5Q2xvY2sgPSB0aGlzLmtleUNsb2NrRGVjb2Rlci5yZWFkKCk7XG4gICAgaWYgKGtleUNsb2NrIDwgdGhpcy5rZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5c1trZXlDbG9ja11cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy5zdHJpbmdEZWNvZGVyLnJlYWQoKTtcbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIERTRW5jb2RlclYxIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKCk7XG4gIH1cblxuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcilcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIC8vIG5vcFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgd3JpdGVEc0Nsb2NrIChjbG9jaykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbik7XG4gIH1cbn1cblxuY2xhc3MgVXBkYXRlRW5jb2RlclYxIGV4dGVuZHMgRFNFbmNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlUmlnaHRJRCAoaWQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xpZW50KTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB3cml0ZUNsaWVudCBhbmQgd3JpdGVDbG9jayBpbnN0ZWFkIG9mIHdyaXRlSUQgaWYgcG9zc2libGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAgICovXG4gIHdyaXRlQ2xpZW50IChjbGllbnQpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xpZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpc1lLZXkgPyAxIDogMCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVUeXBlUmVmIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGluZm8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gYW55XG4gICAqL1xuICB3cml0ZUFueSAoYW55KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVBbnkodGhpcy5yZXN0RW5jb2RlciwgYW55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIEpTT04uc3RyaW5naWZ5KGVtYmVkKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIGtleSk7XG4gIH1cbn1cblxuY2xhc3MgRFNFbmNvZGVyVjIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTsgLy8gZW5jb2RlcyBhbGwgdGhlIHJlc3QgLyBub24tb3B0aW1pemVkXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwO1xuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqL1xuICB3cml0ZURzQ2xvY2sgKGNsb2NrKSB7XG4gICAgY29uc3QgZGlmZiA9IGNsb2NrIC0gdGhpcy5kc0N1cnJWYWw7XG4gICAgdGhpcy5kc0N1cnJWYWwgPSBjbG9jaztcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgZGlmZik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbiAtIDEpO1xuICAgIHRoaXMuZHNDdXJyVmFsICs9IGxlbjtcbiAgfVxufVxuXG5jbGFzcyBVcGRhdGVFbmNvZGVyVjIgZXh0ZW5kcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5rZXlNYXAgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogUmVmZXJzIHRvIHRoZSBuZXh0IHVuaXFlIGtleS1pZGVudGlmaWVyIHRvIG1lIHVzZWQuXG4gICAgICogU2VlIHdyaXRlS2V5IG1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5rZXlDbG9jayA9IDA7XG4gICAgdGhpcy5rZXlDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKCk7XG4gICAgdGhpcy5pbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpO1xuICAgIHRoaXMuc3RyaW5nRW5jb2RlciA9IG5ldyBlbmNvZGluZy5TdHJpbmdFbmNvZGVyKCk7XG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpO1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgICB0aGlzLmxlbkVuY29kZXIgPSBuZXcgZW5jb2RpbmcuVWludE9wdFJsZUVuY29kZXIoKTtcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMCk7IC8vIHRoaXMgaXMgYSBmZWF0dXJlIGZsYWcgdGhhdCB3ZSBtaWdodCB1c2UgaW4gdGhlIGZ1dHVyZVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmtleUNsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMuY2xpZW50RW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMubGVmdENsb2NrRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMucmlnaHRDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5pbmZvRW5jb2RlcikpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnN0cmluZ0VuY29kZXIudG9VaW50OEFycmF5KCkpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5wYXJlbnRJbmZvRW5jb2RlcikpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnR5cGVSZWZFbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5FbmNvZGVyLnRvVWludDhBcnJheSgpKTtcbiAgICAvLyBAbm90ZSBUaGUgcmVzdCBlbmNvZGVyIGlzIGFwcGVuZGVkISAobm90ZSB0aGUgbWlzc2luZyB2YXIpXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KGVuY29kZXIsIGVuY29kaW5nLnRvVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyKSk7XG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoaWQuY2xpZW50KTtcbiAgICB0aGlzLmxlZnRDbG9ja0VuY29kZXIud3JpdGUoaWQuY2xvY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGlkLmNsaWVudCk7XG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2Rlci53cml0ZShpZC5jbG9jayk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShjbGllbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlSW5mbyAoaW5mbykge1xuICAgIHRoaXMuaW5mb0VuY29kZXIud3JpdGUoaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNZS2V5XG4gICAqL1xuICB3cml0ZVBhcmVudEluZm8gKGlzWUtleSkge1xuICAgIHRoaXMucGFyZW50SW5mb0VuY29kZXIud3JpdGUoaXNZS2V5ID8gMSA6IDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIHRoaXMudHlwZVJlZkVuY29kZXIud3JpdGUoaW5mbyk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIHRoaXMubGVuRW5jb2Rlci53cml0ZShsZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gICAqL1xuICB3cml0ZUJ1ZiAoYnVmKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIsIGJ1Zik7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBlbWJlZCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvcGVydHkga2V5cyBhcmUgb2Z0ZW4gcmV1c2VkLiBGb3IgZXhhbXBsZSwgaW4geS1wcm9zZW1pcnJvciB0aGUga2V5IGBib2xkYCBtaWdodFxuICAgKiBvY2N1ciB2ZXJ5IG9mdGVuLiBGb3IgYSAzZCBhcHBsaWNhdGlvbiwgdGhlIGtleSBgcG9zaXRpb25gIG1pZ2h0IG9jY3VyIHZlcnkgb2Z0ZW4uXG4gICAqXG4gICAqIFdlIGNhY2hlIHRoZXNlIGtleXMgaW4gYSBNYXAgYW5kIHJlZmVyIHRvIHRoZW0gdmlhIGEgdW5pcXVlIG51bWJlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgd3JpdGVLZXkgKGtleSkge1xuICAgIGNvbnN0IGNsb2NrID0gdGhpcy5rZXlNYXAuZ2V0KGtleSk7XG4gICAgaWYgKGNsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHRvZG8gdW5jb21tZW50IHRvIGludHJvZHVjZSB0aGlzIGZlYXR1cmUgZmluYWxseVxuICAgICAgICpcbiAgICAgICAqIEJhY2tncm91bmQuIFRoZSBDb250ZW50Rm9ybWF0IG9iamVjdCB3YXMgYWx3YXlzIGVuY29kZWQgdXNpbmcgd3JpdGVLZXksIGJ1dCB0aGUgZGVjb2RlciB1c2VkIHRvIHVzZSByZWFkU3RyaW5nLlxuICAgICAgICogRnVydGhlcm1vcmUsIEkgZm9yZ290IHRvIHNldCB0aGUga2V5Y2xvY2suIFNvIGV2ZXJ5dGhpbmcgd2FzIHdvcmtpbmcgZmluZS5cbiAgICAgICAqXG4gICAgICAgKiBIb3dldmVyLCB0aGlzIGZlYXR1cmUgaGVyZSBpcyBiYXNpY2FsbHkgdXNlbGVzcyBhcyBpdCBpcyBub3QgYmVpbmcgdXNlZCAoaXQgYWN0dWFsbHkgb25seSBjb25zdW1lcyBleHRyYSBtZW1vcnkpLlxuICAgICAgICpcbiAgICAgICAqIEkgZG9uJ3Qga25vdyB5ZXQgaG93IHRvIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4uXG4gICAgICAgKlxuICAgICAgICogT2xkZXIgY2xpZW50cyB3b24ndCBiZSBhYmxlIHRvIHJlYWQgdXBkYXRlcyB3aGVuIHdlIHJlaW50cm9kdWNlIHRoaXMgZmVhdHVyZS4gU28gdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgZG9uZSB1c2luZyBhIGZsYWcuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgICAvLyB0aGlzLmtleU1hcC5zZXQoa2V5LCB0aGlzLmtleUNsb2NrKVxuICAgICAgdGhpcy5rZXlDbG9ja0VuY29kZXIud3JpdGUodGhpcy5rZXlDbG9jaysrKTtcbiAgICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUNsb2NrRW5jb2Rlci53cml0ZShjbG9jayk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7QXJyYXk8R0N8SXRlbT59IHN0cnVjdHMgQWxsIHN0cnVjdHMgYnkgYGNsaWVudGBcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB3cml0ZSBzdHJ1Y3RzIHN0YXJ0aW5nIHdpdGggYElEKGNsaWVudCxjbG9jaylgXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlU3RydWN0cyA9IChlbmNvZGVyLCBzdHJ1Y3RzLCBjbGllbnQsIGNsb2NrKSA9PiB7XG4gIC8vIHdyaXRlIGZpcnN0IGlkXG4gIGNsb2NrID0gbWF0aC5tYXgoY2xvY2ssIHN0cnVjdHNbMF0uaWQuY2xvY2spOyAvLyBtYWtlIHN1cmUgdGhlIGZpcnN0IGlkIGV4aXN0c1xuICBjb25zdCBzdGFydE5ld1N0cnVjdHMgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzdHJ1Y3RzLmxlbmd0aCAtIHN0YXJ0TmV3U3RydWN0cyk7XG4gIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKTtcbiAgY29uc3QgZmlyc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0YXJ0TmV3U3RydWN0c107XG4gIC8vIHdyaXRlIGZpcnN0IHN0cnVjdCB3aXRoIGFuIG9mZnNldFxuICBmaXJzdFN0cnVjdC53cml0ZShlbmNvZGVyLCBjbG9jayAtIGZpcnN0U3RydWN0LmlkLmNsb2NrKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TmV3U3RydWN0cyArIDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBfc21cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlQ2xpZW50c1N0cnVjdHMgPSAoZW5jb2Rlciwgc3RvcmUsIF9zbSkgPT4ge1xuICAvLyB3ZSBmaWx0ZXIgYWxsIHZhbGlkIF9zbSBlbnRyaWVzIGludG8gc21cbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIF9zbS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgLy8gb25seSB3cml0ZSBpZiBuZXcgc3RydWN0cyBhcmUgYXZhaWxhYmxlXG4gICAgaWYgKGdldFN0YXRlKHN0b3JlLCBjbGllbnQpID4gY2xvY2spIHtcbiAgICAgIHNtLnNldChjbGllbnQsIGNsb2NrKTtcbiAgICB9XG4gIH0pO1xuICBnZXRTdGF0ZVZlY3RvcihzdG9yZSkuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKTtcbiAgICB9XG4gIH0pO1xuICAvLyB3cml0ZSAjIHN0YXRlcyB0aGF0IHdlcmUgdXBkYXRlZFxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2Rlciwgc20uc2l6ZSk7XG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIGFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdyaXRlU3RydWN0cyhlbmNvZGVyLCBzdG9yZS5jbGllbnRzLmdldChjbGllbnQpLCBjbGllbnQsIGNsb2NrKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIG9iamVjdCB0byByZWFkIGRhdGEgZnJvbS5cbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZENsaWVudHNTdHJ1Y3RSZWZzID0gKGRlY29kZXIsIGRvYykgPT4ge1xuICAvKipcbiAgICogQHR5cGUge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiBBcnJheTxJdGVtIHwgR0M+IH0+fVxuICAgKi9cbiAgY29uc3QgY2xpZW50UmVmcyA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3QgbnVtT2ZTdGF0ZVVwZGF0ZXMgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IHJlZnMgPSBuZXcgQXJyYXkobnVtYmVyT2ZTdHJ1Y3RzKTtcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKTtcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAvLyBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY2xpZW50UmVmcy5zZXQoY2xpZW50LCB7IGk6IDAsIHJlZnMgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKTtcbiAgICAgIHN3aXRjaCAoYmluYXJ5LkJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICAgIGNsb2NrICs9IGxlbjtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKTtcbiAgICAgICAgICByZWZzW2ldID0gbmV3IFNraXAoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbik7XG4gICAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwO1xuICAgICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAgIC8vIGFuZCB3ZSByZWFkIHRoZSBuZXh0IHN0cmluZyBhcyBwYXJlbnRZS2V5LlxuICAgICAgICAgIC8vIEl0IGluZGljYXRlcyBob3cgd2Ugc3RvcmUvcmV0cmlldmUgcGFyZW50IGZyb20gYHkuc2hhcmVgXG4gICAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICAoaW5mbyAmIGJpbmFyeS5CSVQ3KSA9PT0gYmluYXJ5LkJJVDcgPyBkZWNvZGVyLnJlYWRSaWdodElEKCkgOiBudWxsLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkb2MuZ2V0KGRlY29kZXIucmVhZFN0cmluZygpKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0ZFxuICAgICAgICAgICAgb3JpZ2luLCAvLyBvcmlnaW5cbiAgICAgICAgICAgIG51bGwsIC8vIHJpZ2h0XG4gICAgICAgICAgICByaWdodE9yaWdpbiwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gJiYgIWhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRMZWZ0SUQoKSA6IChwYXJlbnRZS2V5ICE9PSBudWxsID8gZG9jLmdldChwYXJlbnRZS2V5KSA6IG51bGwpLCAvLyBwYXJlbnRcbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgICAqL1xuICAgICAgICAgIHJlZnNbaV0gPSBzdHJ1Y3Q7XG4gICAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgfVxuICByZXR1cm4gY2xpZW50UmVmc1xufTtcblxuLyoqXG4gKiBSZXN1bWUgY29tcHV0aW5nIHN0cnVjdHMgZ2VuZXJhdGVkIGJ5IHN0cnVjdCByZWFkZXJzLlxuICpcbiAqIFdoaWxlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbywgd2UgaW50ZWdyYXRlIHN0cnVjdHMgaW4gdGhpcyBvcmRlclxuICogMS4gdG9wIGVsZW1lbnQgb24gc3RhY2ssIGlmIHN0YWNrIGlzIG5vdCBlbXB0eVxuICogMi4gbmV4dCBlbGVtZW50IGZyb20gY3VycmVudCBzdHJ1Y3QgcmVhZGVyIChpZiBlbXB0eSwgdXNlIG5leHQgc3RydWN0IHJlYWRlcilcbiAqXG4gKiBJZiBzdHJ1Y3QgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHN0cnVjdCAocmVmLm1pc3NpbmcpLCB3ZSBwdXQgbmV4dCByZWFkZXIgb2ZcbiAqIGByZWYuaWQuY2xpZW50YCBvbiB0b3Agb2Ygc3RhY2suXG4gKlxuICogQXQgc29tZSBwb2ludCB3ZSBmaW5kIGEgc3RydWN0IHRoYXQgaGFzIG5vIGNhdXNhbCBkZXBlbmRlbmNpZXMsXG4gKiB0aGVuIHdlIHN0YXJ0IGVtcHR5aW5nIHRoZSBzdGFjay5cbiAqXG4gKiBJdCBpcyBub3QgcG9zc2libGUgdG8gaGF2ZSBjaXJjbGVzOiBpLmUuIHN0cnVjdDEgKGZyb20gY2xpZW50MSkgZGVwZW5kcyBvbiBzdHJ1Y3QyIChmcm9tIGNsaWVudDIpXG4gKiBkZXBlbmRzIG9uIHN0cnVjdDMgKGZyb20gY2xpZW50MSkuIFRoZXJlZm9yZSB0aGUgbWF4IHN0YWNrIHNpemUgaXMgZXFhdWwgdG8gYHN0cnVjdFJlYWRlcnMubGVuZ3RoYC5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBpbXBsZW1lbnRlZCBpbiBhIHdheSBzbyB0aGF0IHdlIGNhbiByZXN1bWUgY29tcHV0YXRpb24gaWYgdGhpcyB1cGRhdGVcbiAqIGNhdXNhbGx5IGRlcGVuZHMgb24gYW5vdGhlciB1cGRhdGUuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsIHsgaTogbnVtYmVyLCByZWZzOiAoR0MgfCBJdGVtKVtdIH0+fSBjbGllbnRzU3RydWN0UmVmc1xuICogQHJldHVybiB7IG51bGwgfCB7IHVwZGF0ZTogVWludDhBcnJheSwgbWlzc2luZzogTWFwPG51bWJlcixudW1iZXI+IH0gfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW50ZWdyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RvcmUsIGNsaWVudHNTdHJ1Y3RSZWZzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8SXRlbSB8IEdDPn1cbiAgICovXG4gIGNvbnN0IHN0YWNrID0gW107XG4gIC8vIHNvcnQgdGhlbSBzbyB0aGF0IHdlIHRha2UgdGhlIGhpZ2hlciBpZCBmaXJzdCwgaW4gY2FzZSBvZiBjb25mbGljdHMgdGhlIGxvd2VyIGlkIHdpbGwgcHJvYmFibHkgbm90IGNvbmZsaWN0IHdpdGggdGhlIGlkIGZyb20gdGhlIGhpZ2hlciB1c2VyLlxuICBsZXQgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBhcnJheS5mcm9tKGNsaWVudHNTdHJ1Y3RSZWZzLmtleXMoKSkuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBnZXROZXh0U3RydWN0VGFyZ2V0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSk7XG4gICAgd2hpbGUgKG5leHRTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoID09PSBuZXh0U3RydWN0c1RhcmdldC5pKSB7XG4gICAgICBjbGllbnRzU3RydWN0UmVmc0lkcy5wb3AoKTtcbiAgICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5leHRTdHJ1Y3RzVGFyZ2V0ID0gLyoqIEB0eXBlIHt7aTpudW1iZXIscmVmczpBcnJheTxHQ3xJdGVtPn19ICovIChjbGllbnRzU3RydWN0UmVmcy5nZXQoY2xpZW50c1N0cnVjdFJlZnNJZHNbY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoIC0gMV0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RydWN0c1RhcmdldFxuICB9O1xuICBsZXQgY3VyU3RydWN0c1RhcmdldCA9IGdldE5leHRTdHJ1Y3RUYXJnZXQoKTtcbiAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwgJiYgc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RydWN0U3RvcmV9XG4gICAqL1xuICBjb25zdCByZXN0U3RydWN0cyA9IG5ldyBTdHJ1Y3RTdG9yZSgpO1xuICBjb25zdCBtaXNzaW5nU1YgPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9ja1xuICAgKi9cbiAgY29uc3QgdXBkYXRlTWlzc2luZ1N2ID0gKGNsaWVudCwgY2xvY2spID0+IHtcbiAgICBjb25zdCBtY2xvY2sgPSBtaXNzaW5nU1YuZ2V0KGNsaWVudCk7XG4gICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICBtaXNzaW5nU1Yuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEB0eXBlIHtHQ3xJdGVtfVxuICAgKi9cbiAgbGV0IHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7YW55fSAqLyAoY3VyU3RydWN0c1RhcmdldCkucmVmc1svKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLmkrK107XG4gIC8vIGNhY2hpbmcgdGhlIHN0YXRlIGJlY2F1c2UgaXQgaXMgdXNlZCB2ZXJ5IG9mdGVuXG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0IGFkZFN0YWNrVG9SZXN0U1MgPSAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIHN0YWNrKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSBpdGVtLmlkLmNsaWVudDtcbiAgICAgIGNvbnN0IHVuYXBwbGljYWJsZUl0ZW1zID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudCk7XG4gICAgICBpZiAodW5hcHBsaWNhYmxlSXRlbXMpIHtcbiAgICAgICAgLy8gZGVjcmVtZW50IGJlY2F1c2Ugd2Ugd2VyZW4ndCBhYmxlIHRvIGFwcGx5IHByZXZpb3VzIG9wZXJhdGlvblxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pLS07XG4gICAgICAgIHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2V0KGNsaWVudCwgdW5hcHBsaWNhYmxlSXRlbXMucmVmcy5zbGljZSh1bmFwcGxpY2FibGVJdGVtcy5pKSk7XG4gICAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzLmRlbGV0ZShjbGllbnQpO1xuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pID0gMDtcbiAgICAgICAgdW5hcHBsaWNhYmxlSXRlbXMucmVmcyA9IFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaXRlbSB3YXMgdGhlIGxhc3QgaXRlbSBvbiBjbGllbnRzU3RydWN0UmVmcyBhbmQgdGhlIGZpZWxkIHdhcyBhbHJlYWR5IGNsZWFyZWQuIEFkZCBpdGVtIHRvIHJlc3RTdHJ1Y3RzIGFuZCBjb250aW51ZVxuICAgICAgICByZXN0U3RydWN0cy5jbGllbnRzLnNldChjbGllbnQsIFtpdGVtXSk7XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xpZW50IGZyb20gY2xpZW50c1N0cnVjdFJlZnNJZHMgdG8gcHJldmVudCB1c2VycyBmcm9tIGFwcGx5aW5nIHRoZSBzYW1lIHVwZGF0ZSBhZ2FpblxuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBjbGllbnRzU3RydWN0UmVmc0lkcy5maWx0ZXIoYyA9PiBjICE9PSBjbGllbnQpO1xuICAgIH1cbiAgICBzdGFjay5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0IHJlYWRlcnMgdW50aWwgd2UgYXJlIGRvbmVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoc3RhY2tIZWFkLmNvbnN0cnVjdG9yICE9PSBTa2lwKSB7XG4gICAgICBjb25zdCBsb2NhbENsb2NrID0gbWFwLnNldElmVW5kZWZpbmVkKHN0YXRlLCBzdGFja0hlYWQuaWQuY2xpZW50LCAoKSA9PiBnZXRTdGF0ZShzdG9yZSwgc3RhY2tIZWFkLmlkLmNsaWVudCkpO1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gbG9jYWxDbG9jayAtIHN0YWNrSGVhZC5pZC5jbG9jaztcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBmcm9tIHRoZSBzYW1lIGNsaWVudCBpcyBtaXNzaW5nXG4gICAgICAgIHN0YWNrLnB1c2goc3RhY2tIZWFkKTtcbiAgICAgICAgdXBkYXRlTWlzc2luZ1N2KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayAtIDEpO1xuICAgICAgICAvLyBoaWQgYSBkZWFkIHdhbGwsIGFkZCBhbGwgaXRlbXMgZnJvbSBzdGFjayB0byByZXN0U1NcbiAgICAgICAgYWRkU3RhY2tUb1Jlc3RTUygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IHN0YWNrSGVhZC5nZXRNaXNzaW5nKHRyYW5zYWN0aW9uLCBzdG9yZSk7XG4gICAgICAgIGlmIChtaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpO1xuICAgICAgICAgIC8vIGdldCB0aGUgc3RydWN0IHJlYWRlciB0aGF0IGhhcyB0aGUgbWlzc2luZyBzdHJ1Y3RcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7eyByZWZzOiBBcnJheTxHQ3xJdGVtPiwgaTogbnVtYmVyIH19XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3Qgc3RydWN0UmVmcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldCgvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpKSB8fCB7IHJlZnM6IFtdLCBpOiAwIH07XG4gICAgICAgICAgaWYgKHN0cnVjdFJlZnMucmVmcy5sZW5ndGggPT09IHN0cnVjdFJlZnMuaSkge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgbWVzc2FnZSBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgdXBkYXRlIG1lc3NhZ2UgdGhhdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgICAgICAgICAgdXBkYXRlTWlzc2luZ1N2KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZyksIGdldFN0YXRlKHN0b3JlLCBtaXNzaW5nKSk7XG4gICAgICAgICAgICBhZGRTdGFja1RvUmVzdFNTKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YWNrSGVhZCA9IHN0cnVjdFJlZnMucmVmc1tzdHJ1Y3RSZWZzLmkrK107XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT09IDAgfHwgb2Zmc2V0IDwgc3RhY2tIZWFkLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGFsbCBmaW5lLCBhcHBseSB0aGUgc3RhY2toZWFkXG4gICAgICAgICAgc3RhY2tIZWFkLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgb2Zmc2V0KTtcbiAgICAgICAgICBzdGF0ZS5zZXQoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrICsgc3RhY2tIZWFkLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaXRlcmF0ZSB0byBuZXh0IHN0YWNrSGVhZFxuICAgIGlmIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgfSBlbHNlIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ICE9PSBudWxsICYmIGN1clN0cnVjdHNUYXJnZXQuaSA8IGN1clN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGgpIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpO1xuICAgICAgaWYgKGN1clN0cnVjdHNUYXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gd2UgYXJlIGRvbmUhXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlc3RTdHJ1Y3RzLmNsaWVudHMuc2l6ZSA+IDApIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpO1xuICAgIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgcmVzdFN0cnVjdHMsIG5ldyBNYXAoKSk7XG4gICAgLy8gd3JpdGUgZW1wdHkgZGVsZXRlc2V0XG4gICAgLy8gd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgbmV3IERlbGV0ZVNldCgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCAwKTsgLy8gPT4gbm8gbmVlZCBmb3IgYW4gZXh0cmEgZnVuY3Rpb24gY2FsbCwganVzdCB3cml0ZSAwIGRlbGV0ZXNcbiAgICByZXR1cm4geyBtaXNzaW5nOiBtaXNzaW5nU1YsIHVwZGF0ZTogZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHNGcm9tVHJhbnNhY3Rpb24gPSAoZW5jb2RlciwgdHJhbnNhY3Rpb24pID0+IHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZSk7XG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gZGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBbc3RydWN0RGVjb2Rlcl1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIC8vIGZvcmNlIHRoYXQgdHJhbnNhY3Rpb24ubG9jYWwgaXMgc2V0IHRvIG5vbi1sb2NhbFxuICAgIHRyYW5zYWN0aW9uLmxvY2FsID0gZmFsc2U7XG4gICAgbGV0IHJldHJ5ID0gZmFsc2U7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgIC8vIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgY29uc3Qgc3MgPSByZWFkQ2xpZW50c1N0cnVjdFJlZnMoc3RydWN0RGVjb2RlciwgZG9jKTtcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkIHN0cnVjdHM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBtZXJnZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IHJlc3RTdHJ1Y3RzID0gaW50ZWdyYXRlU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RvcmUsIHNzKTtcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmUucGVuZGluZ1N0cnVjdHM7XG4gICAgaWYgKHBlbmRpbmcpIHtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIGNhbiBhcHBseSBzb21ldGhpbmdcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHBlbmRpbmcubWlzc2luZykge1xuICAgICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICAgIHJldHJ5ID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdFN0cnVjdHMpIHtcbiAgICAgICAgLy8gbWVyZ2UgcmVzdFN0cnVjdHMgaW50byBzdG9yZS5wZW5kaW5nXG4gICAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgY2xvY2tdIG9mIHJlc3RTdHJ1Y3RzLm1pc3NpbmcpIHtcbiAgICAgICAgICBjb25zdCBtY2xvY2sgPSBwZW5kaW5nLm1pc3NpbmcuZ2V0KGNsaWVudCk7XG4gICAgICAgICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICAgICAgICBwZW5kaW5nLm1pc3Npbmcuc2V0KGNsaWVudCwgY2xvY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZW5kaW5nLnVwZGF0ZSA9IG1lcmdlVXBkYXRlc1YyKFtwZW5kaW5nLnVwZGF0ZSwgcmVzdFN0cnVjdHMudXBkYXRlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gcmVzdFN0cnVjdHM7XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGludGVncmF0ZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGRzUmVzdCA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChzdHJ1Y3REZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpO1xuICAgIGlmIChzdG9yZS5wZW5kaW5nRHMpIHtcbiAgICAgIC8vIEB0b2RvIHdlIGNvdWxkIG1ha2UgYSBsb3dlci1ib3VuZCBzdGF0ZS12ZWN0b3IgY2hlY2sgYXMgd2UgZG8gYWJvdmVcbiAgICAgIGNvbnN0IHBlbmRpbmdEU1VwZGF0ZSA9IG5ldyBVcGRhdGVEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihzdG9yZS5wZW5kaW5nRHMpKTtcbiAgICAgIGRlY29kaW5nLnJlYWRWYXJVaW50KHBlbmRpbmdEU1VwZGF0ZS5yZXN0RGVjb2Rlcik7IC8vIHJlYWQgMCBzdHJ1Y3RzLCBiZWNhdXNlIHdlIG9ubHkgZW5jb2RlIGRlbGV0ZXMgaW4gcGVuZGluZ2RzdXBkYXRlXG4gICAgICBjb25zdCBkc1Jlc3QyID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHBlbmRpbmdEU1VwZGF0ZSwgdHJhbnNhY3Rpb24sIHN0b3JlKTtcbiAgICAgIGlmIChkc1Jlc3QgJiYgZHNSZXN0Mikge1xuICAgICAgICAvLyBjYXNlIDE6IGRzMSAhPSBudWxsICYmIGRzMiAhPSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IG1lcmdlVXBkYXRlc1YyKFtkc1Jlc3QsIGRzUmVzdDJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgMjogZHMxICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSAzOiBkczIgIT0gbnVsbFxuICAgICAgICAvLyBjYXNlIDQ6IGRzMSA9PSBudWxsICYmIGRzMiA9PSBudWxsXG4gICAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdCB8fCBkc1Jlc3QyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgZHNSZXN0ID09IG51bGwgJiYgcGVuZGluZ0RzID09IG51bGwgT1IgZHNSZXN0ICE9IG51bGxcbiAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdDtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gY2xlYW51cDogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVzdW1lIGRlbGV0ZSByZWFkZXJzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgaWYgKHJldHJ5KSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSAvKiogQHR5cGUge3t1cGRhdGU6IFVpbnQ4QXJyYXl9fSAqLyAoc3RvcmUucGVuZGluZ1N0cnVjdHMpLnVwZGF0ZTtcbiAgICAgIHN0b3JlLnBlbmRpbmdTdHJ1Y3RzID0gbnVsbDtcbiAgICAgIGFwcGx5VXBkYXRlVjIodHJhbnNhY3Rpb24uZG9jLCB1cGRhdGUpO1xuICAgIH1cbiAgfSwgdHJhbnNhY3Rpb25PcmlnaW4sIGZhbHNlKTtcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBhIGRvY3VtZW50IHVwZGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYGFwcGx5VXBkYXRlYCBidXQgYWNjZXB0cyBhbiBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkVXBkYXRlID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiByZWFkVXBkYXRlVjIoZGVjb2RlciwgeWRvYywgdHJhbnNhY3Rpb25PcmlnaW4sIG5ldyBVcGRhdGVEZWNvZGVyVjEoZGVjb2RlcikpO1xuXG4vKipcbiAqIEFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlIGNyZWF0ZWQgYnksIGZvciBleGFtcGxlLCBgeS5vbigndXBkYXRlJywgdXBkYXRlID0+IC4uKWAgb3IgYHVwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGUoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGByZWFkVXBkYXRlYCBidXQgYWNjZXB0cyBhbiBVaW50OEFycmF5IGluc3RlYWQgb2YgYSBEZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFwcGx5VXBkYXRlVjIgPSAoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKTtcbiAgcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgWURlY29kZXIoZGVjb2RlcikpO1xufTtcblxuLyoqXG4gKiBBcHBseSBhIGRvY3VtZW50IHVwZGF0ZSBjcmVhdGVkIGJ5LCBmb3IgZXhhbXBsZSwgYHkub24oJ3VwZGF0ZScsIHVwZGF0ZSA9PiAuLilgIG9yIGB1cGRhdGUgPSBlbmNvZGVTdGF0ZUFzVXBkYXRlKClgLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSBzYW1lIGVmZmVjdCBhcyBgcmVhZFVwZGF0ZWAgYnV0IGFjY2VwdHMgYW4gVWludDhBcnJheSBpbnN0ZWFkIG9mIGEgRGVjb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0RvY30geWRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhcHBseVVwZGF0ZSA9ICh5ZG9jLCB1cGRhdGUsIHRyYW5zYWN0aW9uT3JpZ2luKSA9PiBhcHBseVVwZGF0ZVYyKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogV3JpdGUgYWxsIHRoZSBkb2N1bWVudCBhcyBhIHNpbmdsZSB1cGRhdGUgbWVzc2FnZS4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVWZWN0b3JgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBbdGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3Qgd3JpdGVTdGF0ZUFzVXBkYXRlID0gKGVuY29kZXIsIGRvYywgdGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgTWFwKCkpID0+IHtcbiAgd3JpdGVDbGllbnRzU3RydWN0cyhlbmNvZGVyLCBkb2Muc3RvcmUsIHRhcmdldFN0YXRlVmVjdG9yKTtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSkpO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhbGwgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlIHRoYXQgY2FuIGJlIGFwcGxpZWQgb24gdGhlIHJlbW90ZSBkb2N1bWVudC4gSWYgeW91IHNwZWNpZnkgdGhlIHN0YXRlIG9mIHRoZSByZW1vdGUgY2xpZW50IChgdGFyZ2V0U3RhdGVgKSBpdCB3aWxsXG4gKiBvbmx5IHdyaXRlIHRoZSBvcGVyYXRpb25zIHRoYXQgYXJlIG1pc3NpbmcuXG4gKlxuICogVXNlIGB3cml0ZVN0YXRlQXNVcGRhdGVgIGluc3RlYWQgaWYgeW91IGFyZSB3b3JraW5nIHdpdGggbGliMC9lbmNvZGluZy5qcyNFbmNvZGVyXG4gKlxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgVWludDhBcnJheShbMF0pLCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpKSA9PiB7XG4gIGNvbnN0IHRhcmdldFN0YXRlVmVjdG9yID0gZGVjb2RlU3RhdGVWZWN0b3IoZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKTtcbiAgd3JpdGVTdGF0ZUFzVXBkYXRlKGVuY29kZXIsIGRvYywgdGFyZ2V0U3RhdGVWZWN0b3IpO1xuICBjb25zdCB1cGRhdGVzID0gW2VuY29kZXIudG9VaW50OEFycmF5KCldO1xuICAvLyBhbHNvIGFkZCB0aGUgcGVuZGluZyB1cGRhdGVzIChpZiB0aGVyZSBhcmUgYW55KVxuICBpZiAoZG9jLnN0b3JlLnBlbmRpbmdEcykge1xuICAgIHVwZGF0ZXMucHVzaChkb2Muc3RvcmUucGVuZGluZ0RzKTtcbiAgfVxuICBpZiAoZG9jLnN0b3JlLnBlbmRpbmdTdHJ1Y3RzKSB7XG4gICAgdXBkYXRlcy5wdXNoKGRpZmZVcGRhdGVWMihkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMudXBkYXRlLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpKTtcbiAgfVxuICBpZiAodXBkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMSkge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlcyh1cGRhdGVzLm1hcCgodXBkYXRlLCBpKSA9PiBpID09PSAwID8gdXBkYXRlIDogY29udmVydFVwZGF0ZUZvcm1hdFYyVG9WMSh1cGRhdGUpKSlcbiAgICB9IGVsc2UgaWYgKGVuY29kZXIuY29uc3RydWN0b3IgPT09IFVwZGF0ZUVuY29kZXJWMikge1xuICAgICAgcmV0dXJuIG1lcmdlVXBkYXRlc1YyKHVwZGF0ZXMpXG4gICAgfVxuICB9XG4gIHJldHVybiB1cGRhdGVzWzBdXG59O1xuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlQXNVcGRhdGUgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IpID0+IGVuY29kZVN0YXRlQXNVcGRhdGVWMihkb2MsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvciwgbmV3IFVwZGF0ZUVuY29kZXJWMSgpKTtcblxuLyoqXG4gKiBSZWFkIHN0YXRlIHZlY3RvciBmcm9tIERlY29kZXIgYW5kIHJldHVybiBhcyBNYXBcbiAqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkU3RhdGVWZWN0b3IgPSBkZWNvZGVyID0+IHtcbiAgY29uc3Qgc3MgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHNzTGVuZ3RoID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3NMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgc3Muc2V0KGNsaWVudCwgY2xvY2spO1xuICB9XG4gIHJldHVybiBzc1xufTtcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBkZWNvZGVTdGF0ZVZlY3RvclYyID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjIoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSlcblxuLyoqXG4gKiBSZWFkIGRlY29kZWRTdGF0ZSBhbmQgcmV0dXJuIFN0YXRlIGFzIE1hcC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRlY29kZWRTdGF0ZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fSBNYXBzIGBjbGllbnRgIHRvIHRoZSBudW1iZXIgbmV4dCBleHBlY3RlZCBgY2xvY2tgIGZyb20gdGhhdCBjbGllbnQuXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGRlY29kZVN0YXRlVmVjdG9yID0gZGVjb2RlZFN0YXRlID0+IHJlYWRTdGF0ZVZlY3RvcihuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihkZWNvZGVkU3RhdGUpKSk7XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc3ZcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0YXRlVmVjdG9yID0gKGVuY29kZXIsIHN2KSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBzdi5zaXplKTtcbiAgYXJyYXkuZnJvbShzdi5lbnRyaWVzKCkpLnNvcnQoKGEsIGIpID0+IGJbMF0gLSBhWzBdKS5mb3JFYWNoKChbY2xpZW50LCBjbG9ja10pID0+IHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KTsgLy8gQHRvZG8gdXNlIGEgc3BlY2lhbCBjbGllbnQgZGVjb2RlciB0aGF0IGlzIGJhc2VkIG9uIG1hcHBpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spO1xuICB9KTtcbiAgcmV0dXJuIGVuY29kZXJcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHdyaXRlRG9jdW1lbnRTdGF0ZVZlY3RvciA9IChlbmNvZGVyLCBkb2MpID0+IHdyaXRlU3RhdGVWZWN0b3IoZW5jb2RlciwgZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKSk7XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvclYyID0gKGRvYywgZW5jb2RlciA9IG5ldyBEU0VuY29kZXJWMigpKSA9PiB7XG4gIGlmIChkb2MgaW5zdGFuY2VvZiBNYXApIHtcbiAgICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYyk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGVuY29kZVN0YXRlVmVjdG9yID0gZG9jID0+IGVuY29kZVN0YXRlVmVjdG9yVjIoZG9jLCBuZXcgRFNFbmNvZGVyVjEoKSk7XG5cbi8qKlxuICogR2VuZXJhbCBldmVudCBoYW5kbGVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLCBBUkcxXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihBUkcwLCBBUkcxKTp2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLmwgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEByZXR1cm5zIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUV2ZW50SGFuZGxlciA9ICgpID0+IG5ldyBFdmVudEhhbmRsZXIoKTtcblxuLyoqXG4gKiBBZGRzIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaXMgY2FsbGVkIHdoZW5cbiAqIHtAbGluayBFdmVudEhhbmRsZXIjY2FsbEV2ZW50TGlzdGVuZXJzfSBpcyBjYWxsZWQuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT5cbiAgZXZlbnRIYW5kbGVyLmwucHVzaChmKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtmdW5jdGlvbihBUkcwLEFSRzEpOnZvaWR9IGYgVGhlIGV2ZW50IGhhbmRsZXIgdGhhdCB3YXMgYWRkZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciA9IChldmVudEhhbmRsZXIsIGYpID0+IHtcbiAgY29uc3QgbCA9IGV2ZW50SGFuZGxlci5sO1xuICBjb25zdCBsZW4gPSBsLmxlbmd0aDtcbiAgZXZlbnRIYW5kbGVyLmwgPSBsLmZpbHRlcihnID0+IGYgIT09IGcpO1xuICBpZiAobGVuID09PSBldmVudEhhbmRsZXIubC5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbeWpzXSBUcmllZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlciB0aGF0IGRvZXNuXFwndCBleGlzdC4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGFsbCBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkIHZpYVxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNhZGRFdmVudExpc3RlbmVyfS5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7QVJHMH0gYXJnMFxuICogQHBhcmFtIHtBUkcxfSBhcmcxXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzID0gKGV2ZW50SGFuZGxlciwgYXJnMCwgYXJnMSkgPT5cbiAgZi5jYWxsQWxsKGV2ZW50SGFuZGxlci5sLCBbYXJnMCwgYXJnMV0pO1xuXG5jbGFzcyBJRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50IGNsaWVudCBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY2xpZW50LCBjbG9jaykge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgLyoqXG4gICAgICogdW5pcXVlIHBlciBjbGllbnQgaWQsIGNvbnRpbnVvdXMgbnVtYmVyXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2s7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYVxuICogQHBhcmFtIHtJRCB8IG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNvbXBhcmVJRHMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuY2xpZW50ID09PSBiLmNsaWVudCAmJiBhLmNsb2NrID09PSBiLmNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUlEID0gKGNsaWVudCwgY2xvY2spID0+IG5ldyBJRChjbGllbnQsIGNsb2NrKTtcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZUlEID0gKGVuY29kZXIsIGlkKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBpZC5jbGllbnQpO1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xvY2spO1xufTtcblxuLyoqXG4gKiBSZWFkIElELlxuICogKiBJZiBmaXJzdCB2YXJVaW50IHJlYWQgaXMgMHhGRkZGRkYgYSBSb290SUQgaXMgcmV0dXJuZWQuXG4gKiAqIE90aGVyd2lzZSBhbiBJRCBpcyByZXR1cm5lZFxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7SUR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkSUQgPSBkZWNvZGVyID0+XG4gIGNyZWF0ZUlEKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpLCBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSk7XG5cbi8qKlxuICogVGhlIHRvcCB0eXBlcyBhcmUgbWFwcGVkIGZyb20geS5zaGFyZS5nZXQoa2V5bmFtZSkgPT4gdHlwZS5cbiAqIGB0eXBlYCBkb2VzIG5vdCBzdG9yZSBhbnkgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGBrZXluYW1lYC5cbiAqIFRoaXMgZnVuY3Rpb24gZmluZHMgdGhlIGNvcnJlY3QgYGtleW5hbWVgIGZvciBgdHlwZWAgYW5kIHRocm93cyBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFJvb3RUeXBlS2V5ID0gdHlwZSA9PiB7XG4gIC8vIEB0cy1pZ25vcmUgX3kgbXVzdCBiZSBkZWZpbmVkLCBvdGhlcndpc2UgdW5leHBlY3RlZCBjYXNlXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHR5cGUuZG9jLnNoYXJlLmVudHJpZXMoKSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuIGtleVxuICAgIH1cbiAgfVxuICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY2hpbGRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgYHBhcmVudGAgaXMgYSBwYXJlbnQgb2YgYGNoaWxkYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzUGFyZW50T2YgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoY2hpbGQucGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNoaWxkID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGNoaWxkLnBhcmVudCkuX2l0ZW07XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIENvbnZlbmllbnQgaGVscGVyIHRvIGxvZyB0eXBlIGluZm9ybWF0aW9uLlxuICpcbiAqIERvIG5vdCB1c2UgaW4gcHJvZHVjdGl2ZSBzeXN0ZW1zIGFzIHRoZSBvdXRwdXQgY2FuIGJlIGltbWVuc2UhXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICovXG5jb25zdCBsb2dUeXBlID0gdHlwZSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobikge1xuICAgIHJlcy5wdXNoKG4pO1xuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGNvbnNvbGUubG9nKCdDaGlsZHJlbjogJywgcmVzKTtcbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuIGNvbnRlbnQ6ICcsIHJlcy5maWx0ZXIobSA9PiAhbS5kZWxldGVkKS5tYXAobSA9PiBtLmNvbnRlbnQpKTtcbn07XG5cbmNsYXNzIFBlcm1hbmVudFVzZXJEYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtZTWFwPGFueT59IFtzdG9yZVR5cGVdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBzdG9yZVR5cGUgPSBkb2MuZ2V0TWFwKCd1c2VycycpKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsRGVsZXRlU2V0Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkc3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy55dXNlcnMgPSBzdG9yZVR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudGlkIHRvIHVzZXJEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kc3MgPSBkc3M7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtZTWFwPGFueT59IHVzZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgY29uc3QgaW5pdFVzZXIgPSAodXNlciwgdXNlckRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtZQXJyYXk8VWludDhBcnJheT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICBjb25zdCBpZHMgPSB1c2VyLmdldCgnaWRzJyk7XG4gICAgICBjb25zdCBhZGRDbGllbnRJZCA9IC8qKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWQgKi8gY2xpZW50aWQgPT4gdGhpcy5jbGllbnRzLnNldChjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uKTtcbiAgICAgIGRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT4ge1xuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGVuY29kZWREcyA9PiB7XG4gICAgICAgICAgICBpZiAoZW5jb2RlZERzIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICB0aGlzLmRzcy5zZXQodXNlckRlc2NyaXB0aW9uLCBtZXJnZURlbGV0ZVNldHMoW3RoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pIHx8IGNyZWF0ZURlbGV0ZVNldCgpLCByZWFkRGVsZXRlU2V0KG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGVuY29kZWREcykpKV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhkcy5tYXAoZW5jb2RlZERzID0+IHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpKSkpO1xuICAgICAgaWRzLm9ic2VydmUoLyoqIEBwYXJhbSB7WUFycmF5RXZlbnQ8YW55Pn0gZXZlbnQgKi8gZXZlbnQgPT5cbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKS5mb3JFYWNoKGFkZENsaWVudElkKSlcbiAgICAgICk7XG4gICAgICBpZHMuZm9yRWFjaChhZGRDbGllbnRJZCk7XG4gICAgfTtcbiAgICAvLyBvYnNlcnZlIHVzZXJzXG4gICAgc3RvcmVUeXBlLm9ic2VydmUoZXZlbnQgPT4ge1xuICAgICAgZXZlbnQua2V5c0NoYW5nZWQuZm9yRWFjaCh1c2VyRGVzY3JpcHRpb24gPT5cbiAgICAgICAgaW5pdFVzZXIoc3RvcmVUeXBlLmdldCh1c2VyRGVzY3JpcHRpb24pLCB1c2VyRGVzY3JpcHRpb24pXG4gICAgICApO1xuICAgIH0pO1xuICAgIC8vIGFkZCBpbnRpYWwgZGF0YVxuICAgIHN0b3JlVHlwZS5mb3JFYWNoKGluaXRVc2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlckRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25mXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERlbGV0ZVNldCk6Ym9vbGVhbn0gW2NvbmYuZmlsdGVyXVxuICAgKi9cbiAgc2V0VXNlck1hcHBpbmcgKGRvYywgY2xpZW50aWQsIHVzZXJEZXNjcmlwdGlvbiwgeyBmaWx0ZXIgPSAoKSA9PiB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHVzZXJzID0gdGhpcy55dXNlcnM7XG4gICAgbGV0IHVzZXIgPSB1c2Vycy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHVzZXIgPSBuZXcgWU1hcCgpO1xuICAgICAgdXNlci5zZXQoJ2lkcycsIG5ldyBZQXJyYXkoKSk7XG4gICAgICB1c2VyLnNldCgnZHMnLCBuZXcgWUFycmF5KCkpO1xuICAgICAgdXNlcnMuc2V0KHVzZXJEZXNjcmlwdGlvbiwgdXNlcik7XG4gICAgfVxuICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pO1xuICAgIHVzZXJzLm9ic2VydmUoX2V2ZW50ID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zdCB1c2VyT3ZlcndyaXRlID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh1c2VyT3ZlcndyaXRlICE9PSB1c2VyKSB7XG4gICAgICAgICAgLy8gdXNlciB3YXMgb3ZlcndyaXR0ZW4sIHBvcnQgYWxsIGRhdGEgb3ZlciB0byB0aGUgbmV4dCB1c2VyIG9iamVjdFxuICAgICAgICAgIC8vIEB0b2RvIEV4cGVyaW1lbnQgd2l0aCBZLlNldHMgaGVyZVxuICAgICAgICAgIHVzZXIgPSB1c2VyT3ZlcndyaXRlO1xuICAgICAgICAgIC8vIEB0b2RvIGl0ZXJhdGUgb3ZlciBvbGQgdHlwZVxuICAgICAgICAgIHRoaXMuY2xpZW50cy5mb3JFYWNoKChfdXNlckRlc2NyaXB0aW9uLCBjbGllbnRpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHVzZXJEZXNjcmlwdGlvbiA9PT0gX3VzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICB1c2VyLmdldCgnaWRzJykucHVzaChbY2xpZW50aWRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKCk7XG4gICAgICAgICAgY29uc3QgZHMgPSB0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKTtcbiAgICAgICAgICBpZiAoZHMpIHtcbiAgICAgICAgICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgICAgICAgICAgIHVzZXIuZ2V0KCdkcycpLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH0pO1xuICAgIGRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIC8qKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAqLyB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeWRzID0gdXNlci5nZXQoJ2RzJyk7XG4gICAgICAgIGNvbnN0IGRzID0gdHJhbnNhY3Rpb24uZGVsZXRlU2V0O1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24ubG9jYWwgJiYgZHMuY2xpZW50cy5zaXplID4gMCAmJiBmaWx0ZXIodHJhbnNhY3Rpb24sIGRzKSkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjEoKTtcbiAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcyk7XG4gICAgICAgICAgeWRzLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldFVzZXJCeUNsaWVudElkIChjbGllbnRpZCkge1xuICAgIHJldHVybiB0aGlzLmNsaWVudHMuZ2V0KGNsaWVudGlkKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHJldHVybiB7c3RyaW5nIHwgbnVsbH1cbiAgICovXG4gIGdldFVzZXJCeURlbGV0ZWRJZCAoaWQpIHtcbiAgICBmb3IgKGNvbnN0IFt1c2VyRGVzY3JpcHRpb24sIGRzXSBvZiB0aGlzLmRzcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChpc0RlbGV0ZWQoZHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gdXNlckRlc2NyaXB0aW9uXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBBIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGJhc2VkIG9uIHRoZSBZanMgbW9kZWwgYW5kIGlzIG5vdCBhZmZlY3RlZCBieSBkb2N1bWVudCBjaGFuZ2VzLlxuICogRS5nLiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBiZWZvcmUgYSBjZXJ0YWluIGNoYXJhY3RlciwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhpcyBjaGFyYWN0ZXIuXG4gKiBJZiB5b3UgcGxhY2UgYSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIGEgdHlwZSwgaXQgd2lsbCBhbHdheXMgcG9pbnQgdG8gdGhlIGVuZCBvZiB0aGUgdHlwZS5cbiAqXG4gKiBBIG51bWVyaWMgcG9zaXRpb24gaXMgb2Z0ZW4gdW5zdWl0ZWQgZm9yIHVzZXIgc2VsZWN0aW9ucywgYmVjYXVzZSBpdCBkb2VzIG5vdCBjaGFuZ2Ugd2hlbiBjb250ZW50IGlzIGluc2VydGVkXG4gKiBiZWZvcmUgb3IgYWZ0ZXIuXG4gKlxuICogYGBgSW5zZXJ0KDAsICd4JykoJ2F8YmMnKSA9ICd4YXxiYydgYGAgV2hlcmUgfCBpcyB0aGUgcmVsYXRpdmUgcG9zaXRpb24uXG4gKlxuICogT25lIG9mIHRoZSBwcm9wZXJ0aWVzIG11c3QgYmUgZGVmaW5lZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogICAvLyBDdXJyZW50IGN1cnNvciBwb3NpdGlvbiBpcyBhdCBwb3NpdGlvbiAxMFxuICogICBjb25zdCByZWxhdGl2ZVBvc2l0aW9uID0gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21JbmRleCh5VGV4dCwgMTApXG4gKiAgIC8vIG1vZGlmeSB5VGV4dFxuICogICB5VGV4dC5pbnNlcnQoMCwgJ2FiYycpXG4gKiAgIHlUZXh0LmRlbGV0ZSgzLCAxMClcbiAqICAgLy8gQ29tcHV0ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gKiAgIGNvbnN0IGFic29sdXRlUG9zaXRpb24gPSBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oeSwgcmVsYXRpdmVQb3NpdGlvbilcbiAqICAgYWJzb2x1dGVQb3NpdGlvbi50eXBlID09PSB5VGV4dCAvLyA9PiB0cnVlXG4gKiAgIGNvbnNvbGUubG9nKCdjdXJzb3IgbG9jYXRpb24gaXMgJyArIGFic29sdXRlUG9zaXRpb24uaW5kZXgpIC8vID0+IGN1cnNvciBsb2NhdGlvbiBpcyAzXG4gKlxuICovXG5jbGFzcyBSZWxhdGl2ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0bmFtZVxuICAgKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzc29jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMudG5hbWUgPSB0bmFtZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMuaXRlbSA9IGl0ZW07XG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgY2hhcmFjdGVyLiBCeSBkZWZhdWx0XG4gICAgICogYXNzb2MgPj0gMCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGFmdGVyIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKiBJLmUuIHBvc2l0aW9uIDEgaW4gJ2FiJyBpcyBhc3NvY2lhdGVkIHRvIGNoYXJhY3RlciAnYicuXG4gICAgICpcbiAgICAgKiBJZiBhc3NvYyA8IDAsIHRoZW4gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNhaGFyYWN0ZXJcbiAgICAgKiBiZWZvcmUgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFzc29jID0gYXNzb2M7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuY29uc3QgcmVsYXRpdmVQb3NpdGlvblRvSlNPTiA9IHJwb3MgPT4ge1xuICBjb25zdCBqc29uID0ge307XG4gIGlmIChycG9zLnR5cGUpIHtcbiAgICBqc29uLnR5cGUgPSBycG9zLnR5cGU7XG4gIH1cbiAgaWYgKHJwb3MudG5hbWUpIHtcbiAgICBqc29uLnRuYW1lID0gcnBvcy50bmFtZTtcbiAgfVxuICBpZiAocnBvcy5pdGVtKSB7XG4gICAganNvbi5pdGVtID0gcnBvcy5pdGVtO1xuICB9XG4gIGlmIChycG9zLmFzc29jICE9IG51bGwpIHtcbiAgICBqc29uLmFzc29jID0gcnBvcy5hc3NvYztcbiAgfVxuICByZXR1cm4ganNvblxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OID0ganNvbiA9PiBuZXcgUmVsYXRpdmVQb3NpdGlvbihqc29uLnR5cGUgPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLnR5cGUuY2xpZW50LCBqc29uLnR5cGUuY2xvY2spLCBqc29uLnRuYW1lIHx8IG51bGwsIGpzb24uaXRlbSA9PSBudWxsID8gbnVsbCA6IGNyZWF0ZUlEKGpzb24uaXRlbS5jbGllbnQsIGpzb24uaXRlbS5jbG9jayksIGpzb24uYXNzb2MgPT0gbnVsbCA/IDAgOiBqc29uLmFzc29jKTtcblxuY2xhc3MgQWJzb2x1dGVQb3NpdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHR5cGUsIGluZGV4LCBhc3NvYyA9IDApIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmFzc29jID0gYXNzb2M7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZUFic29sdXRlUG9zaXRpb24gPSAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkgPT4gbmV3IEFic29sdXRlUG9zaXRpb24odHlwZSwgaW5kZXgsIGFzc29jKTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24gPSAodHlwZSwgaXRlbSwgYXNzb2MpID0+IHtcbiAgbGV0IHR5cGVpZCA9IG51bGw7XG4gIGxldCB0bmFtZSA9IG51bGw7XG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBmaW5kUm9vdFR5cGVLZXkodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdHlwZWlkID0gY3JlYXRlSUQodHlwZS5faXRlbS5pZC5jbGllbnQsIHR5cGUuX2l0ZW0uaWQuY2xvY2spO1xuICB9XG4gIHJldHVybiBuZXcgUmVsYXRpdmVQb3NpdGlvbih0eXBlaWQsIHRuYW1lLCBpdGVtLCBhc3NvYylcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVsYXRpdmVQb3NpdGlvbiBiYXNlZCBvbiBhIGFic29sdXRlIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGUgVGhlIGJhc2UgdHlwZSAoZS5nLiBZVGV4dCBvciBZQXJyYXkpLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiB7XG4gIGxldCB0ID0gdHlwZS5fc3RhcnQ7XG4gIGlmIChhc3NvYyA8IDApIHtcbiAgICAvLyBhc3NvY2lhdGVkIHRvIHRoZSBsZWZ0IGNoYXJhY3RlciBvciB0aGUgYmVnaW5uaW5nIG9mIGEgdHlwZSwgaW5jcmVtZW50IGluZGV4IGlmIHBvc3NpYmxlLlxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG4gICAgfVxuICAgIGluZGV4LS07XG4gIH1cbiAgd2hpbGUgKHQgIT09IG51bGwpIHtcbiAgICBpZiAoIXQuZGVsZXRlZCAmJiB0LmNvdW50YWJsZSkge1xuICAgICAgaWYgKHQubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICAgIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIGNyZWF0ZUlEKHQuaWQuY2xpZW50LCB0LmlkLmNsb2NrICsgaW5kZXgpLCBhc3NvYylcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IHQubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodC5yaWdodCA9PT0gbnVsbCAmJiBhc3NvYyA8IDApIHtcbiAgICAgIC8vIGxlZnQtYXNzb2NpYXRlZCBwb3NpdGlvbiwgcmV0dXJuIGxhc3QgYXZhaWxhYmxlIGlkXG4gICAgICByZXR1cm4gY3JlYXRlUmVsYXRpdmVQb3NpdGlvbih0eXBlLCB0Lmxhc3RJZCwgYXNzb2MpXG4gICAgfVxuICAgIHQgPSB0LnJpZ2h0O1xuICB9XG4gIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG51bGwsIGFzc29jKVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVJlbGF0aXZlUG9zaXRpb24gPSAoZW5jb2RlciwgcnBvcykgPT4ge1xuICBjb25zdCB7IHR5cGUsIHRuYW1lLCBpdGVtLCBhc3NvYyB9ID0gcnBvcztcbiAgaWYgKGl0ZW0gIT09IG51bGwpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgMCk7XG4gICAgd3JpdGVJRChlbmNvZGVyLCBpdGVtKTtcbiAgfSBlbHNlIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlciwgMSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgdG5hbWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAvLyBjYXNlIDM6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgYXR0YWNoZWQgdG8gYW4gaXRlbVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlciwgMik7XG4gICAgd3JpdGVJRChlbmNvZGVyLCB0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gIH1cbiAgZW5jb2Rpbmcud3JpdGVWYXJJbnQoZW5jb2RlciwgYXNzb2MpO1xuICByZXR1cm4gZW5jb2RlclxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVJlbGF0aXZlUG9zaXRpb24gPSBycG9zID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTtcbiAgd3JpdGVSZWxhdGl2ZVBvc2l0aW9uKGVuY29kZXIsIHJwb3MpO1xuICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFJlbGF0aXZlUG9zaXRpb24gPSBkZWNvZGVyID0+IHtcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgdG5hbWUgPSBudWxsO1xuICBsZXQgaXRlbUlEID0gbnVsbDtcbiAgc3dpdGNoIChkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKSkge1xuICAgIGNhc2UgMDpcbiAgICAgIC8vIGNhc2UgMTogZm91bmQgcG9zaXRpb24gc29tZXdoZXJlIGluIHRoZSBsaW5rZWQgbGlzdFxuICAgICAgaXRlbUlEID0gcmVhZElEKGRlY29kZXIpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDE6XG4gICAgICAvLyBjYXNlIDI6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgc3RvcmVkIGluIHkuc2hhcmVcbiAgICAgIHRuYW1lID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOiB7XG4gICAgICAvLyBjYXNlIDM6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgYXR0YWNoZWQgdG8gYW4gaXRlbVxuICAgICAgdHlwZSA9IHJlYWRJRChkZWNvZGVyKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXNzb2MgPSBkZWNvZGluZy5oYXNDb250ZW50KGRlY29kZXIpID8gZGVjb2RpbmcucmVhZFZhckludChkZWNvZGVyKSA6IDA7XG4gIHJldHVybiBuZXcgUmVsYXRpdmVQb3NpdGlvbih0eXBlLCB0bmFtZSwgaXRlbUlELCBhc3NvYylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICovXG5jb25zdCBkZWNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gdWludDhBcnJheSA9PiByZWFkUmVsYXRpdmVQb3NpdGlvbihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVpbnQ4QXJyYXkpKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEByZXR1cm4ge0Fic29sdXRlUG9zaXRpb258bnVsbH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uID0gKHJwb3MsIGRvYykgPT4ge1xuICBjb25zdCBzdG9yZSA9IGRvYy5zdG9yZTtcbiAgY29uc3QgcmlnaHRJRCA9IHJwb3MuaXRlbTtcbiAgY29uc3QgdHlwZUlEID0gcnBvcy50eXBlO1xuICBjb25zdCB0bmFtZSA9IHJwb3MudG5hbWU7XG4gIGNvbnN0IGFzc29jID0gcnBvcy5hc3NvYztcbiAgbGV0IHR5cGUgPSBudWxsO1xuICBsZXQgaW5kZXggPSAwO1xuICBpZiAocmlnaHRJRCAhPT0gbnVsbCkge1xuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgcmlnaHRJRC5jbGllbnQpIDw9IHJpZ2h0SUQuY2xvY2spIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IGZvbGxvd1JlZG9uZShzdG9yZSwgcmlnaHRJRCk7XG4gICAgY29uc3QgcmlnaHQgPSByZXMuaXRlbTtcbiAgICBpZiAoIShyaWdodCBpbnN0YW5jZW9mIEl0ZW0pKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0LnBhcmVudCk7XG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgaW5kZXggPSAocmlnaHQuZGVsZXRlZCB8fCAhcmlnaHQuY291bnRhYmxlKSA/IDAgOiAocmVzLmRpZmYgKyAoYXNzb2MgPj0gMCA/IDAgOiAxKSk7IC8vIGFkanVzdCBwb3NpdGlvbiBiYXNlZCBvbiBsZWZ0IGFzc29jaWF0aW9uIGlmIG5lY2Vzc2FyeVxuICAgICAgbGV0IG4gPSByaWdodC5sZWZ0O1xuICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgICAgICBpbmRleCArPSBuLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5sZWZ0O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodG5hbWUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBkb2MuZ2V0KHRuYW1lKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVJRCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGdldFN0YXRlKHN0b3JlLCB0eXBlSUQuY2xpZW50KSA8PSB0eXBlSUQuY2xvY2spIHtcbiAgICAgICAgLy8gdHlwZSBkb2VzIG5vdCBleGlzdCB5ZXRcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgaXRlbSB9ID0gZm9sbG93UmVkb25lKHN0b3JlLCB0eXBlSUQpO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIGl0ZW0uY29udGVudCBpbnN0YW5jZW9mIENvbnRlbnRUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLmNvbnRlbnQudHlwZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHN0cnVjdCBpcyBnYXJiYWdlIGNvbGxlY3RlZFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICAgIGlmIChhc3NvYyA+PSAwKSB7XG4gICAgICBpbmRleCA9IHR5cGUuX2xlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXggPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgcnBvcy5hc3NvYylcbn07XG5cbi8qKlxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGFcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbnxudWxsfSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoXG4gIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLnRuYW1lID09PSBiLnRuYW1lICYmIGNvbXBhcmVJRHMoYS5pdGVtLCBiLml0ZW0pICYmIGNvbXBhcmVJRHMoYS50eXBlLCBiLnR5cGUpICYmIGEuYXNzb2MgPT09IGIuYXNzb2Ncbik7XG5cbmNsYXNzIFNuYXBzaG90IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICAgKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gc3Ygc3RhdGUgbWFwXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZHMsIHN2KSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRzID0gZHM7XG4gICAgLyoqXG4gICAgICogU3RhdGUgTWFwXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLnN2ID0gc3Y7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcDJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsU25hcHNob3RzID0gKHNuYXAxLCBzbmFwMikgPT4ge1xuICBjb25zdCBkczEgPSBzbmFwMS5kcy5jbGllbnRzO1xuICBjb25zdCBkczIgPSBzbmFwMi5kcy5jbGllbnRzO1xuICBjb25zdCBzdjEgPSBzbmFwMS5zdjtcbiAgY29uc3Qgc3YyID0gc25hcDIuc3Y7XG4gIGlmIChzdjEuc2l6ZSAhPT0gc3YyLnNpemUgfHwgZHMxLnNpemUgIT09IGRzMi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3YxLmVudHJpZXMoKSkge1xuICAgIGlmIChzdjIuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBbY2xpZW50LCBkc2l0ZW1zMV0gb2YgZHMxLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGRzaXRlbXMyID0gZHMyLmdldChjbGllbnQpIHx8IFtdO1xuICAgIGlmIChkc2l0ZW1zMS5sZW5ndGggIT09IGRzaXRlbXMyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHNpdGVtczEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGRzaXRlbTEgPSBkc2l0ZW1zMVtpXTtcbiAgICAgIGNvbnN0IGRzaXRlbTIgPSBkc2l0ZW1zMltpXTtcbiAgICAgIGlmIChkc2l0ZW0xLmNsb2NrICE9PSBkc2l0ZW0yLmNsb2NrIHx8IGRzaXRlbTEubGVuICE9PSBkc2l0ZW0yLmxlbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTbmFwc2hvdFYyID0gKHNuYXBzaG90LCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2Rlciwgc25hcHNob3QuZHMpO1xuICB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIHNuYXBzaG90LnN2KTtcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVNuYXBzaG90ID0gc25hcHNob3QgPT4gZW5jb2RlU25hcHNob3RWMihzbmFwc2hvdCwgbmV3IERTRW5jb2RlclYxKCkpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IFtkZWNvZGVyXVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGRlY29kZVNuYXBzaG90VjIgPSAoYnVmLCBkZWNvZGVyID0gbmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKSkpID0+IHtcbiAgcmV0dXJuIG5ldyBTbmFwc2hvdChyZWFkRGVsZXRlU2V0KGRlY29kZXIpLCByZWFkU3RhdGVWZWN0b3IoZGVjb2RlcikpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3QgZGVjb2RlU25hcHNob3QgPSBidWYgPT4gZGVjb2RlU25hcHNob3RWMihidWYsIG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzbVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmNvbnN0IGNyZWF0ZVNuYXBzaG90ID0gKGRzLCBzbSkgPT4gbmV3IFNuYXBzaG90KGRzLCBzbSk7XG5cbmNvbnN0IGVtcHR5U25hcHNob3QgPSBjcmVhdGVTbmFwc2hvdChjcmVhdGVEZWxldGVTZXQoKSwgbmV3IE1hcCgpKTtcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuY29uc3Qgc25hcHNob3QgPSBkb2MgPT4gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlKGRvYy5zdG9yZSksIGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSkpO1xuXG4vKipcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTbmFwc2hvdHx1bmRlZmluZWR9IHNuYXBzaG90XG4gKlxuICogQHByb3RlY3RlZFxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT4gc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICA/ICFpdGVtLmRlbGV0ZWRcbiAgOiBzbmFwc2hvdC5zdi5oYXMoaXRlbS5pZC5jbGllbnQpICYmIChzbmFwc2hvdC5zdi5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApID4gaXRlbS5pZC5jbG9jayAmJiAhaXNEZWxldGVkKHNuYXBzaG90LmRzLCBpdGVtLmlkKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqL1xuY29uc3Qgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgbWV0YSA9IG1hcC5zZXRJZlVuZGVmaW5lZCh0cmFuc2FjdGlvbi5tZXRhLCBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzLCBzZXQuY3JlYXRlKTtcbiAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5kb2Muc3RvcmU7XG4gIC8vIGNoZWNrIGlmIHdlIGFscmVhZHkgc3BsaXQgZm9yIHRoaXMgc25hcHNob3RcbiAgaWYgKCFtZXRhLmhhcyhzbmFwc2hvdCkpIHtcbiAgICBzbmFwc2hvdC5zdi5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSkge1xuICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY2xpZW50LCBjbG9jaykpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QuZHMsIGl0ZW0gPT4ge30pO1xuICAgIG1ldGEuYWRkKHNuYXBzaG90KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZXhhbXBsZVxuICogIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoeyBnYzogZmFsc2UgfSlcbiAqICB5ZG9jLmdldFRleHQoKS5pbnNlcnQoMCwgJ3dvcmxkIScpXG4gKiAgY29uc3Qgc25hcHNob3QgPSBZLnNuYXBzaG90KHlkb2MpXG4gKiAgeWRvYy5nZXRUZXh0KCkuaW5zZXJ0KDAsICdoZWxsbyAnKVxuICogIGNvbnN0IHJlc3RvcmVkID0gWS5jcmVhdGVEb2NGcm9tU25hcHNob3QoeWRvYywgc25hcHNob3QpXG4gKiAgYXNzZXJ0KHJlc3RvcmVkLmdldFRleHQoKS50b1N0cmluZygpID09PSAnd29ybGQhJylcbiAqXG4gKiBAcGFyYW0ge0RvY30gb3JpZ2luRG9jXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEb2N9IFtuZXdEb2NdIE9wdGlvbmFsbHksIHlvdSBtYXkgZGVmaW5lIHRoZSBZanMgZG9jdW1lbnQgdGhhdCByZWNlaXZlcyB0aGUgZGF0YSBmcm9tIG9yaWdpbkRvY1xuICogQHJldHVybiB7RG9jfVxuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tU25hcHNob3QgPSAob3JpZ2luRG9jLCBzbmFwc2hvdCwgbmV3RG9jID0gbmV3IERvYygpKSA9PiB7XG4gIGlmIChvcmlnaW5Eb2MuZ2MpIHtcbiAgICAvLyB3ZSBzaG91bGQgbm90IHRyeSB0byByZXN0b3JlIGEgR0MtZWQgZG9jdW1lbnQsIGJlY2F1c2Ugc29tZSBvZiB0aGUgcmVzdG9yZWQgaXRlbXMgbWlnaHQgaGF2ZSB0aGVpciBjb250ZW50IGRlbGV0ZWRcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0dhcmJhZ2UtY29sbGVjdGlvbiBtdXN0IGJlIGRpc2FibGVkIGluIGBvcmlnaW5Eb2NgIScpXG4gIH1cbiAgY29uc3QgeyBzdiwgZHMgfSA9IHNuYXBzaG90O1xuXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwO1xuICAgIHN2LmZvckVhY2goY2xvY2sgPT4ge1xuICAgICAgaWYgKGNsb2NrID4gMCkge1xuICAgICAgICBzaXplKys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpO1xuICAgIC8vIHNwbGl0dGluZyB0aGUgc3RydWN0cyBiZWZvcmUgd3JpdGluZyB0aGVtIHRvIHRoZSBlbmNvZGVyXG4gICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2Ygc3YpIHtcbiAgICAgIGlmIChjbG9jayA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNsb2NrIDwgZ2V0U3RhdGUob3JpZ2luRG9jLnN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJ1Y3RzID0gb3JpZ2luRG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkgfHwgW107XG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpO1xuICAgICAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsYXN0U3RydWN0SW5kZXggKyAxKTtcbiAgICAgIGVuY29kZXIud3JpdGVDbGllbnQoY2xpZW50KTtcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbGFzdFN0cnVjdEluZGV4OyBpKyspIHtcbiAgICAgICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVEZWxldGVTZXQoZW5jb2RlciwgZHMpO1xuICB9KTtcblxuICBhcHBseVVwZGF0ZVYyKG5ld0RvYywgZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgJ3NuYXBzaG90Jyk7XG4gIHJldHVybiBuZXdEb2Ncbn07XG5cbmNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCB7IG1pc3Npbmc6IE1hcDxudW1iZXIsIG51bWJlcj4sIHVwZGF0ZTogVWludDhBcnJheSB9fVxuICAgICAqL1xuICAgIHRoaXMucGVuZGluZ1N0cnVjdHMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgVWludDhBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnBlbmRpbmdEcyA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlcyBhcyBhIE1hcDxjbGllbnQsY2xvY2s+LlxuICogTm90ZSB0aGF0IGNsb2NrIHJlZmVycyB0byB0aGUgbmV4dCBleHBlY3RlZCBjbG9jayBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRTdGF0ZVZlY3RvciA9IHN0b3JlID0+IHtcbiAgY29uc3Qgc20gPSBuZXcgTWFwKCk7XG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdO1xuICAgIHNtLnNldChjbGllbnQsIHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGgpO1xuICB9KTtcbiAgcmV0dXJuIHNtXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldFN0YXRlID0gKHN0b3JlLCBjbGllbnQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCk7XG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gIHJldHVybiBsYXN0U3RydWN0LmlkLmNsb2NrICsgbGFzdFN0cnVjdC5sZW5ndGhcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7R0N8SXRlbX0gc3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBhZGRTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCkgPT4ge1xuICBsZXQgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpO1xuICBpZiAoc3RydWN0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RydWN0cyA9IFtdO1xuICAgIHN0b3JlLmNsaWVudHMuc2V0KHN0cnVjdC5pZC5jbGllbnQsIHN0cnVjdHMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RTdHJ1Y3QuaWQuY2xvY2sgKyBsYXN0U3RydWN0Lmxlbmd0aCAhPT0gc3RydWN0LmlkLmNsb2NrKSB7XG4gICAgICB0aHJvdyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICB9XG4gIHN0cnVjdHMucHVzaChzdHJ1Y3QpO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kSW5kZXhTUyA9IChzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IHN0cnVjdHMubGVuZ3RoIC0gMTtcbiAgbGV0IG1pZCA9IHN0cnVjdHNbcmlnaHRdO1xuICBsZXQgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2s7XG4gIGlmIChtaWRjbG9jayA9PT0gY2xvY2spIHtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuICAvLyBAdG9kbyBkb2VzIGl0IGV2ZW4gbWFrZSBzZW5zZSB0byBwaXZvdCB0aGUgc2VhcmNoP1xuICAvLyBJZiBhIGdvb2Qgc3BsaXQgbWlzc2VzLCBpdCBtaWdodCBhY3R1YWxseSBpbmNyZWFzZSB0aGUgdGltZSB0byBmaW5kIHRoZSBjb3JyZWN0IGl0ZW0uXG4gIC8vIEN1cnJlbnRseSwgdGhlIG9ubHkgYWR2YW50YWdlIGlzIHRoYXQgc2VhcmNoIHdpdGggcGl2b3RpbmcgbWlnaHQgZmluZCB0aGUgaXRlbSBvbiB0aGUgZmlyc3QgdHJ5LlxuICBsZXQgbWlkaW5kZXggPSBtYXRoLmZsb29yKChjbG9jayAvIChtaWRjbG9jayArIG1pZC5sZW5ndGggLSAxKSkgKiByaWdodCk7IC8vIHBpdm90aW5nIHRoZSBzZWFyY2hcbiAgd2hpbGUgKGxlZnQgPD0gcmlnaHQpIHtcbiAgICBtaWQgPSBzdHJ1Y3RzW21pZGluZGV4XTtcbiAgICBtaWRjbG9jayA9IG1pZC5pZC5jbG9jaztcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJpZ2h0ID0gbWlkaW5kZXggLSAxO1xuICAgIH1cbiAgICBtaWRpbmRleCA9IG1hdGguZmxvb3IoKGxlZnQgKyByaWdodCkgLyAyKTtcbiAgfVxuICAvLyBBbHdheXMgY2hlY2sgc3RhdGUgYmVmb3JlIGxvb2tpbmcgZm9yIGEgc3RydWN0IGluIFN0cnVjdFN0b3JlXG4gIC8vIFRoZXJlZm9yZSB0aGUgY2FzZSBvZiBub3QgZmluZGluZyBhIHN0cnVjdCBpcyB1bmV4cGVjdGVkXG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn07XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0dDfEl0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4U1Moc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtID0gLyoqIEB0eXBlIHtmdW5jdGlvbihTdHJ1Y3RTdG9yZSxJRCk6SXRlbX0gKi8gKGZpbmQpO1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqL1xuY29uc3QgZmluZEluZGV4Q2xlYW5TdGFydCA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2spID0+IHtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2sgJiYgc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSk7XG4gICAgcmV0dXJuIGluZGV4ICsgMVxuICB9XG4gIHJldHVybiBpbmRleFxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGdldEl0ZW1DbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBpZCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxJdGVtPn0gKi8gKHRyYW5zYWN0aW9uLmRvYy5zdG9yZS5jbGllbnRzLmdldChpZC5jbGllbnQpKTtcbiAgcmV0dXJuIHN0cnVjdHNbZmluZEluZGV4Q2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgc3RydWN0cywgaWQuY2xvY2spXVxufTtcblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRJdGVtQ2xlYW5FbmQgPSAodHJhbnNhY3Rpb24sIHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KTtcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayk7XG4gIGNvbnN0IHN0cnVjdCA9IHN0cnVjdHNbaW5kZXhdO1xuICBpZiAoaWQuY2xvY2sgIT09IHN0cnVjdC5pZC5jbG9jayArIHN0cnVjdC5sZW5ndGggLSAxICYmIHN0cnVjdC5jb25zdHJ1Y3RvciAhPT0gR0MpIHtcbiAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpZC5jbG9jayAtIHN0cnVjdC5pZC5jbG9jayArIDEpKTtcbiAgfVxuICByZXR1cm4gc3RydWN0XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgYGl0ZW1gIHdpdGggYG5ld2l0ZW1gIGluIHN0b3JlXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7R0N8SXRlbX0gbmV3U3RydWN0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZXBsYWNlU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QsIG5ld1N0cnVjdCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpKTtcbiAgc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBzdHJ1Y3QuaWQuY2xvY2spXSA9IG5ld1N0cnVjdDtcbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2Ygc3RydWN0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tTdGFydCBJbmNsdXNpdmUgc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpdGVyYXRlU3RydWN0cyA9ICh0cmFuc2FjdGlvbiwgc3RydWN0cywgY2xvY2tTdGFydCwgbGVuLCBmKSA9PiB7XG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm5cbiAgfVxuICBjb25zdCBjbG9ja0VuZCA9IGNsb2NrU3RhcnQgKyBsZW47XG4gIGxldCBpbmRleCA9IGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQpO1xuICBsZXQgc3RydWN0O1xuICBkbyB7XG4gICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXTtcbiAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja0VuZCk7XG4gICAgfVxuICAgIGYoc3RydWN0KTtcbiAgfSB3aGlsZSAoaW5kZXggPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3RzW2luZGV4XS5pZC5jbG9jayA8IGNsb2NrRW5kKVxufTtcblxuLyoqXG4gKiBBIHRyYW5zYWN0aW9uIGlzIGNyZWF0ZWQgZm9yIGV2ZXJ5IGNoYW5nZSBvbiB0aGUgWWpzIG1vZGVsLiBJdCBpcyBwb3NzaWJsZVxuICogdG8gYnVuZGxlIGNoYW5nZXMgb24gdGhlIFlqcyBtb2RlbCBpbiBhIHNpbmdsZSB0cmFuc2FjdGlvbiB0b1xuICogbWluaW1pemUgdGhlIG51bWJlciBvbiBtZXNzYWdlcyBzZW50IGFuZCB0aGUgbnVtYmVyIG9mIG9ic2VydmVyIGNhbGxzLlxuICogSWYgcG9zc2libGUgdGhlIHVzZXIgb2YgdGhpcyBsaWJyYXJ5IHNob3VsZCBidW5kbGUgYXMgbWFueSBjaGFuZ2VzIGFzXG4gKiBwb3NzaWJsZS4gSGVyZSBpcyBhbiBleGFtcGxlIHRvIGlsbHVzdHJhdGUgdGhlIGFkdmFudGFnZXMgb2YgYnVuZGxpbmc6XG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IG1hcCA9IHkuZGVmaW5lKCdtYXAnLCBZTWFwKVxuICogLy8gTG9nIGNvbnRlbnQgd2hlbiBjaGFuZ2UgaXMgdHJpZ2dlcmVkXG4gKiBtYXAub2JzZXJ2ZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdjaGFuZ2UgdHJpZ2dlcmVkJylcbiAqIH0pXG4gKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAqIG1hcC5zZXQoJ2EnLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogbWFwLnNldCgnYicsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gKiB5LnRyYW5zYWN0KCgpID0+IHtcbiAqICAgbWFwLnNldCgnYScsIDEpXG4gKiAgIG1hcC5zZXQoJ2InLCAxKVxuICogfSkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxvY2FsXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBvcmlnaW4sIGxvY2FsKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFlqcyBpbnN0YW5jZS5cbiAgICAgKiBAdHlwZSB7RG9jfVxuICAgICAqL1xuICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc2V0IG9mIGRlbGV0ZWQgaXRlbXMgYnkgaWRzXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVNldCA9IG5ldyBEZWxldGVTZXQoKTtcbiAgICAvKipcbiAgICAgKiBIb2xkcyB0aGUgc3RhdGUgYmVmb3JlIHRoZSB0cmFuc2FjdGlvbiBzdGFydGVkLlxuICAgICAqIEB0eXBlIHtNYXA8TnVtYmVyLE51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSk7XG4gICAgLyoqXG4gICAgICogSG9sZHMgdGhlIHN0YXRlIGFmdGVyIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAdHlwZSB7TWFwPE51bWJlcixOdW1iZXI+fVxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBBbGwgdHlwZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IG1vZGlmaWVkIChwcm9wZXJ0eSBhZGRlZCBvciBjaGlsZFxuICAgICAqIGluc2VydGVkL2RlbGV0ZWQpLiBOZXcgdHlwZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIFNldC5cbiAgICAgKiBNYXBzIGZyb20gdHlwZSB0byBwYXJlbnRTdWJzIChgaXRlbS5wYXJlbnRTdWIgPSBudWxsYCBmb3IgWUFycmF5KVxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixTZXQ8U3RyaW5nfG51bGw+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWQgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogU3RvcmVzIHRoZSBldmVudHMgZm9yIHRoZSB0eXBlcyB0aGF0IG9ic2VydmUgYWxzbyBjaGlsZCBlbGVtZW50cy5cbiAgICAgKiBJdCBpcyBtYWlubHkgdXNlZCBieSBgb2JzZXJ2ZURlZXBgLlxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixBcnJheTxZRXZlbnQ8YW55Pj4+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbmdlZFBhcmVudFR5cGVzID0gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFN0cnVjdD59XG4gICAgICovXG4gICAgdGhpcy5fbWVyZ2VTdHJ1Y3RzID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgbWV0YSBpbmZvcm1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKiBAdHlwZSB7TWFwPGFueSxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgY2hhbmdlIG9yaWdpbmF0ZXMgZnJvbSB0aGlzIGRvYy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvY2FsID0gbG9jYWw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0FkZGVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NSZW1vdmVkID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtTZXQ8RG9jPn1cbiAgICAgKi9cbiAgICB0aGlzLnN1YmRvY3NMb2FkZWQgPSBuZXcgU2V0KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgZGF0YSB3YXMgd3JpdHRlbi5cbiAqL1xuY29uc3Qgd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB7XG4gIGlmICh0cmFuc2FjdGlvbi5kZWxldGVTZXQuY2xpZW50cy5zaXplID09PSAwICYmICFtYXAuYW55KHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUsIChjbG9jaywgY2xpZW50KSA9PiB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSAhPT0gY2xvY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHdyaXRlU3RydWN0c0Zyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCk7XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIElmIGB0eXBlLnBhcmVudGAgd2FzIGFkZGVkIGluIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGB0eXBlYCB0ZWNobmljYWxseVxuICogZGlkIG5vdCBjaGFuZ2UsIGl0IHdhcyBqdXN0IGFkZGVkIGFuZCB3ZSBzaG91bGQgbm90IGZpcmUgZXZlbnRzIGZvciBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+Pn0gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gcGFyZW50U3ViXG4gKi9cbmNvbnN0IGFkZENoYW5nZWRUeXBlVG9UcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbiwgdHlwZSwgcGFyZW50U3ViKSA9PiB7XG4gIGNvbnN0IGl0ZW0gPSB0eXBlLl9pdGVtO1xuICBpZiAoaXRlbSA9PT0gbnVsbCB8fCAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApICYmICFpdGVtLmRlbGV0ZWQpKSB7XG4gICAgbWFwLnNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLmNoYW5nZWQsIHR5cGUsIHNldC5jcmVhdGUpLmFkZChwYXJlbnRTdWIpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zXG4gKi9cbmNvbnN0IHRyeVRvTWVyZ2VXaXRoTGVmdCA9IChzdHJ1Y3RzLCBwb3MpID0+IHtcbiAgY29uc3QgbGVmdCA9IHN0cnVjdHNbcG9zIC0gMV07XG4gIGNvbnN0IHJpZ2h0ID0gc3RydWN0c1twb3NdO1xuICBpZiAobGVmdC5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmIGxlZnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yKSB7XG4gICAgaWYgKGxlZnQubWVyZ2VXaXRoKHJpZ2h0KSkge1xuICAgICAgc3RydWN0cy5zcGxpY2UocG9zLCAxKTtcbiAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIEl0ZW0gJiYgcmlnaHQucGFyZW50U3ViICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuZ2V0KHJpZ2h0LnBhcmVudFN1YikgPT09IHJpZ2h0KSB7XG4gICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0LnBhcmVudFN1YiwgLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgZm9yIChjb25zdCBbY2xpZW50LCBkZWxldGVJdGVtc10gb2YgZHMuY2xpZW50cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIGNvbnN0IGVuZERlbGV0ZUl0ZW1DbG9jayA9IGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbjtcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2spLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBlbmREZWxldGVJdGVtQ2xvY2s7XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbKytzaV1cbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgaWYgKGRlbGV0ZUl0ZW0uY2xvY2sgKyBkZWxldGVJdGVtLmxlbiA8PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmIHN0cnVjdC5kZWxldGVkICYmICFzdHJ1Y3Qua2VlcCAmJiBnY0ZpbHRlcihzdHJ1Y3QpKSB7XG4gICAgICAgICAgc3RydWN0LmdjKHN0b3JlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICovXG5jb25zdCB0cnlNZXJnZURlbGV0ZVNldCA9IChkcywgc3RvcmUpID0+IHtcbiAgLy8gdHJ5IHRvIG1lcmdlIGRlbGV0ZWQgLyBnYydkIGl0ZW1zXG4gIC8vIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdCBmb3IgYmV0dGVyIGVmZmljaWVjeSBhbmQgc28gd2UgZG9uJ3QgbWlzcyBhbnkgbWVyZ2UgdGFyZ2V0c1xuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZUl0ZW1zLCBjbGllbnQpID0+IHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXTtcbiAgICAgIC8vIHN0YXJ0IHdpdGggbWVyZ2luZyB0aGUgaXRlbSBuZXh0IHRvIHRoZSBsYXN0IGRlbGV0ZWQgaXRlbVxuICAgICAgY29uc3QgbW9zdFJpZ2h0SW5kZXhUb0NoZWNrID0gbWF0aC5taW4oc3RydWN0cy5sZW5ndGggLSAxLCAxICsgZmluZEluZGV4U1Moc3RydWN0cywgZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIC0gMSkpO1xuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHNpID0gbW9zdFJpZ2h0SW5kZXhUb0NoZWNrLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPiAwICYmIHN0cnVjdC5pZC5jbG9jayA+PSBkZWxldGVJdGVtLmNsb2NrO1xuICAgICAgICBzdHJ1Y3QgPSBzdHJ1Y3RzWy0tc2ldXG4gICAgICApIHtcbiAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHNpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBnY0ZpbHRlcik7XG4gIHRyeU1lcmdlRGVsZXRlU2V0KGRzLCBzdG9yZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VHJhbnNhY3Rpb24+fSB0cmFuc2FjdGlvbkNsZWFudXBzXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5jb25zdCBjbGVhbnVwVHJhbnNhY3Rpb25zID0gKHRyYW5zYWN0aW9uQ2xlYW51cHMsIGkpID0+IHtcbiAgaWYgKGkgPCB0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25DbGVhbnVwc1tpXTtcbiAgICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXQ7XG4gICAgY29uc3QgbWVyZ2VTdHJ1Y3RzID0gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cztcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUgPSBnZXRTdGF0ZVZlY3Rvcih0cmFuc2FjdGlvbi5kb2Muc3RvcmUpO1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZU9ic2VydmVyQ2FsbHMnLCBbdHJhbnNhY3Rpb24sIGRvY10pO1xuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW107XG4gICAgICAvLyBvYnNlcnZlIGV2ZW50cyBvbiBjaGFuZ2VkIHR5cGVzXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YnMsIGl0ZW10eXBlKSA9PlxuICAgICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICBpZiAoaXRlbXR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIWl0ZW10eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGl0ZW10eXBlLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHN1YnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PlxuICAgICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgICAgLy8gWS5Eb2MgaW4gdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwgfHwgIXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICBldmVudHMgPSBldmVudHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGV2ZW50ID0+XG4gICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgZXZlbnRzXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIC8vIHNvcnQgZXZlbnRzIGJ5IHBhdGggbGVuZ3RoIHNvIHRoYXQgdG9wLWxldmVsIGV2ZW50cyBhcmUgZmlyZWQgZmlyc3QuXG4gICAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAgIC5zb3J0KChldmVudDEsIGV2ZW50MikgPT4gZXZlbnQxLnBhdGgubGVuZ3RoIC0gZXZlbnQyLnBhdGgubGVuZ3RoKTtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgZXZlbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdlIGtub3cgaXQgaGFzIGF0IGxlYXN0IG9uZSBlbGVtZW50XG4gICAgICAgICAgICAgIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnModHlwZS5fZEVILCBldmVudHMsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBmcy5wdXNoKCgpID0+IGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgW3RyYW5zYWN0aW9uLCBkb2NdKSk7XG4gICAgICB9KTtcbiAgICAgIGNhbGxBbGwoZnMsIFtdKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVwbGFjZSBkZWxldGVkIGl0ZW1zIHdpdGggSXRlbURlbGV0ZWQgLyBHQy5cbiAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29udGVudCBpcyBhY3R1YWxseSByZW1vdmUgZnJvbSB0aGUgWWpzIERvYy5cbiAgICAgIGlmIChkb2MuZ2MpIHtcbiAgICAgICAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBkb2MuZ2NGaWx0ZXIpO1xuICAgICAgfVxuICAgICAgdHJ5TWVyZ2VEZWxldGVTZXQoZHMsIHN0b3JlKTtcblxuICAgICAgLy8gb24gYWxsIGFmZmVjdGVkIHN0b3JlLmNsaWVudHMgcHJvcHMsIHRyeSB0byBtZXJnZVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChjbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGJlZm9yZUNsb2NrID0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGNsaWVudCkgfHwgMDtcbiAgICAgICAgaWYgKGJlZm9yZUNsb2NrICE9PSBjbG9jaykge1xuICAgICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSk7XG4gICAgICAgICAgLy8gd2UgaXRlcmF0ZSBmcm9tIHJpZ2h0IHRvIGxlZnQgc28gd2UgY2FuIHNhZmVseSByZW1vdmUgZW50cmllc1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hhbmdlUG9zID0gbWF0aC5tYXgoZmluZEluZGV4U1Moc3RydWN0cywgYmVmb3JlQ2xvY2spLCAxKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gc3RydWN0cy5sZW5ndGggLSAxOyBpID49IGZpcnN0Q2hhbmdlUG9zOyBpLS0pIHtcbiAgICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gdHJ5IHRvIG1lcmdlIG1lcmdlU3RydWN0c1xuICAgICAgLy8gQHRvZG86IGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gdHJhbnNmb3JtIG1lcmdlU3RydWN0cyB0byBhIERTLCBzb3J0IGl0LCBhbmQgbWVyZ2UgZnJvbSByaWdodCB0byBsZWZ0XG4gICAgICAvLyAgICAgICAgYnV0IGF0IHRoZSBtb21lbnQgRFMgZG9lcyBub3QgaGFuZGxlIGR1cGxpY2F0ZXNcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVyZ2VTdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbWVyZ2VTdHJ1Y3RzW2ldLmlkO1xuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpO1xuICAgICAgICBjb25zdCByZXBsYWNlZFN0cnVjdFBvcyA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKTtcbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgdHJ5VG9NZXJnZVdpdGhMZWZ0KHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdChzdHJ1Y3RzLCByZXBsYWNlZFN0cnVjdFBvcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgbG9nZ2luZy5wcmludChsb2dnaW5nLk9SQU5HRSwgbG9nZ2luZy5CT0xELCAnW3lqc10gJywgbG9nZ2luZy5VTkJPTEQsIGxvZ2dpbmcuUkVELCAnQ2hhbmdlZCB0aGUgY2xpZW50LWlkIGJlY2F1c2UgYW5vdGhlciBjbGllbnQgc2VlbXMgdG8gYmUgdXNpbmcgaXQuJyk7XG4gICAgICAgIGRvYy5jbGllbnRJRCA9IGdlbmVyYXRlTmV3Q2xpZW50SWQoKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0b2RvIE1lcmdlIGFsbCB0aGUgdHJhbnNhY3Rpb25zIGludG8gb25lIGFuZCBwcm92aWRlIHNlbmQgdGhlIGRhdGEgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2VcbiAgICAgIGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uQ2xlYW51cCcsIFt0cmFuc2FjdGlvbiwgZG9jXSk7XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGUnKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMSgpO1xuICAgICAgICBjb25zdCBoYXNDb250ZW50ID0gd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlJywgW2VuY29kZXIudG9VaW50OEFycmF5KCksIHRyYW5zYWN0aW9uLm9yaWdpbiwgZG9jLCB0cmFuc2FjdGlvbl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGVWMicpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKCk7XG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAoaGFzQ29udGVudCkge1xuICAgICAgICAgIGRvYy5lbWl0KCd1cGRhdGVWMicsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeyBzdWJkb2NzQWRkZWQsIHN1YmRvY3NMb2FkZWQsIHN1YmRvY3NSZW1vdmVkIH0gPSB0cmFuc2FjdGlvbjtcbiAgICAgIGlmIChzdWJkb2NzQWRkZWQuc2l6ZSA+IDAgfHwgc3ViZG9jc1JlbW92ZWQuc2l6ZSA+IDAgfHwgc3ViZG9jc0xvYWRlZC5zaXplID4gMCkge1xuICAgICAgICBzdWJkb2NzQWRkZWQuZm9yRWFjaChzdWJkb2MgPT4ge1xuICAgICAgICAgIHN1YmRvYy5jbGllbnRJRCA9IGRvYy5jbGllbnRJRDtcbiAgICAgICAgICBpZiAoc3ViZG9jLmNvbGxlY3Rpb25pZCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJkb2MuY29sbGVjdGlvbmlkID0gZG9jLmNvbGxlY3Rpb25pZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jLnN1YmRvY3MuYWRkKHN1YmRvYyk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJkb2NzUmVtb3ZlZC5mb3JFYWNoKHN1YmRvYyA9PiBkb2Muc3ViZG9jcy5kZWxldGUoc3ViZG9jKSk7XG4gICAgICAgIGRvYy5lbWl0KCdzdWJkb2NzJywgW3sgbG9hZGVkOiBzdWJkb2NzTG9hZGVkLCBhZGRlZDogc3ViZG9jc0FkZGVkLCByZW1vdmVkOiBzdWJkb2NzUmVtb3ZlZCB9LCBkb2MsIHRyYW5zYWN0aW9uXSk7XG4gICAgICAgIHN1YmRvY3NSZW1vdmVkLmZvckVhY2goc3ViZG9jID0+IHN1YmRvYy5kZXN0cm95KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPD0gaSArIDEpIHtcbiAgICAgICAgZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW107XG4gICAgICAgIGRvYy5lbWl0KCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIFtkb2MsIHRyYW5zYWN0aW9uQ2xlYW51cHNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgaSArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGB5LnRyYW5zYWN0KCgpPT57Li59KWBcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6VH0gZlxuICogQHBhcmFtIHthbnl9IFtvcmlnaW49dHJ1ZV1cbiAqIEByZXR1cm4ge1R9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHRyYW5zYWN0ID0gKGRvYywgZiwgb3JpZ2luID0gbnVsbCwgbG9jYWwgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHRyYW5zYWN0aW9uQ2xlYW51cHMgPSBkb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHM7XG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlO1xuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCByZXN1bHQgPSBudWxsO1xuICBpZiAoZG9jLl90cmFuc2FjdGlvbiA9PT0gbnVsbCkge1xuICAgIGluaXRpYWxDYWxsID0gdHJ1ZTtcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbCk7XG4gICAgdHJhbnNhY3Rpb25DbGVhbnVwcy5wdXNoKGRvYy5fdHJhbnNhY3Rpb24pO1xuICAgIGlmICh0cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZG9jLmVtaXQoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIFtkb2NdKTtcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pO1xuICB9XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gZihkb2MuX3RyYW5zYWN0aW9uKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgIGNvbnN0IGZpbmlzaENsZWFudXAgPSBkb2MuX3RyYW5zYWN0aW9uID09PSB0cmFuc2FjdGlvbkNsZWFudXBzWzBdO1xuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAoZmluaXNoQ2xlYW51cCkge1xuICAgICAgICAvLyBUaGUgZmlyc3QgdHJhbnNhY3Rpb24gZW5kZWQsIG5vdyBwcm9jZXNzIG9ic2VydmVyIGNhbGxzLlxuICAgICAgICAvLyBPYnNlcnZlciBjYWxsIG1heSBjcmVhdGUgbmV3IHRyYW5zYWN0aW9ucyBmb3Igd2hpY2ggd2UgbmVlZCB0byBjYWxsIHRoZSBvYnNlcnZlcnMgYW5kIGRvIGNsZWFudXAuXG4gICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gbmVzdCB0aGVzZSBjYWxscywgc28gd2UgZXhlY3V0ZSB0aGVzZSBjYWxscyBvbmUgYWZ0ZXJcbiAgICAgICAgLy8gYW5vdGhlci5cbiAgICAgICAgLy8gQWxzbyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFsbCBjbGVhbnVwcyBhcmUgY2FsbGVkLCBldmVuIGlmIHRoZVxuICAgICAgICAvLyBvYnNlcnZlcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgIC8vIFRoaXMgZmlsZSBpcyBmdWxsIG9mIGhhY2t5IHRyeSB7fSBmaW5hbGx5IHt9IGJsb2NrcyB0byBlbnN1cmUgdGhhdCBhblxuICAgICAgICAvLyBldmVudCBjYW4gdGhyb3cgZXJyb3JzIGFuZCBhbHNvIHRoYXQgdGhlIGNsZWFudXAgaXMgY2FsbGVkLlxuICAgICAgICBjbGVhbnVwVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9uQ2xlYW51cHMsIDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuXG5jbGFzcyBTdGFja0l0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRlbGV0aW9uc1xuICAgKiBAcGFyYW0ge0RlbGV0ZVNldH0gaW5zZXJ0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlbGV0aW9ucywgaW5zZXJ0aW9ucykge1xuICAgIHRoaXMuaW5zZXJ0aW9ucyA9IGluc2VydGlvbnM7XG4gICAgdGhpcy5kZWxldGlvbnMgPSBkZWxldGlvbnM7XG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgdG8gc2F2ZSBhbmQgcmVzdG9yZSBtZXRhZGF0YSBsaWtlIHNlbGVjdGlvbiByYW5nZVxuICAgICAqL1xuICAgIHRoaXMubWV0YSA9IG5ldyBNYXAoKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW1cbiAqIEBwYXJhbSB7U3RhY2tJdGVtfSBzdGFja0l0ZW1cbiAqL1xuY29uc3QgY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSA9ICh0ciwgdW0sIHN0YWNrSXRlbSkgPT4ge1xuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHIsIHN0YWNrSXRlbS5kZWxldGlvbnMsIGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB1bS5zY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBpdGVtKSkpIHtcbiAgICAgIGtlZXBJdGVtKGl0ZW0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7U3RhY2tJdGVtP31cbiAqL1xuY29uc3QgcG9wU3RhY2tJdGVtID0gKHVuZG9NYW5hZ2VyLCBzdGFjaywgZXZlbnRUeXBlKSA9PiB7XG4gIC8qKlxuICAgKiBXaGV0aGVyIGEgY2hhbmdlIGhhcHBlbmVkXG4gICAqIEB0eXBlIHtTdGFja0l0ZW0/fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGw7XG4gIC8qKlxuICAgKiBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB0cmFuc2FjdGlvbiBzbyB3ZSBjYW4gZmlyZSB0aGUgZXZlbnQgd2l0aCB0aGUgY2hhbmdlZFBhcmVudFR5cGVzXG4gICAqIEB0eXBlIHthbnl9XG4gICAqL1xuICBsZXQgX3RyID0gbnVsbDtcbiAgY29uc3QgZG9jID0gdW5kb01hbmFnZXIuZG9jO1xuICBjb25zdCBzY29wZSA9IHVuZG9NYW5hZ2VyLnNjb3BlO1xuICB0cmFuc2FjdChkb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCAmJiByZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlO1xuICAgICAgY29uc3Qgc3RhY2tJdGVtID0gLyoqIEB0eXBlIHtTdGFja0l0ZW19ICovIChzdGFjay5wb3AoKSk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9SZWRvID0gbmV3IFNldCgpO1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGUgPSBbXTtcbiAgICAgIGxldCBwZXJmb3JtZWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtKSB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGxldCB7IGl0ZW0sIGRpZmYgfSA9IGZvbGxvd1JlZG9uZShzdG9yZSwgc3RydWN0LmlkKTtcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBpdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrICsgZGlmZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RydWN0ID0gaXRlbTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCAmJiBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCAvKiogQHR5cGUge0l0ZW19ICovIChzdHJ1Y3QpKSkpIHtcbiAgICAgICAgICAgIGl0ZW1zVG9EZWxldGUucHVzaChzdHJ1Y3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5kZWxldGlvbnMsIHN0cnVjdCA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzdHJ1Y3QgaW5zdGFuY2VvZiBJdGVtICYmXG4gICAgICAgICAgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgc3RydWN0KSkgJiZcbiAgICAgICAgICAvLyBOZXZlciByZWRvIHN0cnVjdHMgaW4gc3RhY2tJdGVtLmluc2VydGlvbnMgYmVjYXVzZSB0aGV5IHdlcmUgY3JlYXRlZCBhbmQgZGVsZXRlZCBpbiB0aGUgc2FtZSBjYXB0dXJlIGludGVydmFsLlxuICAgICAgICAgICFpc0RlbGV0ZWQoc3RhY2tJdGVtLmluc2VydGlvbnMsIHN0cnVjdC5pZClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaXRlbXNUb1JlZG8uYWRkKHN0cnVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaXRlbXNUb1JlZG8uZm9yRWFjaChzdHJ1Y3QgPT4ge1xuICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSByZWRvSXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpdGVtc1RvUmVkbywgc3RhY2tJdGVtLmluc2VydGlvbnMsIHVuZG9NYW5hZ2VyLmlnbm9yZVJlbW90ZU1hcENoYW5nZXMsIHVuZG9NYW5hZ2VyKSAhPT0gbnVsbCB8fCBwZXJmb3JtZWRDaGFuZ2U7XG4gICAgICB9KTtcbiAgICAgIC8vIFdlIHdhbnQgdG8gZGVsZXRlIGluIHJldmVyc2Ugb3JkZXIgc28gdGhhdCBjaGlsZHJlbiBhcmUgZGVsZXRlZCBiZWZvcmVcbiAgICAgIC8vIHBhcmVudHMsIHNvIHdlIGhhdmUgbW9yZSBpbmZvcm1hdGlvbiBhdmFpbGFibGUgd2hlbiBpdGVtcyBhcmUgZmlsdGVyZWQuXG4gICAgICBmb3IgKGxldCBpID0gaXRlbXNUb0RlbGV0ZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNUb0RlbGV0ZVtpXTtcbiAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLmRlbGV0ZUZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBwZXJmb3JtZWRDaGFuZ2UgPyBzdGFja0l0ZW0gOiBudWxsO1xuICAgIH1cbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmZvckVhY2goKHN1YlByb3BzLCB0eXBlKSA9PiB7XG4gICAgICAvLyBkZXN0cm95IHNlYXJjaCBtYXJrZXIgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAoc3ViUHJvcHMuaGFzKG51bGwpICYmIHR5cGUuX3NlYXJjaE1hcmtlcikge1xuICAgICAgICB0eXBlLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBfdHIgPSB0cmFuc2FjdGlvbjtcbiAgfSwgdW5kb01hbmFnZXIpO1xuICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICBjb25zdCBjaGFuZ2VkUGFyZW50VHlwZXMgPSBfdHIuY2hhbmdlZFBhcmVudFR5cGVzO1xuICAgIHVuZG9NYW5hZ2VyLmVtaXQoJ3N0YWNrLWl0ZW0tcG9wcGVkJywgW3sgc3RhY2tJdGVtOiByZXN1bHQsIHR5cGU6IGV2ZW50VHlwZSwgY2hhbmdlZFBhcmVudFR5cGVzIH0sIHVuZG9NYW5hZ2VyXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBVbmRvTWFuYWdlck9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUaW1lb3V0PTUwMF1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24pOmJvb2xlYW59IFtVbmRvTWFuYWdlck9wdGlvbnMuY2FwdHVyZVRyYW5zYWN0aW9uXSBEbyBub3QgY2FwdHVyZSBjaGFuZ2VzIG9mIGEgVHJhbnNhY3Rpb24gaWYgcmVzdWx0IGZhbHNlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmRlbGV0ZUZpbHRlcj0oKT0+dHJ1ZV0gU29tZXRpbWVzXG4gKiBpdCBpcyBuZWNlc3NhcnkgdG8gZmlsdGVyIHdoYXQgYW4gVW5kby9SZWRvIG9wZXJhdGlvbiBjYW4gZGVsZXRlLiBJZiB0aGlzXG4gKiBmaWx0ZXIgcmV0dXJucyBmYWxzZSwgdGhlIHR5cGUvaXRlbSB3b24ndCBiZSBkZWxldGVkIGV2ZW4gaXQgaXMgaW4gdGhlXG4gKiB1bmRvL3JlZG8gc2NvcGUuXG4gKiBAcHJvcGVydHkge1NldDxhbnk+fSBbVW5kb01hbmFnZXJPcHRpb25zLnRyYWNrZWRPcmlnaW5zPW5ldyBTZXQoW251bGxdKV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZVJlbW90ZU1hcENoYW5nZXNdIEV4cGVyaW1lbnRhbC4gQnkgZGVmYXVsdCwgdGhlIFVuZG9NYW5hZ2VyIHdpbGwgbmV2ZXIgb3ZlcndyaXRlIHJlbW90ZSBjaGFuZ2VzLiBFbmFibGUgdGhpcyBwcm9wZXJ0eSB0byBlbmFibGUgb3ZlcndyaXRpbmcgcmVtb3RlIGNoYW5nZXMgb24ga2V5LXZhbHVlIGNoYW5nZXMgKFkuTWFwLCBwcm9wZXJ0aWVzIG9uIFkuWG1sLCBldGMuLikuXG4gKiBAcHJvcGVydHkge0RvY30gW2RvY10gVGhlIGRvY3VtZW50IHRoYXQgdGhpcyBVbmRvTWFuYWdlciBvcGVyYXRlcyBvbi4gT25seSBuZWVkZWQgaWYgdHlwZVNjb3BlIGlzIGVtcHR5LlxuICovXG5cbi8qKlxuICogRmlyZXMgJ3N0YWNrLWl0ZW0tYWRkZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBhZGRlZCB0byBlaXRoZXIgdGhlIHVuZG8tIG9yXG4gKiB0aGUgcmVkby1zdGFjay4gWW91IG1heSBzdG9yZSBhZGRpdGlvbmFsIHN0YWNrIGluZm9ybWF0aW9uIHZpYSB0aGVcbiAqIG1ldGFkYXRhIHByb3BlcnR5IG9uIGBldmVudC5zdGFja0l0ZW0ubWV0YWAgKGl0IGlzIGEgYE1hcGAgb2YgbWV0YWRhdGEgcHJvcGVydGllcykuXG4gKiBGaXJlcyAnc3RhY2staXRlbS1wb3BwZWQnIGV2ZW50IHdoZW4gYSBzdGFjayBpdGVtIHdhcyBwb3BwZWQgZnJvbSBlaXRoZXIgdGhlXG4gKiB1bmRvLSBvciB0aGUgcmVkby1zdGFjay4gWW91IG1heSByZXN0b3JlIHRoZSBzYXZlZCBzdGFjayBpbmZvcm1hdGlvbiBmcm9tIGBldmVudC5zdGFja0l0ZW0ubWV0YWAuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8J3N0YWNrLWl0ZW0tYWRkZWQnfCdzdGFjay1pdGVtLXBvcHBlZCd8J3N0YWNrLWNsZWFyZWQnfCdzdGFjay1pdGVtLXVwZGF0ZWQnPn1cbiAqL1xuY2xhc3MgVW5kb01hbmFnZXIgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT58QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+fSB0eXBlU2NvcGUgQWNjZXB0cyBlaXRoZXIgYSBzaW5nbGUgdHlwZSwgb3IgYW4gYXJyYXkgb2YgdHlwZXNcbiAgICogQHBhcmFtIHtVbmRvTWFuYWdlck9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlU2NvcGUsIHtcbiAgICBjYXB0dXJlVGltZW91dCA9IDUwMCxcbiAgICBjYXB0dXJlVHJhbnNhY3Rpb24gPSBfdHIgPT4gdHJ1ZSxcbiAgICBkZWxldGVGaWx0ZXIgPSAoKSA9PiB0cnVlLFxuICAgIHRyYWNrZWRPcmlnaW5zID0gbmV3IFNldChbbnVsbF0pLFxuICAgIGlnbm9yZVJlbW90ZU1hcENoYW5nZXMgPSBmYWxzZSxcbiAgICBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKGFycmF5LmlzQXJyYXkodHlwZVNjb3BlKSA/IHR5cGVTY29wZVswXS5kb2MgOiB0eXBlU2NvcGUuZG9jKVxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zY29wZSA9IFtdO1xuICAgIHRoaXMuYWRkVG9TY29wZSh0eXBlU2NvcGUpO1xuICAgIHRoaXMuZGVsZXRlRmlsdGVyID0gZGVsZXRlRmlsdGVyO1xuICAgIHRyYWNrZWRPcmlnaW5zLmFkZCh0aGlzKTtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zID0gdHJhY2tlZE9yaWdpbnM7XG4gICAgdGhpcy5jYXB0dXJlVHJhbnNhY3Rpb24gPSBjYXB0dXJlVHJhbnNhY3Rpb247XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy51bmRvU3RhY2sgPSBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlZG9TdGFjayA9IFtdO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgdW5kb2luZyAoY2FsbGluZyBVbmRvTWFuYWdlci51bmRvKVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51bmRvaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZWRvaW5nID0gZmFsc2U7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgICB0aGlzLmlnbm9yZVJlbW90ZU1hcENoYW5nZXMgPSBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzO1xuICAgIHRoaXMuY2FwdHVyZVRpbWVvdXQgPSBjYXB0dXJlVGltZW91dDtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIgPSB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAvLyBPbmx5IHRyYWNrIGNlcnRhaW4gdHJhbnNhY3Rpb25zXG4gICAgICBpZiAoXG4gICAgICAgICF0aGlzLmNhcHR1cmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikgfHxcbiAgICAgICAgIXRoaXMuc2NvcGUuc29tZSh0eXBlID0+IHRyYW5zYWN0aW9uLmNoYW5nZWRQYXJlbnRUeXBlcy5oYXModHlwZSkpIHx8XG4gICAgICAgICghdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luKSAmJiAoIXRyYW5zYWN0aW9uLm9yaWdpbiB8fCAhdGhpcy50cmFja2VkT3JpZ2lucy5oYXModHJhbnNhY3Rpb24ub3JpZ2luLmNvbnN0cnVjdG9yKSkpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCB1bmRvaW5nID0gdGhpcy51bmRvaW5nO1xuICAgICAgY29uc3QgcmVkb2luZyA9IHRoaXMucmVkb2luZztcbiAgICAgIGNvbnN0IHN0YWNrID0gdW5kb2luZyA/IHRoaXMucmVkb1N0YWNrIDogdGhpcy51bmRvU3RhY2s7XG4gICAgICBpZiAodW5kb2luZykge1xuICAgICAgICB0aGlzLnN0b3BDYXB0dXJpbmcoKTsgLy8gbmV4dCB1bmRvIHNob3VsZCBub3QgYmUgYXBwZW5kZWQgdG8gbGFzdCBzdGFjayBpdGVtXG4gICAgICB9IGVsc2UgaWYgKCFyZWRvaW5nKSB7XG4gICAgICAgIC8vIG5laXRoZXIgdW5kb2luZyBub3IgcmVkb2luZzogZGVsZXRlIHJlZG9TdGFja1xuICAgICAgICB0aGlzLmNsZWFyKGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluc2VydGlvbnMgPSBuZXcgRGVsZXRlU2V0KCk7XG4gICAgICB0cmFuc2FjdGlvbi5hZnRlclN0YXRlLmZvckVhY2goKGVuZENsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDA7XG4gICAgICAgIGNvbnN0IGxlbiA9IGVuZENsb2NrIC0gc3RhcnRDbG9jaztcbiAgICAgICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgICBhZGRUb0RlbGV0ZVNldChpbnNlcnRpb25zLCBjbGllbnQsIHN0YXJ0Q2xvY2ssIGxlbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3Qgbm93ID0gdGltZS5nZXRVbml4VGltZSgpO1xuICAgICAgbGV0IGRpZEFkZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMubGFzdENoYW5nZSA+IDAgJiYgbm93IC0gdGhpcy5sYXN0Q2hhbmdlIDwgdGhpcy5jYXB0dXJlVGltZW91dCAmJiBzdGFjay5sZW5ndGggPiAwICYmICF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIC8vIGFwcGVuZCBjaGFuZ2UgdG8gbGFzdCBzdGFjayBvcFxuICAgICAgICBjb25zdCBsYXN0T3AgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgbGFzdE9wLmRlbGV0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmRlbGV0aW9ucywgdHJhbnNhY3Rpb24uZGVsZXRlU2V0XSk7XG4gICAgICAgIGxhc3RPcC5pbnNlcnRpb25zID0gbWVyZ2VEZWxldGVTZXRzKFtsYXN0T3AuaW5zZXJ0aW9ucywgaW5zZXJ0aW9uc10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IHN0YWNrIG9wXG4gICAgICAgIHN0YWNrLnB1c2gobmV3IFN0YWNrSXRlbSh0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGluc2VydGlvbnMpKTtcbiAgICAgICAgZGlkQWRkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2UgPSBub3c7XG4gICAgICB9XG4gICAgICAvLyBtYWtlIHN1cmUgdGhhdCBkZWxldGVkIHN0cnVjdHMgYXJlIG5vdCBnYydkXG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgLyoqIEBwYXJhbSB7SXRlbXxHQ30gaXRlbSAqLyBpdGVtID0+IHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIHRoaXMuc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICAgICAga2VlcEl0ZW0oaXRlbSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2hhbmdlRXZlbnQgPSBbeyBzdGFja0l0ZW06IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBvcmlnaW46IHRyYW5zYWN0aW9uLm9yaWdpbiwgdHlwZTogdW5kb2luZyA/ICdyZWRvJyA6ICd1bmRvJywgY2hhbmdlZFBhcmVudFR5cGVzOiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMgfSwgdGhpc107XG4gICAgICBpZiAoZGlkQWRkKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS1hZGRlZCcsIGNoYW5nZUV2ZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZW1pdCgnc3RhY2staXRlbS11cGRhdGVkJywgY2hhbmdlRXZlbnQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyVHJhbnNhY3Rpb24nLCB0aGlzLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICB0aGlzLmRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QWJzdHJhY3RUeXBlPGFueT4+IHwgQWJzdHJhY3RUeXBlPGFueT59IHl0eXBlc1xuICAgKi9cbiAgYWRkVG9TY29wZSAoeXR5cGVzKSB7XG4gICAgeXR5cGVzID0gYXJyYXkuaXNBcnJheSh5dHlwZXMpID8geXR5cGVzIDogW3l0eXBlc107XG4gICAgeXR5cGVzLmZvckVhY2goeXR5cGUgPT4ge1xuICAgICAgaWYgKHRoaXMuc2NvcGUuZXZlcnkoeXQgPT4geXQgIT09IHl0eXBlKSkge1xuICAgICAgICB0aGlzLnNjb3BlLnB1c2goeXR5cGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICovXG4gIGFkZFRyYWNrZWRPcmlnaW4gKG9yaWdpbikge1xuICAgIHRoaXMudHJhY2tlZE9yaWdpbnMuYWRkKG9yaWdpbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgcmVtb3ZlVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucy5kZWxldGUob3JpZ2luKTtcbiAgfVxuXG4gIGNsZWFyIChjbGVhclVuZG9TdGFjayA9IHRydWUsIGNsZWFyUmVkb1N0YWNrID0gdHJ1ZSkge1xuICAgIGlmICgoY2xlYXJVbmRvU3RhY2sgJiYgdGhpcy5jYW5VbmRvKCkpIHx8IChjbGVhclJlZG9TdGFjayAmJiB0aGlzLmNhblJlZG8oKSkpIHtcbiAgICAgIHRoaXMuZG9jLnRyYW5zYWN0KHRyID0+IHtcbiAgICAgICAgaWYgKGNsZWFyVW5kb1N0YWNrKSB7XG4gICAgICAgICAgdGhpcy51bmRvU3RhY2suZm9yRWFjaChpdGVtID0+IGNsZWFyVW5kb01hbmFnZXJTdGFja0l0ZW0odHIsIHRoaXMsIGl0ZW0pKTtcbiAgICAgICAgICB0aGlzLnVuZG9TdGFjayA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhclJlZG9TdGFjaykge1xuICAgICAgICAgIHRoaXMucmVkb1N0YWNrLmZvckVhY2goaXRlbSA9PiBjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtKHRyLCB0aGlzLCBpdGVtKSk7XG4gICAgICAgICAgdGhpcy5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWNsZWFyZWQnLCBbeyB1bmRvU3RhY2tDbGVhcmVkOiBjbGVhclVuZG9TdGFjaywgcmVkb1N0YWNrQ2xlYXJlZDogY2xlYXJSZWRvU3RhY2sgfV0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVuZG9NYW5hZ2VyIG1lcmdlcyBVbmRvLVN0YWNrSXRlbSBpZiB0aGV5IGFyZSBjcmVhdGVkIHdpdGhpbiB0aW1lLWdhcFxuICAgKiBzbWFsbGVyIHRoYW4gYG9wdGlvbnMuY2FwdHVyZVRpbWVvdXRgLiBDYWxsIGB1bS5zdG9wQ2FwdHVyaW5nKClgIHNvIHRoYXQgdGhlIG5leHRcbiAgICogU3RhY2tJdGVtIHdvbid0IGJlIG1lcmdlZC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgIC8vIHdpdGhvdXQgc3RvcENhcHR1cmluZ1xuICAgKiAgICAgeXRleHQuaW5zZXJ0KDAsICdhJylcbiAgICogICAgIHl0ZXh0Lmluc2VydCgxLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJycgKG5vdGUgdGhhdCAnYWInIHdhcyByZW1vdmVkKVxuICAgKiAgICAgLy8gd2l0aCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2InKVxuICAgKiAgICAgdW0udW5kbygpXG4gICAqICAgICB5dGV4dC50b1N0cmluZygpIC8vID0+ICdhJyAobm90ZSB0aGF0IG9ubHkgJ2InIHdhcyByZW1vdmVkKVxuICAgKlxuICAgKi9cbiAgc3RvcENhcHR1cmluZyAoKSB7XG4gICAgdGhpcy5sYXN0Q2hhbmdlID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbmRvIGxhc3QgY2hhbmdlcyBvbiB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgdGhpcy51bmRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy51bmRvU3RhY2ssICd1bmRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudW5kb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogUmVkbyBsYXN0IHVuZG8gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgdGhpcy5yZWRvaW5nID0gdHJ1ZTtcbiAgICBsZXQgcmVzO1xuICAgIHRyeSB7XG4gICAgICByZXMgPSBwb3BTdGFja0l0ZW0odGhpcywgdGhpcy5yZWRvU3RhY2ssICdyZWRvJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVkb2luZyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogQXJlIHVuZG8gc3RlcHMgYXZhaWxhYmxlP1xuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdW5kbyBpcyBwb3NzaWJsZVxuICAgKi9cbiAgY2FuVW5kbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5kb1N0YWNrLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgcmVkbyBzdGVwcyBhdmFpbGFibGU/XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiByZWRvIGlzIHBvc3NpYmxlXG4gICAqL1xuICBjYW5SZWRvICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWRvU3RhY2subGVuZ3RoID4gMFxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucy5kZWxldGUodGhpcyk7XG4gICAgdGhpcy5kb2Mub2ZmKCdhZnRlclRyYW5zYWN0aW9uJywgdGhpcy5hZnRlclRyYW5zYWN0aW9uSGFuZGxlcik7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqL1xuZnVuY3Rpb24gKiBsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yIChkZWNvZGVyKSB7XG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtT2ZTdGF0ZVVwZGF0ZXM7IGkrKykge1xuICAgIGNvbnN0IG51bWJlck9mU3RydWN0cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kZXIucmVhZENsaWVudCgpO1xuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKCk7XG4gICAgICAvLyBAdG9kbyB1c2Ugc3dpdGNoIGluc3RlYWQgb2YgaWZzXG4gICAgICBpZiAoaW5mbyA9PT0gMTApIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2Rlcik7XG4gICAgICAgIHlpZWxkIG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pO1xuICAgICAgICBjbG9jayArPSBsZW47XG4gICAgICB9IGVsc2UgaWYgKChiaW5hcnkuQklUUzUgJiBpbmZvKSAhPT0gMCkge1xuICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDA7XG4gICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICBudWxsLCAvLyBsZWZ0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgIChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRm9yY2Ugd3JpdGluZyBhIHN0cmluZyBoZXJlLlxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgKTtcbiAgICAgICAgeWllbGQgc3RydWN0O1xuICAgICAgICBjbG9jayArPSBzdHJ1Y3QubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKCk7XG4gICAgICAgIHlpZWxkIG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKTtcbiAgICAgICAgY2xvY2sgKz0gbGVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBMYXp5U3RydWN0UmVhZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyU2tpcHNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyLCBmaWx0ZXJTa2lwcykge1xuICAgIHRoaXMuZ2VuID0gbGF6eVN0cnVjdFJlYWRlckdlbmVyYXRvcihkZWNvZGVyKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEl0ZW0gfCBTa2lwIHwgR0N9XG4gICAgICovXG4gICAgdGhpcy5jdXJyID0gbnVsbDtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLmZpbHRlclNraXBzID0gZmlsdGVyU2tpcHM7XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlbSB8IEdDIHwgU2tpcCB8bnVsbH1cbiAgICovXG4gIG5leHQgKCkge1xuICAgIC8vIGlnbm9yZSBcIlNraXBcIiBzdHJ1Y3RzXG4gICAgZG8ge1xuICAgICAgdGhpcy5jdXJyID0gdGhpcy5nZW4ubmV4dCgpLnZhbHVlIHx8IG51bGw7XG4gICAgfSB3aGlsZSAodGhpcy5maWx0ZXJTa2lwcyAmJiB0aGlzLmN1cnIgIT09IG51bGwgJiYgdGhpcy5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwKVxuICAgIHJldHVybiB0aGlzLmN1cnJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKlxuICovXG5jb25zdCBsb2dVcGRhdGUgPSB1cGRhdGUgPT4gbG9nVXBkYXRlVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKlxuICovXG5jb25zdCBsb2dVcGRhdGVWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSBbXTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpO1xuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKTtcbiAgZm9yIChsZXQgY3VyciA9IGxhenlEZWNvZGVyLmN1cnI7IGN1cnIgIT09IG51bGw7IGN1cnIgPSBsYXp5RGVjb2Rlci5uZXh0KCkpIHtcbiAgICBzdHJ1Y3RzLnB1c2goY3Vycik7XG4gIH1cbiAgbG9nZ2luZy5wcmludCgnU3RydWN0czogJywgc3RydWN0cyk7XG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKTtcbiAgbG9nZ2luZy5wcmludCgnRGVsZXRlU2V0OiAnLCBkcyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKlxuICovXG5jb25zdCBkZWNvZGVVcGRhdGUgPSAodXBkYXRlKSA9PiBkZWNvZGVVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqXG4gKi9cbmNvbnN0IGRlY29kZVVwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cnVjdHMsXG4gICAgZHM6IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2RlcilcbiAgfVxufTtcblxuY2xhc3MgTGF6eVN0cnVjdFdyaXRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVuY29kZXIpIHtcbiAgICB0aGlzLmN1cnJDbGllbnQgPSAwO1xuICAgIHRoaXMuc3RhcnRDbG9jayA9IDA7XG4gICAgdGhpcy53cml0dGVuID0gMDtcbiAgICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyO1xuICAgIC8qKlxuICAgICAqIFdlIHdhbnQgdG8gd3JpdGUgb3BlcmF0aW9ucyBsYXppbHksIGJ1dCBhbHNvIHdlIG5lZWQgdG8ga25vdyBiZWZvcmVoYW5kIGhvdyBtYW55IG9wZXJhdGlvbnMgd2Ugd2FudCB0byB3cml0ZSBmb3IgZWFjaCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIGtpbmQgb2YgbWV0YS1pbmZvcm1hdGlvbiAoI2NsaWVudHMsICNzdHJ1Y3RzLXBlci1jbGllbnQtd3JpdHRlbikgaXMgd3JpdHRlbiB0byB0aGUgcmVzdEVuY29kZXIuXG4gICAgICpcbiAgICAgKiBXZSBmcmFnbWVudCB0aGUgcmVzdEVuY29kZXIgYW5kIHN0b3JlIGEgc2xpY2Ugb2YgaXQgcGVyLWNsaWVudCB1bnRpbCB3ZSBrbm93IGhvdyBtYW55IGNsaWVudHMgdGhlcmUgYXJlLlxuICAgICAqIFdoZW4gd2UgZmx1c2ggKHRvVWludDhBcnJheSkgd2Ugd3JpdGUgdGhlIHJlc3RFbmNvZGVyIHVzaW5nIHRoZSBmcmFnbWVudHMgYW5kIHRoZSBtZXRhLWluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge0FycmF5PHsgd3JpdHRlbjogbnVtYmVyLCByZXN0RW5jb2RlcjogVWludDhBcnJheSB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudFN0cnVjdHMgPSBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8VWludDhBcnJheT59IHVwZGF0ZXNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IG1lcmdlVXBkYXRlcyA9IHVwZGF0ZXMgPT4gbWVyZ2VVcGRhdGVzVjIodXBkYXRlcywgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBEU0VuY29kZXJWMSB8IHR5cGVvZiBEU0VuY29kZXJWMn0gWUVuY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMiA9ICh1cGRhdGUsIFlFbmNvZGVyID0gRFNFbmNvZGVyVjIsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgWUVuY29kZXIoKTtcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSk7XG4gIGxldCBjdXJyID0gdXBkYXRlRGVjb2Rlci5jdXJyO1xuICBpZiAoY3VyciAhPT0gbnVsbCkge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGxldCBzdG9wQ291bnRpbmcgPSBjdXJyLmlkLmNsb2NrICE9PSAwOyAvLyBtdXN0IHN0YXJ0IGF0IDBcbiAgICBsZXQgY3VyckNsb2NrID0gc3RvcENvdW50aW5nID8gMCA6IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aDtcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgaWYgKGN1cnJDbG9jayAhPT0gMCkge1xuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgICAvLyB3cml0ZSB3aGF0IHdlIGhhdmUgdG8gdGhlIGVuY29kZXJcbiAgICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudCk7XG4gICAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbG9jayk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgICAgICBjdXJyQ2xvY2sgPSAwO1xuICAgICAgICBzdG9wQ291bnRpbmcgPSBjdXJyLmlkLmNsb2NrICE9PSAwO1xuICAgICAgfVxuICAgICAgLy8gd2UgaWdub3JlIHNraXBzXG4gICAgICBpZiAoY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICBzdG9wQ291bnRpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFzdG9wQ291bnRpbmcpIHtcbiAgICAgICAgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyB3cml0ZSB3aGF0IHdlIGhhdmVcbiAgICBpZiAoY3VyckNsb2NrICE9PSAwKSB7XG4gICAgICBzaXplKys7XG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudCk7XG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKTtcbiAgICB9XG4gICAgLy8gcHJlcGVuZCB0aGUgc2l6ZSBvZiB0aGUgc3RhdGUgdmVjdG9yXG4gICAgY29uc3QgZW5jID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpO1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmMsIHNpemUpO1xuICAgIGVuY29kaW5nLndyaXRlQmluYXJ5RW5jb2RlcihlbmMsIGVuY29kZXIucmVzdEVuY29kZXIpO1xuICAgIGVuY29kZXIucmVzdEVuY29kZXIgPSBlbmM7XG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgMCk7XG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlID0gdXBkYXRlID0+IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyKHVwZGF0ZSwgRFNFbmNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMSk7XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFlEZWNvZGVyXG4gKiBAcmV0dXJuIHt7IGZyb206IE1hcDxudW1iZXIsbnVtYmVyPiwgdG86IE1hcDxudW1iZXIsbnVtYmVyPiB9fVxuICovXG5jb25zdCBwYXJzZVVwZGF0ZU1ldGFWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIGNvbnN0IGZyb20gPSBuZXcgTWFwKCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIGNvbnN0IHRvID0gbmV3IE1hcCgpO1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIobmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSksIGZhbHNlKTtcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnI7XG4gIGlmIChjdXJyICE9PSBudWxsKSB7XG4gICAgbGV0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudDtcbiAgICBsZXQgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jaztcbiAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgIGZyb20uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gICAgZm9yICg7IGN1cnIgIT09IG51bGw7IGN1cnIgPSB1cGRhdGVEZWNvZGVyLm5leHQoKSkge1xuICAgICAgaWYgKGN1cnJDbGllbnQgIT09IGN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgbmV3IGNsaWVudFxuICAgICAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICAgICAgdG8uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jayk7XG4gICAgICAgIC8vIHdyaXRlIHRoZSBiZWdpbm5pbmcgdG8gYGZyb21gXG4gICAgICAgIGZyb20uc2V0KGN1cnIuaWQuY2xpZW50LCBjdXJyLmlkLmNsb2NrKTtcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJDbGllbnRcbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgICAgfVxuICAgICAgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0aGUgZW5kIHRvIGB0b2BcbiAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKTtcbiAgfVxuICByZXR1cm4geyBmcm9tLCB0byB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcmV0dXJuIHt7IGZyb206IE1hcDxudW1iZXIsbnVtYmVyPiwgdG86IE1hcDxudW1iZXIsbnVtYmVyPiB9fVxuICovXG5jb25zdCBwYXJzZVVwZGF0ZU1ldGEgPSB1cGRhdGUgPT4gcGFyc2VVcGRhdGVNZXRhVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIHNsaWNlIGFueSBraW5kIG9mIHN0cnVjdCBhbmQgcmV0cmlldmUgdGhlIHJpZ2h0IHBhcnQuXG4gKiBJdCBkb2VzIG5vdCBoYW5kbGUgc2lkZS1lZmZlY3RzLCBzbyBpdCBzaG91bGQgb25seSBiZSB1c2VkIGJ5IHRoZSBsYXp5LWVuY29kZXIuXG4gKlxuICogQHBhcmFtIHtJdGVtIHwgR0MgfCBTa2lwfSBsZWZ0XG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbSB8IEdDfVxuICovXG5jb25zdCBzbGljZVN0cnVjdCA9IChsZWZ0LCBkaWZmKSA9PiB7XG4gIGlmIChsZWZ0LmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgIGNvbnN0IHsgY2xpZW50LCBjbG9jayB9ID0gbGVmdC5pZDtcbiAgICByZXR1cm4gbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2UgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnQuaWQ7XG4gICAgcmV0dXJuIG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlZnRJdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCk7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZDtcbiAgICByZXR1cm4gbmV3IEl0ZW0oXG4gICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgICBudWxsLFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICAgIG51bGwsXG4gICAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICAgIGxlZnRJdGVtLnBhcmVudCxcbiAgICAgIGxlZnRJdGVtLnBhcmVudFN1YixcbiAgICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICAgKVxuICB9XG59O1xuXG4vKipcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIHNpbWlsYXJseSB0byBgcmVhZFVwZGF0ZVYyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBtZXJnZVVwZGF0ZXNWMiA9ICh1cGRhdGVzLCBZRGVjb2RlciA9IFVwZGF0ZURlY29kZXJWMiwgWUVuY29kZXIgPSBVcGRhdGVFbmNvZGVyVjIpID0+IHtcbiAgaWYgKHVwZGF0ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHVwZGF0ZXNbMF1cbiAgfVxuICBjb25zdCB1cGRhdGVEZWNvZGVycyA9IHVwZGF0ZXMubWFwKHVwZGF0ZSA9PiBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSk7XG4gIGxldCBsYXp5U3RydWN0RGVjb2RlcnMgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiBuZXcgTGF6eVN0cnVjdFJlYWRlcihkZWNvZGVyLCB0cnVlKSk7XG5cbiAgLyoqXG4gICAqIEB0b2RvIHdlIGRvbid0IG5lZWQgb2Zmc2V0IGJlY2F1c2Ugd2UgYWx3YXlzIHNsaWNlIGJlZm9yZVxuICAgKiBAdHlwZSB7bnVsbCB8IHsgc3RydWN0OiBJdGVtIHwgR0MgfCBTa2lwLCBvZmZzZXQ6IG51bWJlciB9fVxuICAgKi9cbiAgbGV0IGN1cnJXcml0ZSA9IG51bGw7XG5cbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICAvLyB3cml0ZSBzdHJ1Y3RzIGxhemlseVxuICBjb25zdCBsYXp5U3RydWN0RW5jb2RlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpO1xuXG4gIC8vIE5vdGU6IFdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGxhenlTdHJ1Y3REZWNvZGVycyBhcmUgZnVsbHkgY29uc3VtZWRcbiAgLy8gTm90ZTogU2hvdWxkIG1lcmdlIGRvY3VtZW50IHVwZGF0ZXMgd2hlbmV2ZXIgcG9zc2libGUgLSBldmVuIGZyb20gZGlmZmVyZW50IHVwZGF0ZXNcbiAgLy8gTm90ZTogU2hvdWxkIGhhbmRsZSB0aGF0IHNvbWUgb3BlcmF0aW9ucyBjYW5ub3QgYmUgYXBwbGllZCB5ZXQgKClcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFdyaXRlIGhpZ2hlciBjbGllbnRzIGZpcnN0IOKHkiBzb3J0IGJ5IGNsaWVudElEICYgY2xvY2sgYW5kIHJlbW92ZSBkZWNvZGVycyB3aXRob3V0IGNvbnRlbnRcbiAgICBsYXp5U3RydWN0RGVjb2RlcnMgPSBsYXp5U3RydWN0RGVjb2RlcnMuZmlsdGVyKGRlYyA9PiBkZWMuY3VyciAhPT0gbnVsbCk7XG4gICAgbGF6eVN0cnVjdERlY29kZXJzLnNvcnQoXG4gICAgICAvKiogQHR5cGUge2Z1bmN0aW9uKGFueSxhbnkpOm51bWJlcn0gKi8gKGRlYzEsIGRlYzIpID0+IHtcbiAgICAgICAgaWYgKGRlYzEuY3Vyci5pZC5jbGllbnQgPT09IGRlYzIuY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgICBjb25zdCBjbG9ja0RpZmYgPSBkZWMxLmN1cnIuaWQuY2xvY2sgLSBkZWMyLmN1cnIuaWQuY2xvY2s7XG4gICAgICAgICAgaWYgKGNsb2NrRGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQHRvZG8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gc2tpcCBzaW5jZSB0aGUgc3RydWN0RGVjb2RlcnMgbXVzdCBmaWx0ZXIgU2tpcHMuXG4gICAgICAgICAgICByZXR1cm4gZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBkZWMyLmN1cnIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgIDogZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwID8gMSA6IC0xIC8vIHdlIGFyZSBmaWx0ZXJpbmcgc2tpcHMgYW55d2F5LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2tEaWZmXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWMyLmN1cnIuaWQuY2xpZW50IC0gZGVjMS5jdXJyLmlkLmNsaWVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKTtcbiAgICBpZiAobGF6eVN0cnVjdERlY29kZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgY29uc3QgY3VyckRlY29kZXIgPSBsYXp5U3RydWN0RGVjb2RlcnNbMF07XG4gICAgLy8gd3JpdGUgZnJvbSBjdXJyRGVjb2RlciB1bnRpbCB0aGUgbmV4dCBvcGVyYXRpb24gaXMgZnJvbSBhbm90aGVyIGNsaWVudCBvciBpZiBmaWxsZXItc3RydWN0XG4gICAgLy8gdGhlbiB3ZSBuZWVkIHRvIHJlb3JkZXIgdGhlIGRlY29kZXJzIGFuZCBmaW5kIHRoZSBuZXh0IG9wZXJhdGlvbiB0byB3cml0ZVxuICAgIGNvbnN0IGZpcnN0Q2xpZW50ID0gLyoqIEB0eXBlIHtJdGVtIHwgR0N9ICovIChjdXJyRGVjb2Rlci5jdXJyKS5pZC5jbGllbnQ7XG5cbiAgICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgICBsZXQgY3VyciA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDIHwgbnVsbH0gKi8gKGN1cnJEZWNvZGVyLmN1cnIpO1xuICAgICAgbGV0IGl0ZXJhdGVkID0gZmFsc2U7XG5cbiAgICAgIC8vIGl0ZXJhdGUgdW50aWwgd2UgZmluZCBzb21ldGhpbmcgdGhhdCB3ZSBoYXZlbid0IHdyaXR0ZW4gYWxyZWFkeVxuICAgICAgLy8gcmVtZW1iZXI6IGZpcnN0IHRoZSBoaWdoIGNsaWVudC1pZHMgYXJlIHdyaXR0ZW5cbiAgICAgIHdoaWxlIChjdXJyICE9PSBudWxsICYmIGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA8PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggJiYgY3Vyci5pZC5jbGllbnQgPj0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgY3VyciA9IGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgICAgaXRlcmF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBjdXJyID09PSBudWxsIHx8IC8vIGN1cnJlbnQgZGVjb2RlciBpcyBlbXB0eVxuICAgICAgICBjdXJyLmlkLmNsaWVudCAhPT0gZmlyc3RDbGllbnQgfHwgLy8gY2hlY2sgd2hldGhlciB0aGVyZSBpcyBhbm90aGVyIGRlY29kZXIgdGhhdCBoYXMgaGFzIHVwZGF0ZXMgZnJvbSBgZmlyc3RDbGllbnRgXG4gICAgICAgIChpdGVyYXRlZCAmJiBjdXJyLmlkLmNsb2NrID4gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoKSAvLyB0aGUgYWJvdmUgd2hpbGUgbG9vcCB3YXMgdXNlZCBhbmQgd2UgYXJlIHBvdGVudGlhbGx5IG1pc3NpbmcgdXBkYXRlc1xuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdENsaWVudCAhPT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpO1xuICAgICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogY3Vyciwgb2Zmc2V0OiAwIH07XG4gICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggPCBjdXJyLmlkLmNsb2NrKSB7XG4gICAgICAgICAgLy8gQHRvZG8gd3JpdGUgY3VyclN0cnVjdCAmIHNldCBjdXJyU3RydWN0ID0gU2tpcChjbG9jayA9IGN1cnJTdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyU3RydWN0Lmxlbmd0aCwgbGVuZ3RoID0gY3Vyci5pZC5jbG9jayAtIHNlbGYuY2xvY2spXG4gICAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgICAgIC8vIGV4dGVuZCBleGlzdGluZyBza2lwXG4gICAgICAgICAgICBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA9IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCAtIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2s7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjdXJyLmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayAtIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAdHlwZSB7U2tpcH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IFNraXAoY3JlYXRlSUQoZmlyc3RDbGllbnQsIGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCksIGRpZmYpO1xuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3QsIG9mZnNldDogMCB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA+PSBjdXJyLmlkLmNsb2NrKSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtIGN1cnIuaWQuY2xvY2s7XG4gICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICAgICAgICAvLyBwcmVmZXIgdG8gc2xpY2UgU2tpcCBiZWNhdXNlIHRoZSBvdGhlciBzdHJ1Y3QgbWlnaHQgY29udGFpbiBtb3JlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoIC09IGRpZmY7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gc2xpY2VTdHJ1Y3QoY3VyciwgZGlmZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY3VycldyaXRlLnN0cnVjdC5tZXJnZVdpdGgoLyoqIEB0eXBlIHthbnl9ICovIChjdXJyKSkpIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KTtcbiAgICAgICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0OiBjdXJyLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VyciksIG9mZnNldDogMCB9O1xuICAgICAgY3VyckRlY29kZXIubmV4dCgpO1xuICAgIH1cbiAgICBmb3IgKFxuICAgICAgbGV0IG5leHQgPSBjdXJyRGVjb2Rlci5jdXJyO1xuICAgICAgbmV4dCAhPT0gbnVsbCAmJiBuZXh0LmlkLmNsaWVudCA9PT0gZmlyc3RDbGllbnQgJiYgbmV4dC5pZC5jbG9jayA9PT0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIG5leHQuY29uc3RydWN0b3IgIT09IFNraXA7XG4gICAgICBuZXh0ID0gY3VyckRlY29kZXIubmV4dCgpXG4gICAgKSB7XG4gICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogbmV4dCwgb2Zmc2V0OiAwIH07XG4gICAgfVxuICB9XG4gIGlmIChjdXJyV3JpdGUgIT09IG51bGwpIHtcbiAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldCk7XG4gICAgY3VycldyaXRlID0gbnVsbDtcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5U3RydWN0RW5jb2Rlcik7XG5cbiAgY29uc3QgZHNzID0gdXBkYXRlRGVjb2RlcnMubWFwKGRlY29kZXIgPT4gcmVhZERlbGV0ZVNldChkZWNvZGVyKSk7XG4gIGNvbnN0IGRzID0gbWVyZ2VEZWxldGVTZXRzKGRzcyk7XG4gIHdyaXRlRGVsZXRlU2V0KHVwZGF0ZUVuY29kZXIsIGRzKTtcbiAgcmV0dXJuIHVwZGF0ZUVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc3ZcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjJ9IFtZRGVjb2Rlcl1cbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMSB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjJ9IFtZRW5jb2Rlcl1cbiAqL1xuY29uc3QgZGlmZlVwZGF0ZVYyID0gKHVwZGF0ZSwgc3YsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyLCBZRW5jb2RlciA9IFVwZGF0ZUVuY29kZXJWMikgPT4ge1xuICBjb25zdCBzdGF0ZSA9IGRlY29kZVN0YXRlVmVjdG9yKHN2KTtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpO1xuICBjb25zdCBsYXp5U3RydWN0V3JpdGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIoZW5jb2Rlcik7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKTtcbiAgY29uc3QgcmVhZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIoZGVjb2RlciwgZmFsc2UpO1xuICB3aGlsZSAocmVhZGVyLmN1cnIpIHtcbiAgICBjb25zdCBjdXJyID0gcmVhZGVyLmN1cnI7XG4gICAgY29uc3QgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50O1xuICAgIGNvbnN0IHN2Q2xvY2sgPSBzdGF0ZS5nZXQoY3VyckNsaWVudCkgfHwgMDtcbiAgICBpZiAocmVhZGVyLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgIC8vIHRoZSBmaXJzdCB3cml0dGVuIHN0cnVjdCBzaG91bGRuJ3QgYmUgYSBza2lwXG4gICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCA+IHN2Q2xvY2spIHtcbiAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RXcml0ZXIsIGN1cnIsIG1hdGgubWF4KHN2Q2xvY2sgLSBjdXJyLmlkLmNsb2NrLCAwKSk7XG4gICAgICByZWFkZXIubmV4dCgpO1xuICAgICAgd2hpbGUgKHJlYWRlci5jdXJyICYmIHJlYWRlci5jdXJyLmlkLmNsaWVudCA9PT0gY3VyckNsaWVudCkge1xuICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCByZWFkZXIuY3VyciwgMCk7XG4gICAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlYWQgdW50aWwgc29tZXRoaW5nIG5ldyBjb21lcyB1cFxuICAgICAgd2hpbGUgKHJlYWRlci5jdXJyICYmIHJlYWRlci5jdXJyLmlkLmNsaWVudCA9PT0gY3VyckNsaWVudCAmJiByZWFkZXIuY3Vyci5pZC5jbG9jayArIHJlYWRlci5jdXJyLmxlbmd0aCA8PSBzdkNsb2NrKSB7XG4gICAgICAgIHJlYWRlci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RXcml0ZXIpO1xuICAvLyB3cml0ZSBkc1xuICBjb25zdCBkcyA9IHJlYWREZWxldGVTZXQoZGVjb2Rlcik7XG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKTtcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gc3ZcbiAqL1xuY29uc3QgZGlmZlVwZGF0ZSA9ICh1cGRhdGUsIHN2KSA9PiBkaWZmVXBkYXRlVjIodXBkYXRlLCBzdiwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICovXG5jb25zdCBmbHVzaExhenlTdHJ1Y3RXcml0ZXIgPSBsYXp5V3JpdGVyID0+IHtcbiAgaWYgKGxhenlXcml0ZXIud3JpdHRlbiA+IDApIHtcbiAgICBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMucHVzaCh7IHdyaXR0ZW46IGxhenlXcml0ZXIud3JpdHRlbiwgcmVzdEVuY29kZXI6IGVuY29kaW5nLnRvVWludDhBcnJheShsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIpIH0pO1xuICAgIGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKTtcbiAgICBsYXp5V3JpdGVyLndyaXR0ZW4gPSAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7TGF6eVN0cnVjdFdyaXRlcn0gbGF6eVdyaXRlclxuICogQHBhcmFtIHtJdGVtIHwgR0N9IHN0cnVjdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICovXG5jb25zdCB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlciA9IChsYXp5V3JpdGVyLCBzdHJ1Y3QsIG9mZnNldCkgPT4ge1xuICAvLyBmbHVzaCBjdXJyIGlmIHdlIHN0YXJ0IGFub3RoZXIgY2xpZW50XG4gIGlmIChsYXp5V3JpdGVyLndyaXR0ZW4gPiAwICYmIGxhenlXcml0ZXIuY3VyckNsaWVudCAhPT0gc3RydWN0LmlkLmNsaWVudCkge1xuICAgIGZsdXNoTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyKTtcbiAgfVxuICBpZiAobGF6eVdyaXRlci53cml0dGVuID09PSAwKSB7XG4gICAgbGF6eVdyaXRlci5jdXJyQ2xpZW50ID0gc3RydWN0LmlkLmNsaWVudDtcbiAgICAvLyB3cml0ZSBuZXh0IGNsaWVudFxuICAgIGxhenlXcml0ZXIuZW5jb2Rlci53cml0ZUNsaWVudChzdHJ1Y3QuaWQuY2xpZW50KTtcbiAgICAvLyB3cml0ZSBzdGFydENsb2NrXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2Rlciwgc3RydWN0LmlkLmNsb2NrICsgb2Zmc2V0KTtcbiAgfVxuICBzdHJ1Y3Qud3JpdGUobGF6eVdyaXRlci5lbmNvZGVyLCBvZmZzZXQpO1xuICBsYXp5V3JpdGVyLndyaXR0ZW4rKztcbn07XG4vKipcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHdlIGNvbGxlY3RlZCBhbGwgcGFydHMgYW5kIHdhbnQgdG9cbiAqIHB1dCBhbGwgdGhlIHBhcnRzIHRvZ2V0aGVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLFxuICogeW91IGNhbiBjb250aW51ZSB1c2luZyB0aGUgVXBkYXRlRW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcgPSAobGF6eVdyaXRlcikgPT4ge1xuICBmbHVzaExhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlcik7XG5cbiAgLy8gdGhpcyBpcyBhIGZyZXNoIGVuY29kZXIgYmVjYXVzZSB3ZSBjYWxsZWQgZmx1c2hDdXJyXG4gIGNvbnN0IHJlc3RFbmNvZGVyID0gbGF6eVdyaXRlci5lbmNvZGVyLnJlc3RFbmNvZGVyO1xuXG4gIC8qKlxuICAgKiBOb3cgd2UgcHV0IGFsbCB0aGUgZnJhZ21lbnRzIHRvZ2V0aGVyLlxuICAgKiBUaGlzIHdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVDbGllbnRzU3RydWN0c2BcbiAgICovXG5cbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgLSBpLmUuIHRoZSBjbGllbnRzXG4gIGVuY29kaW5nLndyaXRlVmFyVWludChyZXN0RW5jb2RlciwgbGF6eVdyaXRlci5jbGllbnRTdHJ1Y3RzLmxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJ0U3RydWN0cyA9IGxhenlXcml0ZXIuY2xpZW50U3RydWN0c1tpXTtcbiAgICAvKipcbiAgICAgKiBXb3JrcyBzaW1pbGFybHkgdG8gYHdyaXRlU3RydWN0c2BcbiAgICAgKi9cbiAgICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChyZXN0RW5jb2RlciwgcGFydFN0cnVjdHMud3JpdHRlbik7XG4gICAgLy8gd3JpdGUgdGhlIHJlc3Qgb2YgdGhlIGZyYWdtZW50XG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OEFycmF5KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy5yZXN0RW5jb2Rlcik7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oSXRlbXxHQ3xTa2lwKTpJdGVtfEdDfFNraXB9IGJsb2NrVHJhbnNmb3JtZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFlEZWNvZGVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYxIH0gWUVuY29kZXJcbiAqL1xuY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdCA9ICh1cGRhdGUsIGJsb2NrVHJhbnNmb3JtZXIsIFlEZWNvZGVyLCBZRW5jb2RlcikgPT4ge1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSk7XG4gIGNvbnN0IGxhenlEZWNvZGVyID0gbmV3IExhenlTdHJ1Y3RSZWFkZXIodXBkYXRlRGVjb2RlciwgZmFsc2UpO1xuICBjb25zdCB1cGRhdGVFbmNvZGVyID0gbmV3IFlFbmNvZGVyKCk7XG4gIGNvbnN0IGxhenlXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcih1cGRhdGVFbmNvZGVyKTtcbiAgZm9yIChsZXQgY3VyciA9IGxhenlEZWNvZGVyLmN1cnI7IGN1cnIgIT09IG51bGw7IGN1cnIgPSBsYXp5RGVjb2Rlci5uZXh0KCkpIHtcbiAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5V3JpdGVyLCBibG9ja1RyYW5zZm9ybWVyKGN1cnIpLCAwKTtcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5V3JpdGVyKTtcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpO1xuICB3cml0ZURlbGV0ZVNldCh1cGRhdGVFbmNvZGVyLCBkcyk7XG4gIHJldHVybiB1cGRhdGVFbmNvZGVyLnRvVWludDhBcnJheSgpXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9iZnVzY2F0b3JPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy5mb3JtYXR0aW5nPXRydWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy5zdWJkb2NzPXRydWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy55eG1sPXRydWVdIFdoZXRoZXIgdG8gb2JmdXNjYXRlIG5vZGVOYW1lIC8gaG9va05hbWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IG9iZnVzY2F0b3JcbiAqL1xuY29uc3QgY3JlYXRlT2JmdXNjYXRvciA9ICh7IGZvcm1hdHRpbmcgPSB0cnVlLCBzdWJkb2NzID0gdHJ1ZSwgeXhtbCA9IHRydWUgfSA9IHt9KSA9PiB7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbWFwS2V5Q2FjaGUgPSBtYXAuY3JlYXRlKCk7XG4gIGNvbnN0IG5vZGVOYW1lQ2FjaGUgPSBtYXAuY3JlYXRlKCk7XG4gIGNvbnN0IGZvcm1hdHRpbmdLZXlDYWNoZSA9IG1hcC5jcmVhdGUoKTtcbiAgY29uc3QgZm9ybWF0dGluZ1ZhbHVlQ2FjaGUgPSBtYXAuY3JlYXRlKCk7XG4gIGZvcm1hdHRpbmdWYWx1ZUNhY2hlLnNldChudWxsLCBudWxsKTsgLy8gZW5kIG9mIGEgZm9ybWF0dGluZyByYW5nZSBzaG91bGQgYWx3YXlzIGJlIHRoZSBlbmQgb2YgYSBmb3JtYXR0aW5nIHJhbmdlXG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW18R0N8U2tpcH0gYmxvY2tcbiAgICogQHJldHVybiB7SXRlbXxHQ3xTa2lwfVxuICAgKi9cbiAgcmV0dXJuIGJsb2NrID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEdDOlxuICAgICAgY2FzZSBTa2lwOlxuICAgICAgICByZXR1cm4gYmxvY2tcbiAgICAgIGNhc2UgSXRlbToge1xuICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoYmxvY2spO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gaXRlbS5jb250ZW50O1xuICAgICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICBjYXNlIENvbnRlbnREZWxldGVkOlxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOiB7XG4gICAgICAgICAgICBpZiAoeXhtbCkge1xuICAgICAgICAgICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKGNvbnRlbnQpLnR5cGU7XG4gICAgICAgICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWVhtbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0eXBlLm5vZGVOYW1lID0gbWFwLnNldElmVW5kZWZpbmVkKG5vZGVOYW1lQ2FjaGUsIHR5cGUubm9kZU5hbWUsICgpID0+ICdub2RlLScgKyBpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFlYbWxIb29rKSB7XG4gICAgICAgICAgICAgICAgdHlwZS5ob29rTmFtZSA9IG1hcC5zZXRJZlVuZGVmaW5lZChub2RlTmFtZUNhY2hlLCB0eXBlLmhvb2tOYW1lLCAoKSA9PiAnaG9vay0nICsgaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEFueToge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEFueX0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgYy5hcnIgPSBjLmFyci5tYXAoKCkgPT4gaSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRCaW5hcnk6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRCaW5hcnl9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGMuY29udGVudCA9IG5ldyBVaW50OEFycmF5KFtpXSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnREb2M6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnREb2N9ICovIChjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChzdWJkb2NzKSB7XG4gICAgICAgICAgICAgIGMub3B0cyA9IHt9O1xuICAgICAgICAgICAgICBjLmRvYy5ndWlkID0gaSArICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRFbWJlZH0gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgYy5lbWJlZCA9IHt9O1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICBjLmtleSA9IG1hcC5zZXRJZlVuZGVmaW5lZChmb3JtYXR0aW5nS2V5Q2FjaGUsIGMua2V5LCAoKSA9PiBpICsgJycpO1xuICAgICAgICAgICAgICBjLnZhbHVlID0gbWFwLnNldElmVW5kZWZpbmVkKGZvcm1hdHRpbmdWYWx1ZUNhY2hlLCBjLnZhbHVlLCAoKSA9PiAoeyBpIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEpTT046IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRKU09OfSAqLyAoY29udGVudCk7XG4gICAgICAgICAgICBjLmFyciA9IGMuYXJyLm1hcCgoKSA9PiBpKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGNvbnRlbnQpO1xuICAgICAgICAgICAgYy5zdHIgPSBzdHJpbmcucmVwZWF0KChpICUgMTApICsgJycsIGMuc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gdW5rbm93biBjb250ZW50IHR5cGVcbiAgICAgICAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0ucGFyZW50U3ViKSB7XG4gICAgICAgICAgaXRlbS5wYXJlbnRTdWIgPSBtYXAuc2V0SWZVbmRlZmluZWQobWFwS2V5Q2FjaGUsIGl0ZW0ucGFyZW50U3ViLCAoKSA9PiBpICsgJycpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgICAgcmV0dXJuIGJsb2NrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB1bmtub3duIGJsb2NrLXR5cGVcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBvYmZ1c2NhdGVzIHRoZSBjb250ZW50IG9mIGEgWWpzIHVwZGF0ZS4gVGhpcyBpcyB1c2VmdWwgdG8gc2hhcmVcbiAqIGJ1Z2d5IFlqcyBkb2N1bWVudHMgd2hpbGUgc2lnbmlmaWNhbnRseSBsaW1pdGluZyB0aGUgcG9zc2liaWxpdHkgdGhhdCBhXG4gKiBkZXZlbG9wZXIgY2FuIG9uIHRoZSB1c2VyLiBOb3RlIHRoYXQgaXQgbWlnaHQgc3RpbGwgYmUgcG9zc2libGUgdG8gZGVkdWNlXG4gKiBzb21lIGluZm9ybWF0aW9uIGJ5IGFuYWx5emluZyB0aGUgXCJzdHJ1Y3R1cmVcIiBvZiB0aGUgZG9jdW1lbnQgb3IgYnkgYW5hbHl6aW5nXG4gKiB0aGUgdHlwaW5nIGJlaGF2aW9yIHVzaW5nIHRoZSBDUkRULXJlbGF0ZWQgbWV0YWRhdGEgdGhhdCBpcyBzdGlsbCBrZXB0IGZ1bGx5XG4gKiBpbnRhY3QuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IFtvcHRzXVxuICovXG5jb25zdCBvYmZ1c2NhdGVVcGRhdGUgPSAodXBkYXRlLCBvcHRzKSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgY3JlYXRlT2JmdXNjYXRvcihvcHRzKSwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjEpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBbb3B0c11cbiAqL1xuY29uc3Qgb2JmdXNjYXRlVXBkYXRlVjIgPSAodXBkYXRlLCBvcHRzKSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgY3JlYXRlT2JmdXNjYXRvcihvcHRzKSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjIpO1xuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKi9cbmNvbnN0IGNvbnZlcnRVcGRhdGVGb3JtYXRWMVRvVjIgPSB1cGRhdGUgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGYuaWQsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyKTtcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5jb25zdCBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxID0gdXBkYXRlID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBmLmlkLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSk7XG5cbi8qKlxuICogQHRlbXBsYXRlIHtBYnN0cmFjdFR5cGU8YW55Pn0gVFxuICogWUV2ZW50IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlUeXBlLlxuICovXG5jbGFzcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtUfSB0YXJnZXQgVGhlIGNoYW5nZWQgdHlwZS5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0YXJnZXQsIHRyYW5zYWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb24gd2hpY2ggdGhpcyBldmVudCB3YXMgY3JlYXRlZCBvbi5cbiAgICAgKiBAdHlwZSB7VH1cbiAgICAgKi9cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCB0YXJnZXQgb24gd2hpY2ggdGhlIG9ic2VydmUgY2FsbGJhY2sgaXMgY2FsbGVkLlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fY2hhbmdlcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bGwgfCBNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgICAqL1xuICAgIHRoaXMuX2tleXMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8eyBpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+IHwgb2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT4sIHJldGFpbj86IG51bWJlciwgZGVsZXRlPzogbnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZywgYW55PiB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9kZWx0YSA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHBhdGggZnJvbSBgeWAgdG8gdGhlIGNoYW5nZWQgdHlwZS5cbiAgICpcbiAgICogQHRvZG8gdjE0IHNob3VsZCBzdGFuZGFyZGl6ZSBvbiBwYXRoOiBBcnJheTx7cGFyZW50LCBpbmRleH0+IGJlY2F1c2UgdGhhdCBpcyBlYXNpZXIgdG8gd29yayB3aXRoLlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHByb3BlcnR5IGhvbGRzOlxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGxldCB0eXBlID0geVxuICAgKiAgIGV2ZW50LnBhdGguZm9yRWFjaChkaXIgPT4ge1xuICAgKiAgICAgdHlwZSA9IHR5cGUuZ2V0KGRpcilcbiAgICogICB9KVxuICAgKiAgIHR5cGUgPT09IGV2ZW50LnRhcmdldCAvLyA9PiB0cnVlXG4gICAqL1xuICBnZXQgcGF0aCAoKSB7XG4gICAgLy8gQHRzLWlnbm9yZSBfaXRlbSBpcyBkZWZpbmVkIGJlY2F1c2UgdGFyZ2V0IGlzIGludGVncmF0ZWRcbiAgICByZXR1cm4gZ2V0UGF0aFRvKHRoaXMuY3VycmVudFRhcmdldCwgdGhpcy50YXJnZXQpXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSBzdHJ1Y3QgaXMgZGVsZXRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZWxldGVzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gaXNEZWxldGVkKHRoaXMudHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBzdHJ1Y3QuaWQpXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsIHsgYWN0aW9uOiAnYWRkJyB8ICd1cGRhdGUnIHwgJ2RlbGV0ZScsIG9sZFZhbHVlOiBhbnksIG5ld1ZhbHVlOiBhbnkgfT59XG4gICAqL1xuICBnZXQga2V5cyAoKSB7XG4gICAgaWYgKHRoaXMuX2tleXMgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldDtcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKTtcbiAgICAgIGNoYW5nZWQuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHRhcmdldC5fbWFwLmdldChrZXkpKTtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBAdHlwZSB7J2RlbGV0ZScgfCAnYWRkJyB8ICd1cGRhdGUnfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIGxldCBhY3Rpb247XG4gICAgICAgICAgbGV0IG9sZFZhbHVlO1xuICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gaXRlbS5sZWZ0O1xuICAgICAgICAgICAgd2hpbGUgKHByZXYgIT09IG51bGwgJiYgdGhpcy5hZGRzKHByZXYpKSB7XG4gICAgICAgICAgICAgIHByZXYgPSBwcmV2LmxlZnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdChwcmV2LmNvbnRlbnQuZ2V0Q29udGVudCgpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHByZXYgIT09IG51bGwgJiYgdGhpcy5kZWxldGVzKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ3VwZGF0ZSc7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdhZGQnO1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gYXJyYXkubGFzdCgvKiogQHR5cGUge0l0ZW19ICovIGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC8vIG5vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBrZXlzLnNldChrZXksIHsgYWN0aW9uLCBvbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2tleXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgY29tcHV0ZWQgcHJvcGVydHkuIE5vdGUgdGhhdCB0aGlzIGNhbiBvbmx5IGJlIHNhZmVseSBjb21wdXRlZCBkdXJpbmcgdGhlXG4gICAqIGV2ZW50IGNhbGwuIENvbXB1dGluZyB0aGlzIHByb3BlcnR5IGFmdGVyIG90aGVyIGNoYW5nZXMgaGFwcGVuZWQgbWlnaHQgcmVzdWx0IGluXG4gICAqIHVuZXhwZWN0ZWQgYmVoYXZpb3IgKGluY29ycmVjdCBjb21wdXRhdGlvbiBvZiBkZWx0YXMpLiBBIHNhZmUgd2F5IHRvIGNvbGxlY3QgY2hhbmdlc1xuICAgKiBpcyB0byBzdG9yZSB0aGUgYGNoYW5nZXNgIG9yIHRoZSBgZGVsdGFgIG9iamVjdC4gQXZvaWQgc3RvcmluZyB0aGUgYHRyYW5zYWN0aW9uYCBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0Pzogc3RyaW5nIHwgQXJyYXk8YW55PiB8IG9iamVjdCB8IEFic3RyYWN0VHlwZTxhbnk+LCByZXRhaW4/OiBudW1iZXIsIGRlbGV0ZT86IG51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsIGFueT59Pn1cbiAgICovXG4gIGdldCBkZWx0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlcy5kZWx0YVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGFkZGVkIGJ5IHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEluIGNvbnRyYXN0IHRvIGNoYW5nZS5kZWxldGVkLCB0aGlzIG1ldGhvZCBhbHNvIHJldHVybnMgdHJ1ZSBpZiB0aGUgc3RydWN0IHdhcyBhZGRlZCBhbmQgdGhlbiBkZWxldGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSBzdHJ1Y3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGFkZHMgKHN0cnVjdCkge1xuICAgIHJldHVybiBzdHJ1Y3QuaWQuY2xvY2sgPj0gKHRoaXMudHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KHN0cnVjdC5pZC5jbGllbnQpIHx8IDApXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZSBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZVxuICAgKiBldmVudCBjYWxsLiBDb21wdXRpbmcgdGhpcyBwcm9wZXJ0eSBhZnRlciBvdGhlciBjaGFuZ2VzIGhhcHBlbmVkIG1pZ2h0IHJlc3VsdCBpblxuICAgKiB1bmV4cGVjdGVkIGJlaGF2aW9yIChpbmNvcnJlY3QgY29tcHV0YXRpb24gb2YgZGVsdGFzKS4gQSBzYWZlIHdheSB0byBjb2xsZWN0IGNoYW5nZXNcbiAgICogaXMgdG8gc3RvcmUgdGhlIGBjaGFuZ2VzYCBvciB0aGUgYGRlbHRhYCBvYmplY3QuIEF2b2lkIHN0b3JpbmcgdGhlIGB0cmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZywgZGVsZXRlPzpudW1iZXIsIHJldGFpbj86bnVtYmVyfT59fVxuICAgKi9cbiAgZ2V0IGNoYW5nZXMgKCkge1xuICAgIGxldCBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlcztcbiAgICBpZiAoY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQ7XG4gICAgICBjb25zdCBhZGRlZCA9IHNldC5jcmVhdGUoKTtcbiAgICAgIGNvbnN0IGRlbGV0ZWQgPSBzZXQuY3JlYXRlKCk7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0OkFycmF5PGFueT59fHtkZWxldGU6bnVtYmVyfXx7cmV0YWluOm51bWJlcn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgY2hhbmdlcyA9IHtcbiAgICAgICAgYWRkZWQsXG4gICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIGRlbHRhLFxuICAgICAgICBrZXlzOiB0aGlzLmtleXNcbiAgICAgIH07XG4gICAgICBjb25zdCBjaGFuZ2VkID0gLyoqIEB0eXBlIFNldDxzdHJpbmd8bnVsbD4gKi8gKHRoaXMudHJhbnNhY3Rpb24uY2hhbmdlZC5nZXQodGFyZ2V0KSk7XG4gICAgICBpZiAoY2hhbmdlZC5oYXMobnVsbCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHthbnl9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGFzdE9wID0gbnVsbDtcbiAgICAgICAgY29uc3QgcGFja09wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChsYXN0T3ApIHtcbiAgICAgICAgICAgIGRlbHRhLnB1c2gobGFzdE9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGl0ZW0gPSB0YXJnZXQuX3N0YXJ0OyBpdGVtICE9PSBudWxsOyBpdGVtID0gaXRlbS5yaWdodCkge1xuICAgICAgICAgIGlmIChpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkgJiYgIXRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICBpZiAobGFzdE9wID09PSBudWxsIHx8IGxhc3RPcC5kZWxldGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgZGVsZXRlOiAwIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmRlbGV0ZSArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgZGVsZXRlZC5hZGQoaXRlbSk7XG4gICAgICAgICAgICB9IC8vIGVsc2Ugbm9wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0T3AgPSB7IGluc2VydDogW10gfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuaW5zZXJ0ID0gbGFzdE9wLmluc2VydC5jb25jYXQoaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSk7XG4gICAgICAgICAgICAgIGFkZGVkLmFkZChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChsYXN0T3AgPT09IG51bGwgfHwgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja09wKCk7XG4gICAgICAgICAgICAgICAgbGFzdE9wID0geyByZXRhaW46IDAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AucmV0YWluICs9IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE9wICE9PSBudWxsICYmIGxhc3RPcC5yZXRhaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhY2tPcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlcztcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2hhbmdlcylcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBhdGggZnJvbSB0aGlzIHR5cGUgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gYGNoaWxkYCBzaG91bGQgYmUgYWNjZXNzaWJsZSB2aWEgYHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKS4uYFxuICogICBjb25zdCBwYXRoID0gdHlwZS5nZXRQYXRoVG8oY2hpbGQpXG4gKiAgIC8vIGFzc3VtaW5nIGB0eXBlIGluc3RhbmNlb2YgWUFycmF5YFxuICogICBjb25zb2xlLmxvZyhwYXRoKSAvLyBtaWdodCBsb29rIGxpa2UgPT4gWzIsICdrZXkxJ11cbiAqICAgY2hpbGQgPT09IHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gY2hpbGQgdGFyZ2V0XG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gUGF0aCB0byB0aGUgdGFyZ2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRQYXRoVG8gPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBjb25zdCBwYXRoID0gW107XG4gIHdoaWxlIChjaGlsZC5faXRlbSAhPT0gbnVsbCAmJiBjaGlsZCAhPT0gcGFyZW50KSB7XG4gICAgaWYgKGNoaWxkLl9pdGVtLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgLy8gcGFyZW50IGlzIG1hcC1pc2hcbiAgICAgIHBhdGgudW5zaGlmdChjaGlsZC5faXRlbS5wYXJlbnRTdWIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgYXJyYXktaXNoXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBsZXQgYyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpLl9zdGFydDtcbiAgICAgIHdoaWxlIChjICE9PSBjaGlsZC5faXRlbSAmJiBjICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghYy5kZWxldGVkKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGMgPSBjLnJpZ2h0O1xuICAgICAgfVxuICAgICAgcGF0aC51bnNoaWZ0KGkpO1xuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpO1xuICB9XG4gIHJldHVybiBwYXRoXG59O1xuXG5jb25zdCBtYXhTZWFyY2hNYXJrZXIgPSA4MDtcblxuLyoqXG4gKiBBIHVuaXF1ZSB0aW1lc3RhbXAgdGhhdCBpZGVudGlmaWVzIGVhY2ggbWFya2VyLlxuICpcbiAqIFRpbWUgaXMgcmVsYXRpdmUsLi4gdGhpcyBpcyBtb3JlIGxpa2UgYW4gZXZlci1pbmNyZWFzaW5nIGNsb2NrLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbmxldCBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXAgPSAwO1xuXG5jbGFzcyBBcnJheVNlYXJjaE1hcmtlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW19IHBcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBjb25zdHJ1Y3RvciAocCwgaW5kZXgpIHtcbiAgICBwLm1hcmtlciA9IHRydWU7XG4gICAgdGhpcy5wID0gcDtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKztcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlTZWFyY2hNYXJrZXJ9IG1hcmtlclxuICovXG5jb25zdCByZWZyZXNoTWFya2VyVGltZXN0YW1wID0gbWFya2VyID0+IHsgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrOyB9O1xuXG4vKipcbiAqIFRoaXMgaXMgcmF0aGVyIGNvbXBsZXggc28gdGhpcyBmdW5jdGlvbiBpcyB0aGUgb25seSB0aGluZyB0aGF0IHNob3VsZCBvdmVyd3JpdGUgYSBtYXJrZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5U2VhcmNoTWFya2VyfSBtYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG92ZXJ3cml0ZU1hcmtlciA9IChtYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIG1hcmtlci5wLm1hcmtlciA9IGZhbHNlO1xuICBtYXJrZXIucCA9IHA7XG4gIHAubWFya2VyID0gdHJ1ZTtcbiAgbWFya2VyLmluZGV4ID0gaW5kZXg7XG4gIG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArKztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj59IHNlYXJjaE1hcmtlclxuICogQHBhcmFtIHtJdGVtfSBwXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqL1xuY29uc3QgbWFya1Bvc2l0aW9uID0gKHNlYXJjaE1hcmtlciwgcCwgaW5kZXgpID0+IHtcbiAgaWYgKHNlYXJjaE1hcmtlci5sZW5ndGggPj0gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gb3ZlcnJpZGUgb2xkZXN0IG1hcmtlciAod2UgZG9uJ3Qgd2FudCB0byBjcmVhdGUgbW9yZSBvYmplY3RzKVxuICAgIGNvbnN0IG1hcmtlciA9IHNlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IGEudGltZXN0YW1wIDwgYi50aW1lc3RhbXAgPyBhIDogYik7XG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgaW5kZXgpO1xuICAgIHJldHVybiBtYXJrZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBjcmVhdGUgbmV3IG1hcmtlclxuICAgIGNvbnN0IHBtID0gbmV3IEFycmF5U2VhcmNoTWFya2VyKHAsIGluZGV4KTtcbiAgICBzZWFyY2hNYXJrZXIucHVzaChwbSk7XG4gICAgcmV0dXJuIHBtXG4gIH1cbn07XG5cbi8qKlxuICogU2VhcmNoIG1hcmtlciBoZWxwIHVzIHRvIGZpbmQgcG9zaXRpb25zIGluIHRoZSBhc3NvY2lhdGl2ZSBhcnJheSBmYXN0ZXIuXG4gKlxuICogVGhleSBzcGVlZCB1cCB0aGUgcHJvY2VzcyBvZiBmaW5kaW5nIGEgcG9zaXRpb24gd2l0aG91dCBtdWNoIGJvb2trZWVwaW5nLlxuICpcbiAqIEEgbWF4aW11bSBvZiBgbWF4U2VhcmNoTWFya2VyYCBvYmplY3RzIGFyZSBjcmVhdGVkLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWx3YXlzIHJldHVybnMgYSByZWZyZXNoZWQgbWFya2VyICh1cGRhdGVkIHRpbWVzdGFtcClcbiAqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB5YXJyYXlcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBmaW5kTWFya2VyID0gKHlhcnJheSwgaW5kZXgpID0+IHtcbiAgaWYgKHlhcnJheS5fc3RhcnQgPT09IG51bGwgfHwgaW5kZXggPT09IDAgfHwgeWFycmF5Ll9zZWFyY2hNYXJrZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IG1hcmtlciA9IHlhcnJheS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB5YXJyYXkuX3NlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IG1hdGguYWJzKGluZGV4IC0gYS5pbmRleCkgPCBtYXRoLmFicyhpbmRleCAtIGIuaW5kZXgpID8gYSA6IGIpO1xuICBsZXQgcCA9IHlhcnJheS5fc3RhcnQ7XG4gIGxldCBwaW5kZXggPSAwO1xuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgcCA9IG1hcmtlci5wO1xuICAgIHBpbmRleCA9IG1hcmtlci5pbmRleDtcbiAgICByZWZyZXNoTWFya2VyVGltZXN0YW1wKG1hcmtlcik7IC8vIHdlIHVzZWQgaXQsIHdlIG1pZ2h0IG5lZWQgdG8gdXNlIGl0IGFnYWluXG4gIH1cbiAgLy8gaXRlcmF0ZSB0byByaWdodCBpZiBwb3NzaWJsZVxuICB3aGlsZSAocC5yaWdodCAhPT0gbnVsbCAmJiBwaW5kZXggPCBpbmRleCkge1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBwaW5kZXggKyBwLmxlbmd0aCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGluZGV4ICs9IHAubGVuZ3RoO1xuICAgIH1cbiAgICBwID0gcC5yaWdodDtcbiAgfVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgaWYgbmVjZXNzYXJ5IChtaWdodCBiZSB0aGF0IHBpbmRleCA+IGluZGV4KVxuICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsICYmIHBpbmRleCA+IGluZGV4KSB7XG4gICAgcCA9IHAubGVmdDtcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgcGluZGV4IC09IHAubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHAgY2FuJ3QgYmUgbWVyZ2VkIHdpdGggbGVmdCwgYmVjYXVzZSB0aGF0IHdvdWxkIHNjcmV3IHVwIGV2ZXJ5dGhpbmdcbiAgLy8gaW4gdGhhdCBjYXMganVzdCByZXR1cm4gd2hhdCB3ZSBoYXZlIChpdCBpcyBtb3N0IGxpa2VseSB0aGUgYmVzdCBtYXJrZXIgYW55d2F5KVxuICAvLyBpdGVyYXRlIHRvIGxlZnQgdW50aWwgcCBjYW4ndCBiZSBtZXJnZWQgd2l0aCBsZWZ0XG4gIHdoaWxlIChwLmxlZnQgIT09IG51bGwgJiYgcC5sZWZ0LmlkLmNsaWVudCA9PT0gcC5pZC5jbGllbnQgJiYgcC5sZWZ0LmlkLmNsb2NrICsgcC5sZWZ0Lmxlbmd0aCA9PT0gcC5pZC5jbG9jaykge1xuICAgIHAgPSBwLmxlZnQ7XG4gICAgaWYgKCFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgIHBpbmRleCAtPSBwLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICAvLyBAdG9kbyByZW1vdmUhXG4gIC8vIGFzc3VyZSBwb3NpdGlvblxuICAvLyB7XG4gIC8vICAgbGV0IHN0YXJ0ID0geWFycmF5Ll9zdGFydFxuICAvLyAgIGxldCBwb3MgPSAwXG4gIC8vICAgd2hpbGUgKHN0YXJ0ICE9PSBwKSB7XG4gIC8vICAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQgJiYgc3RhcnQuY291bnRhYmxlKSB7XG4gIC8vICAgICAgIHBvcyArPSBzdGFydC5sZW5ndGhcbiAgLy8gICAgIH1cbiAgLy8gICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpXG4gIC8vICAgfVxuICAvLyAgIGlmIChwb3MgIT09IHBpbmRleCkge1xuICAvLyAgICAgZGVidWdnZXJcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcignR290Y2hhIHBvc2l0aW9uIGZhaWwhJylcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gaWYgKG1hcmtlcikge1xuICAvLyAgIGlmICh3aW5kb3cubGVuZ3RoZXMgPT0gbnVsbCkge1xuICAvLyAgICAgd2luZG93Lmxlbmd0aGVzID0gW11cbiAgLy8gICAgIHdpbmRvdy5nZXRMZW5ndGhlcyA9ICgpID0+IHdpbmRvdy5sZW5ndGhlcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgLy8gICB9XG4gIC8vICAgd2luZG93Lmxlbmd0aGVzLnB1c2gobWFya2VyLmluZGV4IC0gcGluZGV4KVxuICAvLyAgIGNvbnNvbGUubG9nKCdkaXN0YW5jZScsIG1hcmtlci5pbmRleCAtIHBpbmRleCwgJ2xlbicsIHAgJiYgcC5wYXJlbnQubGVuZ3RoKVxuICAvLyB9XG4gIGlmIChtYXJrZXIgIT09IG51bGwgJiYgbWF0aC5hYnMobWFya2VyLmluZGV4IC0gcGluZGV4KSA8IC8qKiBAdHlwZSB7WVRleHR8WUFycmF5PGFueT59ICovIChwLnBhcmVudCkubGVuZ3RoIC8gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gYWRqdXN0IGV4aXN0aW5nIG1hcmtlclxuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIHBpbmRleCk7XG4gICAgcmV0dXJuIG1hcmtlclxuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBuZXcgbWFya2VyXG4gICAgcmV0dXJuIG1hcmtQb3NpdGlvbih5YXJyYXkuX3NlYXJjaE1hcmtlciwgcCwgcGluZGV4KVxuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBtYXJrZXJzIHdoZW4gYSBjaGFuZ2UgaGFwcGVuZWQuXG4gKlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBkb2luZyBhIGRlbGV0aW9uIVxuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBJZiBpbnNlcnRpb24sIGxlbiBpcyBwb3NpdGl2ZS4gSWYgZGVsZXRpb24sIGxlbiBpcyBuZWdhdGl2ZS5cbiAqL1xuY29uc3QgdXBkYXRlTWFya2VyQ2hhbmdlcyA9IChzZWFyY2hNYXJrZXIsIGluZGV4LCBsZW4pID0+IHtcbiAgZm9yIChsZXQgaSA9IHNlYXJjaE1hcmtlci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IG0gPSBzZWFyY2hNYXJrZXJbaV07XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHAgPSBtLnA7XG4gICAgICBwLm1hcmtlciA9IGZhbHNlO1xuICAgICAgLy8gSWRlYWxseSB3ZSBqdXN0IHdhbnQgdG8gZG8gYSBzaW1wbGUgcG9zaXRpb24gY29tcGFyaXNvbiwgYnV0IHRoaXMgd2lsbCBvbmx5IHdvcmsgaWZcbiAgICAgIC8vIHNlYXJjaCBtYXJrZXJzIGRvbid0IHBvaW50IHRvIGRlbGV0ZWQgaXRlbXMgZm9yIGZvcm1hdHMuXG4gICAgICAvLyBJdGVyYXRlIG1hcmtlciB0byBwcmV2IHVuZGVsZXRlZCBjb3VudGFibGUgcG9zaXRpb24gc28gd2Uga25vdyB3aGF0IHRvIGRvIHdoZW4gdXBkYXRpbmcgYSBwb3NpdGlvblxuICAgICAgd2hpbGUgKHAgJiYgKHAuZGVsZXRlZCB8fCAhcC5jb3VudGFibGUpKSB7XG4gICAgICAgIHAgPSBwLmxlZnQ7XG4gICAgICAgIGlmIChwICYmICFwLmRlbGV0ZWQgJiYgcC5jb3VudGFibGUpIHtcbiAgICAgICAgICAvLyBhZGp1c3QgcG9zaXRpb24uIHRoZSBsb29wIHNob3VsZCBicmVhayBub3dcbiAgICAgICAgICBtLmluZGV4IC09IHAubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gbnVsbCB8fCBwLm1hcmtlciA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyByZW1vdmUgc2VhcmNoIG1hcmtlciBpZiB1cGRhdGVkIHBvc2l0aW9uIGlzIG51bGwgb3IgaWYgcG9zaXRpb24gaXMgYWxyZWFkeSBtYXJrZWRcbiAgICAgICAgc2VhcmNoTWFya2VyLnNwbGljZShpLCAxKTtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIG0ucCA9IHA7XG4gICAgICBwLm1hcmtlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpbmRleCA8IG0uaW5kZXggfHwgKGxlbiA+IDAgJiYgaW5kZXggPT09IG0uaW5kZXgpKSB7IC8vIGEgc2ltcGxlIGluZGV4IDw9IG0uaW5kZXggY2hlY2sgd291bGQgYWN0dWFsbHkgc3VmZmljZVxuICAgICAgbS5pbmRleCA9IG1hdGgubWF4KGluZGV4LCBtLmluZGV4ICsgbGVuKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWNjdW11bGF0ZSBhbGwgKGxpc3QpIGNoaWxkcmVuIG9mIGEgdHlwZSBhbmQgcmV0dXJuIHRoZW0gYXMgYW4gQXJyYXkuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdFxuICogQHJldHVybiB7QXJyYXk8SXRlbT59XG4gKi9cbmNvbnN0IGdldFR5cGVDaGlsZHJlbiA9IHQgPT4ge1xuICBsZXQgcyA9IHQuX3N0YXJ0O1xuICBjb25zdCBhcnIgPSBbXTtcbiAgd2hpbGUgKHMpIHtcbiAgICBhcnIucHVzaChzKTtcbiAgICBzID0gcy5yaWdodDtcbiAgfVxuICByZXR1cm4gYXJyXG59O1xuXG4vKipcbiAqIENhbGwgZXZlbnQgbGlzdGVuZXJzIHdpdGggYW4gZXZlbnQuIFRoaXMgd2lsbCBhbHNvIGFkZCBhbiBldmVudCB0byBhbGxcbiAqIHBhcmVudHMgKGZvciBgLm9ic2VydmVEZWVwYCBoYW5kbGVycykuXG4gKlxuICogQHRlbXBsYXRlIEV2ZW50VHlwZVxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn0gdHlwZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXZlbnRUeXBlfSBldmVudFxuICovXG5jb25zdCBjYWxsVHlwZU9ic2VydmVycyA9ICh0eXBlLCB0cmFuc2FjdGlvbiwgZXZlbnQpID0+IHtcbiAgY29uc3QgY2hhbmdlZFR5cGUgPSB0eXBlO1xuICBjb25zdCBjaGFuZ2VkUGFyZW50VHlwZXMgPSB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXM7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIG1hcC5zZXRJZlVuZGVmaW5lZChjaGFuZ2VkUGFyZW50VHlwZXMsIHR5cGUsICgpID0+IFtdKS5wdXNoKGV2ZW50KTtcbiAgICBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdHlwZSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0eXBlLl9pdGVtLnBhcmVudCk7XG4gIH1cbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyhjaGFuZ2VkVHlwZS5fZUgsIGV2ZW50LCB0cmFuc2FjdGlvbik7XG59O1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBFdmVudFR5cGVcbiAqIEFic3RyYWN0IFlqcyBUeXBlIGNsYXNzXG4gKi9cbmNsYXNzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLEl0ZW0+fVxuICAgICAqL1xuICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RG9jfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEV2ZW50VHlwZSxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fZUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKTtcbiAgICAvKipcbiAgICAgKiBEZWVwIGV2ZW50IGhhbmRsZXJzXG4gICAgICogQHR5cGUge0V2ZW50SGFuZGxlcjxBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX2RFSCA9IGNyZWF0ZUV2ZW50SGFuZGxlcigpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT58bnVsbH1cbiAgICovXG4gIGdldCBwYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMuX2l0ZW0ucGFyZW50KSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHRoaXMuZG9jID0geTtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn1cbiAgICovXG4gIGNsb25lICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gX2VuY29kZXJcbiAgICovXG4gIF93cml0ZSAoX2VuY29kZXIpIHsgfVxuXG4gIC8qKlxuICAgKiBUaGUgZmlyc3Qgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IF9maXJzdCAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWUV2ZW50IGFuZCBjYWxscyBhbGwgdHlwZSBvYnNlcnZlcnMuXG4gICAqIE11c3QgYmUgaW1wbGVtZW50ZWQgYnkgZWFjaCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IF9wYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBfcGFyZW50U3Vicykge1xuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdGhpcy5fc2VhcmNoTWFya2VyKSB7XG4gICAgICB0aGlzLl9zZWFyY2hNYXJrZXIubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgb24gdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSwgVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIG9ic2VydmUgKGYpIHtcbiAgICBhZGRFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9lSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhpcyB0eXBlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlRGVlcCAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZSAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2VILCBmKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlRGVlcCAoZikge1xuICAgIHJlbW92ZUV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZik7XG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHRvSlNPTiAoKSB7fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0U2xpY2UgPSAodHlwZSwgc3RhcnQsIGVuZCkgPT4ge1xuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSB0eXBlLl9sZW5ndGggKyBzdGFydDtcbiAgfVxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IHR5cGUuX2xlbmd0aCArIGVuZDtcbiAgfVxuICBsZXQgbGVuID0gZW5kIC0gc3RhcnQ7XG4gIGNvbnN0IGNzID0gW107XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIHdoaWxlIChuICE9PSBudWxsICYmIGxlbiA+IDApIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBpZiAoYy5sZW5ndGggPD0gc3RhcnQpIHtcbiAgICAgICAgc3RhcnQgLT0gYy5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjLmxlbmd0aCAmJiBsZW4gPiAwOyBpKyspIHtcbiAgICAgICAgICBjcy5wdXNoKGNbaV0pO1xuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdFRvQXJyYXkgPSB0eXBlID0+IHtcbiAgY29uc3QgY3MgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RUb0FycmF5U25hcHNob3QgPSAodHlwZSwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgY3MgPSBbXTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3MucHVzaChjW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHQ7XG4gIH1cbiAgcmV0dXJuIGNzXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LG51bWJlcixhbnkpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEZvckVhY2ggPSAodHlwZSwgZikgPT4ge1xuICBsZXQgaW5kZXggPSAwO1xuICBsZXQgbiA9IHR5cGUuX3N0YXJ0O1xuICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGNbaV0sIGluZGV4KyssIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodDtcbiAgfVxufTtcblxuLyoqXG4gKiBAdGVtcGxhdGUgQyxSXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEMsbnVtYmVyLEFic3RyYWN0VHlwZTxhbnk+KTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0TWFwID0gKHR5cGUsIGYpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIHR5cGVMaXN0Rm9yRWFjaCh0eXBlLCAoYywgaSkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKGYoYywgaSwgdHlwZSkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yID0gdHlwZSA9PiB7XG4gIGxldCBuID0gdHlwZS5fc3RhcnQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgKi9cbiAgbGV0IGN1cnJlbnRDb250ZW50ID0gbnVsbDtcbiAgbGV0IGN1cnJlbnRDb250ZW50SW5kZXggPSAwO1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAvLyBmaW5kIHNvbWUgY29udGVudFxuICAgICAgaWYgKGN1cnJlbnRDb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgIHdoaWxlIChuICE9PSBudWxsICYmIG4uZGVsZXRlZCkge1xuICAgICAgICAgIG4gPSBuLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHJlYWNoZWQgdGhlIGVuZCwgbm8gbmVlZCB0byBjaGVjayBjdXJyZW50Q29udGVudCwgYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdFxuICAgICAgICBpZiAobiA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBmb3VuZCBuLCBzbyB3ZSBjYW4gc2V0IGN1cnJlbnRDb250ZW50XG4gICAgICAgIGN1cnJlbnRDb250ZW50ID0gbi5jb250ZW50LmdldENvbnRlbnQoKTtcbiAgICAgICAgY3VycmVudENvbnRlbnRJbmRleCA9IDA7XG4gICAgICAgIG4gPSBuLnJpZ2h0OyAvLyB3ZSB1c2VkIHRoZSBjb250ZW50IG9mIG4sIG5vdyBpdGVyYXRlIHRvIG5leHRcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudENvbnRlbnRbY3VycmVudENvbnRlbnRJbmRleCsrXTtcbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZW1wdHkgY3VycmVudENvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudC5sZW5ndGggPD0gY3VycmVudENvbnRlbnRJbmRleCkge1xuICAgICAgICBjdXJyZW50Q29udGVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcmV0dXJuIHthbnl9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEdldCA9ICh0eXBlLCBpbmRleCkgPT4ge1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHR5cGUsIGluZGV4KTtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgZm9yICg7IG4gIT09IG51bGw7IG4gPSBuLnJpZ2h0KSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUpIHtcbiAgICAgIGlmIChpbmRleCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpW2luZGV4XVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbT99IHJlZmVyZW5jZUl0ZW1cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58Ym9vbGVhbnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlciA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCByZWZlcmVuY2VJdGVtLCBjb250ZW50KSA9PiB7XG4gIGxldCBsZWZ0ID0gcmVmZXJlbmNlSXRlbTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IHJpZ2h0ID0gcmVmZXJlbmNlSXRlbSA9PT0gbnVsbCA/IHBhcmVudC5fc3RhcnQgOiByZWZlcmVuY2VJdGVtLnJpZ2h0O1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PE9iamVjdHxBcnJheTxhbnk+fG51bWJlcnxudWxsPn1cbiAgICovXG4gIGxldCBqc29uQ29udGVudCA9IFtdO1xuICBjb25zdCBwYWNrSnNvbkNvbnRlbnQgPSAoKSA9PiB7XG4gICAgaWYgKGpzb25Db250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudEFueShqc29uQ29udGVudCkpO1xuICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgICAganNvbkNvbnRlbnQgPSBbXTtcbiAgICB9XG4gIH07XG4gIGNvbnRlbnQuZm9yRWFjaChjID0+IHtcbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAganNvbkNvbnRlbnQucHVzaChjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICBqc29uQ29udGVudC5wdXNoKGMpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFja0pzb25Db250ZW50KCk7XG4gICAgICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgICAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRCaW5hcnkobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAoYykpKSk7XG4gICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGNhc2UgRG9jOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovIChjKSkpO1xuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoYyBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBuZXcgQ29udGVudFR5cGUoYykpO1xuICAgICAgICAgICAgICAgIGxlZnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlIGluIGluc2VydCBvcGVyYXRpb24nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHBhY2tKc29uQ29udGVudCgpO1xufTtcblxuY29uc3QgbGVuZ3RoRXhjZWVkZWQgPSBlcnJvci5jcmVhdGUoJ0xlbmd0aCBleGNlZWRlZCEnKTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBjb250ZW50KSA9PiB7XG4gIGlmIChpbmRleCA+IHBhcmVudC5fbGVuZ3RoKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWRcbiAgfVxuICBpZiAoaW5kZXggPT09IDApIHtcbiAgICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIodHJhbnNhY3Rpb24sIHBhcmVudCwgbnVsbCwgY29udGVudClcbiAgfVxuICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gICAgLy8gd2UgbmVlZCB0byBpdGVyYXRlIG9uZSB0byB0aGUgbGVmdCBzbyB0aGF0IHRoZSBhbGdvcml0aG0gd29ya3NcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgIC8vIEB0b2RvIHJlZmFjdG9yIHRoaXMgYXMgaXQgYWN0dWFsbHkgZG9lc24ndCBjb25zaWRlciBmb3JtYXRzXG4gICAgICBuID0gbi5wcmV2OyAvLyBpbXBvcnRhbnQhIGdldCB0aGUgbGVmdCB1bmRlbGV0ZWQgaXRlbSBzbyB0aGF0IHdlIGNhbiBhY3R1YWxseSBkZWNyZWFzZSBpbmRleFxuICAgICAgaW5kZXggKz0gKG4gJiYgbi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkgPyBuLmxlbmd0aCA6IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gbi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgaW4tYmV0d2VlblxuICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGluZGV4KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCBjb250ZW50Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBuLCBjb250ZW50KVxufTtcblxuLyoqXG4gKiBQdXNoaW5nIGNvbnRlbnQgaXMgc3BlY2lhbCBhcyB3ZSBnZW5lcmFsbHkgd2FudCB0byBwdXNoIGFmdGVyIHRoZSBsYXN0IGl0ZW0uIFNvIHdlIGRvbid0IGhhdmUgdG8gdXBkYXRlXG4gKiB0aGUgc2VyYWNoIG1hcmtlci5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5Pn0gY29udGVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3RQdXNoR2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY29udGVudCkgPT4ge1xuICAvLyBVc2UgdGhlIG1hcmtlciB3aXRoIHRoZSBoaWdoZXN0IGluZGV4IGFuZCBpdGVyYXRlIHRvIHRoZSByaWdodC5cbiAgY29uc3QgbWFya2VyID0gKHBhcmVudC5fc2VhcmNoTWFya2VyIHx8IFtdKS5yZWR1Y2UoKG1heE1hcmtlciwgY3Vyck1hcmtlcikgPT4gY3Vyck1hcmtlci5pbmRleCA+IG1heE1hcmtlci5pbmRleCA/IGN1cnJNYXJrZXIgOiBtYXhNYXJrZXIsIHsgaW5kZXg6IDAsIHA6IHBhcmVudC5fc3RhcnQgfSk7XG4gIGxldCBuID0gbWFya2VyLnA7XG4gIGlmIChuKSB7XG4gICAgd2hpbGUgKG4ucmlnaHQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZUxpc3REZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICBpZiAobGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCk7XG4gIGxldCBuID0gcGFyZW50Ll9zdGFydDtcbiAgaWYgKG1hcmtlciAhPT0gbnVsbCkge1xuICAgIG4gPSBtYXJrZXIucDtcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXg7XG4gIH1cbiAgLy8gY29tcHV0ZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBkZWxldGVkXG4gIGZvciAoOyBuICE9PSBudWxsICYmIGluZGV4ID4gMDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIGluZGV4IC09IG4ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICAvLyBkZWxldGUgYWxsIGl0ZW1zIHVudGlsIGRvbmVcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgbiAhPT0gbnVsbCkge1xuICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgICBuLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICBsZW5ndGggLT0gbi5sZW5ndGg7XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0O1xuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWRcbiAgfVxuICBpZiAocGFyZW50Ll9zZWFyY2hNYXJrZXIpIHtcbiAgICB1cGRhdGVNYXJrZXJDaGFuZ2VzKHBhcmVudC5fc2VhcmNoTWFya2VyLCBzdGFydEluZGV4LCAtc3RhcnRMZW5ndGggKyBsZW5ndGggLyogaW4gY2FzZSB3ZSByZW1vdmUgdGhlIGFib3ZlIGV4Y2VwdGlvbiAqLyk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdHlwZU1hcERlbGV0ZSA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBrZXkpID0+IHtcbiAgY29uc3QgYyA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYy5kZWxldGUodHJhbnNhY3Rpb24pO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT59IHZhbHVlXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwU2V0ID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGtleSwgdmFsdWUpID0+IHtcbiAgY29uc3QgbGVmdCA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGw7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGxldCBjb250ZW50O1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEFueShbdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudEJpbmFyeSgvKiogQHR5cGUge1VpbnQ4QXJyYXl9ICovICh2YWx1ZSkpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBEb2M6XG4gICAgICAgIGNvbnRlbnQgPSBuZXcgQ29udGVudERvYygvKiogQHR5cGUge0RvY30gKi8gKHZhbHVlKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRUeXBlKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlJylcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCBudWxsLCBudWxsLCBwYXJlbnQsIGtleSwgY29udGVudCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwR2V0ID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgIXZhbC5kZWxldGVkID8gdmFsLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsT2JqZWN0PHN0cmluZyxhbnk+fG51bWJlcnxudWxsfEFycmF5PGFueT58c3RyaW5nfFVpbnQ4QXJyYXl8QWJzdHJhY3RUeXBlPGFueT58dW5kZWZpbmVkPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRBbGwgPSAocGFyZW50KSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0ge307XG4gIHBhcmVudC5fbWFwLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBpZiAoIXZhbHVlLmRlbGV0ZWQpIHtcbiAgICAgIHJlc1trZXldID0gdmFsdWUuY29udGVudC5nZXRDb250ZW50KClbdmFsdWUubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB0eXBlTWFwSGFzID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpO1xuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgIXZhbC5kZWxldGVkXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHR5cGVNYXBHZXRTbmFwc2hvdCA9IChwYXJlbnQsIGtleSwgc25hcHNob3QpID0+IHtcbiAgbGV0IHYgPSBwYXJlbnQuX21hcC5nZXQoa2V5KSB8fCBudWxsO1xuICB3aGlsZSAodiAhPT0gbnVsbCAmJiAoIXNuYXBzaG90LnN2Lmhhcyh2LmlkLmNsaWVudCkgfHwgdi5pZC5jbG9jayA+PSAoc25hcHNob3Quc3YuZ2V0KHYuaWQuY2xpZW50KSB8fCAwKSkpIHtcbiAgICB2ID0gdi5sZWZ0O1xuICB9XG4gIHJldHVybiB2ICE9PSBudWxsICYmIGlzVmlzaWJsZSh2LCBzbmFwc2hvdCkgPyB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLEl0ZW0+fSBtYXBcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8QXJyYXk8YW55Pj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjcmVhdGVNYXBJdGVyYXRvciA9IG1hcCA9PiBpdGVyYXRvci5pdGVyYXRvckZpbHRlcihtYXAuZW50cmllcygpLCAvKiogQHBhcmFtIHthbnl9IGVudHJ5ICovIGVudHJ5ID0+ICFlbnRyeVsxXS5kZWxldGVkKTtcblxuLyoqXG4gKiBAbW9kdWxlIFlBcnJheVxuICovXG5cbi8qKlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZQXJyYXlcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WUFycmF5PFQ+PlxuICovXG5jbGFzcyBZQXJyYXlFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lBcnJheTxUPn0geWFycmF5IFRoZSBjaGFuZ2VkIHR5cGVcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHlhcnJheSwgdHJhbnNhY3Rpb24pIHtcbiAgICBzdXBlcih5YXJyYXksIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLl90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQSBzaGFyZWQgQXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKiBAdGVtcGxhdGUgVFxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlBcnJheUV2ZW50PFQ+PlxuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFQ+fVxuICovXG5jbGFzcyBZQXJyYXkgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gW107XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSBuZXcgWUFycmF5IGNvbnRhaW5pbmcgdGhlIHNwZWNpZmllZCBpdGVtcy5cbiAgICogQHRlbXBsYXRlIHtPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheX0gVFxuICAgKiBAcGFyYW0ge0FycmF5PFQ+fSBpdGVtc1xuICAgKiBAcmV0dXJuIHtZQXJyYXk8VD59XG4gICAqL1xuICBzdGF0aWMgZnJvbSAoaXRlbXMpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WUFycmF5PFQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGEgPSBuZXcgWUFycmF5KCk7XG4gICAgYS5wdXNoKGl0ZW1zKTtcbiAgICByZXR1cm4gYVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlBcnJheSgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZQXJyYXk8VD59XG4gICAgICovXG4gICAgY29uc3QgYXJyID0gbmV3IFlBcnJheSgpO1xuICAgIGFyci5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGVsID0+XG4gICAgICBlbCBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIGVsfSAqLyAoZWwuY2xvbmUoKSkgOiBlbFxuICAgICkpO1xuICAgIHJldHVybiBhcnJcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVsaW1Db250ZW50ID09PSBudWxsID8gdGhpcy5fbGVuZ3RoIDogdGhpcy5fcHJlbGltQ29udGVudC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlBcnJheUV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIHN1cGVyLl9jYWxsT2JzZXJ2ZXIodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWUFycmF5RXZlbnQodGhpcywgdHJhbnNhY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBJbXBvcnRhbnQ6IFRoaXMgZnVuY3Rpb24gZXhwZWN0cyBhbiBhcnJheSBvZiBjb250ZW50LiBOb3QganVzdCBhIGNvbnRlbnRcbiAgICogb2JqZWN0LiBUaGUgcmVhc29uIGZvciB0aGlzIFwid2VpcmRuZXNzXCIgaXMgdGhhdCBpbnNlcnRpbmcgc2V2ZXJhbCBlbGVtZW50c1xuICAgKiBpcyB2ZXJ5IGVmZmljaWVudCB3aGVuIGl0IGlzIGRvbmUgYXMgYSBzaW5nbGUgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeWFycmF5Lmluc2VydCgwLCBbJ2EnXSlcbiAgICogIC8vIEluc2VydCBudW1iZXJzIDEsIDIgYXQgcG9zaXRpb24gMVxuICAgKiAgeWFycmF5Lmluc2VydCgxLCBbMSwgMl0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXQuXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3ModHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCAvKiogQHR5cGUge2FueX0gKi8gKGNvbnRlbnQpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqXG4gICAqIEB0b2RvIFVzZSB0aGUgZm9sbG93aW5nIGltcGxlbWVudGF0aW9uIGluIGFsbCB0eXBlcy5cbiAgICovXG4gIHB1c2ggKGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0UHVzaEdlbmVyaWNzKHRyYW5zYWN0aW9uLCB0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGNvbnRlbnQpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5wdXNoKC4uLmNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZWxlbWVudHMgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpLXRoIGVsZW1lbnQgZnJvbSBhIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4gZnJvbSB0aGUgWUFycmF5XG4gICAqIEByZXR1cm4ge1R9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdFRvQXJyYXkodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gYy50b0pTT04oKSA6IGMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5XG4gICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBNXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTpNfSBmIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gZWxlbWVudCBvZiB0aGUgbmV3IEFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5PE0+fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG1hcCAoZikge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGYpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBvbiBvdmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgZik7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxUPn1cbiAgICovXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RDcmVhdGVJdGVyYXRvcih0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZQXJyYXlSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZQXJyYXkgPSBfZGVjb2RlciA9PiBuZXcgWUFycmF5KCk7XG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIFlFdmVudDxZTWFwPFQ+PlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZTWFwLlxuICovXG5jbGFzcyBZTWFwRXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZTWFwPFQ+fSB5bWFwIFRoZSBZQXJyYXkgdGhhdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxhbnk+fSBzdWJzIFRoZSBrZXlzIHRoYXQgY2hhbmdlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yICh5bWFwLCB0cmFuc2FjdGlvbiwgc3Vicykge1xuICAgIHN1cGVyKHltYXAsIHRyYW5zYWN0aW9uKTtcbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gc3VicztcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBNYXBUeXBlXG4gKiBBIHNoYXJlZCBNYXAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlNYXBFdmVudDxNYXBUeXBlPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxNYXBUeXBlPn1cbiAqL1xuY2xhc3MgWU1hcCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0l0ZXJhYmxlPHJlYWRvbmx5IFtzdHJpbmcsIGFueV0+PX0gZW50cmllcyAtIGFuIG9wdGlvbmFsIGl0ZXJhYmxlIHRvIGluaXRpYWxpemUgdGhlIFlNYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbnRyaWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+P31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoZW50cmllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7LyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WU1hcDxNYXBUeXBlPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lNYXA8TWFwVHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge1lNYXA8TWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0gbmV3IFlNYXAoKTtcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIHZhbHVlfSAqLyAodmFsdWUuY2xvbmUoKSkgOiB2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWU1hcEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWU1hcEV2ZW50KHRoaXMsIHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSk7XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsTWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge307XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgY29uc3QgdiA9IGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXTtcbiAgICAgICAgbWFwW2tleV0gPSB2IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gdi50b0pTT04oKSA6IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIFlNYXAgKGNvdW50IG9mIGtleS92YWx1ZSBwYWlycylcbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IHNpemUgKCkge1xuICAgIHJldHVybiBbLi4uY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKV0ubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5cyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8c3RyaW5nPn1cbiAgICovXG4gIGtleXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiB2WzBdKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlcyBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSBZTWFwIFR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8YW55Pn1cbiAgICovXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEl0ZXJhdG9yIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICBlbnRyaWVzICgpIHtcbiAgICByZXR1cm4gaXRlcmF0b3IuaXRlcmF0b3JNYXAoY3JlYXRlTWFwSXRlcmF0b3IodGhpcy5fbWFwKSwgLyoqIEBwYXJhbSB7YW55fSB2ICovIHYgPT4gW3ZbMF0sIHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXV0pXG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBvbmNlIG9uIGV2ZXJ5IGtleS12YWx1ZSBwYWlyLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKE1hcFR5cGUsc3RyaW5nLFlNYXA8TWFwVHlwZT4pOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdGhpcy5fbWFwLmZvckVhY2goKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgZihpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpW2l0ZW0ubGVuZ3RoIC0gMV0sIGtleSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMoKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKi9cbiAgZGVsZXRlIChrZXkpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGtleSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgb3IgdXBkYXRlcyBhbiBlbGVtZW50IHdpdGggYSBzcGVjaWZpZWQga2V5IGFuZCB2YWx1ZS5cbiAgICogQHRlbXBsYXRlIHtNYXBUeXBlfSBWQUxcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbGVtZW50IHRvIGFkZCB0byB0aGlzIFlNYXBcbiAgICogQHBhcmFtIHtWQUx9IHZhbHVlIFRoZSB2YWx1ZSBvZiB0aGUgZWxlbWVudCB0byBhZGRcbiAgICogQHJldHVybiB7VkFMfVxuICAgKi9cbiAgc2V0IChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBrZXksIC8qKiBAdHlwZSB7YW55fSAqLyAodmFsdWUpKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzcGVjaWZpZWQgZWxlbWVudCBmcm9tIHRoaXMgWU1hcC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcmV0dXJuIHtNYXBUeXBlfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBrZXkpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgc3BlY2lmaWVkIGtleSBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhcyAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVNYXBIYXModGhpcywga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gdGhpcyBZTWFwLlxuICAgKi9cbiAgY2xlYXIgKCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uIChfdmFsdWUsIGtleSwgbWFwKSB7XG4gICAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgbWFwLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWU1hcFJlZklEKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBfZGVjb2RlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlNYXAgPSBfZGVjb2RlciA9PiBuZXcgWU1hcCgpO1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBhXG4gKiBAcGFyYW0ge2FueX0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgZXF1YWxBdHRycyA9IChhLCBiKSA9PiBhID09PSBiIHx8ICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYiAmJiBvYmplY3QuZXF1YWxGbGF0KGEsIGIpKTtcblxuY2xhc3MgSXRlbVRleHRMaXN0UG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJdGVtfG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChsZWZ0LCByaWdodCwgaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKSB7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY3VycmVudEF0dHJpYnV0ZXMgPSBjdXJyZW50QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXModGhpcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAodGhpcy5yaWdodC5jb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICghdGhpcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdGhpcy5pbmRleCArPSB0aGlzLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0O1xuICAgIHRoaXMucmlnaHQgPSB0aGlzLnJpZ2h0LnJpZ2h0O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IHBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IHN0ZXBzIHRvIG1vdmUgZm9yd2FyZFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBmaW5kTmV4dFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwb3MsIGNvdW50KSA9PiB7XG4gIHdoaWxlIChwb3MucmlnaHQgIT09IG51bGwgJiYgY291bnQgPiAwKSB7XG4gICAgc3dpdGNoIChwb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMocG9zLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChwb3MucmlnaHQuY29udGVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3MuaW5kZXggKz0gcG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBjb3VudCAtPSBwb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHBvcy5sZWZ0ID0gcG9zLnJpZ2h0O1xuICAgIHBvcy5yaWdodCA9IHBvcy5yaWdodC5yaWdodDtcbiAgICAvLyBwb3MuZm9yd2FyZCgpIC0gd2UgZG9uJ3QgZm9yd2FyZCBiZWNhdXNlIHRoYXQgd291bGQgaGFsdmUgdGhlIHBlcmZvcm1hbmNlIGJlY2F1c2Ugd2UgYWxyZWFkeSBkbyB0aGUgY2hlY2tzIGFib3ZlXG4gIH1cbiAgcmV0dXJuIHBvc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZFBvc2l0aW9uID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpO1xuICBpZiAobWFya2VyKSB7XG4gICAgY29uc3QgcG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG1hcmtlci5wLmxlZnQsIG1hcmtlci5wLCBtYXJrZXIuaW5kZXgsIGN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgICByZXR1cm4gZmluZE5leHRQb3NpdGlvbih0cmFuc2FjdGlvbiwgcG9zLCBpbmRleCAtIG1hcmtlci5pbmRleClcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgcGFyZW50Ll9zdGFydCwgMCwgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4KVxuICB9XG59O1xuXG4vKipcbiAqIE5lZ2F0ZSBhcHBsaWVkIGZvcm1hdHNcbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gbmVnYXRlZEF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHdlIHJlYWxseSBuZWVkIHRvIHJlbW92ZSBhdHRyaWJ1dGVzXG4gIHdoaWxlIChcbiAgICBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsICYmIChcbiAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gdHJ1ZSB8fCAoXG4gICAgICAgIGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJlxuICAgICAgICBlcXVhbEF0dHJzKG5lZ2F0ZWRBdHRyaWJ1dGVzLmdldCgvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLmtleSksIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkudmFsdWUpXG4gICAgICApXG4gICAgKVxuICApIHtcbiAgICBpZiAoIWN1cnJQb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KTtcbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbmVnYXRlZEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICBjb25zdCBsZWZ0ID0gY3VyclBvcy5sZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0gY3VyclBvcy5yaWdodDtcbiAgICBjb25zdCBuZXh0Rm9ybWF0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50Rm9ybWF0KGtleSwgdmFsKSk7XG4gICAgbmV4dEZvcm1hdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIGN1cnJQb3MucmlnaHQgPSBuZXh0Rm9ybWF0O1xuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJlbnRBdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IGZvcm1hdFxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMgPSAoY3VycmVudEF0dHJpYnV0ZXMsIGZvcm1hdCkgPT4ge1xuICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IGZvcm1hdDtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgY3VycmVudEF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMgPSAoY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICAvLyBnbyByaWdodCB3aGlsZSBhdHRyaWJ1dGVzW3JpZ2h0LmtleV0gPT09IHJpZ2h0LnZhbHVlIChvciByaWdodCBpcyBkZWxldGVkKVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChjdXJyUG9zLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgICBicmVha1xuICAgIH0gZWxzZSBpZiAoY3VyclBvcy5yaWdodC5kZWxldGVkIHx8IChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQgJiYgZXF1YWxBdHRycyhhdHRyaWJ1dGVzWygvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpKS5rZXldIHx8IG51bGwsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkudmFsdWUpKSkgOyBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBhdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtNYXA8c3RyaW5nLGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICoqL1xuY29uc3QgaW5zZXJ0QXR0cmlidXRlcyA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SUQ7XG4gIGNvbnN0IG5lZ2F0ZWRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpO1xuICAvLyBpbnNlcnQgZm9ybWF0LXN0YXJ0IGl0ZW1zXG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB2YWwgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgY29uc3QgY3VycmVudFZhbCA9IGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICBpZiAoIWVxdWFsQXR0cnMoY3VycmVudFZhbCwgdmFsKSkge1xuICAgICAgLy8gc2F2ZSBuZWdhdGVkIGF0dHJpYnV0ZSAoc2V0IG51bGwgaWYgY3VycmVudFZhbCB1bmRlZmluZWQpXG4gICAgICBuZWdhdGVkQXR0cmlidXRlcy5zZXQoa2V5LCBjdXJyZW50VmFsKTtcbiAgICAgIGNvbnN0IHsgbGVmdCwgcmlnaHQgfSA9IGN1cnJQb3M7XG4gICAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50Rm9ybWF0KGtleSwgdmFsKSk7XG4gICAgICBjdXJyUG9zLnJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZ2F0ZWRBdHRyaWJ1dGVzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdHxBYnN0cmFjdFR5cGU8YW55Pn0gdGV4dFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKiovXG5jb25zdCBpbnNlcnRUZXh0ID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIHRleHQsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKChfdmFsLCBrZXkpID0+IHtcbiAgICBpZiAoYXR0cmlidXRlc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IG51bGw7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGluc2VydCBjb250ZW50XG4gIGNvbnN0IGNvbnRlbnQgPSB0ZXh0LmNvbnN0cnVjdG9yID09PSBTdHJpbmcgPyBuZXcgQ29udGVudFN0cmluZygvKiogQHR5cGUge3N0cmluZ30gKi8gKHRleHQpKSA6ICh0ZXh0IGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gbmV3IENvbnRlbnRUeXBlKHRleHQpIDogbmV3IENvbnRlbnRFbWJlZCh0ZXh0KSk7XG4gIGxldCB7IGxlZnQsIHJpZ2h0LCBpbmRleCB9ID0gY3VyclBvcztcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgY29udGVudC5nZXRMZW5ndGgoKSk7XG4gIH1cbiAgcmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgY29udGVudCk7XG4gIHJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gIGN1cnJQb3MucmlnaHQgPSByaWdodDtcbiAgY3VyclBvcy5pbmRleCA9IGluZGV4O1xuICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZm9ybWF0VGV4dCA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBjdXJyUG9zLCBsZW5ndGgsIGF0dHJpYnV0ZXMpID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRDtcbiAgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzKGN1cnJQb3MsIGF0dHJpYnV0ZXMpO1xuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcyk7XG4gIC8vIGl0ZXJhdGUgdW50aWwgZmlyc3Qgbm9uLWZvcm1hdCBvciBudWxsIGlzIGZvdW5kXG4gIC8vIGRlbGV0ZSBhbGwgZm9ybWF0cyB3aXRoIGF0dHJpYnV0ZXNbZm9ybWF0LmtleV0gIT0gbnVsbFxuICAvLyBhbHNvIGNoZWNrIHRoZSBhdHRyaWJ1dGVzIGFmdGVyIHRoZSBmaXJzdCBub24tZm9ybWF0IGFzIHdlIGRvIG5vdCB3YW50IHRvIGluc2VydCByZWR1bmRhbnQgbmVnYXRlZCBhdHRyaWJ1dGVzIHRoZXJlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgaXRlcmF0aW9uTG9vcDogd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiZcbiAgICAobGVuZ3RoID4gMCB8fFxuICAgICAgKFxuICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zaXplID4gMCAmJlxuICAgICAgICAoY3VyclBvcy5yaWdodC5kZWxldGVkIHx8IGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdClcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCk7XG4gICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoZXF1YWxBdHRycyhhdHRyLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBmdXJ0aGVyIGV4dGVuZCBuZWdhdGVkQXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgICAgICBicmVhayBpdGVyYXRpb25Mb29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyclBvcy5yaWdodC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCAtPSBjdXJyUG9zLnJpZ2h0Lmxlbmd0aDtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICAvLyBRdWlsbCBqdXN0IGFzc3VtZXMgdGhhdCB0aGUgZWRpdG9yIHN0YXJ0cyB3aXRoIGEgbmV3bGluZSBhbmQgdGhhdCBpdCBhbHdheXNcbiAgLy8gZW5kcyB3aXRoIGEgbmV3bGluZS4gV2Ugb25seSBpbnNlcnQgdGhhdCBuZXdsaW5lIHdoZW4gYSBuZXcgbmV3bGluZSBpc1xuICAvLyBpbnNlcnRlZCAtIGkuZSB3aGVuIGxlbmd0aCBpcyBiaWdnZXIgdGhhbiB0eXBlLmxlbmd0aFxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGxldCBuZXdsaW5lcyA9ICcnO1xuICAgIGZvciAoOyBsZW5ndGggPiAwOyBsZW5ndGgtLSkge1xuICAgICAgbmV3bGluZXMgKz0gJ1xcbic7XG4gICAgfVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBjdXJyUG9zLmxlZnQsIGN1cnJQb3MubGVmdCAmJiBjdXJyUG9zLmxlZnQubGFzdElkLCBjdXJyUG9zLnJpZ2h0LCBjdXJyUG9zLnJpZ2h0ICYmIGN1cnJQb3MucmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRTdHJpbmcobmV3bGluZXMpKTtcbiAgICBjdXJyUG9zLnJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gICAgY3VyclBvcy5mb3J3YXJkKCk7XG4gIH1cbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpO1xufTtcblxuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24gYWZ0ZXIgc3RyaW5nIGNvbnRlbnQgaGFzIGJlZW4gZGVsZXRlZCBpbiBvcmRlciB0b1xuICogY2xlYW4gdXAgZm9ybWF0dGluZyBJdGVtcy5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtfSBzdGFydFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGN1cnIgZXhjbHVzaXZlIGVuZCwgYXV0b21hdGljYWxseSBpdGVyYXRlcyB0byB0aGUgbmV4dCBDb250ZW50IEl0ZW1cbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBzdGFydEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBjdXJyQXR0cmlidXRlc1xuICogQHJldHVybiB7bnVtYmVyfSBUaGUgYW1vdW50IG9mIGZvcm1hdHRpbmcgSXRlbXMgZGVsZXRlZC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgY2xlYW51cEZvcm1hdHRpbmdHYXAgPSAodHJhbnNhY3Rpb24sIHN0YXJ0LCBjdXJyLCBzdGFydEF0dHJpYnV0ZXMsIGN1cnJBdHRyaWJ1dGVzKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IGVuZCA9IHN0YXJ0O1xuICAvKipcbiAgICogQHR5cGUge01hcDxzdHJpbmcsQ29udGVudEZvcm1hdD59XG4gICAqL1xuICBjb25zdCBlbmRGb3JtYXRzID0gbWFwLmNyZWF0ZSgpO1xuICB3aGlsZSAoZW5kICYmICghZW5kLmNvdW50YWJsZSB8fCBlbmQuZGVsZXRlZCkpIHtcbiAgICBpZiAoIWVuZC5kZWxldGVkICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICBjb25zdCBjZiA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KTtcbiAgICAgIGVuZEZvcm1hdHMuc2V0KGNmLmtleSwgY2YpO1xuICAgIH1cbiAgICBlbmQgPSBlbmQucmlnaHQ7XG4gIH1cbiAgbGV0IGNsZWFudXBzID0gMDtcbiAgbGV0IHJlYWNoZWRDdXJyID0gZmFsc2U7XG4gIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKGN1cnIgPT09IHN0YXJ0KSB7XG4gICAgICByZWFjaGVkQ3VyciA9IHRydWU7XG4gICAgfVxuICAgIGlmICghc3RhcnQuZGVsZXRlZCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHN0YXJ0LmNvbnRlbnQ7XG4gICAgICBzd2l0Y2ggKGNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjb250ZW50KTtcbiAgICAgICAgICBjb25zdCBzdGFydEF0dHJWYWx1ZSA9IHN0YXJ0QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgICAgICAgIGlmIChlbmRGb3JtYXRzLmdldChrZXkpICE9PSBjb250ZW50IHx8IHN0YXJ0QXR0clZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRWl0aGVyIHRoaXMgZm9ybWF0IGlzIG92ZXJ3cml0dGVuIG9yIGl0IGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYXR0cmlidXRlIGFscmVhZHkgZXhpc3RlZC5cbiAgICAgICAgICAgIHN0YXJ0LmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjbGVhbnVwcysrO1xuICAgICAgICAgICAgaWYgKCFyZWFjaGVkQ3VyciAmJiAoY3VyckF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkgPT09IHZhbHVlICYmIHN0YXJ0QXR0clZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBpZiAoc3RhcnRBdHRyVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyQXR0cmlidXRlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyQXR0cmlidXRlcy5zZXQoa2V5LCBzdGFydEF0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFyZWFjaGVkQ3VyciAmJiAhc3RhcnQuZGVsZXRlZCkge1xuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VyckF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGNvbnRlbnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHN0YXJ0LnJpZ2h0KTtcbiAgfVxuICByZXR1cm4gY2xlYW51cHNcbn07XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGl0ZW1cbiAqL1xuY29uc3QgY2xlYW51cENvbnRleHRsZXNzRm9ybWF0dGluZ0dhcCA9ICh0cmFuc2FjdGlvbiwgaXRlbSkgPT4ge1xuICAvLyBpdGVyYXRlIHVudGlsIGl0ZW0ucmlnaHQgaXMgbnVsbCBvciBjb250ZW50XG4gIHdoaWxlIChpdGVtICYmIGl0ZW0ucmlnaHQgJiYgKGl0ZW0ucmlnaHQuZGVsZXRlZCB8fCAhaXRlbS5yaWdodC5jb3VudGFibGUpKSB7XG4gICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gIH1cbiAgY29uc3QgYXR0cnMgPSBuZXcgU2V0KCk7XG4gIC8vIGl0ZXJhdGUgYmFjayB1bnRpbCBhIGNvbnRlbnQgaXRlbSBpcyBmb3VuZFxuICB3aGlsZSAoaXRlbSAmJiAoaXRlbS5kZWxldGVkIHx8ICFpdGVtLmNvdW50YWJsZSkpIHtcbiAgICBpZiAoIWl0ZW0uZGVsZXRlZCAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCkua2V5O1xuICAgICAgaWYgKGF0dHJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpdGVtID0gaXRlbS5sZWZ0O1xuICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBzdWJqZWN0IHRvIGNoYW5nZSAvIGJlIHJlbW92ZWQuXG4gKlxuICogSWRlYWxseSwgd2UgZG9uJ3QgbmVlZCB0aGlzIGZ1bmN0aW9uIGF0IGFsbC4gRm9ybWF0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBjbGVhbmVkIHVwXG4gKiBhdXRvbWF0aWNhbGx5IGFmdGVyIGVhY2ggY2hhbmdlLiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHR3aWNlIG92ZXIgdGhlIGNvbXBsZXRlIFlUZXh0IHR5cGVcbiAqIGFuZCByZW1vdmVzIHVubmVjZXNzYXJ5IGZvcm1hdHRpbmcgYXR0cmlidXRlcy4gVGhpcyBpcyBhbHNvIGhlbHBmdWwgZm9yIHRlc3RpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3b24ndCBiZSBleHBvcnRlZCBhbnltb3JlIGFzIHNvb24gYXMgdGhlcmUgaXMgY29uZmlkZW5jZSB0aGF0IHRoZSBZVGV4dCB0eXBlIHdvcmtzIGFzIGludGVuZGVkLlxuICpcbiAqIEBwYXJhbSB7WVRleHR9IHR5cGVcbiAqIEByZXR1cm4ge251bWJlcn0gSG93IG1hbnkgZm9ybWF0dGluZyBhdHRyaWJ1dGVzIGhhdmUgYmVlbiBjbGVhbmVkIHVwLlxuICovXG5jb25zdCBjbGVhbnVwWVRleHRGb3JtYXR0aW5nID0gdHlwZSA9PiB7XG4gIGxldCByZXMgPSAwO1xuICB0cmFuc2FjdCgvKiogQHR5cGUge0RvY30gKi8gKHR5cGUuZG9jKSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgIGxldCBzdGFydCA9IC8qKiBAdHlwZSB7SXRlbX0gKi8gKHR5cGUuX3N0YXJ0KTtcbiAgICBsZXQgZW5kID0gdHlwZS5fc3RhcnQ7XG4gICAgbGV0IHN0YXJ0QXR0cmlidXRlcyA9IG1hcC5jcmVhdGUoKTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG1hcC5jb3B5KHN0YXJ0QXR0cmlidXRlcyk7XG4gICAgd2hpbGUgKGVuZCkge1xuICAgICAgaWYgKGVuZC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKGVuZC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSk7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXMgKz0gY2xlYW51cEZvcm1hdHRpbmdHYXAodHJhbnNhY3Rpb24sIHN0YXJ0LCBlbmQsIHN0YXJ0QXR0cmlidXRlcywgY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgc3RhcnRBdHRyaWJ1dGVzID0gbWFwLmNvcHkoY3VycmVudEF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbmQgPSBlbmQucmlnaHQ7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybiB7SXRlbVRleHRMaXN0UG9zaXRpb259XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBkZWxldGVUZXh0ID0gKHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBsZW5ndGgpID0+IHtcbiAgY29uc3Qgc3RhcnRMZW5ndGggPSBsZW5ndGg7XG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBtYXAuY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKTtcbiAgY29uc3Qgc3RhcnQgPSBjdXJyUG9zLnJpZ2h0O1xuICB3aGlsZSAobGVuZ3RoID4gMCAmJiBjdXJyUG9zLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHN3aXRjaCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICBjYXNlIENvbnRlbnRTdHJpbmc6XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IGN1cnJQb3MucmlnaHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgY3JlYXRlSUQoY3VyclBvcy5yaWdodC5pZC5jbGllbnQsIGN1cnJQb3MucmlnaHQuaWQuY2xvY2sgKyBsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoO1xuICAgICAgICAgIGN1cnJQb3MucmlnaHQuZGVsZXRlKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyUG9zLmZvcndhcmQoKTtcbiAgfVxuICBpZiAoc3RhcnQpIHtcbiAgICBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnJQb3MucmlnaHQsIHN0YXJ0QXR0cnMsIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpO1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICgvKiogQHR5cGUge0l0ZW19ICovIChjdXJyUG9zLmxlZnQgfHwgY3VyclBvcy5yaWdodCkucGFyZW50KTtcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgLXN0YXJ0TGVuZ3RoICsgbGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufTtcblxuLyoqXG4gKiBUaGUgUXVpbGwgRGVsdGEgZm9ybWF0IHJlcHJlc2VudHMgY2hhbmdlcyBvbiBhIHRleHQgZG9jdW1lbnQgd2l0aFxuICogZm9ybWF0dGluZyBpbmZvcm1hdGlvbi4gRm9yIG1vciBpbmZvcm1hdGlvbiB2aXNpdCB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX1cbiAqXG4gKiBAZXhhbXBsZVxuICogICB7XG4gKiAgICAgb3BzOiBbXG4gKiAgICAgICB7IGluc2VydDogJ0dhbmRhbGYnLCBhdHRyaWJ1dGVzOiB7IGJvbGQ6IHRydWUgfSB9LFxuICogICAgICAgeyBpbnNlcnQ6ICcgdGhlICcgfSxcbiAqICAgICAgIHsgaW5zZXJ0OiAnR3JleScsIGF0dHJpYnV0ZXM6IHsgY29sb3I6ICcjY2NjY2NjJyB9IH1cbiAqICAgICBdXG4gKiAgIH1cbiAqXG4gKi9cblxuLyoqXG4gICogQXR0cmlidXRlcyB0aGF0IGNhbiBiZSBhc3NpZ25lZCB0byBhIHNlbGVjdGlvbiBvZiB0ZXh0LlxuICAqXG4gICogQGV4YW1wbGVcbiAgKiAgIHtcbiAgKiAgICAgYm9sZDogdHJ1ZSxcbiAgKiAgICAgZm9udC1zaXplOiAnNDBweCdcbiAgKiAgIH1cbiAgKlxuICAqIEB0eXBlZGVmIHtPYmplY3R9IFRleHRBdHRyaWJ1dGVzXG4gICovXG5cbi8qKlxuICogQGV4dGVuZHMgWUV2ZW50PFlUZXh0PlxuICogRXZlbnQgdGhhdCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVGV4dCB0eXBlLlxuICovXG5jbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMua2V5c0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMua2V5c0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZ3xBYnN0cmFjdFR5cGU8YW55PnxvYmplY3QsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHtcbiAgICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgZGVsZXRlZDogbmV3IFNldCgpXG4gICAgICB9O1xuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXM7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2NoYW5nZXMpXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSB0aGUgY2hhbmdlcyBpbiB0aGUgZGVsdGEgZm9ybWF0LlxuICAgKiBBIHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfSkgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG9uIHRoZSBkb2N1bWVudC5cbiAgICpcbiAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIGlmICh0aGlzLl9kZWx0YSA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgeSA9IC8qKiBAdHlwZSB7RG9jfSAqLyAodGhpcy50YXJnZXQuZG9jKTtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdO1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTsgLy8gc2F2ZXMgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBmb3IgaW5zZXJ0XG4gICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpdGVtID0gdGhpcy50YXJnZXQuX3N0YXJ0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge3N0cmluZz99XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgYWN0aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGluc2VydCA9ICcnO1xuICAgICAgICBsZXQgcmV0YWluID0gMDtcbiAgICAgICAgbGV0IGRlbGV0ZUxlbiA9IDA7XG4gICAgICAgIGNvbnN0IGFkZE9wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IG9wID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZSc6XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUxlbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG9wID0geyBkZWxldGU6IGRlbGV0ZUxlbiB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gPSAwO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnNlcnQgPT09ICdvYmplY3QnIHx8IGluc2VydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgaW5zZXJ0IH07XG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudEF0dHJpYnV0ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnNlcnQgPSAnJztcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICBjYXNlICdyZXRhaW4nOlxuICAgICAgICAgICAgICAgIGlmIChyZXRhaW4gPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgcmV0YWluIH07XG4gICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdC5pc0VtcHR5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBvYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluID0gMDtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wKSBkZWx0YS5wdXNoKG9wKTtcbiAgICAgICAgICAgIGFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAoaXRlbS5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6XG4gICAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVswXTtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZUxlbiArPSAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdyZXRhaW4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5zZXJ0ICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKGl0ZW0uY29udGVudCkuc3RyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gaXRlbS5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldGFpbiArPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdXJWYWwgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoa2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWxBdHRycyh2YWx1ZSwgKG9sZEF0dHJpYnV0ZXMuZ2V0KGtleSkgfHwgbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFlcXVhbEF0dHJzKGN1clZhbCwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICBhZGRPcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gY3VyVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgb2xkQXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0ciA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgIT09IG51bGwpIHsgLy8gdGhpcyB3aWxsIGJlIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBieSB0aGUgY29udGV4dGxlc3MgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ2luc2VydCcpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChpdGVtLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtID0gaXRlbS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBhZGRPcCgpO1xuICAgICAgICB3aGlsZSAoZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGxhc3RPcCA9IGRlbHRhW2RlbHRhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0YWluIGRlbHRhJ3MgaWYgdGhleSBkb24ndCBhc3NpZ24gYXR0cmlidXRlc1xuICAgICAgICAgICAgZGVsdGEucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2RlbHRhID0gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2RlbHRhKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSB0aGF0IHJlcHJlc2VudHMgdGV4dCB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICogYmxvY2sgZm9ybWF0cyAoZm9ybWF0IGluZm9ybWF0aW9uIG9uIGEgcGFyYWdyYXBoKSwgZW1iZWRzIChjb21wbGV4IGVsZW1lbnRzXG4gKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZVGV4dEV2ZW50PlxuICovXG5jbGFzcyBZVGV4dCBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW3N0cmluZ10gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIFlUZXh0LlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHN0cmluZykge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGVuZGluZyBvcGVyYXRpb25zIG9uIHRoaXMgdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbigpOnZvaWQ+P31cbiAgICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nID0gc3RyaW5nICE9PSB1bmRlZmluZWQgPyBbKCkgPT4gdGhpcy5pbnNlcnQoMCwgc3RyaW5nKV0gOiBbXTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fVxuICAgICAqL1xuICAgIHRoaXMuX3NlYXJjaE1hcmtlciA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiBjaGFyYWN0ZXJzIG9mIHRoaXMgdGV4dCB0eXBlLlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSB5XG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdHJ5IHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykuZm9yRWFjaChmID0+IGYoKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG4gICAgdGhpcy5fcGVuZGluZyA9IG51bGw7XG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZVGV4dCgpO1xuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSk7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlUZXh0RXZlbnQgYW5kIGNhbGxzIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtTZXQ8bnVsbHxzdHJpbmc+fSBwYXJlbnRTdWJzIEtleXMgY2hhbmdlZCBvbiB0aGlzIHR5cGUuIGBudWxsYCBpZiBsaXN0IHdhcyBtb2RpZmllZC5cbiAgICovXG4gIF9jYWxsT2JzZXJ2ZXIgKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKSB7XG4gICAgc3VwZXIuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgWVRleHRFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3Vicyk7XG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBldmVudCk7XG4gICAgLy8gSWYgYSByZW1vdGUgY2hhbmdlIGhhcHBlbmVkLCB3ZSB0cnkgdG8gY2xlYW51cCBwb3RlbnRpYWwgZm9ybWF0dGluZyBkdXBsaWNhdGVzLlxuICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGFub3RoZXIgZm9ybWF0dGluZyBpdGVtIHdhcyBpbnNlcnRlZFxuICAgICAgbGV0IGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3QgW2NsaWVudCwgYWZ0ZXJDbG9ja10gb2YgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwO1xuICAgICAgICBpZiAoYWZ0ZXJDbG9jayA9PT0gY2xvY2spIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGl0ZXJhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0FycmF5PEl0ZW18R0M+fSAqLyAoZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbG9jaywgYWZ0ZXJDbG9jaywgaXRlbSA9PiB7XG4gICAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQgJiYgLyoqIEB0eXBlIHtJdGVtfSAqLyAoaXRlbSkuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCkge1xuICAgICAgICAgICAgZm91bmRGb3JtYXR0aW5nSXRlbSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZvdW5kRm9ybWF0dGluZ0l0ZW0pIHtcbiAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIGl0ZW0gPT4ge1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MgfHwgZm91bmRGb3JtYXR0aW5nSXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpdGVtLnBhcmVudCA9PT0gdGhpcyAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgICAgICAgIGZvdW5kRm9ybWF0dGluZ0l0ZW0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0cmFuc2FjdChkb2MsICh0KSA9PiB7XG4gICAgICAgIGlmIChmb3VuZEZvcm1hdHRpbmdJdGVtKSB7XG4gICAgICAgICAgLy8gSWYgYSBmb3JtYXR0aW5nIGl0ZW0gd2FzIGluc2VydGVkLCB3ZSBzaW1wbHkgY2xlYW4gdGhlIHdob2xlIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgY3VycmVudCBwb3NpdGlvbiBhbnl3YXkuXG4gICAgICAgICAgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQsIHdlIGNhbiBtYWtlIGR1ZSB3aXRoIGNvbnRleHRsZXNzXG4gICAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgICAvLyBDb250ZXh0bGVzczogaXQgaXMgbm90IG5lY2Vzc2FyeSB0byBjb21wdXRlIGN1cnJlbnRBdHRyaWJ1dGVzIGZvciB0aGUgYWZmZWN0ZWQgcG9zaXRpb24uXG4gICAgICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHQsIHQuZGVsZXRlU2V0LCBpdGVtID0+IHtcbiAgICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR0MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgY2xlYW51cENvbnRleHRsZXNzRm9ybWF0dGluZ0dhcCh0LCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0O1xuICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IC8qKiBAdHlwZSB7Q29udGVudFN0cmluZ30gKi8gKG4uY29udGVudCkuc3RyO1xuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1bmZvcm1hdHRlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IGEge0BsaW5rIERlbHRhfSBvbiB0aGlzIHNoYXJlZCBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZGVsdGEgVGhlIGNoYW5nZXMgdG8gYXBwbHkgb24gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0ge29iamVjdH0gIG9wdHNcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5zYW5pdGl6ZV0gU2FuaXRpemUgaW5wdXQgZGVsdGEuIFJlbW92ZXMgZW5kaW5nIG5ld2xpbmVzIGlmIHNldCB0byB0cnVlLlxuICAgKlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhcHBseURlbHRhIChkZWx0YSwgeyBzYW5pdGl6ZSA9IHRydWUgfSA9IHt9KSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBjdXJyUG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHRoaXMuX3N0YXJ0LCAwLCBuZXcgTWFwKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgb3AgPSBkZWx0YVtpXTtcbiAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFF1aWxsIGFzc3VtZXMgdGhhdCB0aGUgY29udGVudCBzdGFydHMgd2l0aCBhbiBlbXB0eSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBZanMvWS5UZXh0IGFzc3VtZXMgdGhhdCBpdCBzdGFydHMgZW1wdHkuIFdlIGFsd2F5cyBoaWRlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgbmV3bGluZSBhdCB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgLy8gSWYgd2Ugb21pdCB0aGlzIHN0ZXAsIGNsaWVudHMgd2lsbCBzZWUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBwYXJhZ3JhcGhzLCBidXQgbm90aGluZyBiYWQgd2lsbCBoYXBwZW4uXG4gICAgICAgICAgICBjb25zdCBpbnMgPSAoIXNhbml0aXplICYmIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGkgPT09IGRlbHRhLmxlbmd0aCAtIDEgJiYgY3VyclBvcy5yaWdodCA9PT0gbnVsbCAmJiBvcC5pbnNlcnQuc2xpY2UoLTEpID09PSAnXFxuJykgPyBvcC5pbnNlcnQuc2xpY2UoMCwgLTEpIDogb3AuaW5zZXJ0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnMgIT09ICdzdHJpbmcnIHx8IGlucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGluc2VydFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIGN1cnJQb3MsIGlucywgb3AuYXR0cmlidXRlcyB8fCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChvcC5yZXRhaW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9ybWF0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgb3AucmV0YWluLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLmRlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGVUZXh0KHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBvcC5kZWxldGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmFwcGx5RGVsdGEoZGVsdGEpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRGVsdGEgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGV7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvcHMgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkb2MgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMuZG9jKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IG4gPSB0aGlzLl9zdGFydDtcbiAgICBmdW5jdGlvbiBwYWNrU3RyICgpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBwYWNrIHN0ciB3aXRoIGF0dHJpYnV0ZXMgdG8gb3BzXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBsZXQgYWRkQXR0cmlidXRlcyA9IGZhbHNlO1xuICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgYWRkQXR0cmlidXRlcyA9IHRydWU7XG4gICAgICAgICAgYXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG9wID0geyBpbnNlcnQ6IHN0ciB9O1xuICAgICAgICBpZiAoYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKTtcbiAgICAgICAgc3RyID0gJyc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbXB1dGVEZWx0YSA9ICgpID0+IHtcbiAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpIHx8IChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiBpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKG4uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ciA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldCgneWNoYW5nZScpO1xuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KCd5Y2hhbmdlJywgY29tcHV0ZVlDaGFuZ2UgPyBjb21wdXRlWUNoYW5nZSgncmVtb3ZlZCcsIG4uaWQpIDogeyB0eXBlOiAncmVtb3ZlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTbmFwc2hvdCAhPT0gdW5kZWZpbmVkICYmICFpc1Zpc2libGUobiwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdhZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHBhY2tTdHIoKTtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgbi5pZCkgOiB7IHR5cGU6ICdhZGRlZCcgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZSgneWNoYW5nZScpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0cjtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGU6XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDoge1xuICAgICAgICAgICAgICBwYWNrU3RyKCk7XG4gICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBuLmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59ICovICh7fSk7XG4gICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlcyA9IGF0dHJzO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgIGF0dHJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBvcHMucHVzaChvcCk7XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6XG4gICAgICAgICAgICAgIGlmIChpc1Zpc2libGUobiwgc25hcHNob3QpKSB7XG4gICAgICAgICAgICAgICAgcGFja1N0cigpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChuLmNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgIH1cbiAgICAgIHBhY2tTdHIoKTtcbiAgICB9O1xuICAgIGlmIChzbmFwc2hvdCB8fCBwcmV2U25hcHNob3QpIHtcbiAgICAgIC8vIHNuYXBzaG90cyBhcmUgbWVyZ2VkIGFnYWluIGFmdGVyIHRoZSB0cmFuc2FjdGlvbiwgc28gd2UgbmVlZCB0byBrZWVwIHRoZVxuICAgICAgLy8gdHJhbnNhY3Rpb24gYWxpdmUgdW50aWwgd2UgYXJlIGRvbmVcbiAgICAgIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBpZiAoc25hcHNob3QpIHtcbiAgICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBzbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZTbmFwc2hvdCkge1xuICAgICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHByZXZTbmFwc2hvdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZURlbHRhKCk7XG4gICAgICB9LCAnY2xlYW51cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wdXRlRGVsdGEoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvYztcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4KTtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBwb3MuY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodiwgaykgPT4geyBhdHRyaWJ1dGVzW2tdID0gdjsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCB0ZXh0LCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnQoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhbiBlbWJlZCBhdCBhIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIGluc2VydCB0aGUgZW1iZWQgYXQuXG4gICAqIEBwYXJhbSB7T2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT59IGVtYmVkIFRoZSBPYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBlbWJlZC5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gYXR0cmlidXRlcyBBdHRyaWJ1dGUgaW5mb3JtYXRpb24gdG8gYXBwbHkgb24gdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1iZWRcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5zZXJ0RW1iZWQgKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpO1xuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGVtYmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnRFbWJlZChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyB0ZXh0IHN0YXJ0aW5nIGZyb20gYW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBhdCB3aGljaCB0byBzdGFydCBkZWxldGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeSA9IHRoaXMuZG9jO1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgpLCBsZW5ndGgpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmRlbGV0ZShpbmRleCwgbGVuZ3RoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2M7XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHksIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcG9zID0gZmluZFBvc2l0aW9uKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIGlmIChwb3MucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBmb3JtYXRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIGxlbmd0aCwgYXR0cmlidXRlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgb3IgdXBkYXRlcyBhbiBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqIEBwYXJhbSB7YW55fSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBxdWVyaWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlIChhdHRyaWJ1dGVOYW1lKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZU1hcEdldCh0aGlzLCBhdHRyaWJ1dGVOYW1lKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhdHRyaWJ1dGUgbmFtZS92YWx1ZSBwYWlycyBpbiBhIEpTT04gT2JqZWN0LlxuICAgKlxuICAgKiBAbm90ZSBYbWwtVGV4dCBub2RlcyBkb24ndCBoYXZlIGF0dHJpYnV0ZXMuIFlvdSBjYW4gdXNlIHRoaXMgZmVhdHVyZSB0byBhc3NpZ24gcHJvcGVydGllcyB0byBjb21wbGV0ZSB0ZXh0LWJsb2Nrcy5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0PHN0cmluZywgYW55Pn0gQSBKU09OIE9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcyAoKSB7XG4gICAgcmV0dXJuIHR5cGVNYXBHZXRBbGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lUZXh0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlUZXh0ID0gX2RlY29kZXIgPT4gbmV3IFlUZXh0KCk7XG5cbi8qKlxuICogQG1vZHVsZSBZWG1sXG4gKi9cblxuLyoqXG4gKiBEZWZpbmUgdGhlIGVsZW1lbnRzIHRvIHdoaWNoIGEgc2V0IG9mIENTUyBxdWVyaWVzIGFwcGx5LlxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9DU1NfU2VsZWN0b3JzfENTU19TZWxlY3RvcnN9XG4gKlxuICogQGV4YW1wbGVcbiAqICAgcXVlcnkgPSAnLmNsYXNzU2VsZWN0b3InXG4gKiAgIHF1ZXJ5ID0gJ25vZGVTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnI2lkU2VsZWN0b3InXG4gKlxuICogQHR5cGVkZWYge3N0cmluZ30gQ1NTX1NlbGVjdG9yXG4gKi9cblxuLyoqXG4gKiBEb20gZmlsdGVyIGZ1bmN0aW9uLlxuICpcbiAqIEBjYWxsYmFjayBkb21GaWx0ZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBUaGUgbm9kZU5hbWUgb2YgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSB7TWFwfSBhdHRyaWJ1dGVzIFRoZSBtYXAgb2YgYXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgRG9tIG5vZGUgaW4gdGhlIFlYbWxFbGVtZW50LlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHN1YnNldCBvZiB0aGUgbm9kZXMgb2YgYSBZWG1sRWxlbWVudCAvIFlYbWxGcmFnbWVudCBhbmQgYVxuICogcG9zaXRpb24gd2l0aGluIHRoZW0uXG4gKlxuICogQ2FuIGJlIGNyZWF0ZWQgd2l0aCB7QGxpbmsgWVhtbEZyYWdtZW50I2NyZWF0ZVRyZWVXYWxrZXJ9XG4gKlxuICogQHB1YmxpY1xuICogQGltcGxlbWVudHMge0l0ZXJhYmxlPFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxFbGVtZW50fFlYbWxIb29rPn1cbiAqL1xuY2xhc3MgWVhtbFRyZWVXYWxrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtZWG1sRnJhZ21lbnQgfCBZWG1sRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFic3RyYWN0VHlwZTxhbnk+KTpib29sZWFufSBbZl1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyb290LCBmID0gKCkgPT4gdHJ1ZSkge1xuICAgIHRoaXMuX2ZpbHRlciA9IGY7XG4gICAgdGhpcy5fcm9vdCA9IHJvb3Q7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW19XG4gICAgICovXG4gICAgdGhpcy5fY3VycmVudE5vZGUgPSAvKiogQHR5cGUge0l0ZW19ICovIChyb290Ll9zdGFydCk7XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gdHJ1ZTtcbiAgfVxuXG4gIFtTeW1ib2wuaXRlcmF0b3JdICgpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmV4dCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvclJlc3VsdDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9vaz59IFRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG5leHQgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgbGV0IG4gPSB0aGlzLl9jdXJyZW50Tm9kZTtcbiAgICBsZXQgdHlwZSA9IG4gJiYgbi5jb250ZW50ICYmIC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlO1xuICAgIGlmIChuICE9PSBudWxsICYmICghdGhpcy5fZmlyc3RDYWxsIHx8IG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKHR5cGUpKSkgeyAvLyBpZiBmaXJzdCBjYWxsLCB3ZSBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZSBmaXJzdCBpdGVtXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGUgPSAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZTtcbiAgICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgKHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxFbGVtZW50IHx8IHR5cGUuY29uc3RydWN0b3IgPT09IFlYbWxGcmFnbWVudCkgJiYgdHlwZS5fc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB3YWxrIGRvd24gaW4gdGhlIHRyZWVcbiAgICAgICAgICBuID0gdHlwZS5fc3RhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2FsayByaWdodCBvciB1cCBpbiB0aGUgdHJlZVxuICAgICAgICAgIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobi5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBuID0gbi5yaWdodDtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobi5wYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKG4ucGFyZW50KS5faXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG4gIT09IG51bGwgJiYgKG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpKSlcbiAgICB9XG4gICAgdGhpcy5fZmlyc3RDYWxsID0gZmFsc2U7XG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfVxuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG47XG4gICAgcmV0dXJuIHsgdmFsdWU6IC8qKiBAdHlwZSB7YW55fSAqLyAobi5jb250ZW50KS50eXBlLCBkb25lOiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgbGlzdCBvZiB7QGxpbmsgWVhtbEVsZW1lbnR9LmFuZCB7QGxpbmsgWVhtbFRleHR9IHR5cGVzLlxuICogQSBZeG1sRnJhZ21lbnQgaXMgc2ltaWxhciB0byBhIHtAbGluayBZWG1sRWxlbWVudH0sIGJ1dCBpdCBkb2VzIG5vdCBoYXZlIGFcbiAqIG5vZGVOYW1lIGFuZCBpdCBkb2VzIG5vdCBoYXZlIGF0dHJpYnV0ZXMuIFRob3VnaCBpdCBjYW4gYmUgYm91bmQgdG8gYSBET01cbiAqIGVsZW1lbnQgLSBpbiB0aGlzIGNhc2UgdGhlIGF0dHJpYnV0ZXMgYW5kIHRoZSBub2RlTmFtZSBhcmUgbm90IHNoYXJlZC5cbiAqXG4gKiBAcHVibGljXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFR5cGU8WVhtbEV2ZW50PlxuICovXG5jbGFzcyBZWG1sRnJhZ21lbnQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55PnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBmaXJzdENoaWxkICgpIHtcbiAgICBjb25zdCBmaXJzdCA9IHRoaXMuX2ZpcnN0O1xuICAgIHJldHVybiBmaXJzdCA/IGZpcnN0LmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSk7XG4gICAgdGhpcy5pbnNlcnQoMCwgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkpO1xuICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQgPSBudWxsO1xuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEZyYWdtZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEZyYWdtZW50KCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGVsLmluc2VydCgwLCB0aGlzLnRvQXJyYXkoKS5tYXAoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gaXRlbS5jbG9uZSgpIDogaXRlbSkpO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZWxpbUNvbnRlbnQgPT09IG51bGwgPyB0aGlzLl9sZW5ndGggOiB0aGlzLl9wcmVsaW1Db250ZW50Lmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHN1YnRyZWUgb2YgY2hpbGROb2Rlcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgd2Fsa2VyID0gZWxlbS5jcmVhdGVUcmVlV2Fsa2VyKGRvbSA9PiBkb20ubm9kZU5hbWUgPT09ICdkaXYnKVxuICAgKiBmb3IgKGxldCBub2RlIGluIHdhbGtlcikge1xuICAgKiAgIC8vIGBub2RlYCBpcyBhIGRpdiBub2RlXG4gICAqICAgbm9wKG5vZGUpXG4gICAqIH1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBYnN0cmFjdFR5cGU8YW55Pik6Ym9vbGVhbn0gZmlsdGVyIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggY2hpbGQgZWxlbWVudCBhbmRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybnMgYSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgY2hpbGRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBzdWJ0cmVlLlxuICAgKiBAcmV0dXJuIHtZWG1sVHJlZVdhbGtlcn0gQSBzdWJ0cmVlIGFuZCBhIHBvc2l0aW9uIHdpdGhpbiBpdC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY3JlYXRlVHJlZVdhbGtlciAoZmlsdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBmaWx0ZXIpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgWVhtbEVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeS5cbiAgICogU2ltaWxhciB0byBET00ncyB7QGxpbmsgcXVlcnlTZWxlY3Rvcn0uXG4gICAqXG4gICAqIFF1ZXJ5IHN1cHBvcnQ6XG4gICAqICAgLSB0YWduYW1lXG4gICAqIFRPRE86XG4gICAqICAgLSBpZFxuICAgKiAgIC0gYXR0cmlidXRlXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuLlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sSG9va3xudWxsfSBUaGUgZmlyc3QgZWxlbWVudCB0aGF0IG1hdGNoZXMgdGhlIHF1ZXJ5IG9yIG51bGwuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3IgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSk7XG4gICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV4dC52YWx1ZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBZWG1sRWxlbWVudHMgdGhhdCBtYXRjaCB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRG9tJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3JBbGx9LlxuICAgKlxuICAgKiBAdG9kbyBEb2VzIG5vdCB5ZXQgc3VwcG9ydCBhbGwgcXVlcmllcy4gQ3VycmVudGx5IG9ubHkgcXVlcnkgYnkgdGFnTmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHtDU1NfU2VsZWN0b3J9IHF1ZXJ5IFRoZSBxdWVyeSBvbiB0aGUgY2hpbGRyZW5cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbD59IFRoZSBlbGVtZW50cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3JBbGwgKHF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBxdWVyeS50b1VwcGVyQ2FzZSgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gYXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiB0aGlzIFlYbWxGcmFnbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFsbCBjaGlsZHJlbi5cbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RNYXAodGhpcywgeG1sID0+IHhtbC50b1N0cmluZygpKS5qb2luKCcnKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGZyYWdtZW50ID0gX2RvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihmcmFnbWVudCwgdGhpcyk7XG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnJhZ21lbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGNvbnRlbnQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgX3ByZWxpbUNvbnRlbnQgaXMgZGVmaW5lZCBiZWNhdXNlIHRoaXMgaXMgbm90IHlldCBpbnRlZ3JhdGVkXG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50LnNwbGljZShpbmRleCwgMCwgLi4uY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB4bWwuaW5zZXJ0KDAsIFtuZXcgWS5YbWxUZXh0KCd0ZXh0JyldKVxuICAgKlxuICAgKiBAcGFyYW0ge251bGx8SXRlbXxZWG1sRWxlbWVudHxZWG1sVGV4dH0gcmVmIFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdFxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0QWZ0ZXIgKHJlZiwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgcmVmSXRlbSA9IChyZWYgJiYgcmVmIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSA/IHJlZi5faXRlbSA6IHJlZjtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwYyA9IC8qKiBAdHlwZSB7QXJyYXk8YW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpO1xuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMTtcbiAgICAgIGlmIChpbmRleCA9PT0gMCAmJiByZWYgIT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3IuY3JlYXRlKCdSZWZlcmVuY2UgaXRlbSBub3QgZm91bmQnKVxuICAgICAgfVxuICAgICAgcGMuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZW1vdmUuIERlZmF1bHRzIHRvIDEuXG4gICAqL1xuICBkZWxldGUgKGluZGV4LCBsZW5ndGggPSAxKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTGlzdERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIGxlbmd0aCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIHRoaXMgWUFycmF5IHRvIGEgSmF2YVNjcmlwdCBBcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2s+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBhcHBlbmQuXG4gICAqL1xuICBwdXNoIChjb250ZW50KSB7XG4gICAgdGhpcy5pbnNlcnQodGhpcy5sZW5ndGgsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBwZW5kcyBjb250ZW50IHRvIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIHByZXBwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR8WVhtbFRleHR9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBZQXJyYXkgdG8gYSBKYXZhU2NyaXB0IEFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBvdmVyeSBjaGlsZCBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFlYbWxFbGVtZW50fFlYbWxUZXh0LG51bWJlciwgdHlwZW9mIHNlbGYpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqL1xuICBmb3JFYWNoIChmKSB7XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRnJhZ21lbnRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gX2RlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxGcmFnbWVudH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IHJlYWRZWG1sRnJhZ21lbnQgPSBfZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KCk7XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdHxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSBWYWx1ZVR5cGVzXG4gKi9cblxuLyoqXG4gKiBBbiBZWG1sRWxlbWVudCBpbWl0YXRlcyB0aGUgYmVoYXZpb3Igb2YgYVxuICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fS5cbiAqXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBhdHRyaWJ1dGVzIChrZXkgdmFsdWUgcGFpcnMpXG4gKiAqIEFuIFlYbWxFbGVtZW50IGhhcyBjaGlsZEVsZW1lbnRzIHRoYXQgbXVzdCBpbmhlcml0IGZyb20gWVhtbEVsZW1lbnRcbiAqXG4gKiBAdGVtcGxhdGUge3sgW2tleTogc3RyaW5nXTogVmFsdWVUeXBlcyB9fSBbS1Y9eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfV1cbiAqL1xuY2xhc3MgWVhtbEVsZW1lbnQgZXh0ZW5kcyBZWG1sRnJhZ21lbnQge1xuICBjb25zdHJ1Y3RvciAobm9kZU5hbWUgPSAnVU5ERUZJTkVEJykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5ub2RlTmFtZSA9IG5vZGVOYW1lO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgbmV4dFNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5uZXh0IDogbnVsbDtcbiAgICByZXR1cm4gbiA/IC8qKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR9ICovICgvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBwcmV2U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLnByZXYgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7KC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnQ8S1Y+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZWG1sRWxlbWVudDxLVj59XG4gICAgICovXG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBvYmplY3QuZm9yRWFjaChhdHRycywgKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSk7XG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgWE1MIHNlcmlhbGl6YXRpb24gb2YgdGhpcyBZWG1sRWxlbWVudC5cbiAgICogVGhlIGF0dHJpYnV0ZXMgYXJlIG9yZGVyZWQgYnkgYXR0cmlidXRlLW5hbWUsIHNvIHlvdSBjYW4gZWFzaWx5IHVzZSB0aGlzXG4gICAqIG1ldGhvZCB0byBjb21wYXJlIFlYbWxFbGVtZW50c1xuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0eXBlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b1N0cmluZyAoKSB7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBjb25zdCBzdHJpbmdCdWlsZGVyID0gW107XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5zb3J0KCk7XG4gICAgY29uc3Qga2V5c0xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5c0xlbjsgaSsrKSB7XG4gICAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKGtleSArICc9XCInICsgYXR0cnNba2V5XSArICdcIicpO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICBjb25zdCBhdHRyc1N0cmluZyA9IHN0cmluZ0J1aWxkZXIubGVuZ3RoID4gMCA/ICcgJyArIHN0cmluZ0J1aWxkZXIuam9pbignICcpIDogJyc7XG4gICAgcmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzU3RyaW5nfT4ke3N1cGVyLnRvU3RyaW5nKCl9PC8ke25vZGVOYW1lfT5gXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZyxhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtLVltLRVldfSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQXR0cnMpLnNldChhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgS1YgJiBzdHJpbmd9IEtFWVxuICAgKlxuICAgKiBAcGFyYW0ge0tFWX0gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtLVltLRVldfHVuZGVmaW5lZH0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhdHRyaWJ1dGUgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBjaGVjayBmb3IgZXhpc3RlbmNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBoYXNBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwSGFzKHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3sgW0tleSBpbiBFeHRyYWN0PGtleW9mIEtWLHN0cmluZz5dPzogS1ZbS2V5XX19IEEgSlNPTiBPYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGdldEF0dHJpYnV0ZXMgKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVNYXBHZXRBbGwodGhpcykpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ub2RlTmFtZSk7XG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAgY29uc3QgdmFsdWUgPSBhdHRyc1trZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHl4bWwgPT4ge1xuICAgICAgZG9tLmFwcGVuZENoaWxkKHl4bWwudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZykpO1xuICAgIH0pO1xuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEVsZW1lbnRSZWZJRCk7XG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLm5vZGVOYW1lKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxFbGVtZW50ID0gZGVjb2RlciA9PiBuZXcgWVhtbEVsZW1lbnQoZGVjb2Rlci5yZWFkS2V5KCkpO1xuXG4vKipcbiAqIEBleHRlbmRzIFlFdmVudDxZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRnJhZ21lbnQ+XG4gKiBBbiBFdmVudCB0aGF0IGRlc2NyaWJlcyBjaGFuZ2VzIG9uIGEgWVhtbCBFbGVtZW50IG9yIFl4bWwgRnJhZ21lbnRcbiAqL1xuY2xhc3MgWVhtbEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBvbiB3aGljaCB0aGUgZXZlbnQgaXMgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtTZXQ8c3RyaW5nfG51bGw+fSBzdWJzIFRoZSBzZXQgb2YgY2hhbmdlZCBhdHRyaWJ1dGVzLiBgbnVsbGAgaXMgaW5jbHVkZWQgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGNoaWxkIGxpc3QgY2hhbmdlZC5cbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIHRyYW5zYWN0aW9uIGluc3RhbmNlIHdpdGggd2ljaCB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlIHdhcyBjcmVhdGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgc3VicywgdHJhbnNhY3Rpb24pIHtcbiAgICBzdXBlcih0YXJnZXQsIHRyYW5zYWN0aW9uKTtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjaGlsZHJlbiBjaGFuZ2VkLlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQgPSBuZXcgU2V0KCk7XG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQuYWRkKHN1Yik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBZb3UgY2FuIG1hbmFnZSBiaW5kaW5nIHRvIGEgY3VzdG9tIHR5cGUgd2l0aCBZWG1sSG9vay5cbiAqXG4gKiBAZXh0ZW5kcyB7WU1hcDxhbnk+fVxuICovXG5jbGFzcyBZWG1sSG9vayBleHRlbmRzIFlNYXAge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhvb2tOYW1lIG5vZGVOYW1lIG9mIHRoZSBEb20gTm9kZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChob29rTmFtZSkge1xuICAgIHN1cGVyKCk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmhvb2tOYW1lID0gaG9va05hbWU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBJdGVtIHdpdGggdGhlIHNhbWUgZWZmZWN0IGFzIHRoaXMgSXRlbSAod2l0aG91dCBwb3NpdGlvbiBlZmZlY3QpXG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sSG9vayh0aGlzLmhvb2tOYW1lKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lYbWxIb29rfVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IGVsID0gbmV3IFlYbWxIb29rKHRoaXMuaG9va05hbWUpO1xuICAgIHRoaXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgZWwuc2V0KGtleSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywgYW55Pn0gW2hvb2tzXSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGhvb2sgPSBob29rc1t0aGlzLmhvb2tOYW1lXTtcbiAgICBsZXQgZG9tO1xuICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvbSA9IGhvb2suY3JlYXRlRG9tKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuaG9va05hbWUpO1xuICAgIH1cbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLXlqcy1ob29rJywgdGhpcy5ob29rTmFtZSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sSG9va1JlZklEKTtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMuaG9va05hbWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxIb29rfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgcmVhZFlYbWxIb29rID0gZGVjb2RlciA9PlxuICBuZXcgWVhtbEhvb2soZGVjb2Rlci5yZWFkS2V5KCkpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGV4dCBpbiBhIERvbSBFbGVtZW50LiBJbiB0aGUgZnV0dXJlIHRoaXMgdHlwZSB3aWxsIGFsc28gaGFuZGxlXG4gKiBzaW1wbGUgZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBsaWtlIGJvbGQgYW5kIGl0YWxpYy5cbiAqL1xuY2xhc3MgWVhtbFRleHQgZXh0ZW5kcyBZVGV4dCB7XG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsO1xuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxudWxsfVxuICAgKi9cbiAgZ2V0IHByZXZTaWJsaW5nICgpIHtcbiAgICBjb25zdCBuID0gdGhpcy5faXRlbSA/IHRoaXMuX2l0ZW0ucHJldiA6IG51bGw7XG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZWG1sVGV4dCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7WVhtbFRleHR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBZWG1sVGV4dCgpO1xuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSk7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgRG9tIEVsZW1lbnQgdGhhdCBtaXJyb3JzIHRoaXMgWVhtbFRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnR9IFtfZG9jdW1lbnQ9ZG9jdW1lbnRdIFRoZSBkb2N1bWVudCBvYmplY3QgKHlvdSBtdXN0IGRlZmluZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCBpblxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlanMpXG4gICAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gW2hvb2tzXSBPcHRpb25hbCBwcm9wZXJ0eSB0byBjdXN0b21pemUgaG93IGhvb2tzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJlIHByZXNlbnRlZCBpbiB0aGUgRE9NXG4gICAqIEBwYXJhbSB7YW55fSBbYmluZGluZ10gWW91IHNob3VsZCBub3Qgc2V0IHRoaXMgcHJvcGVydHkuIFRoaXMgaXNcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCBpZiBEb21CaW5kaW5nIHdhbnRzIHRvIGNyZWF0ZSBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uIHRvIHRoZSBjcmVhdGVkIERPTSB0eXBlLlxuICAgKiBAcmV0dXJuIHtUZXh0fSBUaGUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b0RPTSAoX2RvY3VtZW50ID0gZG9jdW1lbnQsIGhvb2tzLCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZG9tID0gX2RvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudG9TdHJpbmcoKSk7XG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy50b0RlbHRhKCkubWFwKGRlbHRhID0+IHtcbiAgICAgIGNvbnN0IG5lc3RlZE5vZGVzID0gW107XG4gICAgICBmb3IgKGNvbnN0IG5vZGVOYW1lIGluIGRlbHRhLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV0pIHtcbiAgICAgICAgICBhdHRycy5wdXNoKHsga2V5LCB2YWx1ZTogZGVsdGEuYXR0cmlidXRlc1tub2RlTmFtZV1ba2V5XSB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3J0IGF0dHJpYnV0ZXMgdG8gZ2V0IGEgdW5pcXVlIG9yZGVyXG4gICAgICAgIGF0dHJzLnNvcnQoKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IDEpO1xuICAgICAgICBuZXN0ZWROb2Rlcy5wdXNoKHsgbm9kZU5hbWUsIGF0dHJzIH0pO1xuICAgICAgfVxuICAgICAgLy8gc29ydCBub2RlIG9yZGVyIHRvIGdldCBhIHVuaXF1ZSBvcmRlclxuICAgICAgbmVzdGVkTm9kZXMuc29ydCgoYSwgYikgPT4gYS5ub2RlTmFtZSA8IGIubm9kZU5hbWUgPyAtMSA6IDEpO1xuICAgICAgLy8gbm93IGNvbnZlcnQgdG8gZG9tIHN0cmluZ1xuICAgICAgbGV0IHN0ciA9ICcnO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXN0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbmVzdGVkTm9kZXNbaV07XG4gICAgICAgIHN0ciArPSBgPCR7bm9kZS5ub2RlTmFtZX1gO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBhdHRyID0gbm9kZS5hdHRyc1tqXTtcbiAgICAgICAgICBzdHIgKz0gYCAke2F0dHIua2V5fT1cIiR7YXR0ci52YWx1ZX1cImA7XG4gICAgICAgIH1cbiAgICAgICAgc3RyICs9ICc+JztcbiAgICAgIH1cbiAgICAgIHN0ciArPSBkZWx0YS5pbnNlcnQ7XG4gICAgICBmb3IgKGxldCBpID0gbmVzdGVkTm9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgc3RyICs9IGA8LyR7bmVzdGVkTm9kZXNbaV0ubm9kZU5hbWV9PmA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyXG4gICAgfSkuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbFRleHRSZWZJRCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbFRleHR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCByZWFkWVhtbFRleHQgPSBkZWNvZGVyID0+IG5ldyBZWG1sVGV4dCgpO1xuXG5jbGFzcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlbmd0aCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBkZWxldGVkICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGlzIHN0cnVjdCB3aXRoIHRoZSBpdGVtIHRvIHRoZSByaWdodC5cbiAgICogVGhpcyBtZXRob2QgaXMgYWxyZWFkeSBhc3N1bWluZyB0aGF0IGB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggPT09IHRoaXMuaWQuY2xvY2tgLlxuICAgKiBBbHNvIHRoaXMgbWV0aG9kIGRvZXMgKm5vdCogcmVtb3ZlIHJpZ2h0IGZyb20gU3RydWN0U3RvcmUhXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHdldGhlciB0aGlzIG1lcmdlZCB3aXRoIHJpZ2h0XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcGFyYW0ge251bWJlcn0gZW5jb2RpbmdSZWZcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQsIGVuY29kaW5nUmVmKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cbn1cblxuY29uc3Qgc3RydWN0R0NSZWZOdW1iZXIgPSAwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIEdDIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dDfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICB0aGlzLmlkLmNsb2NrICs9IG9mZnNldDtcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldDtcbiAgICB9XG4gICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVJbmZvKHN0cnVjdEdDUmVmTnVtYmVyKTtcbiAgICBlbmNvZGVyLndyaXRlTGVuKHRoaXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5jbGFzcyBDb250ZW50QmluYXJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNvbnRlbnRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRCaW5hcnkodGhpcy5jb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QmluYXJ5fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlQnVmKHRoaXMuY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gM1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIgfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50QmluYXJ5fVxuICovXG5jb25zdCByZWFkQ29udGVudEJpbmFyeSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRCaW5hcnkoZGVjb2Rlci5yZWFkQnVmKCkpO1xuXG5jbGFzcyBDb250ZW50RGVsZXRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVuKSB7XG4gICAgdGhpcy5sZW4gPSBsZW47XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4gLSBvZmZzZXQpO1xuICAgIHRoaXMubGVuID0gb2Zmc2V0O1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERlbGV0ZWR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5sZW4gKz0gcmlnaHQubGVuO1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jaywgdGhpcy5sZW4pO1xuICAgIGl0ZW0ubWFya0RlbGV0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbiAtIG9mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICovXG5jb25zdCByZWFkQ29udGVudERlbGV0ZWQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RGVsZXRlZChkZWNvZGVyLnJlYWRMZW4oKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGd1aWRcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gb3B0c1xuICovXG5jb25zdCBjcmVhdGVEb2NGcm9tT3B0cyA9IChndWlkLCBvcHRzKSA9PiBuZXcgRG9jKHsgZ3VpZCwgLi4ub3B0cywgc2hvdWxkTG9hZDogb3B0cy5zaG91bGRMb2FkIHx8IG9wdHMuYXV0b0xvYWQgfHwgZmFsc2UgfSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudERvYyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgaWYgKGRvYy5faXRlbSkge1xuICAgICAgY29uc29sZS5lcnJvcignVGhpcyBkb2N1bWVudCB3YXMgYWxyZWFkeSBpbnRlZ3JhdGVkIGFzIGEgc3ViLWRvY3VtZW50LiBZb3Ugc2hvdWxkIGNyZWF0ZSBhIHNlY29uZCBpbnN0YW5jZSBpbnN0ZWFkIHdpdGggdGhlIHNhbWUgZ3VpZC4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIGlmICghZG9jLmdjKSB7XG4gICAgICBvcHRzLmdjID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkb2MuYXV0b0xvYWQpIHtcbiAgICAgIG9wdHMuYXV0b0xvYWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZG9jLm1ldGEgIT09IG51bGwpIHtcbiAgICAgIG9wdHMubWV0YSA9IGRvYy5tZXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy5kb2NdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnREb2MoY3JlYXRlRG9jRnJvbU9wdHModGhpcy5kb2MuZ3VpZCwgdGhpcy5vcHRzKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnREb2N9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudERvY30gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyB0aGlzIG5lZWRzIHRvIGJlIHJlZmxlY3RlZCBpbiBkb2MuZGVzdHJveSBhcyB3ZWxsXG4gICAgdGhpcy5kb2MuX2l0ZW0gPSBpdGVtO1xuICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQodGhpcy5kb2MpO1xuICAgIGlmICh0aGlzLmRvYy5zaG91bGRMb2FkKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzTG9hZGVkLmFkZCh0aGlzLmRvYyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5oYXModGhpcy5kb2MpKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuZGVsZXRlKHRoaXMuZG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMuZG9jKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkgeyB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHRoaXMuZG9jLmd1aWQpO1xuICAgIGVuY29kZXIud3JpdGVBbnkodGhpcy5vcHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA5XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICovXG5jb25zdCByZWFkQ29udGVudERvYyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnREb2MoY3JlYXRlRG9jRnJvbU9wdHMoZGVjb2Rlci5yZWFkU3RyaW5nKCksIGRlY29kZXIucmVhZEFueSgpKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEVtYmVkIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbWJlZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVtYmVkKSB7XG4gICAgdGhpcy5lbWJlZCA9IGVtYmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmVtYmVkXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRFbWJlZCh0aGlzLmVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRFbWJlZH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy5lbWJlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICovXG5jb25zdCByZWFkQ29udGVudEVtYmVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEVtYmVkKGRlY29kZXIucmVhZEpTT04oKSk7XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ29udGVudEZvcm1hdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRGb3JtYXR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRGb3JtYXQodGhpcy5rZXksIHRoaXMudmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRGb3JtYXR9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgLy8gQHRvZG8gc2VhcmNobWFya2VyIGFyZSBjdXJyZW50bHkgdW5zdXBwb3J0ZWQgZm9yIHJpY2ggdGV4dCBkb2N1bWVudHNcbiAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoaXRlbS5wYXJlbnQpLl9zZWFyY2hNYXJrZXIgPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMua2V5KTtcbiAgICBlbmNvZGVyLndyaXRlSlNPTih0aGlzLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA2XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRGb3JtYXQgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50Rm9ybWF0KGRlY29kZXIucmVhZEtleSgpLCBkZWNvZGVyLnJlYWRKU09OKCkpO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRKU09OIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnI7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEpTT04odGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEpTT04odGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSk7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5zbGljZSgwLCBvZmZzZXQpO1xuICAgIHJldHVybiByaWdodFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudEpTT059IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGg7XG4gICAgZW5jb2Rlci53cml0ZUxlbihsZW4gLSBvZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldO1xuICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhjID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IEpTT04uc3RyaW5naWZ5KGMpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMlxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEpTT059XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50SlNPTiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKTtcbiAgY29uc3QgY3MgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGMgPSBkZWNvZGVyLnJlYWRTdHJpbmcoKTtcbiAgICBpZiAoYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3MucHVzaChKU09OLnBhcnNlKGMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50SlNPTihjcylcbn07XG5cbmNsYXNzIENvbnRlbnRBbnkge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxhbnk+fSBhcnJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChhcnIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLmFyciA9IGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50QW55KHRoaXMuYXJyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuc2xpY2UoMCwgb2Zmc2V0KTtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRBbnl9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5jb25jYXQocmlnaHQuYXJyKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGg7XG4gICAgZW5jb2Rlci53cml0ZUxlbihsZW4gLSBvZmZzZXQpO1xuICAgIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgYyA9IHRoaXMuYXJyW2ldO1xuICAgICAgZW5jb2Rlci53cml0ZUFueShjKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gOFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gKi9cbmNvbnN0IHJlYWRDb250ZW50QW55ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpO1xuICBjb25zdCBjcyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY3MucHVzaChkZWNvZGVyLnJlYWRBbnkoKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50QW55KGNzKVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBDb250ZW50U3RyaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3RyID0gc3RyO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyLmxlbmd0aFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIuc3BsaXQoJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRTdHJpbmcodGhpcy5zdHIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50U3RyaW5nfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50U3RyaW5nKHRoaXMuc3RyLnNsaWNlKG9mZnNldCkpO1xuICAgIHRoaXMuc3RyID0gdGhpcy5zdHIuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgIC8vIFByZXZlbnQgZW5jb2RpbmcgaW52YWxpZCBkb2N1bWVudHMgYmVjYXVzZSBvZiBzcGxpdHRpbmcgb2Ygc3Vycm9nYXRlIHBhaXJzOiBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvMjQ4XG4gICAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHRoaXMuc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSk7XG4gICAgaWYgKGZpcnN0Q2hhckNvZGUgPj0gMHhEODAwICYmIGZpcnN0Q2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICAvLyBMYXN0IGNoYXJhY3RlciBvZiB0aGUgbGVmdCBzcGxpdCBpcyB0aGUgc3RhcnQgb2YgYSBzdXJyb2dhdGUgdXRmMTYvdWNzMiBwYWlyLlxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBzcGxpdHRpbmcgb2Ygc3Vycm9nYXRlIHBhaXJzIGJlY2F1c2UgdGhpcyBtYXkgbGVhZCB0byBpbnZhbGlkIGRvY3VtZW50cy5cbiAgICAgIC8vIFJlcGxhY2UgdGhlIGludmFsaWQgY2hhcmFjdGVyIHdpdGggYSB1bmljb2RlIHJlcGxhY2VtZW50IGNoYXJhY3RlciAo77+9IC8gVStGRkZEKVxuICAgICAgdGhpcy5zdHIgPSB0aGlzLnN0ci5zbGljZSgwLCBvZmZzZXQgLSAxKSArICfvv70nO1xuICAgICAgLy8gcmVwbGFjZSByaWdodCBhcyB3ZWxsXG4gICAgICByaWdodC5zdHIgPSAn77+9JyArIHJpZ2h0LnN0ci5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50U3RyaW5nfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuc3RyICs9IHJpZ2h0LnN0cjtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlU3RyaW5nKG9mZnNldCA9PT0gMCA/IHRoaXMuc3RyIDogdGhpcy5zdHIuc2xpY2Uob2Zmc2V0KSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gNFxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAqL1xuY29uc3QgcmVhZENvbnRlbnRTdHJpbmcgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50U3RyaW5nKGRlY29kZXIucmVhZFN0cmluZygpKTtcblxuLyoqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdFR5cGU8YW55Pj59XG4gKiBAcHJpdmF0ZVxuICovXG5jb25zdCB0eXBlUmVmcyA9IFtcbiAgcmVhZFlBcnJheSxcbiAgcmVhZFlNYXAsXG4gIHJlYWRZVGV4dCxcbiAgcmVhZFlYbWxFbGVtZW50LFxuICByZWFkWVhtbEZyYWdtZW50LFxuICByZWFkWVhtbEhvb2ssXG4gIHJlYWRZWG1sVGV4dFxuXTtcblxuY29uc3QgWUFycmF5UmVmSUQgPSAwO1xuY29uc3QgWU1hcFJlZklEID0gMTtcbmNvbnN0IFlUZXh0UmVmSUQgPSAyO1xuY29uc3QgWVhtbEVsZW1lbnRSZWZJRCA9IDM7XG5jb25zdCBZWG1sRnJhZ21lbnRSZWZJRCA9IDQ7XG5jb25zdCBZWG1sSG9va1JlZklEID0gNTtcbmNvbnN0IFlYbWxUZXh0UmVmSUQgPSA2O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIENvbnRlbnRUeXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMudHlwZV1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRUeXBlKHRoaXMudHlwZS5fY29weSgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29udGVudFR5cGV9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgdGhpcy50eXBlLl9pbnRlZ3JhdGUodHJhbnNhY3Rpb24uZG9jLCBpdGVtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydDtcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGdjJ2QgbGF0ZXIgYW5kIHdlIHdhbnQgdG8gbWVyZ2UgaXQgaWYgcG9zc2libGVcbiAgICAgICAgLy8gV2UgdHJ5IHRvIG1lcmdlIGFsbCBkZWxldGVkIGl0ZW1zIGFmdGVyIGVhY2ggdHJhbnNhY3Rpb24sXG4gICAgICAgIC8vIGJ1dCB3ZSBoYXZlIG5vIGtub3dsZWRnZSBhYm91dCB0aGF0IHRoaXMgbmVlZHMgdG8gYmUgbWVyZ2VkXG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIG5vdCBpbiB0cmFuc2FjdGlvbi5kcy4gSGVuY2Ugd2UgYWRkIGl0IHRvIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHNcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pO1xuICAgICAgfVxuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgfVxuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYW1lIGFzIGFib3ZlXG4gICAgICAgIHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmRlbGV0ZSh0aGlzLnR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnQ7XG4gICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpO1xuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHQ7XG4gICAgfVxuICAgIHRoaXMudHlwZS5fc3RhcnQgPSBudWxsO1xuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goLyoqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGl0ZW0gKi8gKGl0ZW0pID0+IHtcbiAgICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW0uZ2Moc3RvcmUsIHRydWUpO1xuICAgICAgICBpdGVtID0gaXRlbS5sZWZ0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMudHlwZS5fbWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICB0aGlzLnR5cGUuX3dyaXRlKGVuY29kZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDdcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRUeXBlfVxuICovXG5jb25zdCByZWFkQ29udGVudFR5cGUgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50VHlwZSh0eXBlUmVmc1tkZWNvZGVyLnJlYWRUeXBlUmVmKCldKGRlY29kZXIpKTtcblxuLyoqXG4gKiBAdG9kbyBUaGlzIHNob3VsZCByZXR1cm4gc2V2ZXJhbCBpdGVtc1xuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7e2l0ZW06SXRlbSwgZGlmZjpudW1iZXJ9fVxuICovXG5jb25zdCBmb2xsb3dSZWRvbmUgPSAoc3RvcmUsIGlkKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7SUR8bnVsbH1cbiAgICovXG4gIGxldCBuZXh0SUQgPSBpZDtcbiAgbGV0IGRpZmYgPSAwO1xuICBsZXQgaXRlbTtcbiAgZG8ge1xuICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgbmV4dElEID0gY3JlYXRlSUQobmV4dElELmNsaWVudCwgbmV4dElELmNsb2NrICsgZGlmZik7XG4gICAgfVxuICAgIGl0ZW0gPSBnZXRJdGVtKHN0b3JlLCBuZXh0SUQpO1xuICAgIGRpZmYgPSBuZXh0SUQuY2xvY2sgLSBpdGVtLmlkLmNsb2NrO1xuICAgIG5leHRJRCA9IGl0ZW0ucmVkb25lO1xuICB9IHdoaWxlIChuZXh0SUQgIT09IG51bGwgJiYgaXRlbSBpbnN0YW5jZW9mIEl0ZW0pXG4gIHJldHVybiB7XG4gICAgaXRlbSwgZGlmZlxuICB9XG59O1xuXG4vKipcbiAqIE1ha2Ugc3VyZSB0aGF0IG5laXRoZXIgaXRlbSBub3IgYW55IG9mIGl0cyBwYXJlbnRzIGlzIGV2ZXIgZGVsZXRlZC5cbiAqXG4gKiBUaGlzIHByb3BlcnR5IGRvZXMgbm90IHBlcnNpc3Qgd2hlbiBzdG9yaW5nIGl0IGludG8gYSBkYXRhYmFzZSBvciB3aGVuXG4gKiBzZW5kaW5nIGl0IHRvIG90aGVyIHBlZXJzXG4gKlxuICogQHBhcmFtIHtJdGVtfG51bGx9IGl0ZW1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0ga2VlcFxuICovXG5jb25zdCBrZWVwSXRlbSA9IChpdGVtLCBrZWVwKSA9PiB7XG4gIHdoaWxlIChpdGVtICE9PSBudWxsICYmIGl0ZW0ua2VlcCAhPT0ga2VlcCkge1xuICAgIGl0ZW0ua2VlcCA9IGtlZXA7XG4gICAgaXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW07XG4gIH1cbn07XG5cbi8qKlxuICogU3BsaXQgbGVmdEl0ZW0gaW50byB0d28gaXRlbXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGxlZnRJdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHNwbGl0SXRlbSA9ICh0cmFuc2FjdGlvbiwgbGVmdEl0ZW0sIGRpZmYpID0+IHtcbiAgLy8gY3JlYXRlIHJpZ2h0SXRlbVxuICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkO1xuICBjb25zdCByaWdodEl0ZW0gPSBuZXcgSXRlbShcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgbGVmdEl0ZW0sXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICBsZWZ0SXRlbS5yaWdodCxcbiAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gICk7XG4gIGlmIChsZWZ0SXRlbS5kZWxldGVkKSB7XG4gICAgcmlnaHRJdGVtLm1hcmtEZWxldGVkKCk7XG4gIH1cbiAgaWYgKGxlZnRJdGVtLmtlZXApIHtcbiAgICByaWdodEl0ZW0ua2VlcCA9IHRydWU7XG4gIH1cbiAgaWYgKGxlZnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yZWRvbmUgPSBjcmVhdGVJRChsZWZ0SXRlbS5yZWRvbmUuY2xpZW50LCBsZWZ0SXRlbS5yZWRvbmUuY2xvY2sgKyBkaWZmKTtcbiAgfVxuICAvLyB1cGRhdGUgbGVmdCAoZG8gbm90IHNldCBsZWZ0SXRlbS5yaWdodE9yaWdpbiBhcyBpdCB3aWxsIGxlYWQgdG8gcHJvYmxlbXMgd2hlbiBzeW5jaW5nKVxuICBsZWZ0SXRlbS5yaWdodCA9IHJpZ2h0SXRlbTtcbiAgLy8gdXBkYXRlIHJpZ2h0XG4gIGlmIChyaWdodEl0ZW0ucmlnaHQgIT09IG51bGwpIHtcbiAgICByaWdodEl0ZW0ucmlnaHQubGVmdCA9IHJpZ2h0SXRlbTtcbiAgfVxuICAvLyByaWdodCBpcyBtb3JlIHNwZWNpZmljLlxuICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2gocmlnaHRJdGVtKTtcbiAgLy8gdXBkYXRlIHBhcmVudC5fbWFwXG4gIGlmIChyaWdodEl0ZW0ucGFyZW50U3ViICE9PSBudWxsICYmIHJpZ2h0SXRlbS5yaWdodCA9PT0gbnVsbCkge1xuICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodEl0ZW0ucGFyZW50KS5fbWFwLnNldChyaWdodEl0ZW0ucGFyZW50U3ViLCByaWdodEl0ZW0pO1xuICB9XG4gIGxlZnRJdGVtLmxlbmd0aCA9IGRpZmY7XG4gIHJldHVybiByaWdodEl0ZW1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdGFja0l0ZW0+fSBzdGFja1xuICogQHBhcmFtIHtJRH0gaWRcbiAqL1xuY29uc3QgaXNEZWxldGVkQnlVbmRvU3RhY2sgPSAoc3RhY2ssIGlkKSA9PiBhcnJheS5zb21lKHN0YWNrLCAvKiogQHBhcmFtIHtTdGFja0l0ZW19IHMgKi8gcyA9PiBpc0RlbGV0ZWQocy5kZWxldGlvbnMsIGlkKSk7XG5cbi8qKlxuICogUmVkb2VzIHRoZSBlZmZlY3Qgb2YgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gVGhlIFlqcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTZXQ8SXRlbT59IHJlZG9pdGVtc1xuICogQHBhcmFtIHtEZWxldGVTZXR9IGl0ZW1zVG9EZWxldGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlUmVtb3RlTWFwQ2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL3V0aWxzL1VuZG9NYW5hZ2VyLmpzJykuVW5kb01hbmFnZXJ9IHVtXG4gKlxuICogQHJldHVybiB7SXRlbXxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHJlZG9JdGVtID0gKHRyYW5zYWN0aW9uLCBpdGVtLCByZWRvaXRlbXMsIGl0ZW1zVG9EZWxldGUsIGlnbm9yZVJlbW90ZU1hcENoYW5nZXMsIHVtKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvYztcbiAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmU7XG4gIGNvbnN0IG93bkNsaWVudElEID0gZG9jLmNsaWVudElEO1xuICBjb25zdCByZWRvbmUgPSBpdGVtLnJlZG9uZTtcbiAgaWYgKHJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmVkb25lKVxuICB9XG4gIGxldCBwYXJlbnRJdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbTtcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbGVmdCA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgKi9cbiAgbGV0IHJpZ2h0O1xuICAvLyBtYWtlIHN1cmUgdGhhdCBwYXJlbnQgaXMgcmVkb25lXG4gIGlmIChwYXJlbnRJdGVtICE9PSBudWxsICYmIHBhcmVudEl0ZW0uZGVsZXRlZCA9PT0gdHJ1ZSkge1xuICAgIC8vIHRyeSB0byB1bmRvIHBhcmVudCBpZiBpdCB3aWxsIGJlIHVuZG9uZSBhbnl3YXlcbiAgICBpZiAocGFyZW50SXRlbS5yZWRvbmUgPT09IG51bGwgJiYgKCFyZWRvaXRlbXMuaGFzKHBhcmVudEl0ZW0pIHx8IHJlZG9JdGVtKHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLCByZWRvaXRlbXMsIGl0ZW1zVG9EZWxldGUsIGlnbm9yZVJlbW90ZU1hcENoYW5nZXMsIHVtKSA9PT0gbnVsbCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHdoaWxlIChwYXJlbnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50SXRlbSA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBwYXJlbnRJdGVtLnJlZG9uZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnRJdGVtID09PSBudWxsID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KSA6IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGU7XG5cbiAgaWYgKGl0ZW0ucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgLy8gSXMgYW4gYXJyYXkgaXRlbS4gSW5zZXJ0IGF0IHRoZSBvbGQgcG9zaXRpb25cbiAgICBsZWZ0ID0gaXRlbS5sZWZ0O1xuICAgIHJpZ2h0ID0gaXRlbTtcbiAgICAvLyBmaW5kIG5leHQgY2xvbmVkX3JlZG8gaXRlbXNcbiAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgbGVmdFRyYWNlID0gbGVmdDtcbiAgICAgIC8vIHRyYWNlIHJlZG9uZSB1bnRpbCBwYXJlbnQgbWF0Y2hlc1xuICAgICAgd2hpbGUgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdFRyYWNlID0gbGVmdFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgbGVmdFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSA9PT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0ID0gbGVmdFRyYWNlO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQubGVmdDtcbiAgICB9XG4gICAgd2hpbGUgKHJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCByaWdodFRyYWNlID0gcmlnaHQ7XG4gICAgICAvLyB0cmFjZSByZWRvbmUgdW50aWwgcGFyZW50IG1hdGNoZXNcbiAgICAgIHdoaWxlIChyaWdodFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodFRyYWNlLnBhcmVudCkuX2l0ZW0gIT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgcmlnaHRUcmFjZSA9IHJpZ2h0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCByaWdodFRyYWNlLnJlZG9uZSk7XG4gICAgICB9XG4gICAgICBpZiAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0ID0gcmlnaHRUcmFjZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJpZ2h0ID0gbnVsbDtcbiAgICBpZiAoaXRlbS5yaWdodCAmJiAhaWdub3JlUmVtb3RlTWFwQ2hhbmdlcykge1xuICAgICAgbGVmdCA9IGl0ZW07XG4gICAgICAvLyBJdGVyYXRlIHJpZ2h0IHdoaWxlIHJpZ2h0IGlzIGluIGl0ZW1zVG9EZWxldGVcbiAgICAgIC8vIElmIGl0IGlzIGludGVuZGVkIHRvIGRlbGV0ZSByaWdodCB3aGlsZSBpdGVtIGlzIHJlZG9uZSwgd2UgY2FuIGV4cGVjdCB0aGF0IGl0ZW0gc2hvdWxkIHJlcGxhY2UgcmlnaHQuXG4gICAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCAmJiBsZWZ0LnJpZ2h0ICE9PSBudWxsICYmIChsZWZ0LnJpZ2h0LnJlZG9uZSB8fCBpc0RlbGV0ZWQoaXRlbXNUb0RlbGV0ZSwgbGVmdC5yaWdodC5pZCkgfHwgaXNEZWxldGVkQnlVbmRvU3RhY2sodW0udW5kb1N0YWNrLCBsZWZ0LnJpZ2h0LmlkKSB8fCBpc0RlbGV0ZWRCeVVuZG9TdGFjayh1bS5yZWRvU3RhY2ssIGxlZnQucmlnaHQuaWQpKSkge1xuICAgICAgICBsZWZ0ID0gbGVmdC5yaWdodDtcbiAgICAgICAgLy8gZm9sbG93IHJlZG9uZVxuICAgICAgICB3aGlsZSAobGVmdC5yZWRvbmUpIGxlZnQgPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgbGVmdC5yZWRvbmUpO1xuICAgICAgfVxuICAgICAgaWYgKGxlZnQgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcmVkbyB0aGlzIGl0ZW0gYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhXG4gICAgICAgIC8vIGNoYW5nZSBmcm9tIGFub3RoZXIgY2xpZW50XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBwYXJlbnRUeXBlLl9tYXAuZ2V0KGl0ZW0ucGFyZW50U3ViKSB8fCBudWxsO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0Q2xvY2sgPSBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SUQpO1xuICBjb25zdCBuZXh0SWQgPSBjcmVhdGVJRChvd25DbGllbnRJRCwgbmV4dENsb2NrKTtcbiAgY29uc3QgcmVkb25lSXRlbSA9IG5ldyBJdGVtKFxuICAgIG5leHRJZCxcbiAgICBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLFxuICAgIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCxcbiAgICBwYXJlbnRUeXBlLFxuICAgIGl0ZW0ucGFyZW50U3ViLFxuICAgIGl0ZW0uY29udGVudC5jb3B5KClcbiAgKTtcbiAgaXRlbS5yZWRvbmUgPSBuZXh0SWQ7XG4gIGtlZXBJdGVtKHJlZG9uZUl0ZW0sIHRydWUpO1xuICByZWRvbmVJdGVtLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMCk7XG4gIHJldHVybiByZWRvbmVJdGVtXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhbnkgY29udGVudC5cbiAqL1xuY2xhc3MgSXRlbSBleHRlbmRzIEFic3RyYWN0U3RydWN0IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IGxlZnRcbiAgICogQHBhcmFtIHtJRCB8IG51bGx9IG9yaWdpblxuICAgKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gcmlnaHRPcmlnaW5cbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55PnxJRHxudWxsfSBwYXJlbnQgSXMgYSB0eXBlIGlmIGludGVncmF0ZWQsIGlzIG51bGwgaWYgaXQgaXMgcG9zc2libGUgdG8gY29weSBwYXJlbnQgZnJvbSBsZWZ0IG9yIHJpZ2h0LCBpcyBJRCBiZWZvcmUgaW50ZWdyYXRpb24gdG8gc2VhcmNoIGZvciBpdC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsfSBwYXJlbnRTdWJcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRlbnR9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChpZCwgbGVmdCwgb3JpZ2luLCByaWdodCwgcmlnaHRPcmlnaW4sIHBhcmVudCwgcGFyZW50U3ViLCBjb250ZW50KSB7XG4gICAgc3VwZXIoaWQsIGNvbnRlbnQuZ2V0TGVuZ3RoKCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5vcmlnaW4gPSBvcmlnaW47XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgIC8qKlxuICAgICAqIFRoZSBpdGVtIHRoYXQgaXMgY3VycmVudGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0l0ZW0gfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSByaWdodCBvZiB0aGlzIGl0ZW0uXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJpZ2h0T3JpZ2luID0gcmlnaHRPcmlnaW47XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBhcmVudCByZWZlcnMgdG8gdGhpcyBpdGVtIHdpdGggc29tZSBraW5kIG9mIGtleSAoZS5nLiBZTWFwLCB0aGVcbiAgICAgKiBrZXkgaXMgc3BlY2lmaWVkIGhlcmUuIFRoZSBrZXkgaXMgdGhlbiB1c2VkIHRvIHJlZmVyIHRvIHRoZSBsaXN0IGluIHdoaWNoXG4gICAgICogdG8gaW5zZXJ0IHRoaXMgaXRlbS4gSWYgYHBhcmVudFN1YiA9IG51bGxgIHR5cGUuX3N0YXJ0IGlzIHRoZSBsaXN0IGluXG4gICAgICogd2hpY2ggdG8gaW5zZXJ0IHRvLiBPdGhlcndpc2UgaXQgaXMgYHBhcmVudC5fbWFwYC5cbiAgICAgKiBAdHlwZSB7U3RyaW5nIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudFN1YiA9IHBhcmVudFN1YjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIHR5cGUncyBlZmZlY3QgaXMgcmVkb25lIHRoaXMgdHlwZSByZWZlcnMgdG8gdGhlIHR5cGUgdGhhdCB1bmRpZFxuICAgICAqIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yZWRvbmUgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdENvbnRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAvKipcbiAgICAgKiBiaXQxOiBrZWVwXG4gICAgICogYml0MjogY291bnRhYmxlXG4gICAgICogYml0MzogZGVsZXRlZFxuICAgICAqIGJpdDQ6IG1hcmsgLSBtYXJrIG5vZGUgYXMgZmFzdC1zZWFyY2gtbWFya2VyXG4gICAgICogQHR5cGUge251bWJlcn0gYnl0ZVxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHRoaXMuY29udGVudC5pc0NvdW50YWJsZSgpID8gYmluYXJ5LkJJVDIgOiAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgdXNlZCB0byBtYXJrIHRoZSBpdGVtIGFzIGFuIGluZGV4ZWQgZmFzdC1zZWFyY2ggbWFya2VyXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc2V0IG1hcmtlciAoaXNNYXJrZWQpIHtcbiAgICBpZiAoKCh0aGlzLmluZm8gJiBiaW5hcnkuQklUNCkgPiAwKSAhPT0gaXNNYXJrZWQpIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUNDtcbiAgICB9XG4gIH1cblxuICBnZXQgbWFya2VyICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQ0KSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkbyBub3QgZ2FyYmFnZSBjb2xsZWN0IHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBrZWVwICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQxKSA+IDBcbiAgfVxuXG4gIHNldCBrZWVwIChkb0tlZXApIHtcbiAgICBpZiAodGhpcy5rZWVwICE9PSBkb0tlZXApIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUMTtcbiAgICB9XG4gIH1cblxuICBnZXQgY291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQyKSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgaXRlbSB3YXMgZGVsZXRlZCBvciBub3QuXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGRlbGV0ZWQgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgYmluYXJ5LkJJVDMpID4gMFxuICB9XG5cbiAgc2V0IGRlbGV0ZWQgKGRvRGVsZXRlKSB7XG4gICAgaWYgKHRoaXMuZGVsZXRlZCAhPT0gZG9EZWxldGUpIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUMztcbiAgICB9XG4gIH1cblxuICBtYXJrRGVsZXRlZCAoKSB7XG4gICAgdGhpcy5pbmZvIHw9IGJpbmFyeS5CSVQzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3JlYXRvciBjbGllbnRJRCBvZiB0aGUgbWlzc2luZyBvcCBvciBkZWZpbmUgbWlzc2luZyBpdGVtcyBhbmQgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLm9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5vcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbiAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5yaWdodE9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodE9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCAmJiB0aGlzLmlkLmNsaWVudCAhPT0gdGhpcy5wYXJlbnQuY2xpZW50ICYmIHRoaXMucGFyZW50LmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnBhcmVudC5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xpZW50XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhbGwgbWlzc2luZyBpZHMsIG5vdyBmaW5kIHRoZSBpdGVtc1xuXG4gICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICB0aGlzLmxlZnQgPSBnZXRJdGVtQ2xlYW5FbmQodHJhbnNhY3Rpb24sIHN0b3JlLCB0aGlzLm9yaWdpbik7XG4gICAgICB0aGlzLm9yaWdpbiA9IHRoaXMubGVmdC5sYXN0SWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLnJpZ2h0T3JpZ2luKSB7XG4gICAgICB0aGlzLnJpZ2h0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHRoaXMucmlnaHRPcmlnaW4pO1xuICAgICAgdGhpcy5yaWdodE9yaWdpbiA9IHRoaXMucmlnaHQuaWQ7XG4gICAgfVxuICAgIGlmICgodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gR0MpIHx8ICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEdDKSkge1xuICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAvLyBvbmx5IHNldCBwYXJlbnQgaWYgdGhpcyBzaG91bGRuJ3QgYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnQ7XG4gICAgICAgIHRoaXMucGFyZW50U3ViID0gdGhpcy5sZWZ0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICYmIHRoaXMucmlnaHQuY29uc3RydWN0b3IgPT09IEl0ZW0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnJpZ2h0LnBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLnJpZ2h0LnBhcmVudFN1YjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgY29uc3QgcGFyZW50SXRlbSA9IGdldEl0ZW0oc3RvcmUsIHRoaXMucGFyZW50KTtcbiAgICAgIGlmIChwYXJlbnRJdGVtLmNvbnN0cnVjdG9yID09PSBHQykge1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0O1xuICAgICAgdGhpcy5sZWZ0ID0gZ2V0SXRlbUNsZWFuRW5kKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kb2Muc3RvcmUsIGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrIC0gMSkpO1xuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkO1xuICAgICAgdGhpcy5jb250ZW50ID0gdGhpcy5jb250ZW50LnNwbGljZShvZmZzZXQpO1xuICAgICAgdGhpcy5sZW5ndGggLT0gb2Zmc2V0O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKCghdGhpcy5sZWZ0ICYmICghdGhpcy5yaWdodCB8fCB0aGlzLnJpZ2h0LmxlZnQgIT09IG51bGwpKSB8fCAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5yaWdodCAhPT0gdGhpcy5yaWdodCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIGxldCBvO1xuICAgICAgICAvLyBzZXQgbyB0byB0aGUgZmlyc3QgY29uZmxpY3RpbmcgaXRlbVxuICAgICAgICBpZiAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG8gPSBsZWZ0LnJpZ2h0O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGw7XG4gICAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgby5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvID0gby5sZWZ0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXNlIHNvbWV0aGluZyBsaWtlIERlbGV0ZVNldCBoZXJlIChhIHRyZWUgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYmVzdClcbiAgICAgICAgLy8gQHRvZG8gdXNlIGdsb2JhbCBzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge1NldDxJdGVtPn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGl0ZW1zQmVmb3JlT3JpZ2luID0gbmV3IFNldCgpO1xuICAgICAgICAvLyBMZXQgYyBpbiBjb25mbGljdGluZ0l0ZW1zLCBiIGluIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIC8vICoqKntvcmlnaW59YmJiYnt0aGlzfXtjLGJ9e2MsYn17b30qKipcbiAgICAgICAgLy8gTm90ZSB0aGF0IGNvbmZsaWN0aW5nSXRlbXMgaXMgYSBzdWJzZXQgb2YgaXRlbXNCZWZvcmVPcmlnaW5cbiAgICAgICAgd2hpbGUgKG8gIT09IG51bGwgJiYgbyAhPT0gdGhpcy5yaWdodCkge1xuICAgICAgICAgIGl0ZW1zQmVmb3JlT3JpZ2luLmFkZChvKTtcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKTtcbiAgICAgICAgICBpZiAoY29tcGFyZUlEcyh0aGlzLm9yaWdpbiwgby5vcmlnaW4pKSB7XG4gICAgICAgICAgICAvLyBjYXNlIDFcbiAgICAgICAgICAgIGlmIChvLmlkLmNsaWVudCA8IHRoaXMuaWQuY2xpZW50KSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgby5yaWdodE9yaWdpbikpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBhbmQgbyBhcmUgY29uZmxpY3RpbmcgYW5kIHBvaW50IHRvIHRoZSBzYW1lIGludGVncmF0aW9uIHBvaW50cy4gVGhlIGlkIGRlY2lkZXMgd2hpY2ggaXRlbSBjb21lcyBmaXJzdC5cbiAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0byB0aGUgbGVmdCBvZiBvLCB3ZSBjYW4gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSAvLyBlbHNlLCBvIG1pZ2h0IGJlIGludGVncmF0ZWQgYmVmb3JlIGFuIGl0ZW0gdGhhdCB0aGlzIGNvbmZsaWN0cyB3aXRoLiBJZiBzbywgd2Ugd2lsbCBmaW5kIGl0IGluIHRoZSBuZXh0IGl0ZXJhdGlvbnNcbiAgICAgICAgICB9IGVsc2UgaWYgKG8ub3JpZ2luICE9PSBudWxsICYmIGl0ZW1zQmVmb3JlT3JpZ2luLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkgeyAvLyB1c2UgZ2V0SXRlbSBpbnN0ZWFkIG9mIGdldEl0ZW1DbGVhbkVuZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgLyBuZWVkIHRvIHNwbGl0IGl0ZW1zLlxuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvO1xuICAgICAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIG8gPSBvLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgICB9XG4gICAgICAvLyByZWNvbm5lY3QgbGVmdC9yaWdodCArIHVwZGF0ZSBwYXJlbnQgbWFwL3N0YXJ0IGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCByaWdodCA9IHRoaXMubGVmdC5yaWdodDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHI7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICAgIHIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuZ2V0KHRoaXMucGFyZW50U3ViKSB8fCBudWxsO1xuICAgICAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIHIubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHIubGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0XG4gICAgICAgICAgOy8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0ID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJpZ2h0ID0gcjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHNldCBhcyBjdXJyZW50IHBhcmVudCB2YWx1ZSBpZiByaWdodCA9PT0gbnVsbCBhbmQgdGhpcyBpcyBwYXJlbnRTdWJcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLnNldCh0aGlzLnBhcmVudFN1YiwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnQuIGRlbGV0ZSByaWdodFxuICAgICAgICAgIHRoaXMubGVmdC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMucGFyZW50U3ViID09PSBudWxsICYmIHRoaXMuY291bnRhYmxlICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbGVuZ3RoICs9IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcyk7XG4gICAgICB0aGlzLmNvbnRlbnQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCB0aGlzKTtcbiAgICAgIC8vIGFkZCBwYXJlbnQgdG8gdHJhbnNhY3Rpb24uY2hhbmdlZFxuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLCB0aGlzLnBhcmVudFN1Yik7XG4gICAgICBpZiAoKC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX2l0ZW0gIT09IG51bGwgJiYgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbS5kZWxldGVkKSB8fCAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwgJiYgdGhpcy5yaWdodCAhPT0gbnVsbCkpIHtcbiAgICAgICAgLy8gZGVsZXRlIGlmIHBhcmVudCBpcyBkZWxldGVkIG9yIGlmIHRoaXMgaXMgbm90IHRoZSBjdXJyZW50IGF0dHJpYnV0ZSB2YWx1ZSBvZiBwYXJlbnRcbiAgICAgICAgdGhpcy5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbm90IGRlZmluZWQuIEludGVncmF0ZSBHQyBzdHJ1Y3QgaW5zdGVhZFxuICAgICAgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBuZXh0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmlnaHQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5yaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIG5cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcmV2aW91cyBub24tZGVsZXRlZCBpdGVtXG4gICAqL1xuICBnZXQgcHJldiAoKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxlZnQ7XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gblxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBsYXN0IGNvbnRlbnQgYWRkcmVzcyBvZiB0aGlzIEl0ZW0uXG4gICAqL1xuICBnZXQgbGFzdElkICgpIHtcbiAgICAvLyBhbGxvY2F0aW5nIGlkcyBpcyBwcmV0dHkgY29zdGx5IGJlY2F1c2Ugb2YgdGhlIGFtb3VudCBvZiBpZHMgY3JlYXRlZCwgc28gd2UgdHJ5IHRvIHJldXNlIHdoZW5ldmVyIHBvc3NpYmxlXG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxID8gdGhpcy5pZCA6IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgdGhpcy5sZW5ndGggLSAxKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBtZXJnZSB0d28gaXRlbXNcbiAgICpcbiAgICogQHBhcmFtIHtJdGVtfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmIChcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnN0cnVjdG9yICYmXG4gICAgICBjb21wYXJlSURzKHJpZ2h0Lm9yaWdpbiwgdGhpcy5sYXN0SWQpICYmXG4gICAgICB0aGlzLnJpZ2h0ID09PSByaWdodCAmJlxuICAgICAgY29tcGFyZUlEcyh0aGlzLnJpZ2h0T3JpZ2luLCByaWdodC5yaWdodE9yaWdpbikgJiZcbiAgICAgIHRoaXMuaWQuY2xpZW50ID09PSByaWdodC5pZC5jbGllbnQgJiZcbiAgICAgIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCA9PT0gcmlnaHQuaWQuY2xvY2sgJiZcbiAgICAgIHRoaXMuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJlxuICAgICAgdGhpcy5yZWRvbmUgPT09IG51bGwgJiZcbiAgICAgIHJpZ2h0LnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgdGhpcy5jb250ZW50LmNvbnN0cnVjdG9yID09PSByaWdodC5jb250ZW50LmNvbnN0cnVjdG9yICYmXG4gICAgICB0aGlzLmNvbnRlbnQubWVyZ2VXaXRoKHJpZ2h0LmNvbnRlbnQpXG4gICAgKSB7XG4gICAgICBjb25zdCBzZWFyY2hNYXJrZXIgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9zZWFyY2hNYXJrZXI7XG4gICAgICBpZiAoc2VhcmNoTWFya2VyKSB7XG4gICAgICAgIHNlYXJjaE1hcmtlci5mb3JFYWNoKG1hcmtlciA9PiB7XG4gICAgICAgICAgaWYgKG1hcmtlci5wID09PSByaWdodCkge1xuICAgICAgICAgICAgLy8gcmlnaHQgaXMgZ29pbmcgdG8gYmUgXCJmb3Jnb3R0ZW5cIiBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbWFya2VyXG4gICAgICAgICAgICBtYXJrZXIucCA9IHRoaXM7XG4gICAgICAgICAgICAvLyBhZGp1c3QgbWFya2VyIGluZGV4XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZCAmJiB0aGlzLmNvdW50YWJsZSkge1xuICAgICAgICAgICAgICBtYXJrZXIuaW5kZXggLT0gdGhpcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyaWdodC5rZWVwKSB7XG4gICAgICAgIHRoaXMua2VlcCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQucmlnaHQ7XG4gICAgICBpZiAodGhpcy5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJpZ2h0LmxlZnQgPSB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5sZW5ndGggKz0gcmlnaHQubGVuZ3RoO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KTtcbiAgICAgIC8vIGFkanVzdCB0aGUgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMuY291bnRhYmxlICYmIHRoaXMucGFyZW50U3ViID09PSBudWxsKSB7XG4gICAgICAgIHBhcmVudC5fbGVuZ3RoIC09IHRoaXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdGhpcy5tYXJrRGVsZXRlZCgpO1xuICAgICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCB0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jaywgdGhpcy5sZW5ndGgpO1xuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBwYXJlbnQsIHRoaXMucGFyZW50U3ViKTtcbiAgICAgIHRoaXMuY29udGVudC5kZWxldGUodHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmVudEdDZFxuICAgKi9cbiAgZ2MgKHN0b3JlLCBwYXJlbnRHQ2QpIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQuZ2Moc3RvcmUpO1xuICAgIGlmIChwYXJlbnRHQ2QpIHtcbiAgICAgIHJlcGxhY2VTdHJ1Y3Qoc3RvcmUsIHRoaXMsIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb2Zmc2V0ID4gMCA/IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgb2Zmc2V0IC0gMSkgOiB0aGlzLm9yaWdpbjtcbiAgICBjb25zdCByaWdodE9yaWdpbiA9IHRoaXMucmlnaHRPcmlnaW47XG4gICAgY29uc3QgcGFyZW50U3ViID0gdGhpcy5wYXJlbnRTdWI7XG4gICAgY29uc3QgaW5mbyA9ICh0aGlzLmNvbnRlbnQuZ2V0UmVmKCkgJiBiaW5hcnkuQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDgpIHwgLy8gb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChyaWdodE9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNykgfCAvLyByaWdodCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHBhcmVudFN1YiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNik7IC8vIHBhcmVudFN1YiBpcyBub24tbnVsbFxuICAgIGVuY29kZXIud3JpdGVJbmZvKGluZm8pO1xuICAgIGlmIChvcmlnaW4gIT09IG51bGwpIHtcbiAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQob3JpZ2luKTtcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbik7XG4gICAgfVxuICAgIGlmIChvcmlnaW4gPT09IG51bGwgJiYgcmlnaHRPcmlnaW4gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCk7XG4gICAgICBpZiAocGFyZW50Ll9pdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50SXRlbSA9IHBhcmVudC5faXRlbTtcbiAgICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBwYXJlbnQgdHlwZSBvbiB5Ll9tYXBcbiAgICAgICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IGtleVxuICAgICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KTtcbiAgICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICAgIGVuY29kZXIud3JpdGVTdHJpbmcoeWtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgICBlbmNvZGVyLndyaXRlTGVmdElEKHBhcmVudEl0ZW0uaWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7IC8vIHRoaXMgZWRnZSBjYXNlIHdhcyBhZGRlZCBieSBkaWZmZXJlbnRpYWwgdXBkYXRlc1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyh0cnVlKTsgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudCk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmVudC5jb25zdHJ1Y3RvciA9PT0gSUQpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpOyAvLyB3cml0ZSBwYXJlbnQgaWRcbiAgICAgICAgZW5jb2Rlci53cml0ZUxlZnRJRChwYXJlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhwYXJlbnRTdWIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQud3JpdGUoZW5jb2Rlciwgb2Zmc2V0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5mb1xuICovXG5jb25zdCByZWFkSXRlbUNvbnRlbnQgPSAoZGVjb2RlciwgaW5mbykgPT4gY29udGVudFJlZnNbaW5mbyAmIGJpbmFyeS5CSVRTNV0oZGVjb2Rlcik7XG5cbi8qKlxuICogQSBsb29rdXAgbWFwIGZvciByZWFkaW5nIEl0ZW0gY29udGVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdENvbnRlbnQ+fVxuICovXG5jb25zdCBjb250ZW50UmVmcyA9IFtcbiAgKCkgPT4geyBlcnJvci51bmV4cGVjdGVkQ2FzZSgpOyB9LCAvLyBHQyBpcyBub3QgSXRlbUNvbnRlbnRcbiAgcmVhZENvbnRlbnREZWxldGVkLCAvLyAxXG4gIHJlYWRDb250ZW50SlNPTiwgLy8gMlxuICByZWFkQ29udGVudEJpbmFyeSwgLy8gM1xuICByZWFkQ29udGVudFN0cmluZywgLy8gNFxuICByZWFkQ29udGVudEVtYmVkLCAvLyA1XG4gIHJlYWRDb250ZW50Rm9ybWF0LCAvLyA2XG4gIHJlYWRDb250ZW50VHlwZSwgLy8gN1xuICByZWFkQ29udGVudEFueSwgLy8gOFxuICByZWFkQ29udGVudERvYywgLy8gOVxuICAoKSA9PiB7IGVycm9yLnVuZXhwZWN0ZWRDYXNlKCk7IH0gLy8gMTAgLSBTa2lwIGlzIG5vdCBJdGVtQ29udGVudFxuXTtcblxuY29uc3Qgc3RydWN0U2tpcFJlZk51bWJlciA9IDEwO1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNsYXNzIFNraXAgZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVsZXRlICgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2tpcH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICAvLyBza2lwIHN0cnVjdHMgY2Fubm90IGJlIGludGVncmF0ZWRcbiAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlSW5mbyhzdHJ1Y3RTa2lwUmVmTnVtYmVyKTtcbiAgICAvLyB3cml0ZSBhcyBWYXJVaW50IGJlY2F1c2UgU2tpcHMgY2FuJ3QgbWFrZSB1c2Ugb2YgcHJlZGljdGFibGUgbGVuZ3RoLWVuY29kaW5nXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHRoaXMubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKiogZXNsaW50LWVudiBicm93c2VyICovXG5cbmNvbnN0IGdsbyA9IC8qKiBAdHlwZSB7YW55fSAqLyAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gID8gZ2xvYmFsVGhpc1xuICA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHt9KTtcblxuY29uc3QgaW1wb3J0SWRlbnRpZmllciA9ICdfXyAkWUpTJCBfXyc7XG5cbmlmIChnbG9baW1wb3J0SWRlbnRpZmllcl0gPT09IHRydWUpIHtcbiAgLyoqXG4gICAqIERlYXIgcmVhZGVyIG9mIHRoaXMgbWVzc2FnZS4gUGxlYXNlIHRha2UgdGhpcyBzZXJpb3VzbHkuXG4gICAqXG4gICAqIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBtYWtlIHN1cmUgdGhhdCB5b3Ugb25seSBpbXBvcnQgb25lIHZlcnNpb24gb2YgWWpzLiBJbiBtYW55IGNhc2VzLFxuICAgKiB5b3VyIHBhY2thZ2UgbWFuYWdlciBpbnN0YWxscyB0d28gdmVyc2lvbnMgb2YgWWpzIHRoYXQgYXJlIHVzZWQgYnkgZGlmZmVyZW50IHBhY2thZ2VzIHdpdGhpbiB5b3VyIHByb2plY3QuXG4gICAqIEFub3RoZXIgcmVhc29uIGZvciB0aGlzIG1lc3NhZ2UgaXMgdGhhdCBzb21lIHBhcnRzIG9mIHlvdXIgcHJvamVjdCB1c2UgdGhlIGNvbW1vbmpzIHZlcnNpb24gb2YgWWpzXG4gICAqIGFuZCBvdGhlcnMgdXNlIHRoZSBFY21hU2NyaXB0IHZlcnNpb24gb2YgWWpzLlxuICAgKlxuICAgKiBUaGlzIG9mdGVuIGxlYWRzIHRvIGlzc3VlcyB0aGF0IGFyZSBoYXJkIHRvIGRlYnVnLiBXZSBvZnRlbiBuZWVkIHRvIHBlcmZvcm0gY29uc3RydWN0b3IgY2hlY2tzLFxuICAgKiBlLmcuIGBzdHJ1Y3QgaW5zdGFuY2VvZiBHQ2AuIElmIHlvdSBpbXBvcnRlZCBkaWZmZXJlbnQgdmVyc2lvbnMgb2YgWWpzLCBpdCBpcyBpbXBvc3NpYmxlIGZvciB1cyB0b1xuICAgKiBkbyB0aGUgY29uc3RydWN0b3IgY2hlY2tzIGFueW1vcmUgLSB3aGljaCBtaWdodCBicmVhayB0aGUgQ1JEVCBhbGdvcml0aG0uXG4gICAqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzhcbiAgICovXG4gIGNvbnNvbGUuZXJyb3IoJ1lqcyB3YXMgYWxyZWFkeSBpbXBvcnRlZC4gVGhpcyBicmVha3MgY29uc3RydWN0b3IgY2hlY2tzIGFuZCB3aWxsIGxlYWQgdG8gaXNzdWVzISAtIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy80MzgnKTtcbn1cbmdsb1tpbXBvcnRJZGVudGlmaWVyXSA9IHRydWU7XG5cbmV4cG9ydCB7IEFic29sdXRlUG9zaXRpb24sIEFic3RyYWN0Q29ubmVjdG9yLCBBYnN0cmFjdFN0cnVjdCwgQWJzdHJhY3RUeXBlLCBZQXJyYXkgYXMgQXJyYXksIENvbnRlbnRBbnksIENvbnRlbnRCaW5hcnksIENvbnRlbnREZWxldGVkLCBDb250ZW50RW1iZWQsIENvbnRlbnRGb3JtYXQsIENvbnRlbnRKU09OLCBDb250ZW50U3RyaW5nLCBDb250ZW50VHlwZSwgRG9jLCBHQywgSUQsIEl0ZW0sIFlNYXAgYXMgTWFwLCBQZXJtYW5lbnRVc2VyRGF0YSwgUmVsYXRpdmVQb3NpdGlvbiwgU25hcHNob3QsIFlUZXh0IGFzIFRleHQsIFRyYW5zYWN0aW9uLCBVbmRvTWFuYWdlciwgVXBkYXRlRW5jb2RlclYxLCBZWG1sRWxlbWVudCBhcyBYbWxFbGVtZW50LCBZWG1sRnJhZ21lbnQgYXMgWG1sRnJhZ21lbnQsIFlYbWxIb29rIGFzIFhtbEhvb2ssIFlYbWxUZXh0IGFzIFhtbFRleHQsIFlBcnJheUV2ZW50LCBZRXZlbnQsIFlNYXBFdmVudCwgWVRleHRFdmVudCwgWVhtbEV2ZW50LCBhcHBseVVwZGF0ZSwgYXBwbHlVcGRhdGVWMiwgY2xlYW51cFlUZXh0Rm9ybWF0dGluZywgY29tcGFyZUlEcywgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zLCBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyLCBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxLCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24sIGNyZWF0ZURlbGV0ZVNldCwgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLCBjcmVhdGVEb2NGcm9tU25hcHNob3QsIGNyZWF0ZUlELCBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04sIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4LCBjcmVhdGVTbmFwc2hvdCwgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiwgZGVjb2RlU25hcHNob3QsIGRlY29kZVNuYXBzaG90VjIsIGRlY29kZVN0YXRlVmVjdG9yLCBkZWNvZGVVcGRhdGUsIGRlY29kZVVwZGF0ZVYyLCBkaWZmVXBkYXRlLCBkaWZmVXBkYXRlVjIsIGVtcHR5U25hcHNob3QsIGVuY29kZVJlbGF0aXZlUG9zaXRpb24sIGVuY29kZVNuYXBzaG90LCBlbmNvZGVTbmFwc2hvdFYyLCBlbmNvZGVTdGF0ZUFzVXBkYXRlLCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIsIGVuY29kZVN0YXRlVmVjdG9yLCBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGUsIGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyLCBlcXVhbFNuYXBzaG90cywgZmluZEluZGV4U1MsIGZpbmRSb290VHlwZUtleSwgZ2V0SXRlbSwgZ2V0U3RhdGUsIGdldFR5cGVDaGlsZHJlbiwgaXNEZWxldGVkLCBpc1BhcmVudE9mLCBpdGVyYXRlRGVsZXRlZFN0cnVjdHMsIGxvZ1R5cGUsIGxvZ1VwZGF0ZSwgbG9nVXBkYXRlVjIsIG1lcmdlVXBkYXRlcywgbWVyZ2VVcGRhdGVzVjIsIG9iZnVzY2F0ZVVwZGF0ZSwgb2JmdXNjYXRlVXBkYXRlVjIsIHBhcnNlVXBkYXRlTWV0YSwgcGFyc2VVcGRhdGVNZXRhVjIsIHJlYWRVcGRhdGUsIHJlYWRVcGRhdGVWMiwgcmVsYXRpdmVQb3NpdGlvblRvSlNPTiwgc25hcHNob3QsIHRyYW5zYWN0LCB0cnlHYywgdHlwZUxpc3RUb0FycmF5U25hcHNob3QsIHR5cGVNYXBHZXRTbmFwc2hvdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWpzLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/yjs/dist/yjs.mjs\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./entries/dist.js");
/******/ 	
/******/ })()
;